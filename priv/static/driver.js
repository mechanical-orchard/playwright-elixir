#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/playwright-core/lib/utils/ascii.js
var require_ascii = __commonJS({
  "node_modules/playwright-core/lib/utils/ascii.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.wrapInASCIIBox = wrapInASCIIBox;
    function wrapInASCIIBox(text, padding = 0) {
      const lines = text.split("\n");
      const maxLength = Math.max(...lines.map((line) => line.length));
      return ["\u2554" + "\u2550".repeat(maxLength + padding * 2) + "\u2557", ...lines.map((line) => "\u2551" + " ".repeat(padding) + line + " ".repeat(maxLength - line.length + padding) + "\u2551"), "\u255A" + "\u2550".repeat(maxLength + padding * 2) + "\u255D"].join("\n");
    }
  }
});

// node_modules/playwright-core/lib/utilsBundleImpl/index.js
var require_utilsBundleImpl = __commonJS({
  "node_modules/playwright-core/lib/utilsBundleImpl/index.js"(exports2, module2) {
    "use strict";
    var Dh = Object.create;
    var ui = Object.defineProperty;
    var jh = Object.getOwnPropertyDescriptor;
    var qh = Object.getOwnPropertyNames;
    var Hh = Object.getPrototypeOf;
    var Vh = Object.prototype.hasOwnProperty;
    var x = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports);
    var $h = (t, e) => {
      for (var r in e)
        ui(t, r, { get: e[r], enumerable: true });
    };
    var Lo = (t, e, r, i) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let n of qh(e))
          !Vh.call(t, n) && n !== r && ui(t, n, { get: () => e[n], enumerable: !(i = jh(e, n)) || i.enumerable });
      return t;
    };
    var Te = (t, e, r) => (r = t != null ? Dh(Hh(t)) : {}, Lo(e || !t || !t.__esModule ? ui(r, "default", { value: t, enumerable: true }) : r, t));
    var Gh = (t) => Lo(ui({}, "__esModule", { value: true }), t);
    var Mo = x((f_, Fo) => {
      var Po = {};
      Fo.exports = Po;
      var No = { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29], black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], grey: [90, 39], brightRed: [91, 39], brightGreen: [92, 39], brightYellow: [93, 39], brightBlue: [94, 39], brightMagenta: [95, 39], brightCyan: [96, 39], brightWhite: [97, 39], bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgGray: [100, 49], bgGrey: [100, 49], bgBrightRed: [101, 49], bgBrightGreen: [102, 49], bgBrightYellow: [103, 49], bgBrightBlue: [104, 49], bgBrightMagenta: [105, 49], bgBrightCyan: [106, 49], bgBrightWhite: [107, 49], blackBG: [40, 49], redBG: [41, 49], greenBG: [42, 49], yellowBG: [43, 49], blueBG: [44, 49], magentaBG: [45, 49], cyanBG: [46, 49], whiteBG: [47, 49] };
      Object.keys(No).forEach(function(t) {
        var e = No[t], r = Po[t] = [];
        r.open = "[" + e[0] + "m", r.close = "[" + e[1] + "m";
      });
    });
    var Do = x((h_, Uo) => {
      "use strict";
      Uo.exports = function(t, e) {
        e = e || process.argv;
        var r = e.indexOf("--"), i = /^-{1,2}/.test(t) ? "" : "--", n = e.indexOf(i + t);
        return n !== -1 && (r === -1 ? true : n < r);
      };
    });
    var qo = x((p_, jo) => {
      "use strict";
      var zh = require("os"), rt = Do(), Ve = process.env, Zt = void 0;
      rt("no-color") || rt("no-colors") || rt("color=false") ? Zt = false : (rt("color") || rt("colors") || rt("color=true") || rt("color=always")) && (Zt = true);
      "FORCE_COLOR" in Ve && (Zt = Ve.FORCE_COLOR.length === 0 || parseInt(Ve.FORCE_COLOR, 10) !== 0);
      function Wh(t) {
        return t === 0 ? false : { level: t, hasBasic: true, has256: t >= 2, has16m: t >= 3 };
      }
      function Yh(t) {
        if (Zt === false)
          return 0;
        if (rt("color=16m") || rt("color=full") || rt("color=truecolor"))
          return 3;
        if (rt("color=256"))
          return 2;
        if (t && !t.isTTY && Zt !== true)
          return 0;
        var e = Zt ? 1 : 0;
        if (process.platform === "win32") {
          var r = zh.release().split(".");
          return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in Ve)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(n) {
            return n in Ve;
          }) || Ve.CI_NAME === "codeship" ? 1 : e;
        if ("TEAMCITY_VERSION" in Ve)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ve.TEAMCITY_VERSION) ? 1 : 0;
        if ("TERM_PROGRAM" in Ve) {
          var i = parseInt((Ve.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (Ve.TERM_PROGRAM) {
            case "iTerm.app":
              return i >= 3 ? 3 : 2;
            case "Hyper":
              return 3;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(Ve.TERM) ? 2 : /^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(Ve.TERM) || "COLORTERM" in Ve ? 1 : (Ve.TERM === "dumb", e);
      }
      function Ji(t) {
        var e = Yh(t);
        return Wh(e);
      }
      jo.exports = { supportsColor: Ji, stdout: Ji(process.stdout), stderr: Ji(process.stderr) };
    });
    var Vo = x((d_, Ho) => {
      Ho.exports = function(e, r) {
        var i = "";
        e = e || "Run the trap, drop the bass", e = e.split("");
        var n = { a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"], b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"], c: ["\xA9", "\u023B", "\u03FE"], d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"], e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"], f: ["\u04FA"], g: ["\u0262"], h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"], i: ["\u0F0F"], j: ["\u0134"], k: ["\u0138", "\u04A0", "\u04C3", "\u051E"], l: ["\u0139"], m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"], n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"], o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"], p: ["\u01F7", "\u048E"], q: ["\u09CD"], r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"], s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"], t: ["\u0141", "\u0166", "\u0373"], u: ["\u01B1", "\u054D"], v: ["\u05D8"], w: ["\u0428", "\u0460", "\u047C", "\u0D70"], x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"], y: ["\xA5", "\u04B0", "\u04CB"], z: ["\u01B5", "\u0240"] };
        return e.forEach(function(s) {
          s = s.toLowerCase();
          var o = n[s] || [" "], a = Math.floor(Math.random() * o.length);
          typeof n[s] != "undefined" ? i += n[s][a] : i += s;
        }), i;
      };
    });
    var Go = x((m_, $o) => {
      $o.exports = function(e, r) {
        e = e || "   he is here   ";
        var i = { up: ["\u030D", "\u030E", "\u0304", "\u0305", "\u033F", "\u0311", "\u0306", "\u0310", "\u0352", "\u0357", "\u0351", "\u0307", "\u0308", "\u030A", "\u0342", "\u0313", "\u0308", "\u034A", "\u034B", "\u034C", "\u0303", "\u0302", "\u030C", "\u0350", "\u0300", "\u0301", "\u030B", "\u030F", "\u0312", "\u0313", "\u0314", "\u033D", "\u0309", "\u0363", "\u0364", "\u0365", "\u0366", "\u0367", "\u0368", "\u0369", "\u036A", "\u036B", "\u036C", "\u036D", "\u036E", "\u036F", "\u033E", "\u035B", "\u0346", "\u031A"], down: ["\u0316", "\u0317", "\u0318", "\u0319", "\u031C", "\u031D", "\u031E", "\u031F", "\u0320", "\u0324", "\u0325", "\u0326", "\u0329", "\u032A", "\u032B", "\u032C", "\u032D", "\u032E", "\u032F", "\u0330", "\u0331", "\u0332", "\u0333", "\u0339", "\u033A", "\u033B", "\u033C", "\u0345", "\u0347", "\u0348", "\u0349", "\u034D", "\u034E", "\u0353", "\u0354", "\u0355", "\u0356", "\u0359", "\u035A", "\u0323"], mid: ["\u0315", "\u031B", "\u0300", "\u0301", "\u0358", "\u0321", "\u0322", "\u0327", "\u0328", "\u0334", "\u0335", "\u0336", "\u035C", "\u035D", "\u035E", "\u035F", "\u0360", "\u0362", "\u0338", "\u0337", "\u0361", " \u0489"] }, n = [].concat(i.up, i.down, i.mid);
        function s(l) {
          var c = Math.floor(Math.random() * l);
          return c;
        }
        function o(l) {
          var c = false;
          return n.filter(function(u) {
            c = u === l;
          }), c;
        }
        function a(l, c) {
          var u = "", f, h;
          c = c || {}, c.up = typeof c.up != "undefined" ? c.up : true, c.mid = typeof c.mid != "undefined" ? c.mid : true, c.down = typeof c.down != "undefined" ? c.down : true, c.size = typeof c.size != "undefined" ? c.size : "maxi", l = l.split("");
          for (h in l)
            if (!o(h)) {
              switch (u = u + l[h], f = { up: 0, down: 0, mid: 0 }, c.size) {
                case "mini":
                  f.up = s(8), f.mid = s(2), f.down = s(8);
                  break;
                case "maxi":
                  f.up = s(16) + 3, f.mid = s(4) + 1, f.down = s(64) + 3;
                  break;
                default:
                  f.up = s(8) + 1, f.mid = s(6) / 2, f.down = s(8) + 1;
                  break;
              }
              var p = ["up", "mid", "down"];
              for (var d in p)
                for (var m = p[d], g = 0; g <= f[m]; g++)
                  c[m] && (u = u + i[m][s(i[m].length)]);
            }
          return u;
        }
        return a(e, r);
      };
    });
    var Wo = x((g_, zo) => {
      zo.exports = function(t) {
        return function(e, r, i) {
          if (e === " ")
            return e;
          switch (r % 3) {
            case 0:
              return t.red(e);
            case 1:
              return t.white(e);
            case 2:
              return t.blue(e);
          }
        };
      };
    });
    var Ko = x((v_, Yo) => {
      Yo.exports = function(t) {
        return function(e, r, i) {
          return r % 2 === 0 ? e : t.inverse(e);
        };
      };
    });
    var Xo = x((__, Zo) => {
      Zo.exports = function(t) {
        var e = ["red", "yellow", "green", "blue", "magenta"];
        return function(r, i, n) {
          return r === " " ? r : t[e[i++ % e.length]](r);
        };
      };
    });
    var Jo = x((x_, Qo) => {
      Qo.exports = function(t) {
        var e = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta", "brightYellow", "brightRed", "brightGreen", "brightBlue", "brightWhite", "brightCyan", "brightMagenta"];
        return function(r, i, n) {
          return r === " " ? r : t[e[Math.round(Math.random() * (e.length - 2))]](r);
        };
      };
    });
    var sa = x((b_, na) => {
      var ae = {};
      na.exports = ae;
      ae.themes = {};
      var Kh = require("util"), At = ae.styles = Mo(), ta = Object.defineProperties, Zh = new RegExp(/[\r\n]+/g);
      ae.supportsColor = qo().supportsColor;
      typeof ae.enabled == "undefined" && (ae.enabled = ae.supportsColor() !== false);
      ae.enable = function() {
        ae.enabled = true;
      };
      ae.disable = function() {
        ae.enabled = false;
      };
      ae.stripColors = ae.strip = function(t) {
        return ("" + t).replace(/\x1B\[\d+m/g, "");
      };
      var y_ = ae.stylize = function(e, r) {
        if (!ae.enabled)
          return e + "";
        var i = At[r];
        return !i && r in ae ? ae[r](e) : i.open + e + i.close;
      }, Xh = /[|\\{}()[\]^$+*?.]/g, Qh = function(t) {
        if (typeof t != "string")
          throw new TypeError("Expected a string");
        return t.replace(Xh, "\\$&");
      };
      function ra(t) {
        var e = function r() {
          return ep.apply(r, arguments);
        };
        return e._styles = t, e.__proto__ = Jh, e;
      }
      var ia = function() {
        var t = {};
        return At.grey = At.gray, Object.keys(At).forEach(function(e) {
          At[e].closeRe = new RegExp(Qh(At[e].close), "g"), t[e] = { get: function() {
            return ra(this._styles.concat(e));
          } };
        }), t;
      }(), Jh = ta(function() {
      }, ia);
      function ep() {
        var t = Array.prototype.slice.call(arguments), e = t.map(function(o) {
          return o != null && o.constructor === String ? o : Kh.inspect(o);
        }).join(" ");
        if (!ae.enabled || !e)
          return e;
        for (var r = e.indexOf(`
`) != -1, i = this._styles, n = i.length; n--; ) {
          var s = At[i[n]];
          e = s.open + e.replace(s.closeRe, s.open) + s.close, r && (e = e.replace(Zh, function(o) {
            return s.close + o + s.open;
          }));
        }
        return e;
      }
      ae.setTheme = function(t) {
        if (typeof t == "string") {
          console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
          return;
        }
        for (var e in t)
          (function(r) {
            ae[r] = function(i) {
              if (typeof t[r] == "object") {
                var n = i;
                for (var s in t[r])
                  n = ae[t[r][s]](n);
                return n;
              }
              return ae[t[r]](i);
            };
          })(e);
      };
      function tp() {
        var t = {};
        return Object.keys(ia).forEach(function(e) {
          t[e] = { get: function() {
            return ra([e]);
          } };
        }), t;
      }
      var rp = function(e, r) {
        var i = r.split("");
        return i = i.map(e), i.join("");
      };
      ae.trap = Vo();
      ae.zalgo = Go();
      ae.maps = {};
      ae.maps.america = Wo()(ae);
      ae.maps.zebra = Ko()(ae);
      ae.maps.rainbow = Xo()(ae);
      ae.maps.random = Jo()(ae);
      for (ea in ae.maps)
        (function(t) {
          ae[t] = function(e) {
            return rp(ae.maps[t], e);
          };
        })(ea);
      var ea;
      ta(ae, tp());
    });
    var aa = x((w_, oa) => {
      var ip = sa();
      oa.exports = ip;
    });
    var ca = x((E_, la) => {
      var Xt = 1e3, Qt = Xt * 60, Jt = Qt * 60, Rt = Jt * 24, np = Rt * 7, sp = Rt * 365.25;
      la.exports = function(t, e) {
        e = e || {};
        var r = typeof t;
        if (r === "string" && t.length > 0)
          return op(t);
        if (r === "number" && isFinite(t))
          return e.long ? lp(t) : ap(t);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t));
      };
      function op(t) {
        if (t = String(t), !(t.length > 100)) {
          var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
          if (!!e) {
            var r = parseFloat(e[1]), i = (e[2] || "ms").toLowerCase();
            switch (i) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return r * sp;
              case "weeks":
              case "week":
              case "w":
                return r * np;
              case "days":
              case "day":
              case "d":
                return r * Rt;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return r * Jt;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return r * Qt;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return r * Xt;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return r;
              default:
                return;
            }
          }
        }
      }
      function ap(t) {
        var e = Math.abs(t);
        return e >= Rt ? Math.round(t / Rt) + "d" : e >= Jt ? Math.round(t / Jt) + "h" : e >= Qt ? Math.round(t / Qt) + "m" : e >= Xt ? Math.round(t / Xt) + "s" : t + "ms";
      }
      function lp(t) {
        var e = Math.abs(t);
        return e >= Rt ? fi(t, e, Rt, "day") : e >= Jt ? fi(t, e, Jt, "hour") : e >= Qt ? fi(t, e, Qt, "minute") : e >= Xt ? fi(t, e, Xt, "second") : t + " ms";
      }
      function fi(t, e, r, i) {
        var n = e >= r * 1.5;
        return Math.round(t / r) + " " + i + (n ? "s" : "");
      }
    });
    var en = x((S_, ua) => {
      function cp(t) {
        r.debug = r, r.default = r, r.coerce = l, r.disable = s, r.enable = n, r.enabled = o, r.humanize = ca(), r.destroy = c, Object.keys(t).forEach((u) => {
          r[u] = t[u];
        }), r.names = [], r.skips = [], r.formatters = {};
        function e(u) {
          let f = 0;
          for (let h = 0; h < u.length; h++)
            f = (f << 5) - f + u.charCodeAt(h), f |= 0;
          return r.colors[Math.abs(f) % r.colors.length];
        }
        r.selectColor = e;
        function r(u) {
          let f, h = null, p, d;
          function m(...g) {
            if (!m.enabled)
              return;
            let y = m, I = Number(new Date()), w = I - (f || I);
            y.diff = w, y.prev = f, y.curr = I, f = I, g[0] = r.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
            let S = 0;
            g[0] = g[0].replace(/%([a-zA-Z%])/g, ($, C) => {
              if ($ === "%%")
                return "%";
              S++;
              let U = r.formatters[C];
              if (typeof U == "function") {
                let E = g[S];
                $ = U.call(y, E), g.splice(S, 1), S--;
              }
              return $;
            }), r.formatArgs.call(y, g), (y.log || r.log).apply(y, g);
          }
          return m.namespace = u, m.useColors = r.useColors(), m.color = r.selectColor(u), m.extend = i, m.destroy = r.destroy, Object.defineProperty(m, "enabled", { enumerable: true, configurable: false, get: () => h !== null ? h : (p !== r.namespaces && (p = r.namespaces, d = r.enabled(u)), d), set: (g) => {
            h = g;
          } }), typeof r.init == "function" && r.init(m), m;
        }
        function i(u, f) {
          let h = r(this.namespace + (typeof f == "undefined" ? ":" : f) + u);
          return h.log = this.log, h;
        }
        function n(u) {
          r.save(u), r.namespaces = u, r.names = [], r.skips = [];
          let f, h = (typeof u == "string" ? u : "").split(/[\s,]+/), p = h.length;
          for (f = 0; f < p; f++)
            !h[f] || (u = h[f].replace(/\*/g, ".*?"), u[0] === "-" ? r.skips.push(new RegExp("^" + u.slice(1) + "$")) : r.names.push(new RegExp("^" + u + "$")));
        }
        function s() {
          let u = [...r.names.map(a), ...r.skips.map(a).map((f) => "-" + f)].join(",");
          return r.enable(""), u;
        }
        function o(u) {
          if (u[u.length - 1] === "*")
            return true;
          let f, h;
          for (f = 0, h = r.skips.length; f < h; f++)
            if (r.skips[f].test(u))
              return false;
          for (f = 0, h = r.names.length; f < h; f++)
            if (r.names[f].test(u))
              return true;
          return false;
        }
        function a(u) {
          return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function l(u) {
          return u instanceof Error ? u.stack || u.message : u;
        }
        function c() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return r.enable(r.load()), r;
      }
      ua.exports = cp;
    });
    var fa = x((We, hi) => {
      We.formatArgs = fp;
      We.save = hp;
      We.load = pp;
      We.useColors = up;
      We.storage = dp();
      We.destroy = (() => {
        let t = false;
        return () => {
          t || (t = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
      })();
      We.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function up() {
        return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function fp(t) {
        if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + hi.exports.humanize(this.diff), !this.useColors)
          return;
        let e = "color: " + this.color;
        t.splice(1, 0, e, "color: inherit");
        let r = 0, i = 0;
        t[0].replace(/%[a-zA-Z%]/g, (n) => {
          n !== "%%" && (r++, n === "%c" && (i = r));
        }), t.splice(i, 0, e);
      }
      We.log = console.debug || console.log || (() => {
      });
      function hp(t) {
        try {
          t ? We.storage.setItem("debug", t) : We.storage.removeItem("debug");
        } catch (e) {
        }
      }
      function pp() {
        let t;
        try {
          t = We.storage.getItem("debug");
        } catch (e) {
        }
        return !t && typeof process != "undefined" && "env" in process && (t = process.env.DEBUG), t;
      }
      function dp() {
        try {
          return localStorage;
        } catch (e) {
        }
      }
      hi.exports = en()(We);
      var { formatters: mp } = hi.exports;
      mp.j = function(t) {
        try {
          return JSON.stringify(t);
        } catch (e) {
          return "[UnexpectedJSONParseError]: " + e.message;
        }
      };
    });
    var pa = x((k_, ha) => {
      "use strict";
      ha.exports = (t, e) => {
        e = e || process.argv;
        let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", i = e.indexOf(r + t), n = e.indexOf("--");
        return i !== -1 && (n === -1 ? true : i < n);
      };
    });
    var ma = x((C_, da) => {
      "use strict";
      var gp = require("os"), it = pa(), je = process.env, er;
      it("no-color") || it("no-colors") || it("color=false") ? er = false : (it("color") || it("colors") || it("color=true") || it("color=always")) && (er = true);
      "FORCE_COLOR" in je && (er = je.FORCE_COLOR.length === 0 || parseInt(je.FORCE_COLOR, 10) !== 0);
      function vp(t) {
        return t === 0 ? false : { level: t, hasBasic: true, has256: t >= 2, has16m: t >= 3 };
      }
      function _p(t) {
        if (er === false)
          return 0;
        if (it("color=16m") || it("color=full") || it("color=truecolor"))
          return 3;
        if (it("color=256"))
          return 2;
        if (t && !t.isTTY && er !== true)
          return 0;
        let e = er ? 1 : 0;
        if (process.platform === "win32") {
          let r = gp.release().split(".");
          return Number(process.versions.node.split(".")[0]) >= 8 && Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in je)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((r) => r in je) || je.CI_NAME === "codeship" ? 1 : e;
        if ("TEAMCITY_VERSION" in je)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(je.TEAMCITY_VERSION) ? 1 : 0;
        if (je.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in je) {
          let r = parseInt((je.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (je.TERM_PROGRAM) {
            case "iTerm.app":
              return r >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(je.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(je.TERM) || "COLORTERM" in je ? 1 : (je.TERM === "dumb", e);
      }
      function tn(t) {
        let e = _p(t);
        return vp(e);
      }
      da.exports = { supportsColor: tn, stdout: tn(process.stdout), stderr: tn(process.stderr) };
    });
    var va = x((Me, di) => {
      var xp = require("tty"), pi = require("util");
      Me.init = Cp;
      Me.log = Ep;
      Me.formatArgs = bp;
      Me.save = Sp;
      Me.load = kp;
      Me.useColors = yp;
      Me.destroy = pi.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      Me.colors = [6, 2, 3, 4, 5, 1];
      try {
        let t = ma();
        t && (t.stderr || t).level >= 2 && (Me.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
      } catch (e) {
      }
      Me.inspectOpts = Object.keys(process.env).filter((t) => /^debug_/i.test(t)).reduce((t, e) => {
        let r = e.substring(6).toLowerCase().replace(/_([a-z])/g, (n, s) => s.toUpperCase()), i = process.env[e];
        return /^(yes|on|true|enabled)$/i.test(i) ? i = true : /^(no|off|false|disabled)$/i.test(i) ? i = false : i === "null" ? i = null : i = Number(i), t[r] = i, t;
      }, {});
      function yp() {
        return "colors" in Me.inspectOpts ? Boolean(Me.inspectOpts.colors) : xp.isatty(process.stderr.fd);
      }
      function bp(t) {
        let { namespace: e, useColors: r } = this;
        if (r) {
          let i = this.color, n = "[3" + (i < 8 ? i : "8;5;" + i), s = `  ${n};1m${e} [0m`;
          t[0] = s + t[0].split(`
`).join(`
` + s), t.push(n + "m+" + di.exports.humanize(this.diff) + "[0m");
        } else
          t[0] = wp() + e + " " + t[0];
      }
      function wp() {
        return Me.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
      }
      function Ep(...t) {
        return process.stderr.write(pi.format(...t) + `
`);
      }
      function Sp(t) {
        t ? process.env.DEBUG = t : delete process.env.DEBUG;
      }
      function kp() {
        return process.env.DEBUG;
      }
      function Cp(t) {
        t.inspectOpts = {};
        let e = Object.keys(Me.inspectOpts);
        for (let r = 0; r < e.length; r++)
          t.inspectOpts[e[r]] = Me.inspectOpts[e[r]];
      }
      di.exports = en()(Me);
      var { formatters: ga } = di.exports;
      ga.o = function(t) {
        return this.inspectOpts.colors = this.useColors, pi.inspect(t, this.inspectOpts).split(`
`).map((e) => e.trim()).join(" ");
      };
      ga.O = function(t) {
        return this.inspectOpts.colors = this.useColors, pi.inspect(t, this.inspectOpts);
      };
    });
    var tr = x((O_, rn) => {
      typeof process == "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs ? rn.exports = fa() : rn.exports = va();
    });
    var xa = x((_a) => {
      "use strict";
      var Op = require("url").parse, Ip = { ftp: 21, gopher: 70, http: 80, https: 443, ws: 80, wss: 443 }, Tp = String.prototype.endsWith || function(t) {
        return t.length <= this.length && this.indexOf(t, this.length - t.length) !== -1;
      };
      function Ap(t) {
        var e = typeof t == "string" ? Op(t) : t || {}, r = e.protocol, i = e.host, n = e.port;
        if (typeof i != "string" || !i || typeof r != "string" || (r = r.split(":", 1)[0], i = i.replace(/:\d*$/, ""), n = parseInt(n) || Ip[r] || 0, !Rp(i, n)))
          return "";
        var s = rr("npm_config_" + r + "_proxy") || rr(r + "_proxy") || rr("npm_config_proxy") || rr("all_proxy");
        return s && s.indexOf("://") === -1 && (s = r + "://" + s), s;
      }
      function Rp(t, e) {
        var r = (rr("npm_config_no_proxy") || rr("no_proxy")).toLowerCase();
        return r ? r === "*" ? false : r.split(/[,\s]/).every(function(i) {
          if (!i)
            return true;
          var n = i.match(/^(.+):(\d+)$/), s = n ? n[1] : i, o = n ? parseInt(n[2]) : 0;
          return o && o !== e ? true : /^[.*]/.test(s) ? (s.charAt(0) === "*" && (s = s.slice(1)), !Tp.call(t, s)) : t !== s;
        }) : true;
      }
      function rr(t) {
        return process.env[t.toLowerCase()] || process.env[t.toUpperCase()] || "";
      }
      _a.getProxyForUrl = Ap;
    });
    var ya = x((nn) => {
      "use strict";
      Object.defineProperty(nn, "__esModule", { value: true });
      function Bp(t) {
        return function(e, r) {
          return new Promise((i, n) => {
            t.call(this, e, r, (s, o) => {
              s ? n(s) : i(o);
            });
          });
        };
      }
      nn.default = Bp;
    });
    var an = x((on, wa) => {
      "use strict";
      var ba = on && on.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      }, Lp = require("events"), Np = ba(tr()), Pp = ba(ya()), Lr = Np.default("agent-base");
      function Fp(t) {
        return Boolean(t) && typeof t.addRequest == "function";
      }
      function sn() {
        let { stack: t } = new Error();
        return typeof t != "string" ? false : t.split(`
`).some((e) => e.indexOf("(https.js:") !== -1 || e.indexOf("node:https:") !== -1);
      }
      function mi(t, e) {
        return new mi.Agent(t, e);
      }
      (function(t) {
        class e extends Lp.EventEmitter {
          constructor(i, n) {
            super();
            let s = n;
            typeof i == "function" ? this.callback = i : i && (s = i), this.timeout = null, s && typeof s.timeout == "number" && (this.timeout = s.timeout), this.maxFreeSockets = 1, this.maxSockets = 1, this.maxTotalSockets = 1 / 0, this.sockets = {}, this.freeSockets = {}, this.requests = {}, this.options = {};
          }
          get defaultPort() {
            return typeof this.explicitDefaultPort == "number" ? this.explicitDefaultPort : sn() ? 443 : 80;
          }
          set defaultPort(i) {
            this.explicitDefaultPort = i;
          }
          get protocol() {
            return typeof this.explicitProtocol == "string" ? this.explicitProtocol : sn() ? "https:" : "http:";
          }
          set protocol(i) {
            this.explicitProtocol = i;
          }
          callback(i, n, s) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
          }
          addRequest(i, n) {
            let s = Object.assign({}, n);
            typeof s.secureEndpoint != "boolean" && (s.secureEndpoint = sn()), s.host == null && (s.host = "localhost"), s.port == null && (s.port = s.secureEndpoint ? 443 : 80), s.protocol == null && (s.protocol = s.secureEndpoint ? "https:" : "http:"), s.host && s.path && delete s.path, delete s.agent, delete s.hostname, delete s._defaultAgent, delete s.defaultPort, delete s.createConnection, i._last = true, i.shouldKeepAlive = false;
            let o = false, a = null, l = s.timeout || this.timeout, c = (p) => {
              i._hadError || (i.emit("error", p), i._hadError = true);
            }, u = () => {
              a = null, o = true;
              let p = new Error(`A "socket" was not created for HTTP request before ${l}ms`);
              p.code = "ETIMEOUT", c(p);
            }, f = (p) => {
              o || (a !== null && (clearTimeout(a), a = null), c(p));
            }, h = (p) => {
              if (o)
                return;
              if (a != null && (clearTimeout(a), a = null), Fp(p)) {
                Lr("Callback returned another Agent instance %o", p.constructor.name), p.addRequest(i, s);
                return;
              }
              if (p) {
                p.once("free", () => {
                  this.freeSocket(p, s);
                }), i.onSocket(p);
                return;
              }
              let d = new Error(`no Duplex stream was returned to agent-base for \`${i.method} ${i.path}\``);
              c(d);
            };
            if (typeof this.callback != "function") {
              c(new Error("`callback` is not defined"));
              return;
            }
            this.promisifiedCallback || (this.callback.length >= 3 ? (Lr("Converting legacy callback function to promise"), this.promisifiedCallback = Pp.default(this.callback)) : this.promisifiedCallback = this.callback), typeof l == "number" && l > 0 && (a = setTimeout(u, l)), "port" in s && typeof s.port != "number" && (s.port = Number(s.port));
            try {
              Lr("Resolving socket for %o request: %o", s.protocol, `${i.method} ${i.path}`), Promise.resolve(this.promisifiedCallback(i, s)).then(h, f);
            } catch (p) {
              Promise.reject(p).catch(f);
            }
          }
          freeSocket(i, n) {
            Lr("Freeing socket %o %o", i.constructor.name, n), i.destroy();
          }
          destroy() {
            Lr("Destroying agent %o", this.constructor.name);
          }
        }
        t.Agent = e, t.prototype = t.Agent.prototype;
      })(mi || (mi = {}));
      wa.exports = mi;
    });
    var Ea = x((Pr) => {
      "use strict";
      var Mp = Pr && Pr.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Pr, "__esModule", { value: true });
      var Up = Mp(tr()), Nr = Up.default("https-proxy-agent:parse-proxy-response");
      function Dp(t) {
        return new Promise((e, r) => {
          let i = 0, n = [];
          function s() {
            let f = t.read();
            f ? u(f) : t.once("readable", s);
          }
          function o() {
            t.removeListener("end", l), t.removeListener("error", c), t.removeListener("close", a), t.removeListener("readable", s);
          }
          function a(f) {
            Nr("onclose had error %o", f);
          }
          function l() {
            Nr("onend");
          }
          function c(f) {
            o(), Nr("onerror %o", f), r(f);
          }
          function u(f) {
            n.push(f), i += f.length;
            let h = Buffer.concat(n, i);
            if (h.indexOf(`\r
\r
`) === -1) {
              Nr("have not received end of HTTP headers yet..."), s();
              return;
            }
            let d = h.toString("ascii", 0, h.indexOf(`\r
`)), m = +d.split(" ")[1];
            Nr("got proxy server response: %o", d), e({ statusCode: m, buffered: h });
          }
          t.on("error", c), t.on("close", a), t.on("end", l), s();
        });
      }
      Pr.default = Dp;
    });
    var Ca = x((Bt) => {
      "use strict";
      var jp = Bt && Bt.__awaiter || function(t, e, r, i) {
        function n(s) {
          return s instanceof r ? s : new r(function(o) {
            o(s);
          });
        }
        return new (r || (r = Promise))(function(s, o) {
          function a(u) {
            try {
              c(i.next(u));
            } catch (f) {
              o(f);
            }
          }
          function l(u) {
            try {
              c(i.throw(u));
            } catch (f) {
              o(f);
            }
          }
          function c(u) {
            u.done ? s(u.value) : n(u.value).then(a, l);
          }
          c((i = i.apply(t, e || [])).next());
        });
      }, ir = Bt && Bt.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(Bt, "__esModule", { value: true });
      var Sa = ir(require("net")), ka = ir(require("tls")), qp = ir(require("url")), Hp = ir(require("assert")), Vp = ir(tr()), $p = an(), Gp = ir(Ea()), Fr = Vp.default("https-proxy-agent:agent"), ln = class extends $p.Agent {
        constructor(e) {
          let r;
          if (typeof e == "string" ? r = qp.default.parse(e) : r = e, !r)
            throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
          Fr("creating new HttpsProxyAgent instance: %o", r), super(r);
          let i = Object.assign({}, r);
          this.secureProxy = r.secureProxy || Yp(i.protocol), i.host = i.hostname || i.host, typeof i.port == "string" && (i.port = parseInt(i.port, 10)), !i.port && i.host && (i.port = this.secureProxy ? 443 : 80), this.secureProxy && !("ALPNProtocols" in i) && (i.ALPNProtocols = ["http 1.1"]), i.host && i.path && (delete i.path, delete i.pathname), this.proxy = i;
        }
        callback(e, r) {
          return jp(this, void 0, void 0, function* () {
            let { proxy: i, secureProxy: n } = this, s;
            n ? (Fr("Creating `tls.Socket`: %o", i), s = ka.default.connect(i)) : (Fr("Creating `net.Socket`: %o", i), s = Sa.default.connect(i));
            let o = Object.assign({}, i.headers), l = `CONNECT ${`${r.host}:${r.port}`} HTTP/1.1\r
`;
            i.auth && (o["Proxy-Authorization"] = `Basic ${Buffer.from(i.auth).toString("base64")}`);
            let { host: c, port: u, secureEndpoint: f } = r;
            Wp(u, f) || (c += `:${u}`), o.Host = c, o.Connection = "close";
            for (let g of Object.keys(o))
              l += `${g}: ${o[g]}\r
`;
            let h = Gp.default(s);
            s.write(`${l}\r
`);
            let { statusCode: p, buffered: d } = yield h;
            if (p === 200) {
              if (e.once("socket", zp), r.secureEndpoint) {
                let g = r.servername || r.host;
                if (!g)
                  throw new Error('Could not determine "servername"');
                return Fr("Upgrading socket connection to TLS"), ka.default.connect(Object.assign(Object.assign({}, Kp(r, "host", "hostname", "path", "port")), { socket: s, servername: g }));
              }
              return s;
            }
            s.destroy();
            let m = new Sa.default.Socket();
            return m.readable = true, e.once("socket", (g) => {
              Fr("replaying proxy buffer for failed request"), Hp.default(g.listenerCount("data") > 0), g.push(d), g.push(null);
            }), m;
          });
        }
      };
      Bt.default = ln;
      function zp(t) {
        t.resume();
      }
      function Wp(t, e) {
        return Boolean(!e && t === 80 || e && t === 443);
      }
      function Yp(t) {
        return typeof t == "string" ? /^https:?$/i.test(t) : false;
      }
      function Kp(t, ...e) {
        let r = {}, i;
        for (i in t)
          e.includes(i) || (r[i] = t[i]);
        return r;
      }
    });
    var Ia = x((fn, Oa) => {
      "use strict";
      var Zp = fn && fn.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      }, cn = Zp(Ca());
      function un(t) {
        return new cn.default(t);
      }
      (function(t) {
        t.HttpsProxyAgent = cn.default, t.prototype = cn.default.prototype;
      })(un || (un = {}));
      Oa.exports = un;
    });
    var Ra = x((B_, gi) => {
      var Aa = Aa || function(t) {
        return Buffer.from(t).toString("base64");
      };
      function Xp(t) {
        var e = this, r = Math.round, i = Math.floor, n = new Array(64), s = new Array(64), o = new Array(64), a = new Array(64), l, c, u, f, h = new Array(65535), p = new Array(65535), d = new Array(64), m = new Array(64), g = [], y = 0, I = 7, w = new Array(64), S = new Array(64), b = new Array(64), $ = new Array(256), C = new Array(2048), U, E = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], T = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], B = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], G = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], L = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], Q = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], R = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], F = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], j = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
        function z(v) {
          for (var D = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], W = 0; W < 64; W++) {
            var V = i((D[W] * v + 50) / 100);
            V < 1 ? V = 1 : V > 255 && (V = 255), n[E[W]] = V;
          }
          for (var J = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], ee = 0; ee < 64; ee++) {
            var he = i((J[ee] * v + 50) / 100);
            he < 1 ? he = 1 : he > 255 && (he = 255), s[E[ee]] = he;
          }
          for (var pe = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Oe = 0, be = 0; be < 8; be++)
            for (var O = 0; O < 8; O++)
              o[Oe] = 1 / (n[E[Oe]] * pe[be] * pe[O] * 8), a[Oe] = 1 / (s[E[Oe]] * pe[be] * pe[O] * 8), Oe++;
        }
        function N(v, D) {
          for (var W = 0, V = 0, J = new Array(), ee = 1; ee <= 16; ee++) {
            for (var he = 1; he <= v[ee]; he++)
              J[D[V]] = [], J[D[V]][0] = W, J[D[V]][1] = ee, V++, W++;
            W *= 2;
          }
          return J;
        }
        function Se() {
          l = N(T, B), c = N(Q, R), u = N(G, L), f = N(F, j);
        }
        function ce() {
          for (var v = 1, D = 2, W = 1; W <= 15; W++) {
            for (var V = v; V < D; V++)
              p[32767 + V] = W, h[32767 + V] = [], h[32767 + V][1] = W, h[32767 + V][0] = V;
            for (var J = -(D - 1); J <= -v; J++)
              p[32767 + J] = W, h[32767 + J] = [], h[32767 + J][1] = W, h[32767 + J][0] = D - 1 + J;
            v <<= 1, D <<= 1;
          }
        }
        function ie() {
          for (var v = 0; v < 256; v++)
            C[v] = 19595 * v, C[v + 256 >> 0] = 38470 * v, C[v + 512 >> 0] = 7471 * v + 32768, C[v + 768 >> 0] = -11059 * v, C[v + 1024 >> 0] = -21709 * v, C[v + 1280 >> 0] = 32768 * v + 8421375, C[v + 1536 >> 0] = -27439 * v, C[v + 1792 >> 0] = -5329 * v;
        }
        function ne(v) {
          for (var D = v[0], W = v[1] - 1; W >= 0; )
            D & 1 << W && (y |= 1 << I), W--, I--, I < 0 && (y == 255 ? (_(255), _(0)) : _(y), I = 7, y = 0);
        }
        function _(v) {
          g.push(v);
        }
        function q(v) {
          _(v >> 8 & 255), _(v & 255);
        }
        function ge(v, D) {
          var W, V, J, ee, he, pe, Oe, be, O = 0, M, Z = 8, ke = 64;
          for (M = 0; M < Z; ++M) {
            W = v[O], V = v[O + 1], J = v[O + 2], ee = v[O + 3], he = v[O + 4], pe = v[O + 5], Oe = v[O + 6], be = v[O + 7];
            var te = W + be, le = W - be, _e = V + Oe, Y = V - Oe, de = J + pe, Fe = J - pe, Ee = ee + he, Xe = ee - he, at = te + Ee, Tt = te - Ee, Yt = _e + de, Kt = _e - de;
            v[O] = at + Yt, v[O + 4] = at - Yt;
            var Cr = (Kt + Tt) * 0.707106781;
            v[O + 2] = Tt + Cr, v[O + 6] = Tt - Cr, at = Xe + Fe, Yt = Fe + Y, Kt = Y + le;
            var Or = (at - Kt) * 0.382683433, oi = 0.5411961 * at + Or, Ir = 1.306562965 * Kt + Or, Tr = Yt * 0.707106781, Ar = le + Tr, Rr = le - Tr;
            v[O + 5] = Rr + oi, v[O + 3] = Rr - oi, v[O + 1] = Ar + Ir, v[O + 7] = Ar - Ir, O += 8;
          }
          for (O = 0, M = 0; M < Z; ++M) {
            W = v[O], V = v[O + 8], J = v[O + 16], ee = v[O + 24], he = v[O + 32], pe = v[O + 40], Oe = v[O + 48], be = v[O + 56];
            var yo = W + be, Xi = W - be, bo = V + Oe, wo = V - Oe, Eo = J + pe, So = J - pe, ko = ee + he, Uh = ee - he, Br = yo + ko, Qi = yo - ko, ai = bo + Eo, li = bo - Eo;
            v[O] = Br + ai, v[O + 32] = Br - ai;
            var Co = (li + Qi) * 0.707106781;
            v[O + 16] = Qi + Co, v[O + 48] = Qi - Co, Br = Uh + So, ai = So + wo, li = wo + Xi;
            var Oo = (Br - li) * 0.382683433, Io = 0.5411961 * Br + Oo, To = 1.306562965 * li + Oo, Ao = ai * 0.707106781, Ro = Xi + Ao, Bo = Xi - Ao;
            v[O + 40] = Bo + Io, v[O + 24] = Bo - Io, v[O + 8] = Ro + To, v[O + 56] = Ro - To, O++;
          }
          var ci;
          for (M = 0; M < ke; ++M)
            ci = v[M] * D[M], d[M] = ci > 0 ? ci + 0.5 | 0 : ci - 0.5 | 0;
          return d;
        }
        function ve() {
          q(65504), q(16), _(74), _(70), _(73), _(70), _(0), _(1), _(1), _(0), q(1), q(1), _(0), _(0);
        }
        function ue(v) {
          if (!!v) {
            q(65505), v[0] === 69 && v[1] === 120 && v[2] === 105 && v[3] === 102 ? q(v.length + 2) : (q(v.length + 5 + 2), _(69), _(120), _(105), _(102), _(0));
            for (var D = 0; D < v.length; D++)
              _(v[D]);
          }
        }
        function fe(v, D) {
          q(65472), q(17), _(8), q(D), q(v), _(3), _(1), _(17), _(0), _(2), _(17), _(1), _(3), _(17), _(1);
        }
        function se() {
          q(65499), q(132), _(0);
          for (var v = 0; v < 64; v++)
            _(n[v]);
          _(1);
          for (var D = 0; D < 64; D++)
            _(s[D]);
        }
        function P() {
          q(65476), q(418), _(0);
          for (var v = 0; v < 16; v++)
            _(T[v + 1]);
          for (var D = 0; D <= 11; D++)
            _(B[D]);
          _(16);
          for (var W = 0; W < 16; W++)
            _(G[W + 1]);
          for (var V = 0; V <= 161; V++)
            _(L[V]);
          _(1);
          for (var J = 0; J < 16; J++)
            _(Q[J + 1]);
          for (var ee = 0; ee <= 11; ee++)
            _(R[ee]);
          _(17);
          for (var he = 0; he < 16; he++)
            _(F[he + 1]);
          for (var pe = 0; pe <= 161; pe++)
            _(j[pe]);
        }
        function A(v) {
          typeof v == "undefined" || v.constructor !== Array || v.forEach((D) => {
            if (typeof D == "string") {
              q(65534);
              var W = D.length;
              q(W + 2);
              var V;
              for (V = 0; V < W; V++)
                _(D.charCodeAt(V));
            }
          });
        }
        function ye() {
          q(65498), q(12), _(3), _(1), _(0), _(2), _(17), _(3), _(17), _(0), _(63), _(0);
        }
        function K(v, D, W, V, J) {
          for (var ee = J[0], he = J[240], pe, Oe = 16, be = 63, O = 64, M = ge(v, D), Z = 0; Z < O; ++Z)
            m[E[Z]] = M[Z];
          var ke = m[0] - W;
          W = m[0], ke == 0 ? ne(V[0]) : (pe = 32767 + ke, ne(V[p[pe]]), ne(h[pe]));
          for (var te = 63; te > 0 && m[te] == 0; te--)
            ;
          if (te == 0)
            return ne(ee), W;
          for (var le = 1, _e; le <= te; ) {
            for (var Y = le; m[le] == 0 && le <= te; ++le)
              ;
            var de = le - Y;
            if (de >= Oe) {
              _e = de >> 4;
              for (var Fe = 1; Fe <= _e; ++Fe)
                ne(he);
              de = de & 15;
            }
            pe = 32767 + m[le], ne(J[(de << 4) + p[pe]]), ne(h[pe]), le++;
          }
          return te != be && ne(ee), W;
        }
        function oe() {
          for (var v = String.fromCharCode, D = 0; D < 256; D++)
            $[D] = v(D);
        }
        this.encode = function(v, D) {
          var W = new Date().getTime();
          D && Ze(D), g = new Array(), y = 0, I = 7, q(65496), ve(), A(v.comments), ue(v.exifBuffer), se(), fe(v.width, v.height), P(), ye();
          var V = 0, J = 0, ee = 0;
          y = 0, I = 7, this.encode.displayName = "_encode_";
          for (var he = v.data, pe = v.width, Oe = v.height, be = pe * 4, O = pe * 3, M, Z = 0, ke, te, le, _e, Y, de, Fe, Ee; Z < Oe; ) {
            for (M = 0; M < be; ) {
              for (_e = be * Z + M, Y = _e, de = -1, Fe = 0, Ee = 0; Ee < 64; Ee++)
                Fe = Ee >> 3, de = (Ee & 7) * 4, Y = _e + Fe * be + de, Z + Fe >= Oe && (Y -= be * (Z + 1 + Fe - Oe)), M + de >= be && (Y -= M + de - be + 4), ke = he[Y++], te = he[Y++], le = he[Y++], w[Ee] = (C[ke] + C[te + 256 >> 0] + C[le + 512 >> 0] >> 16) - 128, S[Ee] = (C[ke + 768 >> 0] + C[te + 1024 >> 0] + C[le + 1280 >> 0] >> 16) - 128, b[Ee] = (C[ke + 1280 >> 0] + C[te + 1536 >> 0] + C[le + 1792 >> 0] >> 16) - 128;
              V = K(w, o, V, l, u), J = K(S, a, J, c, f), ee = K(b, a, ee, c, f), M += 32;
            }
            Z += 8;
          }
          if (I >= 0) {
            var Xe = [];
            Xe[1] = I + 1, Xe[0] = (1 << I + 1) - 1, ne(Xe);
          }
          if (q(65497), typeof gi == "undefined")
            return new Uint8Array(g);
          return Buffer.from(g);
          var at, Tt;
        };
        function Ze(v) {
          if (v <= 0 && (v = 1), v > 100 && (v = 100), U != v) {
            var D = 0;
            v < 50 ? D = Math.floor(5e3 / v) : D = Math.floor(200 - v * 2), z(D), U = v;
          }
        }
        function tt() {
          var v = new Date().getTime();
          t || (t = 50), oe(), Se(), ce(), ie(), Ze(t);
          var D = new Date().getTime() - v;
        }
        tt();
      }
      typeof gi != "undefined" ? gi.exports = Ta : typeof window != "undefined" && (window["jpeg-js"] = window["jpeg-js"] || {}, window["jpeg-js"].encode = Ta);
      function Ta(t, e) {
        typeof e == "undefined" && (e = 50);
        var r = new Xp(e), i = r.encode(t, e);
        return { data: i, width: t.width, height: t.height };
      }
    });
    var La = x((L_, pn) => {
      var hn = function() {
        "use strict";
        var e = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), r = 4017, i = 799, n = 3406, s = 2276, o = 1567, a = 3784, l = 5793, c = 2896;
        function u() {
        }
        function f(I, w) {
          for (var S = 0, b = [], $, C, U = 16; U > 0 && !I[U - 1]; )
            U--;
          b.push({ children: [], index: 0 });
          var E = b[0], T;
          for ($ = 0; $ < U; $++) {
            for (C = 0; C < I[$]; C++) {
              for (E = b.pop(), E.children[E.index] = w[S]; E.index > 0; ) {
                if (b.length === 0)
                  throw new Error("Could not recreate Huffman Table");
                E = b.pop();
              }
              for (E.index++, b.push(E); b.length <= $; )
                b.push(T = { children: [], index: 0 }), E.children[E.index] = T.children, E = T;
              S++;
            }
            $ + 1 < U && (b.push(T = { children: [], index: 0 }), E.children[E.index] = T.children, E = T);
          }
          return b[0].children;
        }
        function h(I, w, S, b, $, C, U, E, T, B) {
          var G = S.precision, L = S.samplesPerLine, Q = S.scanLines, R = S.mcusPerLine, F = S.progressive, j = S.maxH, z = S.maxV, N = w, Se = 0, ce = 0;
          function ie() {
            if (ce > 0)
              return ce--, Se >> ce & 1;
            if (Se = I[w++], Se == 255) {
              var O = I[w++];
              if (O)
                throw new Error("unexpected marker: " + (Se << 8 | O).toString(16));
            }
            return ce = 7, Se >>> 7;
          }
          function ne(O) {
            for (var M = O, Z; (Z = ie()) !== null; ) {
              if (M = M[Z], typeof M == "number")
                return M;
              if (typeof M != "object")
                throw new Error("invalid huffman sequence");
            }
            return null;
          }
          function _(O) {
            for (var M = 0; O > 0; ) {
              var Z = ie();
              if (Z === null)
                return;
              M = M << 1 | Z, O--;
            }
            return M;
          }
          function q(O) {
            var M = _(O);
            return M >= 1 << O - 1 ? M : M + (-1 << O) + 1;
          }
          function ge(O, M) {
            var Z = ne(O.huffmanTableDC), ke = Z === 0 ? 0 : q(Z);
            M[0] = O.pred += ke;
            for (var te = 1; te < 64; ) {
              var le = ne(O.huffmanTableAC), _e = le & 15, Y = le >> 4;
              if (_e === 0) {
                if (Y < 15)
                  break;
                te += 16;
                continue;
              }
              te += Y;
              var de = e[te];
              M[de] = q(_e), te++;
            }
          }
          function ve(O, M) {
            var Z = ne(O.huffmanTableDC), ke = Z === 0 ? 0 : q(Z) << T;
            M[0] = O.pred += ke;
          }
          function ue(O, M) {
            M[0] |= ie() << T;
          }
          var fe = 0;
          function se(O, M) {
            if (fe > 0) {
              fe--;
              return;
            }
            for (var Z = C, ke = U; Z <= ke; ) {
              var te = ne(O.huffmanTableAC), le = te & 15, _e = te >> 4;
              if (le === 0) {
                if (_e < 15) {
                  fe = _(_e) + (1 << _e) - 1;
                  break;
                }
                Z += 16;
                continue;
              }
              Z += _e;
              var Y = e[Z];
              M[Y] = q(le) * (1 << T), Z++;
            }
          }
          var P = 0, A;
          function ye(O, M) {
            for (var Z = C, ke = U, te = 0; Z <= ke; ) {
              var le = e[Z], _e = M[le] < 0 ? -1 : 1;
              switch (P) {
                case 0:
                  var Y = ne(O.huffmanTableAC), de = Y & 15, te = Y >> 4;
                  if (de === 0)
                    te < 15 ? (fe = _(te) + (1 << te), P = 4) : (te = 16, P = 1);
                  else {
                    if (de !== 1)
                      throw new Error("invalid ACn encoding");
                    A = q(de), P = te ? 2 : 3;
                  }
                  continue;
                case 1:
                case 2:
                  M[le] ? M[le] += (ie() << T) * _e : (te--, te === 0 && (P = P == 2 ? 3 : 0));
                  break;
                case 3:
                  M[le] ? M[le] += (ie() << T) * _e : (M[le] = A << T, P = 0);
                  break;
                case 4:
                  M[le] && (M[le] += (ie() << T) * _e);
                  break;
              }
              Z++;
            }
            P === 4 && (fe--, fe === 0 && (P = 0));
          }
          function K(O, M, Z, ke, te) {
            var le = Z / R | 0, _e = Z % R, Y = le * O.v + ke, de = _e * O.h + te;
            O.blocks[Y] === void 0 && B.tolerantDecoding || M(O, O.blocks[Y][de]);
          }
          function oe(O, M, Z) {
            var ke = Z / O.blocksPerLine | 0, te = Z % O.blocksPerLine;
            O.blocks[ke] === void 0 && B.tolerantDecoding || M(O, O.blocks[ke][te]);
          }
          var Ze = b.length, tt, v, D, W, V, J;
          F ? C === 0 ? J = E === 0 ? ve : ue : J = E === 0 ? se : ye : J = ge;
          var ee = 0, he, pe;
          Ze == 1 ? pe = b[0].blocksPerLine * b[0].blocksPerColumn : pe = R * S.mcusPerColumn, $ || ($ = pe);
          for (var Oe, be; ee < pe; ) {
            for (v = 0; v < Ze; v++)
              b[v].pred = 0;
            if (fe = 0, Ze == 1)
              for (tt = b[0], V = 0; V < $; V++)
                oe(tt, J, ee), ee++;
            else
              for (V = 0; V < $; V++) {
                for (v = 0; v < Ze; v++)
                  for (tt = b[v], Oe = tt.h, be = tt.v, D = 0; D < be; D++)
                    for (W = 0; W < Oe; W++)
                      K(tt, J, ee, D, W);
                if (ee++, ee === pe)
                  break;
              }
            if (ee === pe)
              do {
                if (I[w] === 255 && I[w + 1] !== 0)
                  break;
                w += 1;
              } while (w < I.length - 2);
            if (ce = 0, he = I[w] << 8 | I[w + 1], he < 65280)
              throw new Error("marker was not found");
            if (he >= 65488 && he <= 65495)
              w += 2;
            else
              break;
          }
          return w - N;
        }
        function p(I, w) {
          var S = [], b = w.blocksPerLine, $ = w.blocksPerColumn, C = b << 3, U = new Int32Array(64), E = new Uint8Array(64);
          function T(N, Se, ce) {
            var ie = w.quantizationTable, ne, _, q, ge, ve, ue, fe, se, P, A = ce, ye;
            for (ye = 0; ye < 64; ye++)
              A[ye] = N[ye] * ie[ye];
            for (ye = 0; ye < 8; ++ye) {
              var K = 8 * ye;
              if (A[1 + K] == 0 && A[2 + K] == 0 && A[3 + K] == 0 && A[4 + K] == 0 && A[5 + K] == 0 && A[6 + K] == 0 && A[7 + K] == 0) {
                P = l * A[0 + K] + 512 >> 10, A[0 + K] = P, A[1 + K] = P, A[2 + K] = P, A[3 + K] = P, A[4 + K] = P, A[5 + K] = P, A[6 + K] = P, A[7 + K] = P;
                continue;
              }
              ne = l * A[0 + K] + 128 >> 8, _ = l * A[4 + K] + 128 >> 8, q = A[2 + K], ge = A[6 + K], ve = c * (A[1 + K] - A[7 + K]) + 128 >> 8, se = c * (A[1 + K] + A[7 + K]) + 128 >> 8, ue = A[3 + K] << 4, fe = A[5 + K] << 4, P = ne - _ + 1 >> 1, ne = ne + _ + 1 >> 1, _ = P, P = q * a + ge * o + 128 >> 8, q = q * o - ge * a + 128 >> 8, ge = P, P = ve - fe + 1 >> 1, ve = ve + fe + 1 >> 1, fe = P, P = se + ue + 1 >> 1, ue = se - ue + 1 >> 1, se = P, P = ne - ge + 1 >> 1, ne = ne + ge + 1 >> 1, ge = P, P = _ - q + 1 >> 1, _ = _ + q + 1 >> 1, q = P, P = ve * s + se * n + 2048 >> 12, ve = ve * n - se * s + 2048 >> 12, se = P, P = ue * i + fe * r + 2048 >> 12, ue = ue * r - fe * i + 2048 >> 12, fe = P, A[0 + K] = ne + se, A[7 + K] = ne - se, A[1 + K] = _ + fe, A[6 + K] = _ - fe, A[2 + K] = q + ue, A[5 + K] = q - ue, A[3 + K] = ge + ve, A[4 + K] = ge - ve;
            }
            for (ye = 0; ye < 8; ++ye) {
              var oe = ye;
              if (A[8 + oe] == 0 && A[16 + oe] == 0 && A[24 + oe] == 0 && A[32 + oe] == 0 && A[40 + oe] == 0 && A[48 + oe] == 0 && A[56 + oe] == 0) {
                P = l * ce[ye + 0] + 8192 >> 14, A[0 + oe] = P, A[8 + oe] = P, A[16 + oe] = P, A[24 + oe] = P, A[32 + oe] = P, A[40 + oe] = P, A[48 + oe] = P, A[56 + oe] = P;
                continue;
              }
              ne = l * A[0 + oe] + 2048 >> 12, _ = l * A[32 + oe] + 2048 >> 12, q = A[16 + oe], ge = A[48 + oe], ve = c * (A[8 + oe] - A[56 + oe]) + 2048 >> 12, se = c * (A[8 + oe] + A[56 + oe]) + 2048 >> 12, ue = A[24 + oe], fe = A[40 + oe], P = ne - _ + 1 >> 1, ne = ne + _ + 1 >> 1, _ = P, P = q * a + ge * o + 2048 >> 12, q = q * o - ge * a + 2048 >> 12, ge = P, P = ve - fe + 1 >> 1, ve = ve + fe + 1 >> 1, fe = P, P = se + ue + 1 >> 1, ue = se - ue + 1 >> 1, se = P, P = ne - ge + 1 >> 1, ne = ne + ge + 1 >> 1, ge = P, P = _ - q + 1 >> 1, _ = _ + q + 1 >> 1, q = P, P = ve * s + se * n + 2048 >> 12, ve = ve * n - se * s + 2048 >> 12, se = P, P = ue * i + fe * r + 2048 >> 12, ue = ue * r - fe * i + 2048 >> 12, fe = P, A[0 + oe] = ne + se, A[56 + oe] = ne - se, A[8 + oe] = _ + fe, A[48 + oe] = _ - fe, A[16 + oe] = q + ue, A[40 + oe] = q - ue, A[24 + oe] = ge + ve, A[32 + oe] = ge - ve;
            }
            for (ye = 0; ye < 64; ++ye) {
              var Ze = 128 + (A[ye] + 8 >> 4);
              Se[ye] = Ze < 0 ? 0 : Ze > 255 ? 255 : Ze;
            }
          }
          y(C * $ * 8);
          for (var B, G, L = 0; L < $; L++) {
            var Q = L << 3;
            for (B = 0; B < 8; B++)
              S.push(new Uint8Array(C));
            for (var R = 0; R < b; R++) {
              T(w.blocks[L][R], E, U);
              var F = 0, j = R << 3;
              for (G = 0; G < 8; G++) {
                var z = S[Q + G];
                for (B = 0; B < 8; B++)
                  z[j + B] = E[F++];
              }
            }
          }
          return S;
        }
        function d(I) {
          return I < 0 ? 0 : I > 255 ? 255 : I;
        }
        u.prototype = { load: function(w) {
          var S = new XMLHttpRequest();
          S.open("GET", w, true), S.responseType = "arraybuffer", S.onload = function() {
            var b = new Uint8Array(S.response || S.mozResponseArrayBuffer);
            this.parse(b), this.onload && this.onload();
          }.bind(this), S.send(null);
        }, parse: function(w) {
          var S = this.opts.maxResolutionInMP * 1e3 * 1e3, b = 0, $ = w.length;
          function C() {
            var Y = w[b] << 8 | w[b + 1];
            return b += 2, Y;
          }
          function U() {
            var Y = C(), de = w.subarray(b, b + Y - 2);
            return b += de.length, de;
          }
          function E(Y) {
            var de = 1, Fe = 1, Ee, Xe;
            for (Xe in Y.components)
              Y.components.hasOwnProperty(Xe) && (Ee = Y.components[Xe], de < Ee.h && (de = Ee.h), Fe < Ee.v && (Fe = Ee.v));
            var at = Math.ceil(Y.samplesPerLine / 8 / de), Tt = Math.ceil(Y.scanLines / 8 / Fe);
            for (Xe in Y.components)
              if (Y.components.hasOwnProperty(Xe)) {
                Ee = Y.components[Xe];
                var Yt = Math.ceil(Math.ceil(Y.samplesPerLine / 8) * Ee.h / de), Kt = Math.ceil(Math.ceil(Y.scanLines / 8) * Ee.v / Fe), Cr = at * Ee.h, Or = Tt * Ee.v, oi = Or * Cr, Ir = [];
                y(oi * 256);
                for (var Tr = 0; Tr < Or; Tr++) {
                  for (var Ar = [], Rr = 0; Rr < Cr; Rr++)
                    Ar.push(new Int32Array(64));
                  Ir.push(Ar);
                }
                Ee.blocksPerLine = Yt, Ee.blocksPerColumn = Kt, Ee.blocks = Ir;
              }
            Y.maxH = de, Y.maxV = Fe, Y.mcusPerLine = at, Y.mcusPerColumn = Tt;
          }
          var T = null, B = null, G = null, L, Q, R = [], F = [], j = [], z = [], N = C(), Se = -1;
          if (this.comments = [], N != 65496)
            throw new Error("SOI not found");
          for (N = C(); N != 65497; ) {
            var ce, ie, ne;
            switch (N) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var _ = U();
                if (N === 65534) {
                  var q = String.fromCharCode.apply(null, _);
                  this.comments.push(q);
                }
                N === 65504 && _[0] === 74 && _[1] === 70 && _[2] === 73 && _[3] === 70 && _[4] === 0 && (T = { version: { major: _[5], minor: _[6] }, densityUnits: _[7], xDensity: _[8] << 8 | _[9], yDensity: _[10] << 8 | _[11], thumbWidth: _[12], thumbHeight: _[13], thumbData: _.subarray(14, 14 + 3 * _[12] * _[13]) }), N === 65505 && _[0] === 69 && _[1] === 120 && _[2] === 105 && _[3] === 102 && _[4] === 0 && (this.exifBuffer = _.subarray(5, _.length)), N === 65518 && _[0] === 65 && _[1] === 100 && _[2] === 111 && _[3] === 98 && _[4] === 101 && _[5] === 0 && (B = { version: _[6], flags0: _[7] << 8 | _[8], flags1: _[9] << 8 | _[10], transformCode: _[11] });
                break;
              case 65499:
                for (var ge = C(), ve = ge + b - 2; b < ve; ) {
                  var ue = w[b++];
                  y(256);
                  var fe = new Int32Array(64);
                  if (ue >> 4 === 0)
                    for (ie = 0; ie < 64; ie++) {
                      var se = e[ie];
                      fe[se] = w[b++];
                    }
                  else if (ue >> 4 === 1)
                    for (ie = 0; ie < 64; ie++) {
                      var se = e[ie];
                      fe[se] = C();
                    }
                  else
                    throw new Error("DQT: invalid table spec");
                  R[ue & 15] = fe;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                C(), L = {}, L.extended = N === 65473, L.progressive = N === 65474, L.precision = w[b++], L.scanLines = C(), L.samplesPerLine = C(), L.components = {}, L.componentsOrder = [];
                var P = L.scanLines * L.samplesPerLine;
                if (P > S) {
                  var A = Math.ceil((P - S) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${A}MP`);
                }
                var ye = w[b++], K, oe = 0, Ze = 0;
                for (ce = 0; ce < ye; ce++) {
                  K = w[b];
                  var tt = w[b + 1] >> 4, v = w[b + 1] & 15, D = w[b + 2];
                  if (tt <= 0 || v <= 0)
                    throw new Error("Invalid sampling factor, expected values above 0");
                  L.componentsOrder.push(K), L.components[K] = { h: tt, v, quantizationIdx: D }, b += 3;
                }
                E(L), F.push(L);
                break;
              case 65476:
                var W = C();
                for (ce = 2; ce < W; ) {
                  var V = w[b++], J = new Uint8Array(16), ee = 0;
                  for (ie = 0; ie < 16; ie++, b++)
                    ee += J[ie] = w[b];
                  y(16 + ee);
                  var he = new Uint8Array(ee);
                  for (ie = 0; ie < ee; ie++, b++)
                    he[ie] = w[b];
                  ce += 17 + ee, (V >> 4 === 0 ? z : j)[V & 15] = f(J, he);
                }
                break;
              case 65501:
                C(), Q = C();
                break;
              case 65500:
                C(), C();
                break;
              case 65498:
                var pe = C(), Oe = w[b++], be = [], O;
                for (ce = 0; ce < Oe; ce++) {
                  O = L.components[w[b++]];
                  var M = w[b++];
                  O.huffmanTableDC = z[M >> 4], O.huffmanTableAC = j[M & 15], be.push(O);
                }
                var Z = w[b++], ke = w[b++], te = w[b++], le = h(w, b, L, be, Q, Z, ke, te >> 4, te & 15, this.opts);
                b += le;
                break;
              case 65535:
                w[b] !== 255 && b--;
                break;
              default:
                if (w[b - 3] == 255 && w[b - 2] >= 192 && w[b - 2] <= 254) {
                  b -= 3;
                  break;
                } else if (N === 224 || N == 225) {
                  if (Se !== -1)
                    throw new Error(`first unknown JPEG marker at offset ${Se.toString(16)}, second unknown JPEG marker ${N.toString(16)} at offset ${(b - 1).toString(16)}`);
                  Se = b - 1;
                  let Y = C();
                  if (w[b + Y - 2] === 255) {
                    b += Y - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + N.toString(16));
            }
            N = C();
          }
          if (F.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var ce = 0; ce < F.length; ce++) {
            var _e = F[ce].components;
            for (var ie in _e)
              _e[ie].quantizationTable = R[_e[ie].quantizationIdx], delete _e[ie].quantizationIdx;
          }
          this.width = L.samplesPerLine, this.height = L.scanLines, this.jfif = T, this.adobe = B, this.components = [];
          for (var ce = 0; ce < L.componentsOrder.length; ce++) {
            var O = L.components[L.componentsOrder[ce]];
            this.components.push({ lines: p(L, O), scaleX: O.h / L.maxH, scaleY: O.v / L.maxV });
          }
        }, getData: function(w, S) {
          var b = this.width / w, $ = this.height / S, C, U, E, T, B, G, L, Q, R, F, j = 0, z, N, Se, ce, ie, ne, _, q, ge, ve, ue, fe = w * S * this.components.length;
          y(fe);
          var se = new Uint8Array(fe);
          switch (this.components.length) {
            case 1:
              for (C = this.components[0], F = 0; F < S; F++)
                for (B = C.lines[0 | F * C.scaleY * $], R = 0; R < w; R++)
                  z = B[0 | R * C.scaleX * b], se[j++] = z;
              break;
            case 2:
              for (C = this.components[0], U = this.components[1], F = 0; F < S; F++)
                for (B = C.lines[0 | F * C.scaleY * $], G = U.lines[0 | F * U.scaleY * $], R = 0; R < w; R++)
                  z = B[0 | R * C.scaleX * b], se[j++] = z, z = G[0 | R * U.scaleX * b], se[j++] = z;
              break;
            case 3:
              for (ue = true, this.adobe && this.adobe.transformCode ? ue = true : typeof this.opts.colorTransform != "undefined" && (ue = !!this.opts.colorTransform), C = this.components[0], U = this.components[1], E = this.components[2], F = 0; F < S; F++)
                for (B = C.lines[0 | F * C.scaleY * $], G = U.lines[0 | F * U.scaleY * $], L = E.lines[0 | F * E.scaleY * $], R = 0; R < w; R++)
                  ue ? (z = B[0 | R * C.scaleX * b], N = G[0 | R * U.scaleX * b], Se = L[0 | R * E.scaleX * b], q = d(z + 1.402 * (Se - 128)), ge = d(z - 0.3441363 * (N - 128) - 0.71413636 * (Se - 128)), ve = d(z + 1.772 * (N - 128))) : (q = B[0 | R * C.scaleX * b], ge = G[0 | R * U.scaleX * b], ve = L[0 | R * E.scaleX * b]), se[j++] = q, se[j++] = ge, se[j++] = ve;
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              for (ue = false, this.adobe && this.adobe.transformCode ? ue = true : typeof this.opts.colorTransform != "undefined" && (ue = !!this.opts.colorTransform), C = this.components[0], U = this.components[1], E = this.components[2], T = this.components[3], F = 0; F < S; F++)
                for (B = C.lines[0 | F * C.scaleY * $], G = U.lines[0 | F * U.scaleY * $], L = E.lines[0 | F * E.scaleY * $], Q = T.lines[0 | F * T.scaleY * $], R = 0; R < w; R++)
                  ue ? (z = B[0 | R * C.scaleX * b], N = G[0 | R * U.scaleX * b], Se = L[0 | R * E.scaleX * b], ce = Q[0 | R * T.scaleX * b], ie = 255 - d(z + 1.402 * (Se - 128)), ne = 255 - d(z - 0.3441363 * (N - 128) - 0.71413636 * (Se - 128)), _ = 255 - d(z + 1.772 * (N - 128))) : (ie = B[0 | R * C.scaleX * b], ne = G[0 | R * U.scaleX * b], _ = L[0 | R * E.scaleX * b], ce = Q[0 | R * T.scaleX * b]), se[j++] = 255 - ie, se[j++] = 255 - ne, se[j++] = 255 - _, se[j++] = 255 - ce;
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return se;
        }, copyToImageData: function(w, S) {
          var b = w.width, $ = w.height, C = w.data, U = this.getData(b, $), E = 0, T = 0, B, G, L, Q, R, F, j, z, N;
          switch (this.components.length) {
            case 1:
              for (G = 0; G < $; G++)
                for (B = 0; B < b; B++)
                  L = U[E++], C[T++] = L, C[T++] = L, C[T++] = L, S && (C[T++] = 255);
              break;
            case 3:
              for (G = 0; G < $; G++)
                for (B = 0; B < b; B++)
                  j = U[E++], z = U[E++], N = U[E++], C[T++] = j, C[T++] = z, C[T++] = N, S && (C[T++] = 255);
              break;
            case 4:
              for (G = 0; G < $; G++)
                for (B = 0; B < b; B++)
                  R = U[E++], F = U[E++], L = U[E++], Q = U[E++], j = 255 - d(R * (1 - Q / 255) + Q), z = 255 - d(F * (1 - Q / 255) + Q), N = 255 - d(L * (1 - Q / 255) + Q), C[T++] = j, C[T++] = z, C[T++] = N, S && (C[T++] = 255);
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        } };
        var m = 0, g = 0;
        function y(I = 0) {
          var w = m + I;
          if (w > g) {
            var S = Math.ceil((w - g) / 1024 / 1024);
            throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${S}MB`);
          }
          m = w;
        }
        return u.resetMaxMemoryUsage = function(I) {
          m = 0, g = I;
        }, u.getBytesAllocated = function() {
          return m;
        }, u.requestMemoryAllocation = y, u;
      }();
      typeof pn != "undefined" ? pn.exports = Ba : typeof window != "undefined" && (window["jpeg-js"] = window["jpeg-js"] || {}, window["jpeg-js"].decode = Ba);
      function Ba(t, e = {}) {
        var r = { colorTransform: void 0, useTArray: false, formatAsRGBA: true, tolerantDecoding: true, maxResolutionInMP: 100, maxMemoryUsageInMB: 512 }, i = __spreadValues(__spreadValues({}, r), e), n = new Uint8Array(t), s = new hn();
        s.opts = i, hn.resetMaxMemoryUsage(i.maxMemoryUsageInMB * 1024 * 1024), s.parse(n);
        var o = i.formatAsRGBA ? 4 : 3, a = s.width * s.height * o;
        try {
          hn.requestMemoryAllocation(a);
          var l = { width: s.width, height: s.height, exifBuffer: s.exifBuffer, data: i.useTArray ? new Uint8Array(a) : Buffer.alloc(a) };
          s.comments.length > 0 && (l.comments = s.comments);
        } catch (c) {
          throw c instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + a) : c instanceof ReferenceError && c.message === "Buffer is not defined" ? new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true") : c;
        }
        return s.copyToImageData(l, i.formatAsRGBA), l;
      }
    });
    var Pa = x((N_, Na) => {
      var Qp = Ra(), Jp = La();
      Na.exports = { encode: Qp, decode: Jp };
    });
    var Ma = x((P_, Fa) => {
      "use strict";
      function vi() {
        this._types = Object.create(null), this._extensions = Object.create(null);
        for (let t = 0; t < arguments.length; t++)
          this.define(arguments[t]);
        this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
      }
      vi.prototype.define = function(t, e) {
        for (let r in t) {
          let i = t[r].map(function(n) {
            return n.toLowerCase();
          });
          r = r.toLowerCase();
          for (let n = 0; n < i.length; n++) {
            let s = i[n];
            if (s[0] !== "*") {
              if (!e && s in this._types)
                throw new Error('Attempt to change mapping for "' + s + '" extension from "' + this._types[s] + '" to "' + r + '". Pass `force=true` to allow this, otherwise remove "' + s + '" from the list of extensions for "' + r + '".');
              this._types[s] = r;
            }
          }
          if (e || !this._extensions[r]) {
            let n = i[0];
            this._extensions[r] = n[0] !== "*" ? n : n.substr(1);
          }
        }
      };
      vi.prototype.getType = function(t) {
        t = String(t);
        let e = t.replace(/^.*[/\\]/, "").toLowerCase(), r = e.replace(/^.*\./, "").toLowerCase(), i = e.length < t.length;
        return (r.length < e.length - 1 || !i) && this._types[r] || null;
      };
      vi.prototype.getExtension = function(t) {
        return t = /^\s*([^;\s]*)/.test(t) && RegExp.$1, t && this._extensions[t.toLowerCase()] || null;
      };
      Fa.exports = vi;
    });
    var Da = x((F_, Ua) => {
      Ua.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    });
    var qa = x((M_, ja) => {
      ja.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
    });
    var Va = x((U_, Ha) => {
      "use strict";
      var ed = Ma();
      Ha.exports = new ed(Da(), qa());
    });
    var Ga = x((D_, $a) => {
      $a.exports = function(t, e) {
        for (var r = [], i = 0; i < t.length; i++) {
          var n = e(t[i], i);
          td(n) ? r.push.apply(r, n) : r.push(n);
        }
        return r;
      };
      var td = Array.isArray || function(t) {
        return Object.prototype.toString.call(t) === "[object Array]";
      };
    });
    var Za = x((j_, Ka) => {
      "use strict";
      Ka.exports = Wa;
      function Wa(t, e, r) {
        t instanceof RegExp && (t = za(t, r)), e instanceof RegExp && (e = za(e, r));
        var i = Ya(t, e, r);
        return i && { start: i[0], end: i[1], pre: r.slice(0, i[0]), body: r.slice(i[0] + t.length, i[1]), post: r.slice(i[1] + e.length) };
      }
      function za(t, e) {
        var r = e.match(t);
        return r ? r[0] : null;
      }
      Wa.range = Ya;
      function Ya(t, e, r) {
        var i, n, s, o, a, l = r.indexOf(t), c = r.indexOf(e, l + 1), u = l;
        if (l >= 0 && c > 0) {
          if (t === e)
            return [l, c];
          for (i = [], s = r.length; u >= 0 && !a; )
            u == l ? (i.push(u), l = r.indexOf(t, u + 1)) : i.length == 1 ? a = [i.pop(), c] : (n = i.pop(), n < s && (s = n, o = c), c = r.indexOf(e, u + 1)), u = l < c && l >= 0 ? l : c;
          i.length && (a = [s, o]);
        }
        return a;
      }
    });
    var nl = x((q_, il) => {
      var rd = Ga(), Xa = Za();
      il.exports = sd;
      var Qa = "\0SLASH" + Math.random() + "\0", Ja = "\0OPEN" + Math.random() + "\0", mn = "\0CLOSE" + Math.random() + "\0", el = "\0COMMA" + Math.random() + "\0", tl = "\0PERIOD" + Math.random() + "\0";
      function dn(t) {
        return parseInt(t, 10) == t ? parseInt(t, 10) : t.charCodeAt(0);
      }
      function id(t) {
        return t.split("\\\\").join(Qa).split("\\{").join(Ja).split("\\}").join(mn).split("\\,").join(el).split("\\.").join(tl);
      }
      function nd(t) {
        return t.split(Qa).join("\\").split(Ja).join("{").split(mn).join("}").split(el).join(",").split(tl).join(".");
      }
      function rl(t) {
        if (!t)
          return [""];
        var e = [], r = Xa("{", "}", t);
        if (!r)
          return t.split(",");
        var i = r.pre, n = r.body, s = r.post, o = i.split(",");
        o[o.length - 1] += "{" + n + "}";
        var a = rl(s);
        return s.length && (o[o.length - 1] += a.shift(), o.push.apply(o, a)), e.push.apply(e, o), e;
      }
      function sd(t) {
        return t ? (t.substr(0, 2) === "{}" && (t = "\\{\\}" + t.substr(2)), nr(id(t), true).map(nd)) : [];
      }
      function od(t) {
        return "{" + t + "}";
      }
      function ad(t) {
        return /^-?0\d/.test(t);
      }
      function ld(t, e) {
        return t <= e;
      }
      function cd(t, e) {
        return t >= e;
      }
      function nr(t, e) {
        var r = [], i = Xa("{", "}", t);
        if (!i || /\$$/.test(i.pre))
          return [t];
        var n = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(i.body), s = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(i.body), o = n || s, a = i.body.indexOf(",") >= 0;
        if (!o && !a)
          return i.post.match(/,.*\}/) ? (t = i.pre + "{" + i.body + mn + i.post, nr(t)) : [t];
        var l;
        if (o)
          l = i.body.split(/\.\./);
        else if (l = rl(i.body), l.length === 1 && (l = nr(l[0], false).map(od), l.length === 1)) {
          var u = i.post.length ? nr(i.post, false) : [""];
          return u.map(function(B) {
            return i.pre + l[0] + B;
          });
        }
        var c = i.pre, u = i.post.length ? nr(i.post, false) : [""], f;
        if (o) {
          var h = dn(l[0]), p = dn(l[1]), d = Math.max(l[0].length, l[1].length), m = l.length == 3 ? Math.abs(dn(l[2])) : 1, g = ld, y = p < h;
          y && (m *= -1, g = cd);
          var I = l.some(ad);
          f = [];
          for (var w = h; g(w, p); w += m) {
            var S;
            if (s)
              S = String.fromCharCode(w), S === "\\" && (S = "");
            else if (S = String(w), I) {
              var b = d - S.length;
              if (b > 0) {
                var $ = new Array(b + 1).join("0");
                w < 0 ? S = "-" + $ + S.slice(1) : S = $ + S;
              }
            }
            f.push(S);
          }
        } else
          f = rd(l, function(T) {
            return nr(T, false);
          });
        for (var C = 0; C < f.length; C++)
          for (var U = 0; U < u.length; U++) {
            var E = c + f[C] + u[U];
            (!e || o || E) && r.push(E);
          }
        return r;
      }
    });
    var Ur = x((H_, cl) => {
      cl.exports = Ye;
      Ye.Minimatch = Ue;
      var Mr = function() {
        try {
          return require("path");
        } catch (e) {
        }
      }() || { sep: "/" };
      Ye.sep = Mr.sep;
      var _n = Ye.GLOBSTAR = Ue.GLOBSTAR = {}, ud = nl(), sl = { "!": { open: "(?:(?!(?:", close: "))[^/]*?)" }, "?": { open: "(?:", close: ")?" }, "+": { open: "(?:", close: ")+" }, "*": { open: "(?:", close: ")*" }, "@": { open: "(?:", close: ")" } }, gn = "[^/]", vn = gn + "*?", fd = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", hd = "(?:(?!(?:\\/|^)\\.).)*?", ol = pd("().*{}+?[]^$\\!");
      function pd(t) {
        return t.split("").reduce(function(e, r) {
          return e[r] = true, e;
        }, {});
      }
      var al = /\/+/;
      Ye.filter = dd;
      function dd(t, e) {
        return e = e || {}, function(r, i, n) {
          return Ye(r, t, e);
        };
      }
      function gt(t, e) {
        e = e || {};
        var r = {};
        return Object.keys(t).forEach(function(i) {
          r[i] = t[i];
        }), Object.keys(e).forEach(function(i) {
          r[i] = e[i];
        }), r;
      }
      Ye.defaults = function(t) {
        if (!t || typeof t != "object" || !Object.keys(t).length)
          return Ye;
        var e = Ye, r = function(n, s, o) {
          return e(n, s, gt(t, o));
        };
        return r.Minimatch = function(n, s) {
          return new e.Minimatch(n, gt(t, s));
        }, r.Minimatch.defaults = function(n) {
          return e.defaults(gt(t, n)).Minimatch;
        }, r.filter = function(n, s) {
          return e.filter(n, gt(t, s));
        }, r.defaults = function(n) {
          return e.defaults(gt(t, n));
        }, r.makeRe = function(n, s) {
          return e.makeRe(n, gt(t, s));
        }, r.braceExpand = function(n, s) {
          return e.braceExpand(n, gt(t, s));
        }, r.match = function(i, n, s) {
          return e.match(i, n, gt(t, s));
        }, r;
      };
      Ue.defaults = function(t) {
        return Ye.defaults(t).Minimatch;
      };
      function Ye(t, e, r) {
        return xi(e), r || (r = {}), !r.nocomment && e.charAt(0) === "#" ? false : new Ue(e, r).match(t);
      }
      function Ue(t, e) {
        if (!(this instanceof Ue))
          return new Ue(t, e);
        xi(t), e || (e = {}), t = t.trim(), !e.allowWindowsEscape && Mr.sep !== "/" && (t = t.split(Mr.sep).join("/")), this.options = e, this.set = [], this.pattern = t, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.partial = !!e.partial, this.make();
      }
      Ue.prototype.debug = function() {
      };
      Ue.prototype.make = md;
      function md() {
        var t = this.pattern, e = this.options;
        if (!e.nocomment && t.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!t) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var r = this.globSet = this.braceExpand();
        e.debug && (this.debug = function() {
          console.error.apply(console, arguments);
        }), this.debug(this.pattern, r), r = this.globParts = r.map(function(i) {
          return i.split(al);
        }), this.debug(this.pattern, r), r = r.map(function(i, n, s) {
          return i.map(this.parse, this);
        }, this), this.debug(this.pattern, r), r = r.filter(function(i) {
          return i.indexOf(false) === -1;
        }), this.debug(this.pattern, r), this.set = r;
      }
      Ue.prototype.parseNegate = gd;
      function gd() {
        var t = this.pattern, e = false, r = this.options, i = 0;
        if (!r.nonegate) {
          for (var n = 0, s = t.length; n < s && t.charAt(n) === "!"; n++)
            e = !e, i++;
          i && (this.pattern = t.substr(i)), this.negate = e;
        }
      }
      Ye.braceExpand = function(t, e) {
        return ll(t, e);
      };
      Ue.prototype.braceExpand = ll;
      function ll(t, e) {
        return e || (this instanceof Ue ? e = this.options : e = {}), t = typeof t == "undefined" ? this.pattern : t, xi(t), e.nobrace || !/\{(?:(?!\{).)*\}/.test(t) ? [t] : ud(t);
      }
      var vd = 1024 * 64, xi = function(t) {
        if (typeof t != "string")
          throw new TypeError("invalid pattern");
        if (t.length > vd)
          throw new TypeError("pattern is too long");
      };
      Ue.prototype.parse = _d;
      var _i = {};
      function _d(t, e) {
        xi(t);
        var r = this.options;
        if (t === "**")
          if (r.noglobstar)
            t = "*";
          else
            return _n;
        if (t === "")
          return "";
        var i = "", n = !!r.nocase, s = false, o = [], a = [], l, c = false, u = -1, f = -1, h = t.charAt(0) === "." ? "" : r.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", p = this;
        function d() {
          if (l) {
            switch (l) {
              case "*":
                i += vn, n = true;
                break;
              case "?":
                i += gn, n = true;
                break;
              default:
                i += "\\" + l;
                break;
            }
            p.debug("clearStateChar %j %j", l, i), l = false;
          }
        }
        for (var m = 0, g = t.length, y; m < g && (y = t.charAt(m)); m++) {
          if (this.debug("%s	%s %s %j", t, m, i, y), s && ol[y]) {
            i += "\\" + y, s = false;
            continue;
          }
          switch (y) {
            case "/":
              return false;
            case "\\":
              d(), s = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              if (this.debug("%s	%s %s %j <-- stateChar", t, m, i, y), c) {
                this.debug("  in class"), y === "!" && m === f + 1 && (y = "^"), i += y;
                continue;
              }
              p.debug("call clearStateChar %j", l), d(), l = y, r.noext && d();
              continue;
            case "(":
              if (c) {
                i += "(";
                continue;
              }
              if (!l) {
                i += "\\(";
                continue;
              }
              o.push({ type: l, start: m - 1, reStart: i.length, open: sl[l].open, close: sl[l].close }), i += l === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", l, i), l = false;
              continue;
            case ")":
              if (c || !o.length) {
                i += "\\)";
                continue;
              }
              d(), n = true;
              var I = o.pop();
              i += I.close, I.type === "!" && a.push(I), I.reEnd = i.length;
              continue;
            case "|":
              if (c || !o.length || s) {
                i += "\\|", s = false;
                continue;
              }
              d(), i += "|";
              continue;
            case "[":
              if (d(), c) {
                i += "\\" + y;
                continue;
              }
              c = true, f = m, u = i.length, i += y;
              continue;
            case "]":
              if (m === f + 1 || !c) {
                i += "\\" + y, s = false;
                continue;
              }
              var w = t.substring(f + 1, m);
              try {
                RegExp("[" + w + "]");
              } catch (e2) {
                var S = this.parse(w, _i);
                i = i.substr(0, u) + "\\[" + S[0] + "\\]", n = n || S[1], c = false;
                continue;
              }
              n = true, c = false, i += y;
              continue;
            default:
              d(), s ? s = false : ol[y] && !(y === "^" && c) && (i += "\\"), i += y;
          }
        }
        for (c && (w = t.substr(f + 1), S = this.parse(w, _i), i = i.substr(0, u) + "\\[" + S[0], n = n || S[1]), I = o.pop(); I; I = o.pop()) {
          var b = i.slice(I.reStart + I.open.length);
          this.debug("setting tail", i, I), b = b.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(Se, ce, ie) {
            return ie || (ie = "\\"), ce + ce + ie + "|";
          }), this.debug(`tail=%j
   %s`, b, b, I, i);
          var $ = I.type === "*" ? vn : I.type === "?" ? gn : "\\" + I.type;
          n = true, i = i.slice(0, I.reStart) + $ + "\\(" + b;
        }
        d(), s && (i += "\\\\");
        var C = false;
        switch (i.charAt(0)) {
          case "[":
          case ".":
          case "(":
            C = true;
        }
        for (var U = a.length - 1; U > -1; U--) {
          var E = a[U], T = i.slice(0, E.reStart), B = i.slice(E.reStart, E.reEnd - 8), G = i.slice(E.reEnd - 8, E.reEnd), L = i.slice(E.reEnd);
          G += L;
          var Q = T.split("(").length - 1, R = L;
          for (m = 0; m < Q; m++)
            R = R.replace(/\)[+*?]?/, "");
          L = R;
          var F = "";
          L === "" && e !== _i && (F = "$");
          var j = T + B + L + F + G;
          i = j;
        }
        if (i !== "" && n && (i = "(?=.)" + i), C && (i = h + i), e === _i)
          return [i, n];
        if (!n)
          return yd(t);
        var z = r.nocase ? "i" : "";
        try {
          var N = new RegExp("^" + i + "$", z);
        } catch (e2) {
          return new RegExp("$.");
        }
        return N._glob = t, N._src = i, N;
      }
      Ye.makeRe = function(t, e) {
        return new Ue(t, e || {}).makeRe();
      };
      Ue.prototype.makeRe = xd;
      function xd() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var t = this.set;
        if (!t.length)
          return this.regexp = false, this.regexp;
        var e = this.options, r = e.noglobstar ? vn : e.dot ? fd : hd, i = e.nocase ? "i" : "", n = t.map(function(s) {
          return s.map(function(o) {
            return o === _n ? r : typeof o == "string" ? bd(o) : o._src;
          }).join("\\/");
        }).join("|");
        n = "^(?:" + n + ")$", this.negate && (n = "^(?!" + n + ").*$");
        try {
          this.regexp = new RegExp(n, i);
        } catch (e2) {
          this.regexp = false;
        }
        return this.regexp;
      }
      Ye.match = function(t, e, r) {
        r = r || {};
        var i = new Ue(e, r);
        return t = t.filter(function(n) {
          return i.match(n);
        }), i.options.nonull && !t.length && t.push(e), t;
      };
      Ue.prototype.match = function(e, r) {
        if (typeof r == "undefined" && (r = this.partial), this.debug("match", e, this.pattern), this.comment)
          return false;
        if (this.empty)
          return e === "";
        if (e === "/" && r)
          return true;
        var i = this.options;
        Mr.sep !== "/" && (e = e.split(Mr.sep).join("/")), e = e.split(al), this.debug(this.pattern, "split", e);
        var n = this.set;
        this.debug(this.pattern, "set", n);
        var s, o;
        for (o = e.length - 1; o >= 0 && (s = e[o], !s); o--)
          ;
        for (o = 0; o < n.length; o++) {
          var a = n[o], l = e;
          i.matchBase && a.length === 1 && (l = [s]);
          var c = this.matchOne(l, a, r);
          if (c)
            return i.flipNegate ? true : !this.negate;
        }
        return i.flipNegate ? false : this.negate;
      };
      Ue.prototype.matchOne = function(t, e, r) {
        var i = this.options;
        this.debug("matchOne", { this: this, file: t, pattern: e }), this.debug("matchOne", t.length, e.length);
        for (var n = 0, s = 0, o = t.length, a = e.length; n < o && s < a; n++, s++) {
          this.debug("matchOne loop");
          var l = e[s], c = t[n];
          if (this.debug(e, l, c), l === false)
            return false;
          if (l === _n) {
            this.debug("GLOBSTAR", [e, l, c]);
            var u = n, f = s + 1;
            if (f === a) {
              for (this.debug("** at the end"); n < o; n++)
                if (t[n] === "." || t[n] === ".." || !i.dot && t[n].charAt(0) === ".")
                  return false;
              return true;
            }
            for (; u < o; ) {
              var h = t[u];
              if (this.debug(`
globstar while`, t, u, e, f, h), this.matchOne(t.slice(u), e.slice(f), r))
                return this.debug("globstar found match!", u, o, h), true;
              if (h === "." || h === ".." || !i.dot && h.charAt(0) === ".") {
                this.debug("dot detected!", t, u, e, f);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), u++;
            }
            return !!(r && (this.debug(`
>>> no match, partial?`, t, u, e, f), u === o));
          }
          var p;
          if (typeof l == "string" ? (p = c === l, this.debug("string match", l, c, p)) : (p = c.match(l), this.debug("pattern match", l, c, p)), !p)
            return false;
        }
        if (n === o && s === a)
          return true;
        if (n === o)
          return r;
        if (s === a)
          return n === o - 1 && t[n] === "";
        throw new Error("wtf?");
      };
      function yd(t) {
        return t.replace(/\\(.)/g, "$1");
      }
      function bd(t) {
        return t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
    });
    var yn = x((V_, fl) => {
      "use strict";
      var ul = require("fs"), xn;
      function wd() {
        try {
          return ul.statSync("/.dockerenv"), true;
        } catch (e) {
          return false;
        }
      }
      function Ed() {
        try {
          return ul.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
        } catch (e) {
          return false;
        }
      }
      fl.exports = () => (xn === void 0 && (xn = wd() || Ed()), xn);
    });
    var dl = x(($_, bn) => {
      "use strict";
      var Sd = require("os"), kd = require("fs"), hl = yn(), pl = () => {
        if (process.platform !== "linux")
          return false;
        if (Sd.release().toLowerCase().includes("microsoft"))
          return !hl();
        try {
          return kd.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !hl() : false;
        } catch (e) {
          return false;
        }
      };
      process.env.__IS_WSL_TEST__ ? bn.exports = pl : bn.exports = pl();
    });
    var gl = x((G_, ml) => {
      "use strict";
      ml.exports = (t, e, r) => {
        let i = (n) => Object.defineProperty(t, e, { value: n, enumerable: true, writable: true });
        return Object.defineProperty(t, e, { configurable: true, enumerable: true, get() {
          let n = r();
          return i(n), n;
        }, set(n) {
          i(n);
        } }), t;
      };
    });
    var El = x((z_, wl) => {
      var Cd = require("path"), Od = require("child_process"), { promises: wn, constants: bl } = require("fs"), yi = dl(), Id = yn(), En = gl(), vl = Cd.join(__dirname, "xdg-open"), { platform: sr, arch: _l } = process, Td = (() => {
        let t = "/mnt/", e;
        return function() {
          return __async(this, null, function* () {
            if (e)
              return e;
            let r = "/etc/wsl.conf", i = false;
            try {
              yield wn.access(r, bl.F_OK), i = true;
            } catch (e2) {
            }
            if (!i)
              return t;
            let n = yield wn.readFile(r, { encoding: "utf8" }), s = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(n);
            return s ? (e = s.groups.mountPoint.trim(), e = e.endsWith("/") ? e : `${e}/`, e) : t;
          });
        };
      })(), xl = (t, e) => __async(exports2, null, function* () {
        let r;
        for (let i of t)
          try {
            return yield e(i);
          } catch (n) {
            r = n;
          }
        throw r;
      }), bi = (t) => __async(exports2, null, function* () {
        if (t = __spreadValues({ wait: false, background: false, newInstance: false, allowNonzeroExitCode: false }, t), Array.isArray(t.app))
          return xl(t.app, (a) => bi(__spreadProps(__spreadValues({}, t), { app: a })));
        let { name: e, arguments: r = [] } = t.app || {};
        if (r = [...r], Array.isArray(e))
          return xl(e, (a) => bi(__spreadProps(__spreadValues({}, t), { app: { name: a, arguments: r } })));
        let i, n = [], s = {};
        if (sr === "darwin")
          i = "open", t.wait && n.push("--wait-apps"), t.background && n.push("--background"), t.newInstance && n.push("--new"), e && n.push("-a", e);
        else if (sr === "win32" || yi && !Id()) {
          let a = yield Td();
          i = yi ? `${a}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`, n.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand"), yi || (s.windowsVerbatimArguments = true);
          let l = ["Start"];
          t.wait && l.push("-Wait"), e ? (l.push(`"\`"${e}\`""`, "-ArgumentList"), t.target && r.unshift(t.target)) : t.target && l.push(`"${t.target}"`), r.length > 0 && (r = r.map((c) => `"\`"${c}\`""`), l.push(r.join(","))), t.target = Buffer.from(l.join(" "), "utf16le").toString("base64");
        } else {
          if (e)
            i = e;
          else {
            let a = !__dirname || __dirname === "/", l = false;
            try {
              yield wn.access(vl, bl.X_OK), l = true;
            } catch (e2) {
            }
            i = process.versions.electron || sr === "android" || a || !l ? "xdg-open" : vl;
          }
          r.length > 0 && n.push(...r), t.wait || (s.stdio = "ignore", s.detached = true);
        }
        t.target && n.push(t.target), sr === "darwin" && r.length > 0 && n.push("--args", ...r);
        let o = Od.spawn(i, n, s);
        return t.wait ? new Promise((a, l) => {
          o.once("error", l), o.once("close", (c) => {
            if (t.allowNonzeroExitCode && c > 0) {
              l(new Error(`Exited with code ${c}`));
              return;
            }
            a(o);
          });
        }) : (o.unref(), o);
      }), Sn = (t, e) => {
        if (typeof t != "string")
          throw new TypeError("Expected a `target`");
        return bi(__spreadProps(__spreadValues({}, e), { target: t }));
      }, Ad = (t, e) => {
        if (typeof t != "string")
          throw new TypeError("Expected a `name`");
        let { arguments: r = [] } = e || {};
        if (r != null && !Array.isArray(r))
          throw new TypeError("Expected `appArguments` as Array type");
        return bi(__spreadProps(__spreadValues({}, e), { app: { name: t, arguments: r } }));
      };
      function yl(t) {
        if (typeof t == "string" || Array.isArray(t))
          return t;
        let { [_l]: e } = t;
        if (!e)
          throw new Error(`${_l} is not supported`);
        return e;
      }
      function kn({ [sr]: t }, { wsl: e }) {
        if (e && yi)
          return yl(e);
        if (!t)
          throw new Error(`${sr} is not supported`);
        return yl(t);
      }
      var wi = {};
      En(wi, "chrome", () => kn({ darwin: "google chrome", win32: "chrome", linux: ["google-chrome", "google-chrome-stable", "chromium"] }, { wsl: { ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe", x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"] } }));
      En(wi, "firefox", () => kn({ darwin: "firefox", win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe", linux: "firefox" }, { wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe" }));
      En(wi, "edge", () => kn({ darwin: "microsoft edge", win32: "msedge", linux: ["microsoft-edge", "microsoft-edge-dev"] }, { wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" }));
      Sn.apps = wi;
      Sn.openApp = Ad;
      wl.exports = Sn;
    });
    var Cn = x((W_, kl) => {
      "use strict";
      var Rd = require("util"), Sl = require("stream"), nt = kl.exports = function() {
        Sl.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = false, this._encoding = "utf8", this.writable = true;
      };
      Rd.inherits(nt, Sl);
      nt.prototype.read = function(t, e) {
        this._reads.push({ length: Math.abs(t), allowLess: t < 0, func: e }), process.nextTick(function() {
          this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = false, this.emit("drain"));
        }.bind(this));
      };
      nt.prototype.write = function(t, e) {
        if (!this.writable)
          return this.emit("error", new Error("Stream not writable")), false;
        let r;
        return Buffer.isBuffer(t) ? r = t : r = Buffer.from(t, e || this._encoding), this._buffers.push(r), this._buffered += r.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = true), this.writable && !this._paused;
      };
      nt.prototype.end = function(t, e) {
        t && this.write(t, e), this.writable = false, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
      };
      nt.prototype.destroySoon = nt.prototype.end;
      nt.prototype._end = function() {
        this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
      };
      nt.prototype.destroy = function() {
        !this._buffers || (this.writable = false, this._reads = null, this._buffers = null, this.emit("close"));
      };
      nt.prototype._processReadAllowingLess = function(t) {
        this._reads.shift();
        let e = this._buffers[0];
        e.length > t.length ? (this._buffered -= t.length, this._buffers[0] = e.slice(t.length), t.func.call(this, e.slice(0, t.length))) : (this._buffered -= e.length, this._buffers.shift(), t.func.call(this, e));
      };
      nt.prototype._processRead = function(t) {
        this._reads.shift();
        let e = 0, r = 0, i = Buffer.alloc(t.length);
        for (; e < t.length; ) {
          let n = this._buffers[r++], s = Math.min(n.length, t.length - e);
          n.copy(i, e, 0, s), e += s, s !== n.length && (this._buffers[--r] = n.slice(s));
        }
        r > 0 && this._buffers.splice(0, r), this._buffered -= t.length, t.func.call(this, i);
      };
      nt.prototype._process = function() {
        try {
          for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
            let t = this._reads[0];
            if (t.allowLess)
              this._processReadAllowingLess(t);
            else if (this._buffered >= t.length)
              this._processRead(t);
            else
              break;
          }
          this._buffers && !this.writable && this._end();
        } catch (t) {
          this.emit("error", t);
        }
      };
    });
    var In = x((On) => {
      "use strict";
      var vt = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
      On.getImagePasses = function(t, e) {
        let r = [], i = t % 8, n = e % 8, s = (t - i) / 8, o = (e - n) / 8;
        for (let a = 0; a < vt.length; a++) {
          let l = vt[a], c = s * l.x.length, u = o * l.y.length;
          for (let f = 0; f < l.x.length && l.x[f] < i; f++)
            c++;
          for (let f = 0; f < l.y.length && l.y[f] < n; f++)
            u++;
          c > 0 && u > 0 && r.push({ width: c, height: u, index: a });
        }
        return r;
      };
      On.getInterlaceIterator = function(t) {
        return function(e, r, i) {
          let n = e % vt[i].x.length, s = (e - n) / vt[i].x.length * 8 + vt[i].x[n], o = r % vt[i].y.length, a = (r - o) / vt[i].y.length * 8 + vt[i].y[o];
          return s * 4 + a * t * 4;
        };
      };
    });
    var Tn = x((K_, Cl) => {
      "use strict";
      Cl.exports = function(e, r, i) {
        let n = e + r - i, s = Math.abs(n - e), o = Math.abs(n - r), a = Math.abs(n - i);
        return s <= o && s <= a ? e : o <= a ? r : i;
      };
    });
    var An = x((Z_, Il) => {
      "use strict";
      var Bd = In(), Ld = Tn();
      function Ol(t, e, r) {
        let i = t * e;
        return r !== 8 && (i = Math.ceil(i / (8 / r))), i;
      }
      var or = Il.exports = function(t, e) {
        let r = t.width, i = t.height, n = t.interlace, s = t.bpp, o = t.depth;
        if (this.read = e.read, this.write = e.write, this.complete = e.complete, this._imageIndex = 0, this._images = [], n) {
          let a = Bd.getImagePasses(r, i);
          for (let l = 0; l < a.length; l++)
            this._images.push({ byteWidth: Ol(a[l].width, s, o), height: a[l].height, lineIndex: 0 });
        } else
          this._images.push({ byteWidth: Ol(r, s, o), height: i, lineIndex: 0 });
        o === 8 ? this._xComparison = s : o === 16 ? this._xComparison = s * 2 : this._xComparison = 1;
      };
      or.prototype.start = function() {
        this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
      };
      or.prototype._unFilterType1 = function(t, e, r) {
        let i = this._xComparison, n = i - 1;
        for (let s = 0; s < r; s++) {
          let o = t[1 + s], a = s > n ? e[s - i] : 0;
          e[s] = o + a;
        }
      };
      or.prototype._unFilterType2 = function(t, e, r) {
        let i = this._lastLine;
        for (let n = 0; n < r; n++) {
          let s = t[1 + n], o = i ? i[n] : 0;
          e[n] = s + o;
        }
      };
      or.prototype._unFilterType3 = function(t, e, r) {
        let i = this._xComparison, n = i - 1, s = this._lastLine;
        for (let o = 0; o < r; o++) {
          let a = t[1 + o], l = s ? s[o] : 0, c = o > n ? e[o - i] : 0, u = Math.floor((c + l) / 2);
          e[o] = a + u;
        }
      };
      or.prototype._unFilterType4 = function(t, e, r) {
        let i = this._xComparison, n = i - 1, s = this._lastLine;
        for (let o = 0; o < r; o++) {
          let a = t[1 + o], l = s ? s[o] : 0, c = o > n ? e[o - i] : 0, u = o > n && s ? s[o - i] : 0, f = Ld(c, l, u);
          e[o] = a + f;
        }
      };
      or.prototype._reverseFilterLine = function(t) {
        let e = t[0], r, i = this._images[this._imageIndex], n = i.byteWidth;
        if (e === 0)
          r = t.slice(1, n + 1);
        else
          switch (r = Buffer.alloc(n), e) {
            case 1:
              this._unFilterType1(t, r, n);
              break;
            case 2:
              this._unFilterType2(t, r, n);
              break;
            case 3:
              this._unFilterType3(t, r, n);
              break;
            case 4:
              this._unFilterType4(t, r, n);
              break;
            default:
              throw new Error("Unrecognised filter type - " + e);
          }
        this.write(r), i.lineIndex++, i.lineIndex >= i.height ? (this._lastLine = null, this._imageIndex++, i = this._images[this._imageIndex]) : this._lastLine = r, i ? this.read(i.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
      };
    });
    var Rl = x((X_, Al) => {
      "use strict";
      var Nd = require("util"), Tl = Cn(), Pd = An(), Fd = Al.exports = function(t) {
        Tl.call(this);
        let e = [], r = this;
        this._filter = new Pd(t, { read: this.read.bind(this), write: function(i) {
          e.push(i);
        }, complete: function() {
          r.emit("complete", Buffer.concat(e));
        } }), this._filter.start();
      };
      Nd.inherits(Fd, Tl);
    });
    var ar = x((Q_, Bl) => {
      "use strict";
      Bl.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
    });
    var Ln = x((J_, Ll) => {
      "use strict";
      var Rn = [];
      (function() {
        for (let t = 0; t < 256; t++) {
          let e = t;
          for (let r = 0; r < 8; r++)
            e & 1 ? e = 3988292384 ^ e >>> 1 : e = e >>> 1;
          Rn[t] = e;
        }
      })();
      var Bn = Ll.exports = function() {
        this._crc = -1;
      };
      Bn.prototype.write = function(t) {
        for (let e = 0; e < t.length; e++)
          this._crc = Rn[(this._crc ^ t[e]) & 255] ^ this._crc >>> 8;
        return true;
      };
      Bn.prototype.crc32 = function() {
        return this._crc ^ -1;
      };
      Bn.crc32 = function(t) {
        let e = -1;
        for (let r = 0; r < t.length; r++)
          e = Rn[(e ^ t[r]) & 255] ^ e >>> 8;
        return e ^ -1;
      };
    });
    var Nn = x((ex, Nl) => {
      "use strict";
      var Ae = ar(), Md = Ln(), Le = Nl.exports = function(t, e) {
        this._options = t, t.checkCRC = t.checkCRC !== false, this._hasIHDR = false, this._hasIEND = false, this._emittedHeadersFinished = false, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[Ae.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[Ae.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[Ae.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[Ae.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[Ae.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[Ae.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = e.read, this.error = e.error, this.metadata = e.metadata, this.gamma = e.gamma, this.transColor = e.transColor, this.palette = e.palette, this.parsed = e.parsed, this.inflateData = e.inflateData, this.finished = e.finished, this.simpleTransparency = e.simpleTransparency, this.headersFinished = e.headersFinished || function() {
        };
      };
      Le.prototype.start = function() {
        this.read(Ae.PNG_SIGNATURE.length, this._parseSignature.bind(this));
      };
      Le.prototype._parseSignature = function(t) {
        let e = Ae.PNG_SIGNATURE;
        for (let r = 0; r < e.length; r++)
          if (t[r] !== e[r]) {
            this.error(new Error("Invalid file signature"));
            return;
          }
        this.read(8, this._parseChunkBegin.bind(this));
      };
      Le.prototype._parseChunkBegin = function(t) {
        let e = t.readUInt32BE(0), r = t.readUInt32BE(4), i = "";
        for (let s = 4; s < 8; s++)
          i += String.fromCharCode(t[s]);
        let n = Boolean(t[4] & 32);
        if (!this._hasIHDR && r !== Ae.TYPE_IHDR) {
          this.error(new Error("Expected IHDR on beggining"));
          return;
        }
        if (this._crc = new Md(), this._crc.write(Buffer.from(i)), this._chunks[r])
          return this._chunks[r](e);
        if (!n) {
          this.error(new Error("Unsupported critical chunk type " + i));
          return;
        }
        this.read(e + 4, this._skipChunk.bind(this));
      };
      Le.prototype._skipChunk = function() {
        this.read(8, this._parseChunkBegin.bind(this));
      };
      Le.prototype._handleChunkEnd = function() {
        this.read(4, this._parseChunkEnd.bind(this));
      };
      Le.prototype._parseChunkEnd = function(t) {
        let e = t.readInt32BE(0), r = this._crc.crc32();
        if (this._options.checkCRC && r !== e) {
          this.error(new Error("Crc error - " + e + " - " + r));
          return;
        }
        this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
      };
      Le.prototype._handleIHDR = function(t) {
        this.read(t, this._parseIHDR.bind(this));
      };
      Le.prototype._parseIHDR = function(t) {
        this._crc.write(t);
        let e = t.readUInt32BE(0), r = t.readUInt32BE(4), i = t[8], n = t[9], s = t[10], o = t[11], a = t[12];
        if (i !== 8 && i !== 4 && i !== 2 && i !== 1 && i !== 16) {
          this.error(new Error("Unsupported bit depth " + i));
          return;
        }
        if (!(n in Ae.COLORTYPE_TO_BPP_MAP)) {
          this.error(new Error("Unsupported color type"));
          return;
        }
        if (s !== 0) {
          this.error(new Error("Unsupported compression method"));
          return;
        }
        if (o !== 0) {
          this.error(new Error("Unsupported filter method"));
          return;
        }
        if (a !== 0 && a !== 1) {
          this.error(new Error("Unsupported interlace method"));
          return;
        }
        this._colorType = n;
        let l = Ae.COLORTYPE_TO_BPP_MAP[this._colorType];
        this._hasIHDR = true, this.metadata({ width: e, height: r, depth: i, interlace: Boolean(a), palette: Boolean(n & Ae.COLORTYPE_PALETTE), color: Boolean(n & Ae.COLORTYPE_COLOR), alpha: Boolean(n & Ae.COLORTYPE_ALPHA), bpp: l, colorType: n }), this._handleChunkEnd();
      };
      Le.prototype._handlePLTE = function(t) {
        this.read(t, this._parsePLTE.bind(this));
      };
      Le.prototype._parsePLTE = function(t) {
        this._crc.write(t);
        let e = Math.floor(t.length / 3);
        for (let r = 0; r < e; r++)
          this._palette.push([t[r * 3], t[r * 3 + 1], t[r * 3 + 2], 255]);
        this.palette(this._palette), this._handleChunkEnd();
      };
      Le.prototype._handleTRNS = function(t) {
        this.simpleTransparency(), this.read(t, this._parseTRNS.bind(this));
      };
      Le.prototype._parseTRNS = function(t) {
        if (this._crc.write(t), this._colorType === Ae.COLORTYPE_PALETTE_COLOR) {
          if (this._palette.length === 0) {
            this.error(new Error("Transparency chunk must be after palette"));
            return;
          }
          if (t.length > this._palette.length) {
            this.error(new Error("More transparent colors than palette size"));
            return;
          }
          for (let e = 0; e < t.length; e++)
            this._palette[e][3] = t[e];
          this.palette(this._palette);
        }
        this._colorType === Ae.COLORTYPE_GRAYSCALE && this.transColor([t.readUInt16BE(0)]), this._colorType === Ae.COLORTYPE_COLOR && this.transColor([t.readUInt16BE(0), t.readUInt16BE(2), t.readUInt16BE(4)]), this._handleChunkEnd();
      };
      Le.prototype._handleGAMA = function(t) {
        this.read(t, this._parseGAMA.bind(this));
      };
      Le.prototype._parseGAMA = function(t) {
        this._crc.write(t), this.gamma(t.readUInt32BE(0) / Ae.GAMMA_DIVISION), this._handleChunkEnd();
      };
      Le.prototype._handleIDAT = function(t) {
        this._emittedHeadersFinished || (this._emittedHeadersFinished = true, this.headersFinished()), this.read(-t, this._parseIDAT.bind(this, t));
      };
      Le.prototype._parseIDAT = function(t, e) {
        if (this._crc.write(e), this._colorType === Ae.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
          throw new Error("Expected palette not found");
        this.inflateData(e);
        let r = t - e.length;
        r > 0 ? this._handleIDAT(r) : this._handleChunkEnd();
      };
      Le.prototype._handleIEND = function(t) {
        this.read(t, this._parseIEND.bind(this));
      };
      Le.prototype._parseIEND = function(t) {
        this._crc.write(t), this._hasIEND = true, this._handleChunkEnd(), this.finished && this.finished();
      };
    });
    var Pn = x((Fl) => {
      "use strict";
      var Pl = In(), Ud = [function() {
      }, function(t, e, r, i) {
        if (i === e.length)
          throw new Error("Ran out of data");
        let n = e[i];
        t[r] = n, t[r + 1] = n, t[r + 2] = n, t[r + 3] = 255;
      }, function(t, e, r, i) {
        if (i + 1 >= e.length)
          throw new Error("Ran out of data");
        let n = e[i];
        t[r] = n, t[r + 1] = n, t[r + 2] = n, t[r + 3] = e[i + 1];
      }, function(t, e, r, i) {
        if (i + 2 >= e.length)
          throw new Error("Ran out of data");
        t[r] = e[i], t[r + 1] = e[i + 1], t[r + 2] = e[i + 2], t[r + 3] = 255;
      }, function(t, e, r, i) {
        if (i + 3 >= e.length)
          throw new Error("Ran out of data");
        t[r] = e[i], t[r + 1] = e[i + 1], t[r + 2] = e[i + 2], t[r + 3] = e[i + 3];
      }], Dd = [function() {
      }, function(t, e, r, i) {
        let n = e[0];
        t[r] = n, t[r + 1] = n, t[r + 2] = n, t[r + 3] = i;
      }, function(t, e, r) {
        let i = e[0];
        t[r] = i, t[r + 1] = i, t[r + 2] = i, t[r + 3] = e[1];
      }, function(t, e, r, i) {
        t[r] = e[0], t[r + 1] = e[1], t[r + 2] = e[2], t[r + 3] = i;
      }, function(t, e, r) {
        t[r] = e[0], t[r + 1] = e[1], t[r + 2] = e[2], t[r + 3] = e[3];
      }];
      function jd(t, e) {
        let r = [], i = 0;
        function n() {
          if (i === t.length)
            throw new Error("Ran out of data");
          let s = t[i];
          i++;
          let o, a, l, c, u, f, h, p;
          switch (e) {
            default:
              throw new Error("unrecognised depth");
            case 16:
              h = t[i], i++, r.push((s << 8) + h);
              break;
            case 4:
              h = s & 15, p = s >> 4, r.push(p, h);
              break;
            case 2:
              u = s & 3, f = s >> 2 & 3, h = s >> 4 & 3, p = s >> 6 & 3, r.push(p, h, f, u);
              break;
            case 1:
              o = s & 1, a = s >> 1 & 1, l = s >> 2 & 1, c = s >> 3 & 1, u = s >> 4 & 1, f = s >> 5 & 1, h = s >> 6 & 1, p = s >> 7 & 1, r.push(p, h, f, u, c, l, a, o);
              break;
          }
        }
        return { get: function(s) {
          for (; r.length < s; )
            n();
          let o = r.slice(0, s);
          return r = r.slice(s), o;
        }, resetAfterLine: function() {
          r.length = 0;
        }, end: function() {
          if (i !== t.length)
            throw new Error("extra data found");
        } };
      }
      function qd(t, e, r, i, n, s) {
        let o = t.width, a = t.height, l = t.index;
        for (let c = 0; c < a; c++)
          for (let u = 0; u < o; u++) {
            let f = r(u, c, l);
            Ud[i](e, n, f, s), s += i;
          }
        return s;
      }
      function Hd(t, e, r, i, n, s) {
        let o = t.width, a = t.height, l = t.index;
        for (let c = 0; c < a; c++) {
          for (let u = 0; u < o; u++) {
            let f = n.get(i), h = r(u, c, l);
            Dd[i](e, f, h, s);
          }
          n.resetAfterLine();
        }
      }
      Fl.dataToBitMap = function(t, e) {
        let r = e.width, i = e.height, n = e.depth, s = e.bpp, o = e.interlace, a;
        n !== 8 && (a = jd(t, n));
        let l;
        n <= 8 ? l = Buffer.alloc(r * i * 4) : l = new Uint16Array(r * i * 4);
        let c = Math.pow(2, n) - 1, u = 0, f, h;
        if (o)
          f = Pl.getImagePasses(r, i), h = Pl.getInterlaceIterator(r, i);
        else {
          let p = 0;
          h = function() {
            let d = p;
            return p += 4, d;
          }, f = [{ width: r, height: i }];
        }
        for (let p = 0; p < f.length; p++)
          n === 8 ? u = qd(f[p], l, h, s, t, u) : Hd(f[p], l, h, s, a, c);
        if (n === 8) {
          if (u !== t.length)
            throw new Error("extra data found");
        } else
          a.end();
        return l;
      };
    });
    var Fn = x((rx, Ml) => {
      "use strict";
      function Vd(t, e, r, i, n) {
        let s = 0;
        for (let o = 0; o < i; o++)
          for (let a = 0; a < r; a++) {
            let l = n[t[s]];
            if (!l)
              throw new Error("index " + t[s] + " not in palette");
            for (let c = 0; c < 4; c++)
              e[s + c] = l[c];
            s += 4;
          }
      }
      function $d(t, e, r, i, n) {
        let s = 0;
        for (let o = 0; o < i; o++)
          for (let a = 0; a < r; a++) {
            let l = false;
            if (n.length === 1 ? n[0] === t[s] && (l = true) : n[0] === t[s] && n[1] === t[s + 1] && n[2] === t[s + 2] && (l = true), l)
              for (let c = 0; c < 4; c++)
                e[s + c] = 0;
            s += 4;
          }
      }
      function Gd(t, e, r, i, n) {
        let s = 255, o = Math.pow(2, n) - 1, a = 0;
        for (let l = 0; l < i; l++)
          for (let c = 0; c < r; c++) {
            for (let u = 0; u < 4; u++)
              e[a + u] = Math.floor(t[a + u] * s / o + 0.5);
            a += 4;
          }
      }
      Ml.exports = function(t, e, r = false) {
        let i = e.depth, n = e.width, s = e.height, o = e.colorType, a = e.transColor, l = e.palette, c = t;
        return o === 3 ? Vd(t, c, n, s, l) : (a && $d(t, c, n, s, a), i !== 8 && !r && (i === 16 && (c = Buffer.alloc(n * s * 4)), Gd(t, c, n, s, i))), c;
      };
    });
    var jl = x((ix, Dl) => {
      "use strict";
      var zd = require("util"), Mn = require("zlib"), Ul = Cn(), Wd = Rl(), Yd = Nn(), Kd = Pn(), Zd = Fn(), lt = Dl.exports = function(t) {
        Ul.call(this), this._parser = new Yd(t, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = t, this.writable = true, this._parser.start();
      };
      zd.inherits(lt, Ul);
      lt.prototype._handleError = function(t) {
        this.emit("error", t), this.writable = false, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
        })), this.errord = true;
      };
      lt.prototype._inflateData = function(t) {
        if (!this._inflate)
          if (this._bitmapInfo.interlace)
            this._inflate = Mn.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
          else {
            let r = ((this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1) * this._bitmapInfo.height, i = Math.max(r, Mn.Z_MIN_CHUNK);
            this._inflate = Mn.createInflate({ chunkSize: i });
            let n = r, s = this.emit.bind(this, "error");
            this._inflate.on("error", function(a) {
              !n || s(a);
            }), this._filter.on("complete", this._complete.bind(this));
            let o = this._filter.write.bind(this._filter);
            this._inflate.on("data", function(a) {
              !n || (a.length > n && (a = a.slice(0, n)), n -= a.length, o(a));
            }), this._inflate.on("end", this._filter.end.bind(this._filter));
          }
        this._inflate.write(t);
      };
      lt.prototype._handleMetaData = function(t) {
        this._metaData = t, this._bitmapInfo = Object.create(t), this._filter = new Wd(this._bitmapInfo);
      };
      lt.prototype._handleTransColor = function(t) {
        this._bitmapInfo.transColor = t;
      };
      lt.prototype._handlePalette = function(t) {
        this._bitmapInfo.palette = t;
      };
      lt.prototype._simpleTransparency = function() {
        this._metaData.alpha = true;
      };
      lt.prototype._headersFinished = function() {
        this.emit("metadata", this._metaData);
      };
      lt.prototype._finished = function() {
        this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
      };
      lt.prototype._complete = function(t) {
        if (this.errord)
          return;
        let e;
        try {
          let r = Kd.dataToBitMap(t, this._bitmapInfo);
          e = Zd(r, this._bitmapInfo, this._options.skipRescale), r = null;
        } catch (r) {
          this._handleError(r);
          return;
        }
        this.emit("parsed", e);
      };
    });
    var Hl = x((nx, ql) => {
      "use strict";
      var Qe = ar();
      ql.exports = function(t, e, r, i) {
        let n = [Qe.COLORTYPE_COLOR_ALPHA, Qe.COLORTYPE_ALPHA].indexOf(i.colorType) !== -1;
        if (i.colorType === i.inputColorType) {
          let d = function() {
            let m = new ArrayBuffer(2);
            return new DataView(m).setInt16(0, 256, true), new Int16Array(m)[0] !== 256;
          }();
          if (i.bitDepth === 8 || i.bitDepth === 16 && d)
            return t;
        }
        let s = i.bitDepth !== 16 ? t : new Uint16Array(t.buffer), o = 255, a = Qe.COLORTYPE_TO_BPP_MAP[i.inputColorType];
        a === 4 && !i.inputHasAlpha && (a = 3);
        let l = Qe.COLORTYPE_TO_BPP_MAP[i.colorType];
        i.bitDepth === 16 && (o = 65535, l *= 2);
        let c = Buffer.alloc(e * r * l), u = 0, f = 0, h = i.bgColor || {};
        h.red === void 0 && (h.red = o), h.green === void 0 && (h.green = o), h.blue === void 0 && (h.blue = o);
        function p() {
          let d, m, g, y = o;
          switch (i.inputColorType) {
            case Qe.COLORTYPE_COLOR_ALPHA:
              y = s[u + 3], d = s[u], m = s[u + 1], g = s[u + 2];
              break;
            case Qe.COLORTYPE_COLOR:
              d = s[u], m = s[u + 1], g = s[u + 2];
              break;
            case Qe.COLORTYPE_ALPHA:
              y = s[u + 1], d = s[u], m = d, g = d;
              break;
            case Qe.COLORTYPE_GRAYSCALE:
              d = s[u], m = d, g = d;
              break;
            default:
              throw new Error("input color type:" + i.inputColorType + " is not supported at present");
          }
          return i.inputHasAlpha && (n || (y /= o, d = Math.min(Math.max(Math.round((1 - y) * h.red + y * d), 0), o), m = Math.min(Math.max(Math.round((1 - y) * h.green + y * m), 0), o), g = Math.min(Math.max(Math.round((1 - y) * h.blue + y * g), 0), o))), { red: d, green: m, blue: g, alpha: y };
        }
        for (let d = 0; d < r; d++)
          for (let m = 0; m < e; m++) {
            let g = p(s, u);
            switch (i.colorType) {
              case Qe.COLORTYPE_COLOR_ALPHA:
              case Qe.COLORTYPE_COLOR:
                i.bitDepth === 8 ? (c[f] = g.red, c[f + 1] = g.green, c[f + 2] = g.blue, n && (c[f + 3] = g.alpha)) : (c.writeUInt16BE(g.red, f), c.writeUInt16BE(g.green, f + 2), c.writeUInt16BE(g.blue, f + 4), n && c.writeUInt16BE(g.alpha, f + 6));
                break;
              case Qe.COLORTYPE_ALPHA:
              case Qe.COLORTYPE_GRAYSCALE: {
                let y = (g.red + g.green + g.blue) / 3;
                i.bitDepth === 8 ? (c[f] = y, n && (c[f + 1] = g.alpha)) : (c.writeUInt16BE(y, f), n && c.writeUInt16BE(g.alpha, f + 2));
                break;
              }
              default:
                throw new Error("unrecognised color Type " + i.colorType);
            }
            u += a, f += l;
          }
        return c;
      };
    });
    var Gl = x((sx, $l) => {
      "use strict";
      var Vl = Tn();
      function Xd(t, e, r, i, n) {
        for (let s = 0; s < r; s++)
          i[n + s] = t[e + s];
      }
      function Qd(t, e, r) {
        let i = 0, n = e + r;
        for (let s = e; s < n; s++)
          i += Math.abs(t[s]);
        return i;
      }
      function Jd(t, e, r, i, n, s) {
        for (let o = 0; o < r; o++) {
          let a = o >= s ? t[e + o - s] : 0, l = t[e + o] - a;
          i[n + o] = l;
        }
      }
      function em(t, e, r, i) {
        let n = 0;
        for (let s = 0; s < r; s++) {
          let o = s >= i ? t[e + s - i] : 0, a = t[e + s] - o;
          n += Math.abs(a);
        }
        return n;
      }
      function tm(t, e, r, i, n) {
        for (let s = 0; s < r; s++) {
          let o = e > 0 ? t[e + s - r] : 0, a = t[e + s] - o;
          i[n + s] = a;
        }
      }
      function rm(t, e, r) {
        let i = 0, n = e + r;
        for (let s = e; s < n; s++) {
          let o = e > 0 ? t[s - r] : 0, a = t[s] - o;
          i += Math.abs(a);
        }
        return i;
      }
      function im(t, e, r, i, n, s) {
        for (let o = 0; o < r; o++) {
          let a = o >= s ? t[e + o - s] : 0, l = e > 0 ? t[e + o - r] : 0, c = t[e + o] - (a + l >> 1);
          i[n + o] = c;
        }
      }
      function nm(t, e, r, i) {
        let n = 0;
        for (let s = 0; s < r; s++) {
          let o = s >= i ? t[e + s - i] : 0, a = e > 0 ? t[e + s - r] : 0, l = t[e + s] - (o + a >> 1);
          n += Math.abs(l);
        }
        return n;
      }
      function sm(t, e, r, i, n, s) {
        for (let o = 0; o < r; o++) {
          let a = o >= s ? t[e + o - s] : 0, l = e > 0 ? t[e + o - r] : 0, c = e > 0 && o >= s ? t[e + o - (r + s)] : 0, u = t[e + o] - Vl(a, l, c);
          i[n + o] = u;
        }
      }
      function om(t, e, r, i) {
        let n = 0;
        for (let s = 0; s < r; s++) {
          let o = s >= i ? t[e + s - i] : 0, a = e > 0 ? t[e + s - r] : 0, l = e > 0 && s >= i ? t[e + s - (r + i)] : 0, c = t[e + s] - Vl(o, a, l);
          n += Math.abs(c);
        }
        return n;
      }
      var am = { 0: Xd, 1: Jd, 2: tm, 3: im, 4: sm }, lm = { 0: Qd, 1: em, 2: rm, 3: nm, 4: om };
      $l.exports = function(t, e, r, i, n) {
        let s;
        if (!("filterType" in i) || i.filterType === -1)
          s = [0, 1, 2, 3, 4];
        else if (typeof i.filterType == "number")
          s = [i.filterType];
        else
          throw new Error("unrecognised filter types");
        i.bitDepth === 16 && (n *= 2);
        let o = e * n, a = 0, l = 0, c = Buffer.alloc((o + 1) * r), u = s[0];
        for (let f = 0; f < r; f++) {
          if (s.length > 1) {
            let h = 1 / 0;
            for (let p = 0; p < s.length; p++) {
              let d = lm[s[p]](t, l, o, n);
              d < h && (u = s[p], h = d);
            }
          }
          c[a] = u, a++, am[u](t, l, o, c, a, n), a += o, l += o;
        }
        return c;
      };
    });
    var Un = x((ox, zl) => {
      "use strict";
      var qe = ar(), cm = Ln(), um = Hl(), fm = Gl(), hm = require("zlib"), _t = zl.exports = function(t) {
        if (this._options = t, t.deflateChunkSize = t.deflateChunkSize || 32 * 1024, t.deflateLevel = t.deflateLevel != null ? t.deflateLevel : 9, t.deflateStrategy = t.deflateStrategy != null ? t.deflateStrategy : 3, t.inputHasAlpha = t.inputHasAlpha != null ? t.inputHasAlpha : true, t.deflateFactory = t.deflateFactory || hm.createDeflate, t.bitDepth = t.bitDepth || 8, t.colorType = typeof t.colorType == "number" ? t.colorType : qe.COLORTYPE_COLOR_ALPHA, t.inputColorType = typeof t.inputColorType == "number" ? t.inputColorType : qe.COLORTYPE_COLOR_ALPHA, [qe.COLORTYPE_GRAYSCALE, qe.COLORTYPE_COLOR, qe.COLORTYPE_COLOR_ALPHA, qe.COLORTYPE_ALPHA].indexOf(t.colorType) === -1)
          throw new Error("option color type:" + t.colorType + " is not supported at present");
        if ([qe.COLORTYPE_GRAYSCALE, qe.COLORTYPE_COLOR, qe.COLORTYPE_COLOR_ALPHA, qe.COLORTYPE_ALPHA].indexOf(t.inputColorType) === -1)
          throw new Error("option input color type:" + t.inputColorType + " is not supported at present");
        if (t.bitDepth !== 8 && t.bitDepth !== 16)
          throw new Error("option bit depth:" + t.bitDepth + " is not supported at present");
      };
      _t.prototype.getDeflateOptions = function() {
        return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
      };
      _t.prototype.createDeflate = function() {
        return this._options.deflateFactory(this.getDeflateOptions());
      };
      _t.prototype.filterData = function(t, e, r) {
        let i = um(t, e, r, this._options), n = qe.COLORTYPE_TO_BPP_MAP[this._options.colorType];
        return fm(i, e, r, this._options, n);
      };
      _t.prototype._packChunk = function(t, e) {
        let r = e ? e.length : 0, i = Buffer.alloc(r + 12);
        return i.writeUInt32BE(r, 0), i.writeUInt32BE(t, 4), e && e.copy(i, 8), i.writeInt32BE(cm.crc32(i.slice(4, i.length - 4)), i.length - 4), i;
      };
      _t.prototype.packGAMA = function(t) {
        let e = Buffer.alloc(4);
        return e.writeUInt32BE(Math.floor(t * qe.GAMMA_DIVISION), 0), this._packChunk(qe.TYPE_gAMA, e);
      };
      _t.prototype.packIHDR = function(t, e) {
        let r = Buffer.alloc(13);
        return r.writeUInt32BE(t, 0), r.writeUInt32BE(e, 4), r[8] = this._options.bitDepth, r[9] = this._options.colorType, r[10] = 0, r[11] = 0, r[12] = 0, this._packChunk(qe.TYPE_IHDR, r);
      };
      _t.prototype.packIDAT = function(t) {
        return this._packChunk(qe.TYPE_IDAT, t);
      };
      _t.prototype.packIEND = function() {
        return this._packChunk(qe.TYPE_IEND, null);
      };
    });
    var Zl = x((ax, Kl) => {
      "use strict";
      var pm = require("util"), Wl = require("stream"), dm = ar(), mm = Un(), Yl = Kl.exports = function(t) {
        Wl.call(this);
        let e = t || {};
        this._packer = new mm(e), this._deflate = this._packer.createDeflate(), this.readable = true;
      };
      pm.inherits(Yl, Wl);
      Yl.prototype.pack = function(t, e, r, i) {
        this.emit("data", Buffer.from(dm.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(e, r)), i && this.emit("data", this._packer.packGAMA(i));
        let n = this._packer.filterData(t, e, r);
        this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(s) {
          this.emit("data", this._packer.packIDAT(s));
        }.bind(this)), this._deflate.on("end", function() {
          this.emit("data", this._packer.packIEND()), this.emit("end");
        }.bind(this)), this._deflate.end(n);
      };
    });
    var rc = x((Dr, tc) => {
      "use strict";
      var Xl = require("assert").ok, lr = require("zlib"), gm = require("util"), Ql = require("buffer").kMaxLength;
      function Lt(t) {
        if (!(this instanceof Lt))
          return new Lt(t);
        t && t.chunkSize < lr.Z_MIN_CHUNK && (t.chunkSize = lr.Z_MIN_CHUNK), lr.Inflate.call(this, t), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, t && t.maxLength != null && (this._maxLength = t.maxLength);
      }
      function vm(t) {
        return new Lt(t);
      }
      function Jl(t, e) {
        e && process.nextTick(e), t._handle && (t._handle.close(), t._handle = null);
      }
      Lt.prototype._processChunk = function(t, e, r) {
        if (typeof r == "function")
          return lr.Inflate._processChunk.call(this, t, e, r);
        let i = this, n = t && t.length, s = this._chunkSize - this._offset, o = this._maxLength, a = 0, l = [], c = 0, u;
        this.on("error", function(d) {
          u = d;
        });
        function f(d, m) {
          if (i._hadError)
            return;
          let g = s - m;
          if (Xl(g >= 0, "have should not go down"), g > 0) {
            let y = i._buffer.slice(i._offset, i._offset + g);
            if (i._offset += g, y.length > o && (y = y.slice(0, o)), l.push(y), c += y.length, o -= y.length, o === 0)
              return false;
          }
          return (m === 0 || i._offset >= i._chunkSize) && (s = i._chunkSize, i._offset = 0, i._buffer = Buffer.allocUnsafe(i._chunkSize)), m === 0 ? (a += n - d, n = d, true) : false;
        }
        Xl(this._handle, "zlib binding closed");
        let h;
        do
          h = this._handle.writeSync(e, t, a, n, this._buffer, this._offset, s), h = h || this._writeState;
        while (!this._hadError && f(h[0], h[1]));
        if (this._hadError)
          throw u;
        if (c >= Ql)
          throw Jl(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + Ql.toString(16) + " bytes");
        let p = Buffer.concat(l, c);
        return Jl(this), p;
      };
      gm.inherits(Lt, lr.Inflate);
      function _m(t, e) {
        if (typeof e == "string" && (e = Buffer.from(e)), !(e instanceof Buffer))
          throw new TypeError("Not a string or buffer");
        let r = t._finishFlushFlag;
        return r == null && (r = lr.Z_FINISH), t._processChunk(e, r);
      }
      function ec(t, e) {
        return _m(new Lt(e), t);
      }
      tc.exports = Dr = ec;
      Dr.Inflate = Lt;
      Dr.createInflate = vm;
      Dr.inflateSync = ec;
    });
    var Dn = x((lx, nc) => {
      "use strict";
      var ic = nc.exports = function(t) {
        this._buffer = t, this._reads = [];
      };
      ic.prototype.read = function(t, e) {
        this._reads.push({ length: Math.abs(t), allowLess: t < 0, func: e });
      };
      ic.prototype.process = function() {
        for (; this._reads.length > 0 && this._buffer.length; ) {
          let t = this._reads[0];
          if (this._buffer.length && (this._buffer.length >= t.length || t.allowLess)) {
            this._reads.shift();
            let e = this._buffer;
            this._buffer = e.slice(t.length), t.func.call(this, e.slice(0, t.length));
          } else
            break;
        }
        if (this._reads.length > 0)
          throw new Error("There are some read requests waitng on finished stream");
        if (this._buffer.length > 0)
          throw new Error("unrecognised content at end of stream");
      };
    });
    var oc = x((sc) => {
      "use strict";
      var xm = Dn(), ym = An();
      sc.process = function(t, e) {
        let r = [], i = new xm(t);
        return new ym(e, { read: i.read.bind(i), write: function(s) {
          r.push(s);
        }, complete: function() {
        } }).start(), i.process(), Buffer.concat(r);
      };
    });
    var uc = x((ux, cc) => {
      "use strict";
      var ac = true, lc = require("zlib"), bm = rc();
      lc.deflateSync || (ac = false);
      var wm = Dn(), Em = oc(), Sm = Nn(), km = Pn(), Cm = Fn();
      cc.exports = function(t, e) {
        if (!ac)
          throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        let r;
        function i(S) {
          r = S;
        }
        let n;
        function s(S) {
          n = S;
        }
        function o(S) {
          n.transColor = S;
        }
        function a(S) {
          n.palette = S;
        }
        function l() {
          n.alpha = true;
        }
        let c;
        function u(S) {
          c = S;
        }
        let f = [];
        function h(S) {
          f.push(S);
        }
        let p = new wm(t);
        if (new Sm(e, { read: p.read.bind(p), error: i, metadata: s, gamma: u, palette: a, transColor: o, inflateData: h, simpleTransparency: l }).start(), p.process(), r)
          throw r;
        let m = Buffer.concat(f);
        f.length = 0;
        let g;
        if (n.interlace)
          g = lc.inflateSync(m);
        else {
          let b = ((n.width * n.bpp * n.depth + 7 >> 3) + 1) * n.height;
          g = bm(m, { chunkSize: b, maxLength: b });
        }
        if (m = null, !g || !g.length)
          throw new Error("bad png - invalid inflate data response");
        let y = Em.process(g, n);
        m = null;
        let I = km.dataToBitMap(y, n);
        y = null;
        let w = Cm(I, n, e.skipRescale);
        return n.data = w, n.gamma = c || 0, n;
      };
    });
    var dc = x((fx, pc) => {
      "use strict";
      var fc = true, hc = require("zlib");
      hc.deflateSync || (fc = false);
      var Om = ar(), Im = Un();
      pc.exports = function(t, e) {
        if (!fc)
          throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        let r = e || {}, i = new Im(r), n = [];
        n.push(Buffer.from(Om.PNG_SIGNATURE)), n.push(i.packIHDR(t.width, t.height)), t.gamma && n.push(i.packGAMA(t.gamma));
        let s = i.filterData(t.data, t.width, t.height), o = hc.deflateSync(s, i.getDeflateOptions());
        if (s = null, !o || !o.length)
          throw new Error("bad png - invalid compressed data response");
        return n.push(i.packIDAT(o)), n.push(i.packIEND()), Buffer.concat(n);
      };
    });
    var mc = x((jn) => {
      "use strict";
      var Tm = uc(), Am = dc();
      jn.read = function(t, e) {
        return Tm(t, e || {});
      };
      jn.write = function(t, e) {
        return Am(t, e);
      };
    });
    var _c = x((vc) => {
      "use strict";
      var Rm = require("util"), gc = require("stream"), Bm = jl(), Lm = Zl(), Nm = mc(), $e = vc.PNG = function(t) {
        gc.call(this), t = t || {}, this.width = t.width | 0, this.height = t.height | 0, this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null, t.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = true, this._parser = new Bm(t), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(e) {
          this.data = e, this.emit("parsed", e);
        }.bind(this)), this._packer = new Lm(t), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
      };
      Rm.inherits($e, gc);
      $e.sync = Nm;
      $e.prototype.pack = function() {
        return !this.data || !this.data.length ? (this.emit("error", "No data provided"), this) : (process.nextTick(function() {
          this._packer.pack(this.data, this.width, this.height, this.gamma);
        }.bind(this)), this);
      };
      $e.prototype.parse = function(t, e) {
        if (e) {
          let r, i;
          r = function(n) {
            this.removeListener("error", i), this.data = n, e(null, this);
          }.bind(this), i = function(n) {
            this.removeListener("parsed", r), e(n, null);
          }.bind(this), this.once("parsed", r), this.once("error", i);
        }
        return this.end(t), this;
      };
      $e.prototype.write = function(t) {
        return this._parser.write(t), true;
      };
      $e.prototype.end = function(t) {
        this._parser.end(t);
      };
      $e.prototype._metadata = function(t) {
        this.width = t.width, this.height = t.height, this.emit("metadata", t);
      };
      $e.prototype._gamma = function(t) {
        this.gamma = t;
      };
      $e.prototype._handleClose = function() {
        !this._parser.writable && !this._packer.readable && this.emit("close");
      };
      $e.bitblt = function(t, e, r, i, n, s, o, a) {
        if (r |= 0, i |= 0, n |= 0, s |= 0, o |= 0, a |= 0, r > t.width || i > t.height || r + n > t.width || i + s > t.height)
          throw new Error("bitblt reading outside image");
        if (o > e.width || a > e.height || o + n > e.width || a + s > e.height)
          throw new Error("bitblt writing outside image");
        for (let l = 0; l < s; l++)
          t.data.copy(e.data, (a + l) * e.width + o << 2, (i + l) * t.width + r << 2, (i + l) * t.width + r + n << 2);
      };
      $e.prototype.bitblt = function(t, e, r, i, n, s, o) {
        return $e.bitblt(this, t, e, r, i, n, s, o), this;
      };
      $e.adjustGamma = function(t) {
        if (t.gamma) {
          for (let e = 0; e < t.height; e++)
            for (let r = 0; r < t.width; r++) {
              let i = t.width * e + r << 2;
              for (let n = 0; n < 3; n++) {
                let s = t.data[i + n] / 255;
                s = Math.pow(s, 1 / 2.2 / t.gamma), t.data[i + n] = Math.round(s * 255);
              }
            }
          t.gamma = 0;
        }
      };
      $e.prototype.adjustGamma = function() {
        $e.adjustGamma(this);
      };
    });
    var jr = x((Hn) => {
      var Ei = class extends Error {
        constructor(e, r, i) {
          super(i), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name, this.code = r, this.exitCode = e, this.nestedError = void 0;
        }
      }, qn = class extends Ei {
        constructor(e) {
          super(1, "commander.invalidArgument", e), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name;
        }
      };
      Hn.CommanderError = Ei;
      Hn.InvalidArgumentError = qn;
    });
    var Si = x(($n) => {
      var { InvalidArgumentError: Pm } = jr(), Vn = class {
        constructor(e, r) {
          switch (this.description = r || "", this.variadic = false, this.parseArg = void 0, this.defaultValue = void 0, this.defaultValueDescription = void 0, this.argChoices = void 0, e[0]) {
            case "<":
              this.required = true, this._name = e.slice(1, -1);
              break;
            case "[":
              this.required = false, this._name = e.slice(1, -1);
              break;
            default:
              this.required = true, this._name = e;
              break;
          }
          this._name.length > 3 && this._name.slice(-3) === "..." && (this.variadic = true, this._name = this._name.slice(0, -3));
        }
        name() {
          return this._name;
        }
        _concatValue(e, r) {
          return r === this.defaultValue || !Array.isArray(r) ? [e] : r.concat(e);
        }
        default(e, r) {
          return this.defaultValue = e, this.defaultValueDescription = r, this;
        }
        argParser(e) {
          return this.parseArg = e, this;
        }
        choices(e) {
          return this.argChoices = e, this.parseArg = (r, i) => {
            if (!e.includes(r))
              throw new Pm(`Allowed choices are ${e.join(", ")}.`);
            return this.variadic ? this._concatValue(r, i) : r;
          }, this;
        }
        argRequired() {
          return this.required = true, this;
        }
        argOptional() {
          return this.required = false, this;
        }
      };
      function Fm(t) {
        let e = t.name() + (t.variadic === true ? "..." : "");
        return t.required ? "<" + e + ">" : "[" + e + "]";
      }
      $n.Argument = Vn;
      $n.humanReadableArgName = Fm;
    });
    var zn = x((xc) => {
      var { humanReadableArgName: Mm } = Si(), Gn = class {
        constructor() {
          this.helpWidth = void 0, this.sortSubcommands = false, this.sortOptions = false;
        }
        visibleCommands(e) {
          let r = e.commands.filter((i) => !i._hidden);
          if (e._hasImplicitHelpCommand()) {
            let [, i, n] = e._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/), s = e.createCommand(i).helpOption(false);
            s.description(e._helpCommandDescription), n && s.arguments(n), r.push(s);
          }
          return this.sortSubcommands && r.sort((i, n) => i.name().localeCompare(n.name())), r;
        }
        visibleOptions(e) {
          let r = e.options.filter((s) => !s.hidden), i = e._hasHelpOption && e._helpShortFlag && !e._findOption(e._helpShortFlag), n = e._hasHelpOption && !e._findOption(e._helpLongFlag);
          if (i || n) {
            let s;
            i ? n ? s = e.createOption(e._helpFlags, e._helpDescription) : s = e.createOption(e._helpShortFlag, e._helpDescription) : s = e.createOption(e._helpLongFlag, e._helpDescription), r.push(s);
          }
          if (this.sortOptions) {
            let s = (o) => o.short ? o.short.replace(/^-/, "") : o.long.replace(/^--/, "");
            r.sort((o, a) => s(o).localeCompare(s(a)));
          }
          return r;
        }
        visibleArguments(e) {
          return e._argsDescription && e._args.forEach((r) => {
            r.description = r.description || e._argsDescription[r.name()] || "";
          }), e._args.find((r) => r.description) ? e._args : [];
        }
        subcommandTerm(e) {
          let r = e._args.map((i) => Mm(i)).join(" ");
          return e._name + (e._aliases[0] ? "|" + e._aliases[0] : "") + (e.options.length ? " [options]" : "") + (r ? " " + r : "");
        }
        optionTerm(e) {
          return e.flags;
        }
        argumentTerm(e) {
          return e.name();
        }
        longestSubcommandTermLength(e, r) {
          return r.visibleCommands(e).reduce((i, n) => Math.max(i, r.subcommandTerm(n).length), 0);
        }
        longestOptionTermLength(e, r) {
          return r.visibleOptions(e).reduce((i, n) => Math.max(i, r.optionTerm(n).length), 0);
        }
        longestArgumentTermLength(e, r) {
          return r.visibleArguments(e).reduce((i, n) => Math.max(i, r.argumentTerm(n).length), 0);
        }
        commandUsage(e) {
          let r = e._name;
          e._aliases[0] && (r = r + "|" + e._aliases[0]);
          let i = "";
          for (let n = e.parent; n; n = n.parent)
            i = n.name() + " " + i;
          return i + r + " " + e.usage();
        }
        commandDescription(e) {
          return e.description();
        }
        subcommandDescription(e) {
          return e.description();
        }
        optionDescription(e) {
          let r = [];
          return e.argChoices && !e.negate && r.push(`choices: ${e.argChoices.map((i) => JSON.stringify(i)).join(", ")}`), e.defaultValue !== void 0 && !e.negate && r.push(`default: ${e.defaultValueDescription || JSON.stringify(e.defaultValue)}`), e.envVar !== void 0 && r.push(`env: ${e.envVar}`), r.length > 0 ? `${e.description} (${r.join(", ")})` : e.description;
        }
        argumentDescription(e) {
          let r = [];
          if (e.argChoices && r.push(`choices: ${e.argChoices.map((i) => JSON.stringify(i)).join(", ")}`), e.defaultValue !== void 0 && r.push(`default: ${e.defaultValueDescription || JSON.stringify(e.defaultValue)}`), r.length > 0) {
            let i = `(${r.join(", ")})`;
            return e.description ? `${e.description} ${i}` : i;
          }
          return e.description;
        }
        formatHelp(e, r) {
          let i = r.padWidth(e, r), n = r.helpWidth || 80, s = 2, o = 2;
          function a(d, m) {
            if (m) {
              let g = `${d.padEnd(i + o)}${m}`;
              return r.wrap(g, n - s, i + o);
            }
            return d;
          }
          function l(d) {
            return d.join(`
`).replace(/^/gm, " ".repeat(s));
          }
          let c = [`Usage: ${r.commandUsage(e)}`, ""], u = r.commandDescription(e);
          u.length > 0 && (c = c.concat([u, ""]));
          let f = r.visibleArguments(e).map((d) => a(r.argumentTerm(d), r.argumentDescription(d)));
          f.length > 0 && (c = c.concat(["Arguments:", l(f), ""]));
          let h = r.visibleOptions(e).map((d) => a(r.optionTerm(d), r.optionDescription(d)));
          h.length > 0 && (c = c.concat(["Options:", l(h), ""]));
          let p = r.visibleCommands(e).map((d) => a(r.subcommandTerm(d), r.subcommandDescription(d)));
          return p.length > 0 && (c = c.concat(["Commands:", l(p), ""])), c.join(`
`);
        }
        padWidth(e, r) {
          return Math.max(r.longestOptionTermLength(e, r), r.longestSubcommandTermLength(e, r), r.longestArgumentTermLength(e, r));
        }
        wrap(e, r, i, n = 40) {
          if (e.match(/[\n]\s+/))
            return e;
          let s = r - i;
          if (s < n)
            return e;
          let o = e.substr(0, i), a = e.substr(i), l = " ".repeat(i), c = new RegExp(".{1," + (s - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g"), u = a.match(c) || [];
          return o + u.map((f, h) => (f.slice(-1) === `
` && (f = f.slice(0, f.length - 1)), (h > 0 ? l : "") + f.trimRight())).join(`
`);
        }
      };
      xc.Help = Gn;
    });
    var Kn = x((Yn) => {
      var { InvalidArgumentError: Um } = jr(), Wn = class {
        constructor(e, r) {
          this.flags = e, this.description = r || "", this.required = e.includes("<"), this.optional = e.includes("["), this.variadic = /\w\.\.\.[>\]]$/.test(e), this.mandatory = false;
          let i = yc(e);
          this.short = i.shortFlag, this.long = i.longFlag, this.negate = false, this.long && (this.negate = this.long.startsWith("--no-")), this.defaultValue = void 0, this.defaultValueDescription = void 0, this.envVar = void 0, this.parseArg = void 0, this.hidden = false, this.argChoices = void 0;
        }
        default(e, r) {
          return this.defaultValue = e, this.defaultValueDescription = r, this;
        }
        env(e) {
          return this.envVar = e, this;
        }
        argParser(e) {
          return this.parseArg = e, this;
        }
        makeOptionMandatory(e = true) {
          return this.mandatory = !!e, this;
        }
        hideHelp(e = true) {
          return this.hidden = !!e, this;
        }
        _concatValue(e, r) {
          return r === this.defaultValue || !Array.isArray(r) ? [e] : r.concat(e);
        }
        choices(e) {
          return this.argChoices = e, this.parseArg = (r, i) => {
            if (!e.includes(r))
              throw new Um(`Allowed choices are ${e.join(", ")}.`);
            return this.variadic ? this._concatValue(r, i) : r;
          }, this;
        }
        name() {
          return this.long ? this.long.replace(/^--/, "") : this.short.replace(/^-/, "");
        }
        attributeName() {
          return Dm(this.name().replace(/^no-/, ""));
        }
        is(e) {
          return this.short === e || this.long === e;
        }
      };
      function Dm(t) {
        return t.split("-").reduce((e, r) => e + r[0].toUpperCase() + r.slice(1));
      }
      function yc(t) {
        let e, r, i = t.split(/[ |,]+/);
        return i.length > 1 && !/^[[<]/.test(i[1]) && (e = i.shift()), r = i.shift(), !e && /^-[^-]$/.test(r) && (e = r, r = void 0), { shortFlag: e, longFlag: r };
      }
      Yn.Option = Wn;
      Yn.splitOptionFlags = yc;
    });
    var wc = x((bc) => {
      function jm(t, e) {
        if (Math.abs(t.length - e.length) > 3)
          return Math.max(t.length, e.length);
        let r = [];
        for (let i = 0; i <= t.length; i++)
          r[i] = [i];
        for (let i = 0; i <= e.length; i++)
          r[0][i] = i;
        for (let i = 1; i <= e.length; i++)
          for (let n = 1; n <= t.length; n++) {
            let s = 1;
            t[n - 1] === e[i - 1] ? s = 0 : s = 1, r[n][i] = Math.min(r[n - 1][i] + 1, r[n][i - 1] + 1, r[n - 1][i - 1] + s), n > 1 && i > 1 && t[n - 1] === e[i - 2] && t[n - 2] === e[i - 1] && (r[n][i] = Math.min(r[n][i], r[n - 2][i - 2] + 1));
          }
        return r[t.length][e.length];
      }
      function qm(t, e) {
        if (!e || e.length === 0)
          return "";
        e = Array.from(new Set(e));
        let r = t.startsWith("--");
        r && (t = t.slice(2), e = e.map((o) => o.slice(2)));
        let i = [], n = 3, s = 0.4;
        return e.forEach((o) => {
          if (o.length <= 1)
            return;
          let a = jm(t, o), l = Math.max(t.length, o.length);
          (l - a) / l > s && (a < n ? (n = a, i = [o]) : a === n && i.push(o));
        }), i.sort((o, a) => o.localeCompare(a)), r && (i = i.map((o) => `--${o}`)), i.length > 1 ? `
(Did you mean one of ${i.join(", ")}?)` : i.length === 1 ? `
(Did you mean ${i[0]}?)` : "";
      }
      bc.suggestSimilar = qm;
    });
    var Oc = x((Cc) => {
      var Hm = require("events").EventEmitter, Zn = require("child_process"), Nt = require("path"), Xn = require("fs"), { Argument: Vm, humanReadableArgName: $m } = Si(), { CommanderError: Qn } = jr(), { Help: Gm } = zn(), { Option: zm, splitOptionFlags: Wm } = Kn(), { suggestSimilar: Ec } = wc(), qr = class extends Hm {
        constructor(e) {
          super(), this.commands = [], this.options = [], this.parent = null, this._allowUnknownOption = false, this._allowExcessArguments = true, this._args = [], this.args = [], this.rawArgs = [], this.processedArgs = [], this._scriptPath = null, this._name = e || "", this._optionValues = {}, this._optionValueSources = {}, this._storeOptionsAsProperties = false, this._actionHandler = null, this._executableHandler = false, this._executableFile = null, this._defaultCommandName = null, this._exitCallback = null, this._aliases = [], this._combineFlagAndOptionalValue = true, this._description = "", this._argsDescription = void 0, this._enablePositionalOptions = false, this._passThroughOptions = false, this._lifeCycleHooks = {}, this._showHelpAfterError = false, this._showSuggestionAfterError = false, this._outputConfiguration = { writeOut: (r) => process.stdout.write(r), writeErr: (r) => process.stderr.write(r), getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : void 0, getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : void 0, outputError: (r, i) => i(r) }, this._hidden = false, this._hasHelpOption = true, this._helpFlags = "-h, --help", this._helpDescription = "display help for command", this._helpShortFlag = "-h", this._helpLongFlag = "--help", this._addImplicitHelpCommand = void 0, this._helpCommandName = "help", this._helpCommandnameAndArgs = "help [command]", this._helpCommandDescription = "display help for command", this._helpConfiguration = {};
        }
        copyInheritedSettings(e) {
          return this._outputConfiguration = e._outputConfiguration, this._hasHelpOption = e._hasHelpOption, this._helpFlags = e._helpFlags, this._helpDescription = e._helpDescription, this._helpShortFlag = e._helpShortFlag, this._helpLongFlag = e._helpLongFlag, this._helpCommandName = e._helpCommandName, this._helpCommandnameAndArgs = e._helpCommandnameAndArgs, this._helpCommandDescription = e._helpCommandDescription, this._helpConfiguration = e._helpConfiguration, this._exitCallback = e._exitCallback, this._storeOptionsAsProperties = e._storeOptionsAsProperties, this._combineFlagAndOptionalValue = e._combineFlagAndOptionalValue, this._allowExcessArguments = e._allowExcessArguments, this._enablePositionalOptions = e._enablePositionalOptions, this._showHelpAfterError = e._showHelpAfterError, this._showSuggestionAfterError = e._showSuggestionAfterError, this;
        }
        command(e, r, i) {
          let n = r, s = i;
          typeof n == "object" && n !== null && (s = n, n = null), s = s || {};
          let [, o, a] = e.match(/([^ ]+) *(.*)/), l = this.createCommand(o);
          return n && (l.description(n), l._executableHandler = true), s.isDefault && (this._defaultCommandName = l._name), l._hidden = !!(s.noHelp || s.hidden), l._executableFile = s.executableFile || null, a && l.arguments(a), this.commands.push(l), l.parent = this, l.copyInheritedSettings(this), n ? this : l;
        }
        createCommand(e) {
          return new qr(e);
        }
        createHelp() {
          return Object.assign(new Gm(), this.configureHelp());
        }
        configureHelp(e) {
          return e === void 0 ? this._helpConfiguration : (this._helpConfiguration = e, this);
        }
        configureOutput(e) {
          return e === void 0 ? this._outputConfiguration : (Object.assign(this._outputConfiguration, e), this);
        }
        showHelpAfterError(e = true) {
          return typeof e != "string" && (e = !!e), this._showHelpAfterError = e, this;
        }
        showSuggestionAfterError(e = true) {
          return this._showSuggestionAfterError = !!e, this;
        }
        addCommand(e, r) {
          if (!e._name)
            throw new Error("Command passed to .addCommand() must have a name");
          function i(n) {
            n.forEach((s) => {
              if (s._executableHandler && !s._executableFile)
                throw new Error(`Must specify executableFile for deeply nested executable: ${s.name()}`);
              i(s.commands);
            });
          }
          return i(e.commands), r = r || {}, r.isDefault && (this._defaultCommandName = e._name), (r.noHelp || r.hidden) && (e._hidden = true), this.commands.push(e), e.parent = this, this;
        }
        createArgument(e, r) {
          return new Vm(e, r);
        }
        argument(e, r, i, n) {
          let s = this.createArgument(e, r);
          return typeof i == "function" ? s.default(n).argParser(i) : s.default(i), this.addArgument(s), this;
        }
        arguments(e) {
          return e.split(/ +/).forEach((r) => {
            this.argument(r);
          }), this;
        }
        addArgument(e) {
          let r = this._args.slice(-1)[0];
          if (r && r.variadic)
            throw new Error(`only the last argument can be variadic '${r.name()}'`);
          if (e.required && e.defaultValue !== void 0 && e.parseArg === void 0)
            throw new Error(`a default value for a required argument is never used: '${e.name()}'`);
          return this._args.push(e), this;
        }
        addHelpCommand(e, r) {
          return e === false ? this._addImplicitHelpCommand = false : (this._addImplicitHelpCommand = true, typeof e == "string" && (this._helpCommandName = e.split(" ")[0], this._helpCommandnameAndArgs = e), this._helpCommandDescription = r || this._helpCommandDescription), this;
        }
        _hasImplicitHelpCommand() {
          return this._addImplicitHelpCommand === void 0 ? this.commands.length && !this._actionHandler && !this._findCommand("help") : this._addImplicitHelpCommand;
        }
        hook(e, r) {
          let i = ["preAction", "postAction"];
          if (!i.includes(e))
            throw new Error(`Unexpected value for event passed to hook : '${e}'.
Expecting one of '${i.join("', '")}'`);
          return this._lifeCycleHooks[e] ? this._lifeCycleHooks[e].push(r) : this._lifeCycleHooks[e] = [r], this;
        }
        exitOverride(e) {
          return e ? this._exitCallback = e : this._exitCallback = (r) => {
            if (r.code !== "commander.executeSubCommandAsync")
              throw r;
          }, this;
        }
        _exit(e, r, i) {
          this._exitCallback && this._exitCallback(new Qn(e, r, i)), process.exit(e);
        }
        action(e) {
          let r = (i) => {
            let n = this._args.length, s = i.slice(0, n);
            return this._storeOptionsAsProperties ? s[n] = this : s[n] = this.opts(), s.push(this), e.apply(this, s);
          };
          return this._actionHandler = r, this;
        }
        createOption(e, r) {
          return new zm(e, r);
        }
        addOption(e) {
          let r = e.name(), i = e.attributeName(), n = e.defaultValue;
          if (e.negate || e.optional || e.required || typeof n == "boolean") {
            if (e.negate) {
              let o = e.long.replace(/^--no-/, "--");
              n = this._findOption(o) ? this.getOptionValue(i) : true;
            }
            n !== void 0 && this.setOptionValueWithSource(i, n, "default");
          }
          this.options.push(e);
          let s = (o, a, l) => {
            let c = this.getOptionValue(i);
            if (o !== null && e.parseArg)
              try {
                o = e.parseArg(o, c === void 0 ? n : c);
              } catch (u) {
                if (u.code === "commander.invalidArgument") {
                  let f = `${a} ${u.message}`;
                  this._displayError(u.exitCode, u.code, f);
                }
                throw u;
              }
            else
              o !== null && e.variadic && (o = e._concatValue(o, c));
            typeof c == "boolean" || typeof c == "undefined" ? o == null ? this.setOptionValueWithSource(i, e.negate ? false : n || true, l) : this.setOptionValueWithSource(i, o, l) : o !== null && this.setOptionValueWithSource(i, e.negate ? false : o, l);
          };
          return this.on("option:" + r, (o) => {
            let a = `error: option '${e.flags}' argument '${o}' is invalid.`;
            s(o, a, "cli");
          }), e.envVar && this.on("optionEnv:" + r, (o) => {
            let a = `error: option '${e.flags}' value '${o}' from env '${e.envVar}' is invalid.`;
            s(o, a, "env");
          }), this;
        }
        _optionEx(e, r, i, n, s) {
          let o = this.createOption(r, i);
          if (o.makeOptionMandatory(!!e.mandatory), typeof n == "function")
            o.default(s).argParser(n);
          else if (n instanceof RegExp) {
            let a = n;
            n = (l, c) => {
              let u = a.exec(l);
              return u ? u[0] : c;
            }, o.default(s).argParser(n);
          } else
            o.default(n);
          return this.addOption(o);
        }
        option(e, r, i, n) {
          return this._optionEx({}, e, r, i, n);
        }
        requiredOption(e, r, i, n) {
          return this._optionEx({ mandatory: true }, e, r, i, n);
        }
        combineFlagAndOptionalValue(e = true) {
          return this._combineFlagAndOptionalValue = !!e, this;
        }
        allowUnknownOption(e = true) {
          return this._allowUnknownOption = !!e, this;
        }
        allowExcessArguments(e = true) {
          return this._allowExcessArguments = !!e, this;
        }
        enablePositionalOptions(e = true) {
          return this._enablePositionalOptions = !!e, this;
        }
        passThroughOptions(e = true) {
          if (this._passThroughOptions = !!e, !!this.parent && e && !this.parent._enablePositionalOptions)
            throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
          return this;
        }
        storeOptionsAsProperties(e = true) {
          if (this._storeOptionsAsProperties = !!e, this.options.length)
            throw new Error("call .storeOptionsAsProperties() before adding options");
          return this;
        }
        getOptionValue(e) {
          return this._storeOptionsAsProperties ? this[e] : this._optionValues[e];
        }
        setOptionValue(e, r) {
          return this._storeOptionsAsProperties ? this[e] = r : this._optionValues[e] = r, this;
        }
        setOptionValueWithSource(e, r, i) {
          return this.setOptionValue(e, r), this._optionValueSources[e] = i, this;
        }
        getOptionValueSource(e) {
          return this._optionValueSources[e];
        }
        _prepareUserArgs(e, r) {
          if (e !== void 0 && !Array.isArray(e))
            throw new Error("first parameter to parse must be array or undefined");
          r = r || {}, e === void 0 && (e = process.argv, process.versions && process.versions.electron && (r.from = "electron")), this.rawArgs = e.slice();
          let i;
          switch (r.from) {
            case void 0:
            case "node":
              this._scriptPath = e[1], i = e.slice(2);
              break;
            case "electron":
              process.defaultApp ? (this._scriptPath = e[1], i = e.slice(2)) : i = e.slice(1);
              break;
            case "user":
              i = e.slice(0);
              break;
            default:
              throw new Error(`unexpected parse option { from: '${r.from}' }`);
          }
          return !this._scriptPath && require.main && (this._scriptPath = require.main.filename), this._name = this._name || this._scriptPath && Nt.basename(this._scriptPath, Nt.extname(this._scriptPath)), i;
        }
        parse(e, r) {
          let i = this._prepareUserArgs(e, r);
          return this._parseCommand([], i), this;
        }
        parseAsync(e, r) {
          return __async(this, null, function* () {
            let i = this._prepareUserArgs(e, r);
            return yield this._parseCommand([], i), this;
          });
        }
        _executeSubCommand(e, r) {
          r = r.slice();
          let i = false, n = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
          this._checkForMissingMandatoryOptions();
          let s = this._scriptPath;
          !s && require.main && (s = require.main.filename);
          let o;
          try {
            let h = Xn.realpathSync(s);
            o = Nt.dirname(h);
          } catch (e2) {
            o = ".";
          }
          let a = Nt.basename(s, Nt.extname(s)) + "-" + e._name;
          e._executableFile && (a = e._executableFile);
          let l = Nt.join(o, a);
          Xn.existsSync(l) ? a = l : n.forEach((h) => {
            Xn.existsSync(`${l}${h}`) && (a = `${l}${h}`);
          }), i = n.includes(Nt.extname(a));
          let c;
          process.platform !== "win32" ? i ? (r.unshift(a), r = kc(process.execArgv).concat(r), c = Zn.spawn(process.argv[0], r, { stdio: "inherit" })) : c = Zn.spawn(a, r, { stdio: "inherit" }) : (r.unshift(a), r = kc(process.execArgv).concat(r), c = Zn.spawn(process.execPath, r, { stdio: "inherit" })), ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"].forEach((h) => {
            process.on(h, () => {
              c.killed === false && c.exitCode === null && c.kill(h);
            });
          });
          let f = this._exitCallback;
          f ? c.on("close", () => {
            f(new Qn(process.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          }) : c.on("close", process.exit.bind(process)), c.on("error", (h) => {
            if (h.code === "ENOENT") {
              let p = `'${a}' does not exist
 - if '${e._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
              throw new Error(p);
            } else if (h.code === "EACCES")
              throw new Error(`'${a}' not executable`);
            if (!f)
              process.exit(1);
            else {
              let p = new Qn(1, "commander.executeSubCommandAsync", "(error)");
              p.nestedError = h, f(p);
            }
          }), this.runningCommand = c;
        }
        _dispatchSubcommand(e, r, i) {
          let n = this._findCommand(e);
          if (n || this.help({ error: true }), n._executableHandler)
            this._executeSubCommand(n, r.concat(i));
          else
            return n._parseCommand(r, i);
        }
        _checkNumberOfArguments() {
          this._args.forEach((e, r) => {
            e.required && this.args[r] == null && this.missingArgument(e.name());
          }), !(this._args.length > 0 && this._args[this._args.length - 1].variadic) && this.args.length > this._args.length && this._excessArguments(this.args);
        }
        _processArguments() {
          let e = (i, n, s) => {
            let o = n;
            if (n !== null && i.parseArg)
              try {
                o = i.parseArg(n, s);
              } catch (a) {
                if (a.code === "commander.invalidArgument") {
                  let l = `error: command-argument value '${n}' is invalid for argument '${i.name()}'. ${a.message}`;
                  this._displayError(a.exitCode, a.code, l);
                }
                throw a;
              }
            return o;
          };
          this._checkNumberOfArguments();
          let r = [];
          this._args.forEach((i, n) => {
            let s = i.defaultValue;
            i.variadic ? n < this.args.length ? (s = this.args.slice(n), i.parseArg && (s = s.reduce((o, a) => e(i, a, o), i.defaultValue))) : s === void 0 && (s = []) : n < this.args.length && (s = this.args[n], i.parseArg && (s = e(i, s, i.defaultValue))), r[n] = s;
          }), this.processedArgs = r;
        }
        _chainOrCall(e, r) {
          return e && e.then && typeof e.then == "function" ? e.then(() => r()) : r();
        }
        _chainOrCallHooks(e, r) {
          let i = e, n = [];
          return Jn(this).reverse().filter((s) => s._lifeCycleHooks[r] !== void 0).forEach((s) => {
            s._lifeCycleHooks[r].forEach((o) => {
              n.push({ hookedCommand: s, callback: o });
            });
          }), r === "postAction" && n.reverse(), n.forEach((s) => {
            i = this._chainOrCall(i, () => s.callback(s.hookedCommand, this));
          }), i;
        }
        _parseCommand(e, r) {
          let i = this.parseOptions(r);
          if (this._parseOptionsEnv(), e = e.concat(i.operands), r = i.unknown, this.args = e.concat(r), e && this._findCommand(e[0]))
            return this._dispatchSubcommand(e[0], e.slice(1), r);
          if (this._hasImplicitHelpCommand() && e[0] === this._helpCommandName)
            return e.length === 1 && this.help(), this._dispatchSubcommand(e[1], [], [this._helpLongFlag]);
          if (this._defaultCommandName)
            return Sc(this, r), this._dispatchSubcommand(this._defaultCommandName, e, r);
          this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName && this.help({ error: true }), Sc(this, i.unknown), this._checkForMissingMandatoryOptions();
          let n = () => {
            i.unknown.length > 0 && this.unknownOption(i.unknown[0]);
          }, s = `command:${this.name()}`;
          if (this._actionHandler) {
            n(), this._processArguments();
            let o;
            return o = this._chainOrCallHooks(o, "preAction"), o = this._chainOrCall(o, () => this._actionHandler(this.processedArgs)), this.parent && this.parent.emit(s, e, r), o = this._chainOrCallHooks(o, "postAction"), o;
          }
          if (this.parent && this.parent.listenerCount(s))
            n(), this._processArguments(), this.parent.emit(s, e, r);
          else if (e.length) {
            if (this._findCommand("*"))
              return this._dispatchSubcommand("*", e, r);
            this.listenerCount("command:*") ? this.emit("command:*", e, r) : this.commands.length ? this.unknownCommand() : (n(), this._processArguments());
          } else
            this.commands.length ? (n(), this.help({ error: true })) : (n(), this._processArguments());
        }
        _findCommand(e) {
          if (!!e)
            return this.commands.find((r) => r._name === e || r._aliases.includes(e));
        }
        _findOption(e) {
          return this.options.find((r) => r.is(e));
        }
        _checkForMissingMandatoryOptions() {
          for (let e = this; e; e = e.parent)
            e.options.forEach((r) => {
              r.mandatory && e.getOptionValue(r.attributeName()) === void 0 && e.missingMandatoryOptionValue(r);
            });
        }
        parseOptions(e) {
          let r = [], i = [], n = r, s = e.slice();
          function o(l) {
            return l.length > 1 && l[0] === "-";
          }
          let a = null;
          for (; s.length; ) {
            let l = s.shift();
            if (l === "--") {
              n === i && n.push(l), n.push(...s);
              break;
            }
            if (a && !o(l)) {
              this.emit(`option:${a.name()}`, l);
              continue;
            }
            if (a = null, o(l)) {
              let c = this._findOption(l);
              if (c) {
                if (c.required) {
                  let u = s.shift();
                  u === void 0 && this.optionMissingArgument(c), this.emit(`option:${c.name()}`, u);
                } else if (c.optional) {
                  let u = null;
                  s.length > 0 && !o(s[0]) && (u = s.shift()), this.emit(`option:${c.name()}`, u);
                } else
                  this.emit(`option:${c.name()}`);
                a = c.variadic ? c : null;
                continue;
              }
            }
            if (l.length > 2 && l[0] === "-" && l[1] !== "-") {
              let c = this._findOption(`-${l[1]}`);
              if (c) {
                c.required || c.optional && this._combineFlagAndOptionalValue ? this.emit(`option:${c.name()}`, l.slice(2)) : (this.emit(`option:${c.name()}`), s.unshift(`-${l.slice(2)}`));
                continue;
              }
            }
            if (/^--[^=]+=/.test(l)) {
              let c = l.indexOf("="), u = this._findOption(l.slice(0, c));
              if (u && (u.required || u.optional)) {
                this.emit(`option:${u.name()}`, l.slice(c + 1));
                continue;
              }
            }
            if (o(l) && (n = i), (this._enablePositionalOptions || this._passThroughOptions) && r.length === 0 && i.length === 0) {
              if (this._findCommand(l)) {
                r.push(l), s.length > 0 && i.push(...s);
                break;
              } else if (l === this._helpCommandName && this._hasImplicitHelpCommand()) {
                r.push(l), s.length > 0 && r.push(...s);
                break;
              } else if (this._defaultCommandName) {
                i.push(l), s.length > 0 && i.push(...s);
                break;
              }
            }
            if (this._passThroughOptions) {
              n.push(l), s.length > 0 && n.push(...s);
              break;
            }
            n.push(l);
          }
          return { operands: r, unknown: i };
        }
        opts() {
          if (this._storeOptionsAsProperties) {
            let e = {}, r = this.options.length;
            for (let i = 0; i < r; i++) {
              let n = this.options[i].attributeName();
              e[n] = n === this._versionOptionName ? this._version : this[n];
            }
            return e;
          }
          return this._optionValues;
        }
        _displayError(e, r, i) {
          this._outputConfiguration.outputError(`${i}
`, this._outputConfiguration.writeErr), typeof this._showHelpAfterError == "string" ? this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`) : this._showHelpAfterError && (this._outputConfiguration.writeErr(`
`), this.outputHelp({ error: true })), this._exit(e, r, i);
        }
        _parseOptionsEnv() {
          this.options.forEach((e) => {
            if (e.envVar && e.envVar in process.env) {
              let r = e.attributeName();
              (this.getOptionValue(r) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(r))) && (e.required || e.optional ? this.emit(`optionEnv:${e.name()}`, process.env[e.envVar]) : this.emit(`optionEnv:${e.name()}`));
            }
          });
        }
        missingArgument(e) {
          let r = `error: missing required argument '${e}'`;
          this._displayError(1, "commander.missingArgument", r);
        }
        optionMissingArgument(e) {
          let r = `error: option '${e.flags}' argument missing`;
          this._displayError(1, "commander.optionMissingArgument", r);
        }
        missingMandatoryOptionValue(e) {
          let r = `error: required option '${e.flags}' not specified`;
          this._displayError(1, "commander.missingMandatoryOptionValue", r);
        }
        unknownOption(e) {
          if (this._allowUnknownOption)
            return;
          let r = "";
          if (e.startsWith("--") && this._showSuggestionAfterError) {
            let n = [], s = this;
            do {
              let o = s.createHelp().visibleOptions(s).filter((a) => a.long).map((a) => a.long);
              n = n.concat(o), s = s.parent;
            } while (s && !s._enablePositionalOptions);
            r = Ec(e, n);
          }
          let i = `error: unknown option '${e}'${r}`;
          this._displayError(1, "commander.unknownOption", i);
        }
        _excessArguments(e) {
          if (this._allowExcessArguments)
            return;
          let r = this._args.length, i = r === 1 ? "" : "s", s = `error: too many arguments${this.parent ? ` for '${this.name()}'` : ""}. Expected ${r} argument${i} but got ${e.length}.`;
          this._displayError(1, "commander.excessArguments", s);
        }
        unknownCommand() {
          let e = this.args[0], r = "";
          if (this._showSuggestionAfterError) {
            let n = [];
            this.createHelp().visibleCommands(this).forEach((s) => {
              n.push(s.name()), s.alias() && n.push(s.alias());
            }), r = Ec(e, n);
          }
          let i = `error: unknown command '${e}'${r}`;
          this._displayError(1, "commander.unknownCommand", i);
        }
        version(e, r, i) {
          if (e === void 0)
            return this._version;
          this._version = e, r = r || "-V, --version", i = i || "output the version number";
          let n = this.createOption(r, i);
          return this._versionOptionName = n.attributeName(), this.options.push(n), this.on("option:" + n.name(), () => {
            this._outputConfiguration.writeOut(`${e}
`), this._exit(0, "commander.version", e);
          }), this;
        }
        description(e, r) {
          return e === void 0 && r === void 0 ? this._description : (this._description = e, r && (this._argsDescription = r), this);
        }
        alias(e) {
          if (e === void 0)
            return this._aliases[0];
          let r = this;
          if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler && (r = this.commands[this.commands.length - 1]), e === r._name)
            throw new Error("Command alias can't be the same as its name");
          return r._aliases.push(e), this;
        }
        aliases(e) {
          return e === void 0 ? this._aliases : (e.forEach((r) => this.alias(r)), this);
        }
        usage(e) {
          if (e === void 0) {
            if (this._usage)
              return this._usage;
            let r = this._args.map((i) => $m(i));
            return [].concat(this.options.length || this._hasHelpOption ? "[options]" : [], this.commands.length ? "[command]" : [], this._args.length ? r : []).join(" ");
          }
          return this._usage = e, this;
        }
        name(e) {
          return e === void 0 ? this._name : (this._name = e, this);
        }
        helpInformation(e) {
          let r = this.createHelp();
          return r.helpWidth === void 0 && (r.helpWidth = e && e.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth()), r.formatHelp(this, r);
        }
        _getHelpContext(e) {
          e = e || {};
          let r = { error: !!e.error }, i;
          return r.error ? i = (n) => this._outputConfiguration.writeErr(n) : i = (n) => this._outputConfiguration.writeOut(n), r.write = e.write || i, r.command = this, r;
        }
        outputHelp(e) {
          let r;
          typeof e == "function" && (r = e, e = void 0);
          let i = this._getHelpContext(e);
          Jn(this).reverse().forEach((s) => s.emit("beforeAllHelp", i)), this.emit("beforeHelp", i);
          let n = this.helpInformation(i);
          if (r && (n = r(n), typeof n != "string" && !Buffer.isBuffer(n)))
            throw new Error("outputHelp callback must return a string or a Buffer");
          i.write(n), this.emit(this._helpLongFlag), this.emit("afterHelp", i), Jn(this).forEach((s) => s.emit("afterAllHelp", i));
        }
        helpOption(e, r) {
          if (typeof e == "boolean")
            return this._hasHelpOption = e, this;
          this._helpFlags = e || this._helpFlags, this._helpDescription = r || this._helpDescription;
          let i = Wm(this._helpFlags);
          return this._helpShortFlag = i.shortFlag, this._helpLongFlag = i.longFlag, this;
        }
        help(e) {
          this.outputHelp(e);
          let r = process.exitCode || 0;
          r === 0 && e && typeof e != "function" && e.error && (r = 1), this._exit(r, "commander.help", "(outputHelp)");
        }
        addHelpText(e, r) {
          let i = ["beforeAll", "before", "after", "afterAll"];
          if (!i.includes(e))
            throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${i.join("', '")}'`);
          let n = `${e}Help`;
          return this.on(n, (s) => {
            let o;
            typeof r == "function" ? o = r({ error: s.error, command: s.command }) : o = r, o && s.write(`${o}
`);
          }), this;
        }
      };
      function Sc(t, e) {
        t._hasHelpOption && e.find((i) => i === t._helpLongFlag || i === t._helpShortFlag) && (t.outputHelp(), t._exit(0, "commander.helpDisplayed", "(outputHelp)"));
      }
      function kc(t) {
        return t.map((e) => {
          if (!e.startsWith("--inspect"))
            return e;
          let r, i = "127.0.0.1", n = "9229", s;
          return (s = e.match(/^(--inspect(-brk)?)$/)) !== null ? r = s[1] : (s = e.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null ? (r = s[1], /^\d+$/.test(s[3]) ? n = s[3] : i = s[3]) : (s = e.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null && (r = s[1], i = s[3], n = s[4]), r && n !== "0" ? `${r}=${i}:${parseInt(n) + 1}` : e;
        });
      }
      function Jn(t) {
        let e = [];
        for (let r = t; r; r = r.parent)
          e.push(r);
        return e;
      }
      Cc.Command = qr;
    });
    var Rc = x((st, Ac) => {
      var { Argument: Ym } = Si(), { Command: Ic } = Oc(), { CommanderError: Km, InvalidArgumentError: Tc } = jr(), { Help: Zm } = zn(), { Option: Xm } = Kn();
      st = Ac.exports = new Ic();
      st.program = st;
      st.Argument = Ym;
      st.Command = Ic;
      st.CommanderError = Km;
      st.Help = Zm;
      st.InvalidArgumentError = Tc;
      st.InvalidOptionArgumentError = Tc;
      st.Option = Xm;
    });
    var Nc = x((Bc, Lc) => {
      Bc = Lc.exports = cr;
      function cr(t, e) {
        if (this.stream = e.stream || process.stderr, typeof e == "number") {
          var r = e;
          e = {}, e.total = r;
        } else {
          if (e = e || {}, typeof t != "string")
            throw new Error("format required");
          if (typeof e.total != "number")
            throw new Error("total required");
        }
        this.fmt = t, this.curr = e.curr || 0, this.total = e.total, this.width = e.width || this.total, this.clear = e.clear, this.chars = { complete: e.complete || "=", incomplete: e.incomplete || "-", head: e.head || e.complete || "=" }, this.renderThrottle = e.renderThrottle !== 0 ? e.renderThrottle || 16 : 0, this.lastRender = -1 / 0, this.callback = e.callback || function() {
        }, this.tokens = {}, this.lastDraw = "";
      }
      cr.prototype.tick = function(t, e) {
        if (t !== 0 && (t = t || 1), typeof t == "object" && (e = t, t = 1), e && (this.tokens = e), this.curr == 0 && (this.start = new Date()), this.curr += t, this.render(), this.curr >= this.total) {
          this.render(void 0, true), this.complete = true, this.terminate(), this.callback(this);
          return;
        }
      };
      cr.prototype.render = function(t, e) {
        if (e = e !== void 0 ? e : false, t && (this.tokens = t), !!this.stream.isTTY) {
          var r = Date.now(), i = r - this.lastRender;
          if (!(!e && i < this.renderThrottle)) {
            this.lastRender = r;
            var n = this.curr / this.total;
            n = Math.min(Math.max(n, 0), 1);
            var s = Math.floor(n * 100), o, a, l, c = new Date() - this.start, u = s == 100 ? 0 : c * (this.total / this.curr - 1), f = this.curr / (c / 1e3), h = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(c) ? "0.0" : (c / 1e3).toFixed(1)).replace(":eta", isNaN(u) || !isFinite(u) ? "0.0" : (u / 1e3).toFixed(1)).replace(":percent", s.toFixed(0) + "%").replace(":rate", Math.round(f)), p = Math.max(0, this.stream.columns - h.replace(":bar", "").length);
            p && process.platform === "win32" && (p = p - 1);
            var d = Math.min(this.width, p);
            if (l = Math.round(d * n), a = Array(Math.max(0, l + 1)).join(this.chars.complete), o = Array(Math.max(0, d - l + 1)).join(this.chars.incomplete), l > 0 && (a = a.slice(0, -1) + this.chars.head), h = h.replace(":bar", a + o), this.tokens)
              for (var m in this.tokens)
                h = h.replace(":" + m, this.tokens[m]);
            this.lastDraw !== h && (this.stream.cursorTo(0), this.stream.write(h), this.stream.clearLine(1), this.lastDraw = h);
          }
        }
      };
      cr.prototype.update = function(t, e) {
        var r = Math.floor(t * this.total), i = r - this.curr;
        this.tick(i, e);
      };
      cr.prototype.interrupt = function(t) {
        this.stream.clearLine(), this.stream.cursorTo(0), this.stream.write(t), this.stream.write(`
`), this.stream.write(this.lastDraw);
      };
      cr.prototype.terminate = function() {
        this.clear ? this.stream.clearLine && (this.stream.clearLine(), this.stream.cursorTo(0)) : this.stream.write(`
`);
      };
    });
    var Fc = x((yx, Pc) => {
      Pc.exports = Nc();
    });
    var Mc = x((es) => {
      var Pt = require("path"), yt = process.platform === "win32", xt = require("fs"), Qm = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
      function Jm() {
        var t;
        if (Qm) {
          var e = new Error();
          t = r;
        } else
          t = i;
        return t;
        function r(n) {
          n && (e.message = n.message, n = e, i(n));
        }
        function i(n) {
          if (n) {
            if (process.throwDeprecation)
              throw n;
            if (!process.noDeprecation) {
              var s = "fs: missing callback " + (n.stack || n.message);
              process.traceDeprecation ? console.trace(s) : console.error(s);
            }
          }
        }
      }
      function eg(t) {
        return typeof t == "function" ? t : Jm();
      }
      var bx = Pt.normalize;
      yt ? ft = /(.*?)(?:[\/\\]+|$)/g : ft = /(.*?)(?:[\/]+|$)/g;
      var ft;
      yt ? Hr = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/ : Hr = /^[\/]*/;
      var Hr;
      es.realpathSync = function(e, r) {
        if (e = Pt.resolve(e), r && Object.prototype.hasOwnProperty.call(r, e))
          return r[e];
        var i = e, n = {}, s = {}, o, a, l, c;
        u();
        function u() {
          var g = Hr.exec(e);
          o = g[0].length, a = g[0], l = g[0], c = "", yt && !s[l] && (xt.lstatSync(l), s[l] = true);
        }
        for (; o < e.length; ) {
          ft.lastIndex = o;
          var f = ft.exec(e);
          if (c = a, a += f[0], l = c + f[1], o = ft.lastIndex, !(s[l] || r && r[l] === l)) {
            var h;
            if (r && Object.prototype.hasOwnProperty.call(r, l))
              h = r[l];
            else {
              var p = xt.lstatSync(l);
              if (!p.isSymbolicLink()) {
                s[l] = true, r && (r[l] = l);
                continue;
              }
              var d = null;
              if (!yt) {
                var m = p.dev.toString(32) + ":" + p.ino.toString(32);
                n.hasOwnProperty(m) && (d = n[m]);
              }
              d === null && (xt.statSync(l), d = xt.readlinkSync(l)), h = Pt.resolve(c, d), r && (r[l] = h), yt || (n[m] = d);
            }
            e = Pt.resolve(h, e.slice(o)), u();
          }
        }
        return r && (r[i] = e), e;
      };
      es.realpath = function(e, r, i) {
        if (typeof i != "function" && (i = eg(r), r = null), e = Pt.resolve(e), r && Object.prototype.hasOwnProperty.call(r, e))
          return process.nextTick(i.bind(null, null, r[e]));
        var n = e, s = {}, o = {}, a, l, c, u;
        f();
        function f() {
          var g = Hr.exec(e);
          a = g[0].length, l = g[0], c = g[0], u = "", yt && !o[c] ? xt.lstat(c, function(y) {
            if (y)
              return i(y);
            o[c] = true, h();
          }) : process.nextTick(h);
        }
        function h() {
          if (a >= e.length)
            return r && (r[n] = e), i(null, e);
          ft.lastIndex = a;
          var g = ft.exec(e);
          return u = l, l += g[0], c = u + g[1], a = ft.lastIndex, o[c] || r && r[c] === c ? process.nextTick(h) : r && Object.prototype.hasOwnProperty.call(r, c) ? m(r[c]) : xt.lstat(c, p);
        }
        function p(g, y) {
          if (g)
            return i(g);
          if (!y.isSymbolicLink())
            return o[c] = true, r && (r[c] = c), process.nextTick(h);
          if (!yt) {
            var I = y.dev.toString(32) + ":" + y.ino.toString(32);
            if (s.hasOwnProperty(I))
              return d(null, s[I], c);
          }
          xt.stat(c, function(w) {
            if (w)
              return i(w);
            xt.readlink(c, function(S, b) {
              yt || (s[I] = b), d(S, b);
            });
          });
        }
        function d(g, y, I) {
          if (g)
            return i(g);
          var w = Pt.resolve(u, y);
          r && (r[I] = w), m(w);
        }
        function m(g) {
          e = Pt.resolve(g, e.slice(a)), f();
        }
      };
    });
    var ns = x((Ex, qc) => {
      qc.exports = bt;
      bt.realpath = bt;
      bt.sync = is;
      bt.realpathSync = is;
      bt.monkeypatch = rg;
      bt.unmonkeypatch = ig;
      var ur = require("fs"), ts = ur.realpath, rs = ur.realpathSync, tg = process.version, Uc = /^v[0-5]\./.test(tg), Dc = Mc();
      function jc(t) {
        return t && t.syscall === "realpath" && (t.code === "ELOOP" || t.code === "ENOMEM" || t.code === "ENAMETOOLONG");
      }
      function bt(t, e, r) {
        if (Uc)
          return ts(t, e, r);
        typeof e == "function" && (r = e, e = null), ts(t, e, function(i, n) {
          jc(i) ? Dc.realpath(t, e, r) : r(i, n);
        });
      }
      function is(t, e) {
        if (Uc)
          return rs(t, e);
        try {
          return rs(t, e);
        } catch (r) {
          if (jc(r))
            return Dc.realpathSync(t, e);
          throw r;
        }
      }
      function rg() {
        ur.realpath = bt, ur.realpathSync = is;
      }
      function ig() {
        ur.realpath = ts, ur.realpathSync = rs;
      }
    });
    var Hc = x((Sx, ss) => {
      typeof Object.create == "function" ? ss.exports = function(e, r) {
        r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
      } : ss.exports = function(e, r) {
        if (r) {
          e.super_ = r;
          var i = function() {
          };
          i.prototype = r.prototype, e.prototype = new i(), e.prototype.constructor = e;
        }
      };
    });
    var Vc = x((kx, as) => {
      try {
        if (os = require("util"), typeof os.inherits != "function")
          throw "";
        as.exports = os.inherits;
      } catch (e) {
        as.exports = Hc();
      }
      var os;
    });
    var Ci = x((Cx, ki) => {
      "use strict";
      function $c(t) {
        return t.charAt(0) === "/";
      }
      function Gc(t) {
        var e = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/, r = e.exec(t), i = r[1] || "", n = Boolean(i && i.charAt(1) !== ":");
        return Boolean(r[2] || n);
      }
      ki.exports = process.platform === "win32" ? Gc : $c;
      ki.exports.posix = $c;
      ki.exports.win32 = Gc;
    });
    var cs = x((wt) => {
      wt.setopts = cg;
      wt.ownProp = zc;
      wt.makeAbs = Vr;
      wt.finish = ug;
      wt.mark = fg;
      wt.isIgnored = Yc;
      wt.childrenIgnored = hg;
      function zc(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }
      var ng = require("fs"), fr = require("path"), sg = Ur(), Wc = Ci(), ls = sg.Minimatch;
      function og(t, e) {
        return t.localeCompare(e, "en");
      }
      function ag(t, e) {
        t.ignore = e.ignore || [], Array.isArray(t.ignore) || (t.ignore = [t.ignore]), t.ignore.length && (t.ignore = t.ignore.map(lg));
      }
      function lg(t) {
        var e = null;
        if (t.slice(-3) === "/**") {
          var r = t.replace(/(\/\*\*)+$/, "");
          e = new ls(r, { dot: true });
        }
        return { matcher: new ls(t, { dot: true }), gmatcher: e };
      }
      function cg(t, e, r) {
        if (r || (r = {}), r.matchBase && e.indexOf("/") === -1) {
          if (r.noglobstar)
            throw new Error("base matching requires globstar");
          e = "**/" + e;
        }
        t.silent = !!r.silent, t.pattern = e, t.strict = r.strict !== false, t.realpath = !!r.realpath, t.realpathCache = r.realpathCache || Object.create(null), t.follow = !!r.follow, t.dot = !!r.dot, t.mark = !!r.mark, t.nodir = !!r.nodir, t.nodir && (t.mark = true), t.sync = !!r.sync, t.nounique = !!r.nounique, t.nonull = !!r.nonull, t.nosort = !!r.nosort, t.nocase = !!r.nocase, t.stat = !!r.stat, t.noprocess = !!r.noprocess, t.absolute = !!r.absolute, t.fs = r.fs || ng, t.maxLength = r.maxLength || 1 / 0, t.cache = r.cache || Object.create(null), t.statCache = r.statCache || Object.create(null), t.symlinks = r.symlinks || Object.create(null), ag(t, r), t.changedCwd = false;
        var i = process.cwd();
        zc(r, "cwd") ? (t.cwd = fr.resolve(r.cwd), t.changedCwd = t.cwd !== i) : t.cwd = i, t.root = r.root || fr.resolve(t.cwd, "/"), t.root = fr.resolve(t.root), process.platform === "win32" && (t.root = t.root.replace(/\\/g, "/")), t.cwdAbs = Wc(t.cwd) ? t.cwd : Vr(t, t.cwd), process.platform === "win32" && (t.cwdAbs = t.cwdAbs.replace(/\\/g, "/")), t.nomount = !!r.nomount, r.nonegate = true, r.nocomment = true, t.minimatch = new ls(e, r), t.options = t.minimatch.options;
      }
      function ug(t) {
        for (var e = t.nounique, r = e ? [] : Object.create(null), i = 0, n = t.matches.length; i < n; i++) {
          var s = t.matches[i];
          if (!s || Object.keys(s).length === 0) {
            if (t.nonull) {
              var o = t.minimatch.globSet[i];
              e ? r.push(o) : r[o] = true;
            }
          } else {
            var a = Object.keys(s);
            e ? r.push.apply(r, a) : a.forEach(function(l) {
              r[l] = true;
            });
          }
        }
        if (e || (r = Object.keys(r)), t.nosort || (r = r.sort(og)), t.mark) {
          for (var i = 0; i < r.length; i++)
            r[i] = t._mark(r[i]);
          t.nodir && (r = r.filter(function(l) {
            var c = !/\/$/.test(l), u = t.cache[l] || t.cache[Vr(t, l)];
            return c && u && (c = u !== "DIR" && !Array.isArray(u)), c;
          }));
        }
        t.ignore.length && (r = r.filter(function(l) {
          return !Yc(t, l);
        })), t.found = r;
      }
      function fg(t, e) {
        var r = Vr(t, e), i = t.cache[r], n = e;
        if (i) {
          var s = i === "DIR" || Array.isArray(i), o = e.slice(-1) === "/";
          if (s && !o ? n += "/" : !s && o && (n = n.slice(0, -1)), n !== e) {
            var a = Vr(t, n);
            t.statCache[a] = t.statCache[r], t.cache[a] = t.cache[r];
          }
        }
        return n;
      }
      function Vr(t, e) {
        var r = e;
        return e.charAt(0) === "/" ? r = fr.join(t.root, e) : Wc(e) || e === "" ? r = e : t.changedCwd ? r = fr.resolve(t.cwd, e) : r = fr.resolve(e), process.platform === "win32" && (r = r.replace(/\\/g, "/")), r;
      }
      function Yc(t, e) {
        return t.ignore.length ? t.ignore.some(function(r) {
          return r.matcher.match(e) || !!(r.gmatcher && r.gmatcher.match(e));
        }) : false;
      }
      function hg(t, e) {
        return t.ignore.length ? t.ignore.some(function(r) {
          return !!(r.gmatcher && r.gmatcher.match(e));
        }) : false;
      }
    });
    var Jc = x((Rx, Qc) => {
      Qc.exports = Xc;
      Xc.GlobSync = Re;
      var pg = ns(), Kc = Ur(), Ix = Kc.Minimatch, Tx = hs().Glob, Ax = require("util"), us = require("path"), Zc = require("assert"), Oi = Ci(), Ft = cs(), dg = Ft.setopts, fs = Ft.ownProp, mg = Ft.childrenIgnored, gg = Ft.isIgnored;
      function Xc(t, e) {
        if (typeof e == "function" || arguments.length === 3)
          throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
        return new Re(t, e).found;
      }
      function Re(t, e) {
        if (!t)
          throw new Error("must provide pattern");
        if (typeof e == "function" || arguments.length === 3)
          throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
        if (!(this instanceof Re))
          return new Re(t, e);
        if (dg(this, t, e), this.noprocess)
          return this;
        var r = this.minimatch.set.length;
        this.matches = new Array(r);
        for (var i = 0; i < r; i++)
          this._process(this.minimatch.set[i], i, false);
        this._finish();
      }
      Re.prototype._finish = function() {
        if (Zc(this instanceof Re), this.realpath) {
          var t = this;
          this.matches.forEach(function(e, r) {
            var i = t.matches[r] = Object.create(null);
            for (var n in e)
              try {
                n = t._makeAbs(n);
                var s = pg.realpathSync(n, t.realpathCache);
                i[s] = true;
              } catch (o) {
                if (o.syscall === "stat")
                  i[t._makeAbs(n)] = true;
                else
                  throw o;
              }
          });
        }
        Ft.finish(this);
      };
      Re.prototype._process = function(t, e, r) {
        Zc(this instanceof Re);
        for (var i = 0; typeof t[i] == "string"; )
          i++;
        var n;
        switch (i) {
          case t.length:
            this._processSimple(t.join("/"), e);
            return;
          case 0:
            n = null;
            break;
          default:
            n = t.slice(0, i).join("/");
            break;
        }
        var s = t.slice(i), o;
        n === null ? o = "." : ((Oi(n) || Oi(t.join("/"))) && (!n || !Oi(n)) && (n = "/" + n), o = n);
        var a = this._makeAbs(o);
        if (!mg(this, o)) {
          var l = s[0] === Kc.GLOBSTAR;
          l ? this._processGlobStar(n, o, a, s, e, r) : this._processReaddir(n, o, a, s, e, r);
        }
      };
      Re.prototype._processReaddir = function(t, e, r, i, n, s) {
        var o = this._readdir(r, s);
        if (!!o) {
          for (var a = i[0], l = !!this.minimatch.negate, c = a._glob, u = this.dot || c.charAt(0) === ".", f = [], h = 0; h < o.length; h++) {
            var p = o[h];
            if (p.charAt(0) !== "." || u) {
              var d;
              l && !t ? d = !p.match(a) : d = p.match(a), d && f.push(p);
            }
          }
          var m = f.length;
          if (m !== 0) {
            if (i.length === 1 && !this.mark && !this.stat) {
              this.matches[n] || (this.matches[n] = Object.create(null));
              for (var h = 0; h < m; h++) {
                var p = f[h];
                t && (t.slice(-1) !== "/" ? p = t + "/" + p : p = t + p), p.charAt(0) === "/" && !this.nomount && (p = us.join(this.root, p)), this._emitMatch(n, p);
              }
              return;
            }
            i.shift();
            for (var h = 0; h < m; h++) {
              var p = f[h], g;
              t ? g = [t, p] : g = [p], this._process(g.concat(i), n, s);
            }
          }
        }
      };
      Re.prototype._emitMatch = function(t, e) {
        if (!gg(this, e)) {
          var r = this._makeAbs(e);
          if (this.mark && (e = this._mark(e)), this.absolute && (e = r), !this.matches[t][e]) {
            if (this.nodir) {
              var i = this.cache[r];
              if (i === "DIR" || Array.isArray(i))
                return;
            }
            this.matches[t][e] = true, this.stat && this._stat(e);
          }
        }
      };
      Re.prototype._readdirInGlobStar = function(t) {
        if (this.follow)
          return this._readdir(t, false);
        var e, r, i;
        try {
          r = this.fs.lstatSync(t);
        } catch (s) {
          if (s.code === "ENOENT")
            return null;
        }
        var n = r && r.isSymbolicLink();
        return this.symlinks[t] = n, !n && r && !r.isDirectory() ? this.cache[t] = "FILE" : e = this._readdir(t, false), e;
      };
      Re.prototype._readdir = function(t, e) {
        var r;
        if (e && !fs(this.symlinks, t))
          return this._readdirInGlobStar(t);
        if (fs(this.cache, t)) {
          var i = this.cache[t];
          if (!i || i === "FILE")
            return null;
          if (Array.isArray(i))
            return i;
        }
        try {
          return this._readdirEntries(t, this.fs.readdirSync(t));
        } catch (n) {
          return this._readdirError(t, n), null;
        }
      };
      Re.prototype._readdirEntries = function(t, e) {
        if (!this.mark && !this.stat)
          for (var r = 0; r < e.length; r++) {
            var i = e[r];
            t === "/" ? i = t + i : i = t + "/" + i, this.cache[i] = true;
          }
        return this.cache[t] = e, e;
      };
      Re.prototype._readdirError = function(t, e) {
        switch (e.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var r = this._makeAbs(t);
            if (this.cache[r] = "FILE", r === this.cwdAbs) {
              var i = new Error(e.code + " invalid cwd " + this.cwd);
              throw i.path = this.cwd, i.code = e.code, i;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(t)] = false;
            break;
          default:
            if (this.cache[this._makeAbs(t)] = false, this.strict)
              throw e;
            this.silent || console.error("glob error", e);
            break;
        }
      };
      Re.prototype._processGlobStar = function(t, e, r, i, n, s) {
        var o = this._readdir(r, s);
        if (!!o) {
          var a = i.slice(1), l = t ? [t] : [], c = l.concat(a);
          this._process(c, n, false);
          var u = o.length, f = this.symlinks[r];
          if (!(f && s))
            for (var h = 0; h < u; h++) {
              var p = o[h];
              if (!(p.charAt(0) === "." && !this.dot)) {
                var d = l.concat(o[h], a);
                this._process(d, n, true);
                var m = l.concat(o[h], i);
                this._process(m, n, true);
              }
            }
        }
      };
      Re.prototype._processSimple = function(t, e) {
        var r = this._stat(t);
        if (this.matches[e] || (this.matches[e] = Object.create(null)), !!r) {
          if (t && Oi(t) && !this.nomount) {
            var i = /[\/\\]$/.test(t);
            t.charAt(0) === "/" ? t = us.join(this.root, t) : (t = us.resolve(this.root, t), i && (t += "/"));
          }
          process.platform === "win32" && (t = t.replace(/\\/g, "/")), this._emitMatch(e, t);
        }
      };
      Re.prototype._stat = function(t) {
        var e = this._makeAbs(t), r = t.slice(-1) === "/";
        if (t.length > this.maxLength)
          return false;
        if (!this.stat && fs(this.cache, e)) {
          var o = this.cache[e];
          if (Array.isArray(o) && (o = "DIR"), !r || o === "DIR")
            return o;
          if (r && o === "FILE")
            return false;
        }
        var i, n = this.statCache[e];
        if (!n) {
          var s;
          try {
            s = this.fs.lstatSync(e);
          } catch (a) {
            if (a && (a.code === "ENOENT" || a.code === "ENOTDIR"))
              return this.statCache[e] = false, false;
          }
          if (s && s.isSymbolicLink())
            try {
              n = this.fs.statSync(e);
            } catch (e2) {
              n = s;
            }
          else
            n = s;
        }
        this.statCache[e] = n;
        var o = true;
        return n && (o = n.isDirectory() ? "DIR" : "FILE"), this.cache[e] = this.cache[e] || o, r && o === "FILE" ? false : o;
      };
      Re.prototype._mark = function(t) {
        return Ft.mark(this, t);
      };
      Re.prototype._makeAbs = function(t) {
        return Ft.makeAbs(this, t);
      };
    });
    var ps = x((Bx, tu) => {
      tu.exports = eu;
      function eu(t, e) {
        if (t && e)
          return eu(t)(e);
        if (typeof t != "function")
          throw new TypeError("need wrapper function");
        return Object.keys(t).forEach(function(i) {
          r[i] = t[i];
        }), r;
        function r() {
          for (var i = new Array(arguments.length), n = 0; n < i.length; n++)
            i[n] = arguments[n];
          var s = t.apply(this, i), o = i[i.length - 1];
          return typeof s == "function" && s !== o && Object.keys(o).forEach(function(a) {
            s[a] = o[a];
          }), s;
        }
      }
    });
    var ms = x((Lx, ds) => {
      var ru = ps();
      ds.exports = ru(Ii);
      ds.exports.strict = ru(iu);
      Ii.proto = Ii(function() {
        Object.defineProperty(Function.prototype, "once", { value: function() {
          return Ii(this);
        }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
          return iu(this);
        }, configurable: true });
      });
      function Ii(t) {
        var e = function() {
          return e.called ? e.value : (e.called = true, e.value = t.apply(this, arguments));
        };
        return e.called = false, e;
      }
      function iu(t) {
        var e = function() {
          if (e.called)
            throw new Error(e.onceError);
          return e.called = true, e.value = t.apply(this, arguments);
        }, r = t.name || "Function wrapped with `once`";
        return e.onceError = r + " shouldn't be called more than once", e.called = false, e;
      }
    });
    var su = x((Nx, nu) => {
      var vg = ps(), $r = Object.create(null), _g = ms();
      nu.exports = vg(xg);
      function xg(t, e) {
        return $r[t] ? ($r[t].push(e), null) : ($r[t] = [e], yg(t));
      }
      function yg(t) {
        return _g(function e() {
          var r = $r[t], i = r.length, n = bg(arguments);
          try {
            for (var s = 0; s < i; s++)
              r[s].apply(null, n);
          } finally {
            r.length > i ? (r.splice(0, i), process.nextTick(function() {
              e.apply(null, n);
            })) : delete $r[t];
          }
        });
      }
      function bg(t) {
        for (var e = t.length, r = [], i = 0; i < e; i++)
          r[i] = t[i];
        return r;
      }
    });
    var hs = x((Mx, au) => {
      au.exports = Mt;
      var wg = ns(), ou = Ur(), Px = ou.Minimatch, Eg = Vc(), Sg = require("events").EventEmitter, gs = require("path"), vs = require("assert"), Gr = Ci(), xs = Jc(), Ut = cs(), kg = Ut.setopts, _s = Ut.ownProp, ys = su(), Fx = require("util"), Cg = Ut.childrenIgnored, Og = Ut.isIgnored, Ig = ms();
      function Mt(t, e, r) {
        if (typeof e == "function" && (r = e, e = {}), e || (e = {}), e.sync) {
          if (r)
            throw new TypeError("callback provided to sync glob");
          return xs(t, e);
        }
        return new me(t, e, r);
      }
      Mt.sync = xs;
      var Tg = Mt.GlobSync = xs.GlobSync;
      Mt.glob = Mt;
      function Ag(t, e) {
        if (e === null || typeof e != "object")
          return t;
        for (var r = Object.keys(e), i = r.length; i--; )
          t[r[i]] = e[r[i]];
        return t;
      }
      Mt.hasMagic = function(t, e) {
        var r = Ag({}, e);
        r.noprocess = true;
        var i = new me(t, r), n = i.minimatch.set;
        if (!t)
          return false;
        if (n.length > 1)
          return true;
        for (var s = 0; s < n[0].length; s++)
          if (typeof n[0][s] != "string")
            return true;
        return false;
      };
      Mt.Glob = me;
      Eg(me, Sg);
      function me(t, e, r) {
        if (typeof e == "function" && (r = e, e = null), e && e.sync) {
          if (r)
            throw new TypeError("callback provided to sync glob");
          return new Tg(t, e);
        }
        if (!(this instanceof me))
          return new me(t, e, r);
        kg(this, t, e), this._didRealPath = false;
        var i = this.minimatch.set.length;
        this.matches = new Array(i), typeof r == "function" && (r = Ig(r), this.on("error", r), this.on("end", function(l) {
          r(null, l);
        }));
        var n = this;
        if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = false, this.noprocess)
          return this;
        if (i === 0)
          return a();
        for (var s = true, o = 0; o < i; o++)
          this._process(this.minimatch.set[o], o, false, a);
        s = false;
        function a() {
          --n._processing, n._processing <= 0 && (s ? process.nextTick(function() {
            n._finish();
          }) : n._finish());
        }
      }
      me.prototype._finish = function() {
        if (vs(this instanceof me), !this.aborted) {
          if (this.realpath && !this._didRealpath)
            return this._realpath();
          Ut.finish(this), this.emit("end", this.found);
        }
      };
      me.prototype._realpath = function() {
        if (this._didRealpath)
          return;
        this._didRealpath = true;
        var t = this.matches.length;
        if (t === 0)
          return this._finish();
        for (var e = this, r = 0; r < this.matches.length; r++)
          this._realpathSet(r, i);
        function i() {
          --t === 0 && e._finish();
        }
      };
      me.prototype._realpathSet = function(t, e) {
        var r = this.matches[t];
        if (!r)
          return e();
        var i = Object.keys(r), n = this, s = i.length;
        if (s === 0)
          return e();
        var o = this.matches[t] = Object.create(null);
        i.forEach(function(a, l) {
          a = n._makeAbs(a), wg.realpath(a, n.realpathCache, function(c, u) {
            c ? c.syscall === "stat" ? o[a] = true : n.emit("error", c) : o[u] = true, --s === 0 && (n.matches[t] = o, e());
          });
        });
      };
      me.prototype._mark = function(t) {
        return Ut.mark(this, t);
      };
      me.prototype._makeAbs = function(t) {
        return Ut.makeAbs(this, t);
      };
      me.prototype.abort = function() {
        this.aborted = true, this.emit("abort");
      };
      me.prototype.pause = function() {
        this.paused || (this.paused = true, this.emit("pause"));
      };
      me.prototype.resume = function() {
        if (this.paused) {
          if (this.emit("resume"), this.paused = false, this._emitQueue.length) {
            var t = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var e = 0; e < t.length; e++) {
              var r = t[e];
              this._emitMatch(r[0], r[1]);
            }
          }
          if (this._processQueue.length) {
            var i = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (var e = 0; e < i.length; e++) {
              var n = i[e];
              this._processing--, this._process(n[0], n[1], n[2], n[3]);
            }
          }
        }
      };
      me.prototype._process = function(t, e, r, i) {
        if (vs(this instanceof me), vs(typeof i == "function"), !this.aborted) {
          if (this._processing++, this.paused) {
            this._processQueue.push([t, e, r, i]);
            return;
          }
          for (var n = 0; typeof t[n] == "string"; )
            n++;
          var s;
          switch (n) {
            case t.length:
              this._processSimple(t.join("/"), e, i);
              return;
            case 0:
              s = null;
              break;
            default:
              s = t.slice(0, n).join("/");
              break;
          }
          var o = t.slice(n), a;
          s === null ? a = "." : ((Gr(s) || Gr(t.join("/"))) && (!s || !Gr(s)) && (s = "/" + s), a = s);
          var l = this._makeAbs(a);
          if (Cg(this, a))
            return i();
          var c = o[0] === ou.GLOBSTAR;
          c ? this._processGlobStar(s, a, l, o, e, r, i) : this._processReaddir(s, a, l, o, e, r, i);
        }
      };
      me.prototype._processReaddir = function(t, e, r, i, n, s, o) {
        var a = this;
        this._readdir(r, s, function(l, c) {
          return a._processReaddir2(t, e, r, i, n, s, c, o);
        });
      };
      me.prototype._processReaddir2 = function(t, e, r, i, n, s, o, a) {
        if (!o)
          return a();
        for (var l = i[0], c = !!this.minimatch.negate, u = l._glob, f = this.dot || u.charAt(0) === ".", h = [], p = 0; p < o.length; p++) {
          var d = o[p];
          if (d.charAt(0) !== "." || f) {
            var m;
            c && !t ? m = !d.match(l) : m = d.match(l), m && h.push(d);
          }
        }
        var g = h.length;
        if (g === 0)
          return a();
        if (i.length === 1 && !this.mark && !this.stat) {
          this.matches[n] || (this.matches[n] = Object.create(null));
          for (var p = 0; p < g; p++) {
            var d = h[p];
            t && (t !== "/" ? d = t + "/" + d : d = t + d), d.charAt(0) === "/" && !this.nomount && (d = gs.join(this.root, d)), this._emitMatch(n, d);
          }
          return a();
        }
        i.shift();
        for (var p = 0; p < g; p++) {
          var d = h[p], y;
          t && (t !== "/" ? d = t + "/" + d : d = t + d), this._process([d].concat(i), n, s, a);
        }
        a();
      };
      me.prototype._emitMatch = function(t, e) {
        if (!this.aborted && !Og(this, e)) {
          if (this.paused) {
            this._emitQueue.push([t, e]);
            return;
          }
          var r = Gr(e) ? e : this._makeAbs(e);
          if (this.mark && (e = this._mark(e)), this.absolute && (e = r), !this.matches[t][e]) {
            if (this.nodir) {
              var i = this.cache[r];
              if (i === "DIR" || Array.isArray(i))
                return;
            }
            this.matches[t][e] = true;
            var n = this.statCache[r];
            n && this.emit("stat", e, n), this.emit("match", e);
          }
        }
      };
      me.prototype._readdirInGlobStar = function(t, e) {
        if (this.aborted)
          return;
        if (this.follow)
          return this._readdir(t, false, e);
        var r = "lstat\0" + t, i = this, n = ys(r, s);
        n && i.fs.lstat(t, n);
        function s(o, a) {
          if (o && o.code === "ENOENT")
            return e();
          var l = a && a.isSymbolicLink();
          i.symlinks[t] = l, !l && a && !a.isDirectory() ? (i.cache[t] = "FILE", e()) : i._readdir(t, false, e);
        }
      };
      me.prototype._readdir = function(t, e, r) {
        if (!this.aborted && (r = ys("readdir\0" + t + "\0" + e, r), !!r)) {
          if (e && !_s(this.symlinks, t))
            return this._readdirInGlobStar(t, r);
          if (_s(this.cache, t)) {
            var i = this.cache[t];
            if (!i || i === "FILE")
              return r();
            if (Array.isArray(i))
              return r(null, i);
          }
          var n = this;
          n.fs.readdir(t, Rg(this, t, r));
        }
      };
      function Rg(t, e, r) {
        return function(i, n) {
          i ? t._readdirError(e, i, r) : t._readdirEntries(e, n, r);
        };
      }
      me.prototype._readdirEntries = function(t, e, r) {
        if (!this.aborted) {
          if (!this.mark && !this.stat)
            for (var i = 0; i < e.length; i++) {
              var n = e[i];
              t === "/" ? n = t + n : n = t + "/" + n, this.cache[n] = true;
            }
          return this.cache[t] = e, r(null, e);
        }
      };
      me.prototype._readdirError = function(t, e, r) {
        if (!this.aborted) {
          switch (e.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var i = this._makeAbs(t);
              if (this.cache[i] = "FILE", i === this.cwdAbs) {
                var n = new Error(e.code + " invalid cwd " + this.cwd);
                n.path = this.cwd, n.code = e.code, this.emit("error", n), this.abort();
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(t)] = false;
              break;
            default:
              this.cache[this._makeAbs(t)] = false, this.strict && (this.emit("error", e), this.abort()), this.silent || console.error("glob error", e);
              break;
          }
          return r();
        }
      };
      me.prototype._processGlobStar = function(t, e, r, i, n, s, o) {
        var a = this;
        this._readdir(r, s, function(l, c) {
          a._processGlobStar2(t, e, r, i, n, s, c, o);
        });
      };
      me.prototype._processGlobStar2 = function(t, e, r, i, n, s, o, a) {
        if (!o)
          return a();
        var l = i.slice(1), c = t ? [t] : [], u = c.concat(l);
        this._process(u, n, false, a);
        var f = this.symlinks[r], h = o.length;
        if (f && s)
          return a();
        for (var p = 0; p < h; p++) {
          var d = o[p];
          if (!(d.charAt(0) === "." && !this.dot)) {
            var m = c.concat(o[p], l);
            this._process(m, n, true, a);
            var g = c.concat(o[p], i);
            this._process(g, n, true, a);
          }
        }
        a();
      };
      me.prototype._processSimple = function(t, e, r) {
        var i = this;
        this._stat(t, function(n, s) {
          i._processSimple2(t, e, n, s, r);
        });
      };
      me.prototype._processSimple2 = function(t, e, r, i, n) {
        if (this.matches[e] || (this.matches[e] = Object.create(null)), !i)
          return n();
        if (t && Gr(t) && !this.nomount) {
          var s = /[\/\\]$/.test(t);
          t.charAt(0) === "/" ? t = gs.join(this.root, t) : (t = gs.resolve(this.root, t), s && (t += "/"));
        }
        process.platform === "win32" && (t = t.replace(/\\/g, "/")), this._emitMatch(e, t), n();
      };
      me.prototype._stat = function(t, e) {
        var r = this._makeAbs(t), i = t.slice(-1) === "/";
        if (t.length > this.maxLength)
          return e();
        if (!this.stat && _s(this.cache, r)) {
          var n = this.cache[r];
          if (Array.isArray(n) && (n = "DIR"), !i || n === "DIR")
            return e(null, n);
          if (i && n === "FILE")
            return e();
        }
        var s, o = this.statCache[r];
        if (o !== void 0) {
          if (o === false)
            return e(null, o);
          var a = o.isDirectory() ? "DIR" : "FILE";
          return i && a === "FILE" ? e() : e(null, a, o);
        }
        var l = this, c = ys("stat\0" + r, u);
        c && l.fs.lstat(r, c);
        function u(f, h) {
          if (h && h.isSymbolicLink())
            return l.fs.stat(r, function(p, d) {
              p ? l._stat2(t, r, null, h, e) : l._stat2(t, r, p, d, e);
            });
          l._stat2(t, r, f, h, e);
        }
      };
      me.prototype._stat2 = function(t, e, r, i, n) {
        if (r && (r.code === "ENOENT" || r.code === "ENOTDIR"))
          return this.statCache[e] = false, n();
        var s = t.slice(-1) === "/";
        if (this.statCache[e] = i, e.slice(-1) === "/" && i && !i.isDirectory())
          return n(null, false, i);
        var o = true;
        return i && (o = i.isDirectory() ? "DIR" : "FILE"), this.cache[e] = this.cache[e] || o, s && o === "FILE" ? n() : n(null, o, i);
      };
    });
    var mu = x((Ux, du) => {
      var xe = require("assert"), fu = require("path"), lu = require("fs"), hr;
      try {
        hr = hs();
      } catch (e) {
      }
      var Bg = { nosort: true, silent: true }, bs = 0, zr = process.platform === "win32", hu = (t) => {
        if (["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((r) => {
          t[r] = t[r] || lu[r], r = r + "Sync", t[r] = t[r] || lu[r];
        }), t.maxBusyTries = t.maxBusyTries || 3, t.emfileWait = t.emfileWait || 1e3, t.glob === false && (t.disableGlob = true), t.disableGlob !== true && hr === void 0)
          throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
        t.disableGlob = t.disableGlob || false, t.glob = t.glob || Bg;
      }, Es = (t, e, r) => {
        typeof e == "function" && (r = e, e = {}), xe(t, "rimraf: missing path"), xe.equal(typeof t, "string", "rimraf: path should be a string"), xe.equal(typeof r, "function", "rimraf: callback function required"), xe(e, "rimraf: invalid options argument provided"), xe.equal(typeof e, "object", "rimraf: options should be object"), hu(e);
        let i = 0, n = null, s = 0, o = (l) => {
          n = n || l, --s === 0 && r(n);
        }, a = (l, c) => {
          if (l)
            return r(l);
          if (s = c.length, s === 0)
            return r();
          c.forEach((u) => {
            let f = (h) => {
              if (h) {
                if ((h.code === "EBUSY" || h.code === "ENOTEMPTY" || h.code === "EPERM") && i < e.maxBusyTries)
                  return i++, setTimeout(() => ws2(u, e, f), i * 100);
                if (h.code === "EMFILE" && bs < e.emfileWait)
                  return setTimeout(() => ws2(u, e, f), bs++);
                h.code === "ENOENT" && (h = null);
              }
              bs = 0, o(h);
            };
            ws2(u, e, f);
          });
        };
        if (e.disableGlob || !hr.hasMagic(t))
          return a(null, [t]);
        e.lstat(t, (l, c) => {
          if (!l)
            return a(null, [t]);
          hr(t, e.glob, a);
        });
      }, ws2 = (t, e, r) => {
        xe(t), xe(e), xe(typeof r == "function"), e.lstat(t, (i, n) => {
          if (i && i.code === "ENOENT")
            return r(null);
          if (i && i.code === "EPERM" && zr && cu(t, e, i, r), n && n.isDirectory())
            return Ti(t, e, i, r);
          e.unlink(t, (s) => {
            if (s) {
              if (s.code === "ENOENT")
                return r(null);
              if (s.code === "EPERM")
                return zr ? cu(t, e, s, r) : Ti(t, e, s, r);
              if (s.code === "EISDIR")
                return Ti(t, e, s, r);
            }
            return r(s);
          });
        });
      }, cu = (t, e, r, i) => {
        xe(t), xe(e), xe(typeof i == "function"), e.chmod(t, 438, (n) => {
          n ? i(n.code === "ENOENT" ? null : r) : e.stat(t, (s, o) => {
            s ? i(s.code === "ENOENT" ? null : r) : o.isDirectory() ? Ti(t, e, r, i) : e.unlink(t, i);
          });
        });
      }, uu = (t, e, r) => {
        xe(t), xe(e);
        try {
          e.chmodSync(t, 438);
        } catch (n) {
          if (n.code === "ENOENT")
            return;
          throw r;
        }
        let i;
        try {
          i = e.statSync(t);
        } catch (n) {
          if (n.code === "ENOENT")
            return;
          throw r;
        }
        i.isDirectory() ? Ai(t, e, r) : e.unlinkSync(t);
      }, Ti = (t, e, r, i) => {
        xe(t), xe(e), xe(typeof i == "function"), e.rmdir(t, (n) => {
          n && (n.code === "ENOTEMPTY" || n.code === "EEXIST" || n.code === "EPERM") ? Lg(t, e, i) : n && n.code === "ENOTDIR" ? i(r) : i(n);
        });
      }, Lg = (t, e, r) => {
        xe(t), xe(e), xe(typeof r == "function"), e.readdir(t, (i, n) => {
          if (i)
            return r(i);
          let s = n.length;
          if (s === 0)
            return e.rmdir(t, r);
          let o;
          n.forEach((a) => {
            Es(fu.join(t, a), e, (l) => {
              if (!o) {
                if (l)
                  return r(o = l);
                --s === 0 && e.rmdir(t, r);
              }
            });
          });
        });
      }, pu = (t, e) => {
        e = e || {}, hu(e), xe(t, "rimraf: missing path"), xe.equal(typeof t, "string", "rimraf: path should be a string"), xe(e, "rimraf: missing options"), xe.equal(typeof e, "object", "rimraf: options should be object");
        let r;
        if (e.disableGlob || !hr.hasMagic(t))
          r = [t];
        else
          try {
            e.lstatSync(t), r = [t];
          } catch (e2) {
            r = hr.sync(t, e.glob);
          }
        if (!!r.length)
          for (let i = 0; i < r.length; i++) {
            let n = r[i], s;
            try {
              s = e.lstatSync(n);
            } catch (o) {
              if (o.code === "ENOENT")
                return;
              o.code === "EPERM" && zr && uu(n, e, o);
            }
            try {
              s && s.isDirectory() ? Ai(n, e, null) : e.unlinkSync(n);
            } catch (o) {
              if (o.code === "ENOENT")
                return;
              if (o.code === "EPERM")
                return zr ? uu(n, e, o) : Ai(n, e, o);
              if (o.code !== "EISDIR")
                throw o;
              Ai(n, e, o);
            }
          }
      }, Ai = (t, e, r) => {
        xe(t), xe(e);
        try {
          e.rmdirSync(t);
        } catch (i) {
          if (i.code === "ENOENT")
            return;
          if (i.code === "ENOTDIR")
            throw r;
          (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM") && Ng(t, e);
        }
      }, Ng = (t, e) => {
        xe(t), xe(e), e.readdirSync(t).forEach((n) => pu(fu.join(t, n), e));
        let r = zr ? 100 : 1, i = 0;
        do {
          let n = true;
          try {
            let s = e.rmdirSync(t, e);
            return n = false, s;
          } finally {
            if (++i < r && n)
              continue;
          }
        } while (true);
      };
      du.exports = Es;
      Es.sync = pu;
    });
    var vu = x((gu) => {
      var H = gu, { Buffer: Ri } = require("buffer"), Pg = require("os");
      H.toBuffer = function(t, e, r) {
        r = ~~r;
        let i;
        if (this.isV4Format(t))
          i = e || Ri.alloc(r + 4), t.split(/\./g).map((n) => {
            i[r++] = parseInt(n, 10) & 255;
          });
        else if (this.isV6Format(t)) {
          let n = t.split(":", 8), s;
          for (s = 0; s < n.length; s++) {
            let o = this.isV4Format(n[s]), a;
            o && (a = this.toBuffer(n[s]), n[s] = a.slice(0, 2).toString("hex")), a && ++s < 8 && n.splice(s, 0, a.slice(2, 4).toString("hex"));
          }
          if (n[0] === "")
            for (; n.length < 8; )
              n.unshift("0");
          else if (n[n.length - 1] === "")
            for (; n.length < 8; )
              n.push("0");
          else if (n.length < 8) {
            for (s = 0; s < n.length && n[s] !== ""; s++)
              ;
            let o = [s, 1];
            for (s = 9 - n.length; s > 0; s--)
              o.push("0");
            n.splice(...o);
          }
          for (i = e || Ri.alloc(r + 16), s = 0; s < n.length; s++) {
            let o = parseInt(n[s], 16);
            i[r++] = o >> 8 & 255, i[r++] = o & 255;
          }
        }
        if (!i)
          throw Error(`Invalid ip address: ${t}`);
        return i;
      };
      H.toString = function(t, e, r) {
        e = ~~e, r = r || t.length - e;
        let i = [];
        if (r === 4) {
          for (let n = 0; n < r; n++)
            i.push(t[e + n]);
          i = i.join(".");
        } else if (r === 16) {
          for (let n = 0; n < r; n += 2)
            i.push(t.readUInt16BE(e + n).toString(16));
          i = i.join(":"), i = i.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), i = i.replace(/:{3,4}/, "::");
        }
        return i;
      };
      var Fg = /^(\d{1,3}\.){3,3}\d{1,3}$/, Mg = /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;
      H.isV4Format = function(t) {
        return Fg.test(t);
      };
      H.isV6Format = function(t) {
        return Mg.test(t);
      };
      function Wr(t) {
        return t === 4 ? "ipv4" : t === 6 ? "ipv6" : t ? t.toLowerCase() : "ipv4";
      }
      H.fromPrefixLen = function(t, e) {
        t > 32 ? e = "ipv6" : e = Wr(e);
        let r = 4;
        e === "ipv6" && (r = 16);
        let i = Ri.alloc(r);
        for (let n = 0, s = i.length; n < s; ++n) {
          let o = 8;
          t < 8 && (o = t), t -= o, i[n] = ~(255 >> o) & 255;
        }
        return H.toString(i);
      };
      H.mask = function(t, e) {
        t = H.toBuffer(t), e = H.toBuffer(e);
        let r = Ri.alloc(Math.max(t.length, e.length)), i;
        if (t.length === e.length)
          for (i = 0; i < t.length; i++)
            r[i] = t[i] & e[i];
        else if (e.length === 4)
          for (i = 0; i < e.length; i++)
            r[i] = t[t.length - 4 + i] & e[i];
        else {
          for (i = 0; i < r.length - 6; i++)
            r[i] = 0;
          for (r[10] = 255, r[11] = 255, i = 0; i < t.length; i++)
            r[i + 12] = t[i] & e[i + 12];
          i += 12;
        }
        for (; i < r.length; i++)
          r[i] = 0;
        return H.toString(r);
      };
      H.cidr = function(t) {
        let e = t.split("/"), r = e[0];
        if (e.length !== 2)
          throw new Error(`invalid CIDR subnet: ${r}`);
        let i = H.fromPrefixLen(parseInt(e[1], 10));
        return H.mask(r, i);
      };
      H.subnet = function(t, e) {
        let r = H.toLong(H.mask(t, e)), i = H.toBuffer(e), n = 0;
        for (let o = 0; o < i.length; o++)
          if (i[o] === 255)
            n += 8;
          else {
            let a = i[o] & 255;
            for (; a; )
              a = a << 1 & 255, n++;
          }
        let s = 2 ** (32 - n);
        return { networkAddress: H.fromLong(r), firstAddress: s <= 2 ? H.fromLong(r) : H.fromLong(r + 1), lastAddress: s <= 2 ? H.fromLong(r + s - 1) : H.fromLong(r + s - 2), broadcastAddress: H.fromLong(r + s - 1), subnetMask: e, subnetMaskLength: n, numHosts: s <= 2 ? s : s - 2, length: s, contains(o) {
          return r === H.toLong(H.mask(o, e));
        } };
      };
      H.cidrSubnet = function(t) {
        let e = t.split("/"), r = e[0];
        if (e.length !== 2)
          throw new Error(`invalid CIDR subnet: ${r}`);
        let i = H.fromPrefixLen(parseInt(e[1], 10));
        return H.subnet(r, i);
      };
      H.not = function(t) {
        let e = H.toBuffer(t);
        for (let r = 0; r < e.length; r++)
          e[r] = 255 ^ e[r];
        return H.toString(e);
      };
      H.or = function(t, e) {
        if (t = H.toBuffer(t), e = H.toBuffer(e), t.length === e.length) {
          for (let s = 0; s < t.length; ++s)
            t[s] |= e[s];
          return H.toString(t);
        }
        let r = t, i = e;
        e.length > t.length && (r = e, i = t);
        let n = r.length - i.length;
        for (let s = n; s < r.length; ++s)
          r[s] |= i[s - n];
        return H.toString(r);
      };
      H.isEqual = function(t, e) {
        if (t = H.toBuffer(t), e = H.toBuffer(e), t.length === e.length) {
          for (let i = 0; i < t.length; i++)
            if (t[i] !== e[i])
              return false;
          return true;
        }
        if (e.length === 4) {
          let i = e;
          e = t, t = i;
        }
        for (let i = 0; i < 10; i++)
          if (e[i] !== 0)
            return false;
        let r = e.readUInt16BE(10);
        if (r !== 0 && r !== 65535)
          return false;
        for (let i = 0; i < 4; i++)
          if (t[i] !== e[i + 12])
            return false;
        return true;
      };
      H.isPrivate = function(t) {
        return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t) || /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t) || /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t) || /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t) || /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t) || /^f[cd][0-9a-f]{2}:/i.test(t) || /^fe80:/i.test(t) || /^::1$/.test(t) || /^::$/.test(t);
      };
      H.isPublic = function(t) {
        return !H.isPrivate(t);
      };
      H.isLoopback = function(t) {
        return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(t) || /^fe80::1$/.test(t) || /^::1$/.test(t) || /^::$/.test(t);
      };
      H.loopback = function(t) {
        if (t = Wr(t), t !== "ipv4" && t !== "ipv6")
          throw new Error("family must be ipv4 or ipv6");
        return t === "ipv4" ? "127.0.0.1" : "fe80::1";
      };
      H.address = function(t, e) {
        let r = Pg.networkInterfaces();
        if (e = Wr(e), t && t !== "private" && t !== "public") {
          let n = r[t].filter((s) => Wr(s.family) === e);
          return n.length === 0 ? void 0 : n[0].address;
        }
        let i = Object.keys(r).map((n) => {
          let s = r[n].filter((o) => (o.family = Wr(o.family), o.family !== e || H.isLoopback(o.address) ? false : t ? t === "public" ? H.isPrivate(o.address) : H.isPublic(o.address) : true));
          return s.length ? s[0].address : void 0;
        }).filter(Boolean);
        return i.length ? i[0] : H.loopback(e);
      };
      H.toLong = function(t) {
        let e = 0;
        return t.split(".").forEach((r) => {
          e <<= 8, e += parseInt(r);
        }), e >>> 0;
      };
      H.fromLong = function(t) {
        return `${t >>> 24}.${t >> 16 & 255}.${t >> 8 & 255}.${t & 255}`;
      };
    });
    var bu = x((ht) => {
      "use strict";
      Object.defineProperty(ht, "__esModule", { value: true });
      var _u = require("buffer"), Dt = { INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.", INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.", INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.", INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.", INVALID_OFFSET: "An invalid offset value was provided.", INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.", INVALID_LENGTH: "An invalid length value was provided.", INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.", INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.", INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.", INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.", INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data." };
      ht.ERRORS = Dt;
      function Ug(t) {
        if (!_u.Buffer.isEncoding(t))
          throw new Error(Dt.INVALID_ENCODING);
      }
      ht.checkEncoding = Ug;
      function xu(t) {
        return typeof t == "number" && isFinite(t) && Hg(t);
      }
      ht.isFiniteInteger = xu;
      function yu(t, e) {
        if (typeof t == "number") {
          if (!xu(t) || t < 0)
            throw new Error(e ? Dt.INVALID_OFFSET : Dt.INVALID_LENGTH);
        } else
          throw new Error(e ? Dt.INVALID_OFFSET_NON_NUMBER : Dt.INVALID_LENGTH_NON_NUMBER);
      }
      function Dg(t) {
        yu(t, false);
      }
      ht.checkLengthValue = Dg;
      function jg(t) {
        yu(t, true);
      }
      ht.checkOffsetValue = jg;
      function qg(t, e) {
        if (t < 0 || t > e.length)
          throw new Error(Dt.INVALID_TARGET_OFFSET);
      }
      ht.checkTargetOffset = qg;
      function Hg(t) {
        return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
      }
      function Vg(t) {
        if (typeof BigInt == "undefined")
          throw new Error("Platform does not support JS BigInt type.");
        if (typeof _u.Buffer.prototype[t] == "undefined")
          throw new Error(`Platform does not support Buffer.prototype.${t}.`);
      }
      ht.bigIntAndBufferInt64Check = Vg;
    });
    var Eu = x((Ss) => {
      "use strict";
      Object.defineProperty(Ss, "__esModule", { value: true });
      var re = bu(), wu = 4096, $g = "utf8", Yr = class {
        constructor(e) {
          if (this.length = 0, this._encoding = $g, this._writeOffset = 0, this._readOffset = 0, Yr.isSmartBufferOptions(e))
            if (e.encoding && (re.checkEncoding(e.encoding), this._encoding = e.encoding), e.size)
              if (re.isFiniteInteger(e.size) && e.size > 0)
                this._buff = Buffer.allocUnsafe(e.size);
              else
                throw new Error(re.ERRORS.INVALID_SMARTBUFFER_SIZE);
            else if (e.buff)
              if (Buffer.isBuffer(e.buff))
                this._buff = e.buff, this.length = e.buff.length;
              else
                throw new Error(re.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            else
              this._buff = Buffer.allocUnsafe(wu);
          else {
            if (typeof e != "undefined")
              throw new Error(re.ERRORS.INVALID_SMARTBUFFER_OBJECT);
            this._buff = Buffer.allocUnsafe(wu);
          }
        }
        static fromSize(e, r) {
          return new this({ size: e, encoding: r });
        }
        static fromBuffer(e, r) {
          return new this({ buff: e, encoding: r });
        }
        static fromOptions(e) {
          return new this(e);
        }
        static isSmartBufferOptions(e) {
          let r = e;
          return r && (r.encoding !== void 0 || r.size !== void 0 || r.buff !== void 0);
        }
        readInt8(e) {
          return this._readNumberValue(Buffer.prototype.readInt8, 1, e);
        }
        readInt16BE(e) {
          return this._readNumberValue(Buffer.prototype.readInt16BE, 2, e);
        }
        readInt16LE(e) {
          return this._readNumberValue(Buffer.prototype.readInt16LE, 2, e);
        }
        readInt32BE(e) {
          return this._readNumberValue(Buffer.prototype.readInt32BE, 4, e);
        }
        readInt32LE(e) {
          return this._readNumberValue(Buffer.prototype.readInt32LE, 4, e);
        }
        readBigInt64BE(e) {
          return re.bigIntAndBufferInt64Check("readBigInt64BE"), this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, e);
        }
        readBigInt64LE(e) {
          return re.bigIntAndBufferInt64Check("readBigInt64LE"), this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, e);
        }
        writeInt8(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeInt8, 1, e, r), this;
        }
        insertInt8(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeInt8, 1, e, r);
        }
        writeInt16BE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, e, r);
        }
        insertInt16BE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, e, r);
        }
        writeInt16LE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, e, r);
        }
        insertInt16LE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, e, r);
        }
        writeInt32BE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, e, r);
        }
        insertInt32BE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, e, r);
        }
        writeInt32LE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, e, r);
        }
        insertInt32LE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, e, r);
        }
        writeBigInt64BE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigInt64BE"), this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, e, r);
        }
        insertBigInt64BE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigInt64BE"), this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, e, r);
        }
        writeBigInt64LE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigInt64LE"), this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, e, r);
        }
        insertBigInt64LE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigInt64LE"), this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, e, r);
        }
        readUInt8(e) {
          return this._readNumberValue(Buffer.prototype.readUInt8, 1, e);
        }
        readUInt16BE(e) {
          return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, e);
        }
        readUInt16LE(e) {
          return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, e);
        }
        readUInt32BE(e) {
          return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, e);
        }
        readUInt32LE(e) {
          return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, e);
        }
        readBigUInt64BE(e) {
          return re.bigIntAndBufferInt64Check("readBigUInt64BE"), this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, e);
        }
        readBigUInt64LE(e) {
          return re.bigIntAndBufferInt64Check("readBigUInt64LE"), this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, e);
        }
        writeUInt8(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, e, r);
        }
        insertUInt8(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, e, r);
        }
        writeUInt16BE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, e, r);
        }
        insertUInt16BE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, e, r);
        }
        writeUInt16LE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, e, r);
        }
        insertUInt16LE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, e, r);
        }
        writeUInt32BE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, e, r);
        }
        insertUInt32BE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, e, r);
        }
        writeUInt32LE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, e, r);
        }
        insertUInt32LE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, e, r);
        }
        writeBigUInt64BE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigUInt64BE"), this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, e, r);
        }
        insertBigUInt64BE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigUInt64BE"), this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, e, r);
        }
        writeBigUInt64LE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigUInt64LE"), this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, e, r);
        }
        insertBigUInt64LE(e, r) {
          return re.bigIntAndBufferInt64Check("writeBigUInt64LE"), this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, e, r);
        }
        readFloatBE(e) {
          return this._readNumberValue(Buffer.prototype.readFloatBE, 4, e);
        }
        readFloatLE(e) {
          return this._readNumberValue(Buffer.prototype.readFloatLE, 4, e);
        }
        writeFloatBE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, e, r);
        }
        insertFloatBE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, e, r);
        }
        writeFloatLE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, e, r);
        }
        insertFloatLE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, e, r);
        }
        readDoubleBE(e) {
          return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, e);
        }
        readDoubleLE(e) {
          return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, e);
        }
        writeDoubleBE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, e, r);
        }
        insertDoubleBE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, e, r);
        }
        writeDoubleLE(e, r) {
          return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, e, r);
        }
        insertDoubleLE(e, r) {
          return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, e, r);
        }
        readString(e, r) {
          let i;
          typeof e == "number" ? (re.checkLengthValue(e), i = Math.min(e, this.length - this._readOffset)) : (r = e, i = this.length - this._readOffset), typeof r != "undefined" && re.checkEncoding(r);
          let n = this._buff.slice(this._readOffset, this._readOffset + i).toString(r || this._encoding);
          return this._readOffset += i, n;
        }
        insertString(e, r, i) {
          return re.checkOffsetValue(r), this._handleString(e, true, r, i);
        }
        writeString(e, r, i) {
          return this._handleString(e, false, r, i);
        }
        readStringNT(e) {
          typeof e != "undefined" && re.checkEncoding(e);
          let r = this.length;
          for (let n = this._readOffset; n < this.length; n++)
            if (this._buff[n] === 0) {
              r = n;
              break;
            }
          let i = this._buff.slice(this._readOffset, r);
          return this._readOffset = r + 1, i.toString(e || this._encoding);
        }
        insertStringNT(e, r, i) {
          return re.checkOffsetValue(r), this.insertString(e, r, i), this.insertUInt8(0, r + e.length), this;
        }
        writeStringNT(e, r, i) {
          return this.writeString(e, r, i), this.writeUInt8(0, typeof r == "number" ? r + e.length : this.writeOffset), this;
        }
        readBuffer(e) {
          typeof e != "undefined" && re.checkLengthValue(e);
          let r = typeof e == "number" ? e : this.length, i = Math.min(this.length, this._readOffset + r), n = this._buff.slice(this._readOffset, i);
          return this._readOffset = i, n;
        }
        insertBuffer(e, r) {
          return re.checkOffsetValue(r), this._handleBuffer(e, true, r);
        }
        writeBuffer(e, r) {
          return this._handleBuffer(e, false, r);
        }
        readBufferNT() {
          let e = this.length;
          for (let i = this._readOffset; i < this.length; i++)
            if (this._buff[i] === 0) {
              e = i;
              break;
            }
          let r = this._buff.slice(this._readOffset, e);
          return this._readOffset = e + 1, r;
        }
        insertBufferNT(e, r) {
          return re.checkOffsetValue(r), this.insertBuffer(e, r), this.insertUInt8(0, r + e.length), this;
        }
        writeBufferNT(e, r) {
          return typeof r != "undefined" && re.checkOffsetValue(r), this.writeBuffer(e, r), this.writeUInt8(0, typeof r == "number" ? r + e.length : this._writeOffset), this;
        }
        clear() {
          return this._writeOffset = 0, this._readOffset = 0, this.length = 0, this;
        }
        remaining() {
          return this.length - this._readOffset;
        }
        get readOffset() {
          return this._readOffset;
        }
        set readOffset(e) {
          re.checkOffsetValue(e), re.checkTargetOffset(e, this), this._readOffset = e;
        }
        get writeOffset() {
          return this._writeOffset;
        }
        set writeOffset(e) {
          re.checkOffsetValue(e), re.checkTargetOffset(e, this), this._writeOffset = e;
        }
        get encoding() {
          return this._encoding;
        }
        set encoding(e) {
          re.checkEncoding(e), this._encoding = e;
        }
        get internalBuffer() {
          return this._buff;
        }
        toBuffer() {
          return this._buff.slice(0, this.length);
        }
        toString(e) {
          let r = typeof e == "string" ? e : this._encoding;
          return re.checkEncoding(r), this._buff.toString(r, 0, this.length);
        }
        destroy() {
          return this.clear(), this;
        }
        _handleString(e, r, i, n) {
          let s = this._writeOffset, o = this._encoding;
          typeof i == "number" ? s = i : typeof i == "string" && (re.checkEncoding(i), o = i), typeof n == "string" && (re.checkEncoding(n), o = n);
          let a = Buffer.byteLength(e, o);
          return r ? this.ensureInsertable(a, s) : this._ensureWriteable(a, s), this._buff.write(e, s, a, o), r ? this._writeOffset += a : typeof i == "number" ? this._writeOffset = Math.max(this._writeOffset, s + a) : this._writeOffset += a, this;
        }
        _handleBuffer(e, r, i) {
          let n = typeof i == "number" ? i : this._writeOffset;
          return r ? this.ensureInsertable(e.length, n) : this._ensureWriteable(e.length, n), e.copy(this._buff, n), r ? this._writeOffset += e.length : typeof i == "number" ? this._writeOffset = Math.max(this._writeOffset, n + e.length) : this._writeOffset += e.length, this;
        }
        ensureReadable(e, r) {
          let i = this._readOffset;
          if (typeof r != "undefined" && (re.checkOffsetValue(r), i = r), i < 0 || i + e > this.length)
            throw new Error(re.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
        ensureInsertable(e, r) {
          re.checkOffsetValue(r), this._ensureCapacity(this.length + e), r < this.length && this._buff.copy(this._buff, r + e, r, this._buff.length), r + e > this.length ? this.length = r + e : this.length += e;
        }
        _ensureWriteable(e, r) {
          let i = typeof r == "number" ? r : this._writeOffset;
          this._ensureCapacity(i + e), i + e > this.length && (this.length = i + e);
        }
        _ensureCapacity(e) {
          let r = this._buff.length;
          if (e > r) {
            let i = this._buff, n = r * 3 / 2 + 1;
            n < e && (n = e), this._buff = Buffer.allocUnsafe(n), i.copy(this._buff, 0, 0, r);
          }
        }
        _readNumberValue(e, r, i) {
          this.ensureReadable(r, i);
          let n = e.call(this._buff, typeof i == "number" ? i : this._readOffset);
          return typeof i == "undefined" && (this._readOffset += r), n;
        }
        _insertNumberValue(e, r, i, n) {
          return re.checkOffsetValue(n), this.ensureInsertable(r, n), e.call(this._buff, i, n), this._writeOffset += r, this;
        }
        _writeNumberValue(e, r, i, n) {
          if (typeof n == "number") {
            if (n < 0)
              throw new Error(re.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
            re.checkOffsetValue(n);
          }
          let s = typeof n == "number" ? n : this._writeOffset;
          return this._ensureWriteable(r, s), e.call(this._buff, i, s), typeof n == "number" ? this._writeOffset = Math.max(this._writeOffset, s + r) : this._writeOffset += r, this;
        }
      };
      Ss.SmartBuffer = Yr;
    });
    var Rs = x((we) => {
      "use strict";
      Object.defineProperty(we, "__esModule", { value: true });
      we.SOCKS5_NO_ACCEPTABLE_AUTH = we.SOCKS5_CUSTOM_AUTH_END = we.SOCKS5_CUSTOM_AUTH_START = we.SOCKS_INCOMING_PACKET_SIZES = we.SocksClientState = we.Socks5Response = we.Socks5HostType = we.Socks5Auth = we.Socks4Response = we.SocksCommand = we.ERRORS = we.DEFAULT_TIMEOUT = void 0;
      var Gg = 3e4;
      we.DEFAULT_TIMEOUT = Gg;
      var zg = { InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.", InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.", InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.", InvalidSocksClientOptionsDestination: "An invalid destination host was provided.", InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.", InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.", InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).", InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.", InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.", InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.", NegotiationError: "Negotiation error", SocketClosed: "Socket closed", ProxyConnectionTimedOut: "Proxy connection timed out", InternalError: "SocksClient internal error (this should not happen)", InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response", Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection", InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response", Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection", InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response", InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)", InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)", InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)", Socks5AuthenticationFailed: "Socks5 Authentication failed", InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response", InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection", InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response", Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection" };
      we.ERRORS = zg;
      var Wg = { Socks5InitialHandshakeResponse: 2, Socks5UserPassAuthenticationResponse: 2, Socks5ResponseHeader: 5, Socks5ResponseIPv4: 10, Socks5ResponseIPv6: 22, Socks5ResponseHostname: (t) => t + 7, Socks4Response: 8 };
      we.SOCKS_INCOMING_PACKET_SIZES = Wg;
      var ks;
      (function(t) {
        t[t.connect = 1] = "connect", t[t.bind = 2] = "bind", t[t.associate = 3] = "associate";
      })(ks || (ks = {}));
      we.SocksCommand = ks;
      var Cs;
      (function(t) {
        t[t.Granted = 90] = "Granted", t[t.Failed = 91] = "Failed", t[t.Rejected = 92] = "Rejected", t[t.RejectedIdent = 93] = "RejectedIdent";
      })(Cs || (Cs = {}));
      we.Socks4Response = Cs;
      var Os;
      (function(t) {
        t[t.NoAuth = 0] = "NoAuth", t[t.GSSApi = 1] = "GSSApi", t[t.UserPass = 2] = "UserPass";
      })(Os || (Os = {}));
      we.Socks5Auth = Os;
      var Yg = 128;
      we.SOCKS5_CUSTOM_AUTH_START = Yg;
      var Kg = 254;
      we.SOCKS5_CUSTOM_AUTH_END = Kg;
      var Zg = 255;
      we.SOCKS5_NO_ACCEPTABLE_AUTH = Zg;
      var Is;
      (function(t) {
        t[t.Granted = 0] = "Granted", t[t.Failure = 1] = "Failure", t[t.NotAllowed = 2] = "NotAllowed", t[t.NetworkUnreachable = 3] = "NetworkUnreachable", t[t.HostUnreachable = 4] = "HostUnreachable", t[t.ConnectionRefused = 5] = "ConnectionRefused", t[t.TTLExpired = 6] = "TTLExpired", t[t.CommandNotSupported = 7] = "CommandNotSupported", t[t.AddressNotSupported = 8] = "AddressNotSupported";
      })(Is || (Is = {}));
      we.Socks5Response = Is;
      var Ts;
      (function(t) {
        t[t.IPv4 = 1] = "IPv4", t[t.Hostname = 3] = "Hostname", t[t.IPv6 = 4] = "IPv6";
      })(Ts || (Ts = {}));
      we.Socks5HostType = Ts;
      var As;
      (function(t) {
        t[t.Created = 0] = "Created", t[t.Connecting = 1] = "Connecting", t[t.Connected = 2] = "Connected", t[t.SentInitialHandshake = 3] = "SentInitialHandshake", t[t.ReceivedInitialHandshakeResponse = 4] = "ReceivedInitialHandshakeResponse", t[t.SentAuthentication = 5] = "SentAuthentication", t[t.ReceivedAuthenticationResponse = 6] = "ReceivedAuthenticationResponse", t[t.SentFinalHandshake = 7] = "SentFinalHandshake", t[t.ReceivedFinalResponse = 8] = "ReceivedFinalResponse", t[t.BoundWaitingForConnection = 9] = "BoundWaitingForConnection", t[t.Established = 10] = "Established", t[t.Disconnected = 11] = "Disconnected", t[t.Error = 99] = "Error";
      })(As || (As = {}));
      we.SocksClientState = As;
    });
    var Ls = x((pr) => {
      "use strict";
      Object.defineProperty(pr, "__esModule", { value: true });
      pr.shuffleArray = pr.SocksClientError = void 0;
      var Bs = class extends Error {
        constructor(e, r) {
          super(e), this.options = r;
        }
      };
      pr.SocksClientError = Bs;
      function Xg(t) {
        for (let e = t.length - 1; e > 0; e--) {
          let r = Math.floor(Math.random() * (e + 1));
          [t[e], t[r]] = [t[r], t[e]];
        }
      }
      pr.shuffleArray = Xg;
    });
    var Iu = x((dr) => {
      "use strict";
      Object.defineProperty(dr, "__esModule", { value: true });
      dr.validateSocksClientChainOptions = dr.validateSocksClientOptions = void 0;
      var Ge = Ls(), Ne = Rs(), Qg = require("stream");
      function Jg(t, e = ["connect", "bind", "associate"]) {
        if (!Ne.SocksCommand[t.command])
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksCommand, t);
        if (e.indexOf(t.command) === -1)
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksCommandForOperation, t);
        if (!ku(t.destination))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsDestination, t);
        if (!Cu(t.proxy))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsProxy, t);
        if (Su(t.proxy, t), t.timeout && !Ou(t.timeout))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsTimeout, t);
        if (t.existing_socket && !(t.existing_socket instanceof Qg.Duplex))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsExistingSocket, t);
      }
      dr.validateSocksClientOptions = Jg;
      function e0(t) {
        if (t.command !== "connect")
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksCommandChain, t);
        if (!ku(t.destination))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsDestination, t);
        if (!(t.proxies && Array.isArray(t.proxies) && t.proxies.length >= 2))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsProxiesLength, t);
        if (t.proxies.forEach((e) => {
          if (!Cu(e))
            throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsProxy, t);
          Su(e, t);
        }), t.timeout && !Ou(t.timeout))
          throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsTimeout, t);
      }
      dr.validateSocksClientChainOptions = e0;
      function Su(t, e) {
        if (t.custom_auth_method !== void 0) {
          if (t.custom_auth_method < Ne.SOCKS5_CUSTOM_AUTH_START || t.custom_auth_method > Ne.SOCKS5_CUSTOM_AUTH_END)
            throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsCustomAuthRange, e);
          if (t.custom_auth_request_handler === void 0 || typeof t.custom_auth_request_handler != "function")
            throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, e);
          if (t.custom_auth_response_size === void 0)
            throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, e);
          if (t.custom_auth_response_handler === void 0 || typeof t.custom_auth_response_handler != "function")
            throw new Ge.SocksClientError(Ne.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, e);
        }
      }
      function ku(t) {
        return t && typeof t.host == "string" && typeof t.port == "number" && t.port >= 0 && t.port <= 65535;
      }
      function Cu(t) {
        return t && (typeof t.host == "string" || typeof t.ipaddress == "string") && typeof t.port == "number" && t.port >= 0 && t.port <= 65535 && (t.type === 4 || t.type === 5);
      }
      function Ou(t) {
        return typeof t == "number" && t > 0;
      }
    });
    var Tu = x((Bi) => {
      "use strict";
      Object.defineProperty(Bi, "__esModule", { value: true });
      Bi.ReceiveBuffer = void 0;
      var Ns = class {
        constructor(e = 4096) {
          this.buffer = Buffer.allocUnsafe(e), this.offset = 0, this.originalSize = e;
        }
        get length() {
          return this.offset;
        }
        append(e) {
          if (!Buffer.isBuffer(e))
            throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
          if (this.offset + e.length >= this.buffer.length) {
            let r = this.buffer;
            this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + e.length)), r.copy(this.buffer);
          }
          return e.copy(this.buffer, this.offset), this.offset += e.length;
        }
        peek(e) {
          if (e > this.offset)
            throw new Error("Attempted to read beyond the bounds of the managed internal data.");
          return this.buffer.slice(0, e);
        }
        get(e) {
          if (e > this.offset)
            throw new Error("Attempted to read beyond the bounds of the managed internal data.");
          let r = Buffer.allocUnsafe(e);
          return this.buffer.slice(0, e).copy(r), this.buffer.copyWithin(0, e, e + this.offset - e), this.offset -= e, r;
        }
      };
      Bi.ReceiveBuffer = Ns;
    });
    var Au = x((Et) => {
      "use strict";
      var mr = Et && Et.__awaiter || function(t, e, r, i) {
        function n(s) {
          return s instanceof r ? s : new r(function(o) {
            o(s);
          });
        }
        return new (r || (r = Promise))(function(s, o) {
          function a(u) {
            try {
              c(i.next(u));
            } catch (f) {
              o(f);
            }
          }
          function l(u) {
            try {
              c(i.throw(u));
            } catch (f) {
              o(f);
            }
          }
          function c(u) {
            u.done ? s(u.value) : n(u.value).then(a, l);
          }
          c((i = i.apply(t, e || [])).next());
        });
      };
      Object.defineProperty(Et, "__esModule", { value: true });
      Et.SocksClientError = Et.SocksClient = void 0;
      var t0 = require("events"), gr = require("net"), Ke = vu(), ze = Eu(), k = Rs(), Ps = Iu(), r0 = Tu(), Fs = Ls();
      Object.defineProperty(Et, "SocksClientError", { enumerable: true, get: function() {
        return Fs.SocksClientError;
      } });
      var vr = class extends t0.EventEmitter {
        constructor(e) {
          super(), this.options = Object.assign({}, e), (0, Ps.validateSocksClientOptions)(e), this.setState(k.SocksClientState.Created);
        }
        static createConnection(e, r) {
          return new Promise((i, n) => {
            try {
              (0, Ps.validateSocksClientOptions)(e, ["connect"]);
            } catch (o) {
              return typeof r == "function" ? (r(o), i(o)) : n(o);
            }
            let s = new vr(e);
            s.connect(e.existing_socket), s.once("established", (o) => {
              s.removeAllListeners(), typeof r == "function" && r(null, o), i(o);
            }), s.once("error", (o) => {
              s.removeAllListeners(), typeof r == "function" ? (r(o), i(o)) : n(o);
            });
          });
        }
        static createConnectionChain(e, r) {
          return new Promise((i, n) => mr(this, void 0, void 0, function* () {
            try {
              (0, Ps.validateSocksClientChainOptions)(e);
            } catch (o) {
              return typeof r == "function" ? (r(o), i(o)) : n(o);
            }
            let s;
            e.randomizeChain && (0, Fs.shuffleArray)(e.proxies);
            try {
              for (let o = 0; o < e.proxies.length; o++) {
                let a = e.proxies[o], l = o === e.proxies.length - 1 ? e.destination : { host: e.proxies[o + 1].host || e.proxies[o + 1].ipaddress, port: e.proxies[o + 1].port }, c = yield vr.createConnection({ command: "connect", proxy: a, destination: l });
                s || (s = c.socket);
              }
              typeof r == "function" ? (r(null, { socket: s }), i({ socket: s })) : i({ socket: s });
            } catch (o) {
              typeof r == "function" ? (r(o), i(o)) : n(o);
            }
          }));
        }
        static createUDPFrame(e) {
          let r = new ze.SmartBuffer();
          return r.writeUInt16BE(0), r.writeUInt8(e.frameNumber || 0), gr.isIPv4(e.remoteHost.host) ? (r.writeUInt8(k.Socks5HostType.IPv4), r.writeUInt32BE(Ke.toLong(e.remoteHost.host))) : gr.isIPv6(e.remoteHost.host) ? (r.writeUInt8(k.Socks5HostType.IPv6), r.writeBuffer(Ke.toBuffer(e.remoteHost.host))) : (r.writeUInt8(k.Socks5HostType.Hostname), r.writeUInt8(Buffer.byteLength(e.remoteHost.host)), r.writeString(e.remoteHost.host)), r.writeUInt16BE(e.remoteHost.port), r.writeBuffer(e.data), r.toBuffer();
        }
        static parseUDPFrame(e) {
          let r = ze.SmartBuffer.fromBuffer(e);
          r.readOffset = 2;
          let i = r.readUInt8(), n = r.readUInt8(), s;
          n === k.Socks5HostType.IPv4 ? s = Ke.fromLong(r.readUInt32BE()) : n === k.Socks5HostType.IPv6 ? s = Ke.toString(r.readBuffer(16)) : s = r.readString(r.readUInt8());
          let o = r.readUInt16BE();
          return { frameNumber: i, remoteHost: { host: s, port: o }, data: r.readBuffer() };
        }
        setState(e) {
          this.state !== k.SocksClientState.Error && (this.state = e);
        }
        connect(e) {
          this.onDataReceived = (i) => this.onDataReceivedHandler(i), this.onClose = () => this.onCloseHandler(), this.onError = (i) => this.onErrorHandler(i), this.onConnect = () => this.onConnectHandler();
          let r = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || k.DEFAULT_TIMEOUT);
          r.unref && typeof r.unref == "function" && r.unref(), e ? this.socket = e : this.socket = new gr.Socket(), this.socket.once("close", this.onClose), this.socket.once("error", this.onError), this.socket.once("connect", this.onConnect), this.socket.on("data", this.onDataReceived), this.setState(k.SocksClientState.Connecting), this.receiveBuffer = new r0.ReceiveBuffer(), e ? this.socket.emit("connect") : (this.socket.connect(this.getSocketOptions()), this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null && this.socket.setNoDelay(!!this.options.set_tcp_nodelay)), this.prependOnceListener("established", (i) => {
            setImmediate(() => {
              if (this.receiveBuffer.length > 0) {
                let n = this.receiveBuffer.get(this.receiveBuffer.length);
                i.socket.emit("data", n);
              }
              i.socket.resume();
            });
          });
        }
        getSocketOptions() {
          return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
        }
        onEstablishedTimeout() {
          this.state !== k.SocksClientState.Established && this.state !== k.SocksClientState.BoundWaitingForConnection && this.closeSocket(k.ERRORS.ProxyConnectionTimedOut);
        }
        onConnectHandler() {
          this.setState(k.SocksClientState.Connected), this.options.proxy.type === 4 ? this.sendSocks4InitialHandshake() : this.sendSocks5InitialHandshake(), this.setState(k.SocksClientState.SentInitialHandshake);
        }
        onDataReceivedHandler(e) {
          this.receiveBuffer.append(e), this.processData();
        }
        processData() {
          for (; this.state !== k.SocksClientState.Established && this.state !== k.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize; )
            if (this.state === k.SocksClientState.SentInitialHandshake)
              this.options.proxy.type === 4 ? this.handleSocks4FinalHandshakeResponse() : this.handleInitialSocks5HandshakeResponse();
            else if (this.state === k.SocksClientState.SentAuthentication)
              this.handleInitialSocks5AuthenticationHandshakeResponse();
            else if (this.state === k.SocksClientState.SentFinalHandshake)
              this.handleSocks5FinalHandshakeResponse();
            else if (this.state === k.SocksClientState.BoundWaitingForConnection)
              this.options.proxy.type === 4 ? this.handleSocks4IncomingConnectionResponse() : this.handleSocks5IncomingConnectionResponse();
            else {
              this.closeSocket(k.ERRORS.InternalError);
              break;
            }
        }
        onCloseHandler() {
          this.closeSocket(k.ERRORS.SocketClosed);
        }
        onErrorHandler(e) {
          this.closeSocket(e.message);
        }
        removeInternalSocketHandlers() {
          this.socket.pause(), this.socket.removeListener("data", this.onDataReceived), this.socket.removeListener("close", this.onClose), this.socket.removeListener("error", this.onError), this.socket.removeListener("connect", this.onConnect);
        }
        closeSocket(e) {
          this.state !== k.SocksClientState.Error && (this.setState(k.SocksClientState.Error), this.socket.destroy(), this.removeInternalSocketHandlers(), this.emit("error", new Fs.SocksClientError(e, this.options)));
        }
        sendSocks4InitialHandshake() {
          let e = this.options.proxy.userId || "", r = new ze.SmartBuffer();
          r.writeUInt8(4), r.writeUInt8(k.SocksCommand[this.options.command]), r.writeUInt16BE(this.options.destination.port), gr.isIPv4(this.options.destination.host) ? (r.writeBuffer(Ke.toBuffer(this.options.destination.host)), r.writeStringNT(e)) : (r.writeUInt8(0), r.writeUInt8(0), r.writeUInt8(0), r.writeUInt8(1), r.writeStringNT(e), r.writeStringNT(this.options.destination.host)), this.nextRequiredPacketBufferSize = k.SOCKS_INCOMING_PACKET_SIZES.Socks4Response, this.socket.write(r.toBuffer());
        }
        handleSocks4FinalHandshakeResponse() {
          let e = this.receiveBuffer.get(8);
          if (e[1] !== k.Socks4Response.Granted)
            this.closeSocket(`${k.ERRORS.Socks4ProxyRejectedConnection} - (${k.Socks4Response[e[1]]})`);
          else if (k.SocksCommand[this.options.command] === k.SocksCommand.bind) {
            let r = ze.SmartBuffer.fromBuffer(e);
            r.readOffset = 2;
            let i = { port: r.readUInt16BE(), host: Ke.fromLong(r.readUInt32BE()) };
            i.host === "0.0.0.0" && (i.host = this.options.proxy.ipaddress), this.setState(k.SocksClientState.BoundWaitingForConnection), this.emit("bound", { remoteHost: i, socket: this.socket });
          } else
            this.setState(k.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { socket: this.socket });
        }
        handleSocks4IncomingConnectionResponse() {
          let e = this.receiveBuffer.get(8);
          if (e[1] !== k.Socks4Response.Granted)
            this.closeSocket(`${k.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${k.Socks4Response[e[1]]})`);
          else {
            let r = ze.SmartBuffer.fromBuffer(e);
            r.readOffset = 2;
            let i = { port: r.readUInt16BE(), host: Ke.fromLong(r.readUInt32BE()) };
            this.setState(k.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: i, socket: this.socket });
          }
        }
        sendSocks5InitialHandshake() {
          let e = new ze.SmartBuffer(), r = [k.Socks5Auth.NoAuth];
          (this.options.proxy.userId || this.options.proxy.password) && r.push(k.Socks5Auth.UserPass), this.options.proxy.custom_auth_method !== void 0 && r.push(this.options.proxy.custom_auth_method), e.writeUInt8(5), e.writeUInt8(r.length);
          for (let i of r)
            e.writeUInt8(i);
          this.nextRequiredPacketBufferSize = k.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse, this.socket.write(e.toBuffer()), this.setState(k.SocksClientState.SentInitialHandshake);
        }
        handleInitialSocks5HandshakeResponse() {
          let e = this.receiveBuffer.get(2);
          e[0] !== 5 ? this.closeSocket(k.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion) : e[1] === k.SOCKS5_NO_ACCEPTABLE_AUTH ? this.closeSocket(k.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType) : e[1] === k.Socks5Auth.NoAuth ? (this.socks5ChosenAuthType = k.Socks5Auth.NoAuth, this.sendSocks5CommandRequest()) : e[1] === k.Socks5Auth.UserPass ? (this.socks5ChosenAuthType = k.Socks5Auth.UserPass, this.sendSocks5UserPassAuthentication()) : e[1] === this.options.proxy.custom_auth_method ? (this.socks5ChosenAuthType = this.options.proxy.custom_auth_method, this.sendSocks5CustomAuthentication()) : this.closeSocket(k.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
        }
        sendSocks5UserPassAuthentication() {
          let e = this.options.proxy.userId || "", r = this.options.proxy.password || "", i = new ze.SmartBuffer();
          i.writeUInt8(1), i.writeUInt8(Buffer.byteLength(e)), i.writeString(e), i.writeUInt8(Buffer.byteLength(r)), i.writeString(r), this.nextRequiredPacketBufferSize = k.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse, this.socket.write(i.toBuffer()), this.setState(k.SocksClientState.SentAuthentication);
        }
        sendSocks5CustomAuthentication() {
          return mr(this, void 0, void 0, function* () {
            this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size, this.socket.write(yield this.options.proxy.custom_auth_request_handler()), this.setState(k.SocksClientState.SentAuthentication);
          });
        }
        handleSocks5CustomAuthHandshakeResponse(e) {
          return mr(this, void 0, void 0, function* () {
            return yield this.options.proxy.custom_auth_response_handler(e);
          });
        }
        handleSocks5AuthenticationNoAuthHandshakeResponse(e) {
          return mr(this, void 0, void 0, function* () {
            return e[1] === 0;
          });
        }
        handleSocks5AuthenticationUserPassHandshakeResponse(e) {
          return mr(this, void 0, void 0, function* () {
            return e[1] === 0;
          });
        }
        handleInitialSocks5AuthenticationHandshakeResponse() {
          return mr(this, void 0, void 0, function* () {
            this.setState(k.SocksClientState.ReceivedAuthenticationResponse);
            let e = false;
            this.socks5ChosenAuthType === k.Socks5Auth.NoAuth ? e = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2)) : this.socks5ChosenAuthType === k.Socks5Auth.UserPass ? e = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2)) : this.socks5ChosenAuthType === this.options.proxy.custom_auth_method && (e = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size))), e ? this.sendSocks5CommandRequest() : this.closeSocket(k.ERRORS.Socks5AuthenticationFailed);
          });
        }
        sendSocks5CommandRequest() {
          let e = new ze.SmartBuffer();
          e.writeUInt8(5), e.writeUInt8(k.SocksCommand[this.options.command]), e.writeUInt8(0), gr.isIPv4(this.options.destination.host) ? (e.writeUInt8(k.Socks5HostType.IPv4), e.writeBuffer(Ke.toBuffer(this.options.destination.host))) : gr.isIPv6(this.options.destination.host) ? (e.writeUInt8(k.Socks5HostType.IPv6), e.writeBuffer(Ke.toBuffer(this.options.destination.host))) : (e.writeUInt8(k.Socks5HostType.Hostname), e.writeUInt8(this.options.destination.host.length), e.writeString(this.options.destination.host)), e.writeUInt16BE(this.options.destination.port), this.nextRequiredPacketBufferSize = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader, this.socket.write(e.toBuffer()), this.setState(k.SocksClientState.SentFinalHandshake);
        }
        handleSocks5FinalHandshakeResponse() {
          let e = this.receiveBuffer.peek(5);
          if (e[0] !== 5 || e[1] !== k.Socks5Response.Granted)
            this.closeSocket(`${k.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${k.Socks5Response[e[1]]}`);
          else {
            let r = e[3], i, n;
            if (r === k.Socks5HostType.IPv4) {
              let s = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
              if (this.receiveBuffer.length < s) {
                this.nextRequiredPacketBufferSize = s;
                return;
              }
              n = ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)), i = { host: Ke.fromLong(n.readUInt32BE()), port: n.readUInt16BE() }, i.host === "0.0.0.0" && (i.host = this.options.proxy.ipaddress);
            } else if (r === k.Socks5HostType.Hostname) {
              let s = e[4], o = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(s);
              if (this.receiveBuffer.length < o) {
                this.nextRequiredPacketBufferSize = o;
                return;
              }
              n = ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(o).slice(5)), i = { host: n.readString(s), port: n.readUInt16BE() };
            } else if (r === k.Socks5HostType.IPv6) {
              let s = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
              if (this.receiveBuffer.length < s) {
                this.nextRequiredPacketBufferSize = s;
                return;
              }
              n = ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)), i = { host: Ke.toString(n.readBuffer(16)), port: n.readUInt16BE() };
            }
            this.setState(k.SocksClientState.ReceivedFinalResponse), k.SocksCommand[this.options.command] === k.SocksCommand.connect ? (this.setState(k.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: i, socket: this.socket })) : k.SocksCommand[this.options.command] === k.SocksCommand.bind ? (this.setState(k.SocksClientState.BoundWaitingForConnection), this.nextRequiredPacketBufferSize = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader, this.emit("bound", { remoteHost: i, socket: this.socket })) : k.SocksCommand[this.options.command] === k.SocksCommand.associate && (this.setState(k.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: i, socket: this.socket }));
          }
        }
        handleSocks5IncomingConnectionResponse() {
          let e = this.receiveBuffer.peek(5);
          if (e[0] !== 5 || e[1] !== k.Socks5Response.Granted)
            this.closeSocket(`${k.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${k.Socks5Response[e[1]]}`);
          else {
            let r = e[3], i, n;
            if (r === k.Socks5HostType.IPv4) {
              let s = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
              if (this.receiveBuffer.length < s) {
                this.nextRequiredPacketBufferSize = s;
                return;
              }
              n = ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)), i = { host: Ke.fromLong(n.readUInt32BE()), port: n.readUInt16BE() }, i.host === "0.0.0.0" && (i.host = this.options.proxy.ipaddress);
            } else if (r === k.Socks5HostType.Hostname) {
              let s = e[4], o = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(s);
              if (this.receiveBuffer.length < o) {
                this.nextRequiredPacketBufferSize = o;
                return;
              }
              n = ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(o).slice(5)), i = { host: n.readString(s), port: n.readUInt16BE() };
            } else if (r === k.Socks5HostType.IPv6) {
              let s = k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
              if (this.receiveBuffer.length < s) {
                this.nextRequiredPacketBufferSize = s;
                return;
              }
              n = ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)), i = { host: Ke.toString(n.readBuffer(16)), port: n.readUInt16BE() };
            }
            this.setState(k.SocksClientState.Established), this.removeInternalSocketHandlers(), this.emit("established", { remoteHost: i, socket: this.socket });
          }
        }
        get socksClientOptions() {
          return Object.assign({}, this.options);
        }
      };
      Et.SocksClient = vr;
    });
    var Ru = x((jt) => {
      "use strict";
      var i0 = jt && jt.__createBinding || (Object.create ? function(t, e, r, i) {
        i === void 0 && (i = r);
        var n = Object.getOwnPropertyDescriptor(e, r);
        (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) && (n = { enumerable: true, get: function() {
          return e[r];
        } }), Object.defineProperty(t, i, n);
      } : function(t, e, r, i) {
        i === void 0 && (i = r), t[i] = e[r];
      }), n0 = jt && jt.__exportStar || function(t, e) {
        for (var r in t)
          r !== "default" && !Object.prototype.hasOwnProperty.call(e, r) && i0(e, t, r);
      };
      Object.defineProperty(jt, "__esModule", { value: true });
      n0(Au(), jt);
    });
    var Bu = x((qt) => {
      "use strict";
      var s0 = qt && qt.__awaiter || function(t, e, r, i) {
        function n(s) {
          return s instanceof r ? s : new r(function(o) {
            o(s);
          });
        }
        return new (r || (r = Promise))(function(s, o) {
          function a(u) {
            try {
              c(i.next(u));
            } catch (f) {
              o(f);
            }
          }
          function l(u) {
            try {
              c(i.throw(u));
            } catch (f) {
              o(f);
            }
          }
          function c(u) {
            u.done ? s(u.value) : n(u.value).then(a, l);
          }
          c((i = i.apply(t, e || [])).next());
        });
      }, Li = qt && qt.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      };
      Object.defineProperty(qt, "__esModule", { value: true });
      var o0 = Li(require("dns")), a0 = Li(require("tls")), l0 = Li(require("url")), c0 = Li(tr()), u0 = an(), f0 = Ru(), Ms = c0.default("socks-proxy-agent");
      function h0(t) {
        return new Promise((e, r) => {
          o0.default.lookup(t, (i, n) => {
            i ? r(i) : e(n);
          });
        });
      }
      function p0(t) {
        let e = 0, r = false, i = 5, n = t.hostname || t.host;
        if (!n)
          throw new TypeError('No "host"');
        if (typeof t.port == "number" ? e = t.port : typeof t.port == "string" && (e = parseInt(t.port, 10)), e || (e = 1080), t.protocol)
          switch (t.protocol.replace(":", "")) {
            case "socks4":
              r = true;
            case "socks4a":
              i = 4;
              break;
            case "socks5":
              r = true;
            case "socks":
            case "socks5h":
              i = 5;
              break;
            default:
              throw new TypeError(`A "socks" protocol must be specified! Got: ${t.protocol}`);
          }
        if (typeof t.type != "undefined")
          if (t.type === 4 || t.type === 5)
            i = t.type;
          else
            throw new TypeError(`"type" must be 4 or 5, got: ${t.type}`);
        let s = { host: n, port: e, type: i }, o = t.userId || t.username, a = t.password;
        if (t.auth) {
          let l = t.auth.split(":");
          o = l[0], a = l[1];
        }
        return o && Object.defineProperty(s, "userId", { value: o, enumerable: false }), a && Object.defineProperty(s, "password", { value: a, enumerable: false }), { lookup: r, proxy: s };
      }
      var Us = class extends u0.Agent {
        constructor(e) {
          let r;
          if (typeof e == "string" ? r = l0.default.parse(e) : r = e, !r)
            throw new TypeError("a SOCKS proxy server `host` and `port` must be specified!");
          super(r);
          let i = p0(r);
          this.lookup = i.lookup, this.proxy = i.proxy, this.tlsConnectionOptions = r.tls || {};
        }
        callback(e, r) {
          return s0(this, void 0, void 0, function* () {
            let { lookup: i, proxy: n } = this, { host: s, port: o, timeout: a } = r;
            if (!s)
              throw new Error("No `host` defined!");
            i && (s = yield h0(s));
            let l = { proxy: n, destination: { host: s, port: o }, command: "connect", timeout: a };
            Ms("Creating socks proxy connection: %o", l);
            let { socket: c } = yield f0.SocksClient.createConnection(l);
            if (Ms("Successfully created socks proxy connection"), r.secureEndpoint) {
              Ms("Upgrading socket connection to TLS");
              let u = r.servername || r.host;
              return a0.default.connect(Object.assign(Object.assign(Object.assign({}, d0(r, "host", "hostname", "path", "port")), { socket: c, servername: u }), this.tlsConnectionOptions));
            }
            return c;
          });
        }
      };
      qt.default = Us;
      function d0(t, ...e) {
        let r = {}, i;
        for (i in t)
          e.includes(i) || (r[i] = t[i]);
        return r;
      }
    });
    var Nu = x((qs, Lu) => {
      "use strict";
      var m0 = qs && qs.__importDefault || function(t) {
        return t && t.__esModule ? t : { default: t };
      }, Ds = m0(Bu());
      function js(t) {
        return new Ds.default(t);
      }
      (function(t) {
        t.SocksProxyAgent = Ds.default, t.prototype = Ds.default.prototype;
      })(js || (js = {}));
      Lu.exports = js;
    });
    var Fu = x((Kx, Pu) => {
      "use strict";
      var g0 = /[|\\{}()[\]^$+*?.-]/g;
      Pu.exports = (t) => {
        if (typeof t != "string")
          throw new TypeError("Expected a string");
        return t.replace(g0, "\\$&");
      };
    });
    var ju = x((Zx, Du) => {
      "use strict";
      var v0 = Fu(), _0 = typeof process == "object" && process && typeof process.cwd == "function" ? process.cwd() : ".", Uu = [].concat(require("module").builtinModules, "bootstrap_node", "node").map((t) => new RegExp(`(?:\\((?:node:)?${t}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${t}(?:\\.js)?:\\d+:\\d+$)`));
      Uu.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
      var Kr = class {
        constructor(e) {
          e = __spreadValues({ ignoredPackages: [] }, e), "internals" in e || (e.internals = Kr.nodeInternals()), "cwd" in e || (e.cwd = _0), this._cwd = e.cwd.replace(/\\/g, "/"), this._internals = [].concat(e.internals, x0(e.ignoredPackages)), this._wrapCallSite = e.wrapCallSite || false;
        }
        static nodeInternals() {
          return [...Uu];
        }
        clean(e, r = 0) {
          r = " ".repeat(r), Array.isArray(e) || (e = e.split(`
`)), !/^\s*at /.test(e[0]) && /^\s*at /.test(e[1]) && (e = e.slice(1));
          let i = false, n = null, s = [];
          return e.forEach((o) => {
            if (o = o.replace(/\\/g, "/"), this._internals.some((l) => l.test(o)))
              return;
            let a = /^\s*at /.test(o);
            i ? o = o.trimEnd().replace(/^(\s+)at /, "$1") : (o = o.trim(), a && (o = o.slice(3))), o = o.replace(`${this._cwd}/`, ""), o && (a ? (n && (s.push(n), n = null), s.push(o)) : (i = true, n = o));
          }), s.map((o) => `${r}${o}
`).join("");
        }
        captureString(e, r = this.captureString) {
          typeof e == "function" && (r = e, e = 1 / 0);
          let { stackTraceLimit: i } = Error;
          e && (Error.stackTraceLimit = e);
          let n = {};
          Error.captureStackTrace(n, r);
          let { stack: s } = n;
          return Error.stackTraceLimit = i, this.clean(s);
        }
        capture(e, r = this.capture) {
          typeof e == "function" && (r = e, e = 1 / 0);
          let { prepareStackTrace: i, stackTraceLimit: n } = Error;
          Error.prepareStackTrace = (a, l) => this._wrapCallSite ? l.map(this._wrapCallSite) : l, e && (Error.stackTraceLimit = e);
          let s = {};
          Error.captureStackTrace(s, r);
          let { stack: o } = s;
          return Object.assign(Error, { prepareStackTrace: i, stackTraceLimit: n }), o;
        }
        at(e = this.at) {
          let [r] = this.capture(1, e);
          if (!r)
            return {};
          let i = { line: r.getLineNumber(), column: r.getColumnNumber() };
          Mu(i, r.getFileName(), this._cwd), r.isConstructor() && (i.constructor = true), r.isEval() && (i.evalOrigin = r.getEvalOrigin()), r.isNative() && (i.native = true);
          let n;
          try {
            n = r.getTypeName();
          } catch (e2) {
          }
          n && n !== "Object" && n !== "[object Object]" && (i.type = n);
          let s = r.getFunctionName();
          s && (i.function = s);
          let o = r.getMethodName();
          return o && s !== o && (i.method = o), i;
        }
        parseLine(e) {
          let r = e && e.match(y0);
          if (!r)
            return null;
          let i = r[1] === "new", n = r[2], s = r[3], o = r[4], a = Number(r[5]), l = Number(r[6]), c = r[7], u = r[8], f = r[9], h = r[10] === "native", p = r[11] === ")", d, m = {};
          if (u && (m.line = Number(u)), f && (m.column = Number(f)), p && c) {
            let g = 0;
            for (let y = c.length - 1; y > 0; y--)
              if (c.charAt(y) === ")")
                g++;
              else if (c.charAt(y) === "(" && c.charAt(y - 1) === " " && (g--, g === -1 && c.charAt(y - 1) === " ")) {
                let I = c.slice(0, y - 1);
                c = c.slice(y + 1), n += ` (${I}`;
                break;
              }
          }
          if (n) {
            let g = n.match(b0);
            g && (n = g[1], d = g[2]);
          }
          return Mu(m, c, this._cwd), i && (m.constructor = true), s && (m.evalOrigin = s, m.evalLine = a, m.evalColumn = l, m.evalFile = o && o.replace(/\\/g, "/")), h && (m.native = true), n && (m.function = n), d && n !== d && (m.method = d), m;
        }
      };
      function Mu(t, e, r) {
        e && (e = e.replace(/\\/g, "/"), e.startsWith(`${r}/`) && (e = e.slice(r.length + 1)), t.file = e);
      }
      function x0(t) {
        if (t.length === 0)
          return [];
        let e = t.map((r) => v0(r));
        return new RegExp(`[/\\\\]node_modules[/\\\\](?:${e.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
      }
      var y0 = new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"), b0 = /^(.*?) \[as (.*?)\]$/;
      Du.exports = Kr;
    });
    var $u = x((Xx, Vu) => {
      "use strict";
      var { Duplex: w0 } = require("stream");
      function qu(t) {
        t.emit("close");
      }
      function E0() {
        !this.destroyed && this._writableState.finished && this.destroy();
      }
      function Hu(t) {
        this.removeListener("error", Hu), this.destroy(), this.listenerCount("error") === 0 && this.emit("error", t);
      }
      function S0(t, e) {
        let r = true, i = new w0(__spreadProps(__spreadValues({}, e), { autoDestroy: false, emitClose: false, objectMode: false, writableObjectMode: false }));
        return t.on("message", function(s, o) {
          let a = !o && i._readableState.objectMode ? s.toString() : s;
          i.push(a) || t.pause();
        }), t.once("error", function(s) {
          i.destroyed || (r = false, i.destroy(s));
        }), t.once("close", function() {
          i.destroyed || i.push(null);
        }), i._destroy = function(n, s) {
          if (t.readyState === t.CLOSED) {
            s(n), process.nextTick(qu, i);
            return;
          }
          let o = false;
          t.once("error", function(l) {
            o = true, s(l);
          }), t.once("close", function() {
            o || s(n), process.nextTick(qu, i);
          }), r && t.terminate();
        }, i._final = function(n) {
          if (t.readyState === t.CONNECTING) {
            t.once("open", function() {
              i._final(n);
            });
            return;
          }
          t._socket !== null && (t._socket._writableState.finished ? (n(), i._readableState.endEmitted && i.destroy()) : (t._socket.once("finish", function() {
            n();
          }), t.close()));
        }, i._read = function() {
          t.isPaused && t.resume();
        }, i._write = function(n, s, o) {
          if (t.readyState === t.CONNECTING) {
            t.once("open", function() {
              i._write(n, s, o);
            });
            return;
          }
          t.send(n, o);
        }, i.on("end", E0), i.on("error", Hu), i;
      }
      Vu.exports = S0;
    });
    var St = x((Qx, Gu) => {
      "use strict";
      Gu.exports = { BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"], EMPTY_BUFFER: Buffer.alloc(0), GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", kForOnEventAttribute: Symbol("kIsForOnEventAttribute"), kListener: Symbol("kListener"), kStatusCode: Symbol("status-code"), kWebSocket: Symbol("websocket"), NOOP: () => {
      } };
    });
    var Zr = x((Jx, Hs) => {
      "use strict";
      var { EMPTY_BUFFER: k0 } = St();
      function zu(t, e) {
        if (t.length === 0)
          return k0;
        if (t.length === 1)
          return t[0];
        let r = Buffer.allocUnsafe(e), i = 0;
        for (let n = 0; n < t.length; n++) {
          let s = t[n];
          r.set(s, i), i += s.length;
        }
        return i < e ? r.slice(0, i) : r;
      }
      function Wu(t, e, r, i, n) {
        for (let s = 0; s < n; s++)
          r[i + s] = t[s] ^ e[s & 3];
      }
      function Yu(t, e) {
        for (let r = 0; r < t.length; r++)
          t[r] ^= e[r & 3];
      }
      function Ku(t) {
        return t.byteLength === t.buffer.byteLength ? t.buffer : t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
      }
      function Ni(t) {
        if (Ni.readOnly = true, Buffer.isBuffer(t))
          return t;
        let e;
        return t instanceof ArrayBuffer ? e = Buffer.from(t) : ArrayBuffer.isView(t) ? e = Buffer.from(t.buffer, t.byteOffset, t.byteLength) : (e = Buffer.from(t), Ni.readOnly = false), e;
      }
      try {
        let t = require("bufferutil");
        Hs.exports = { concat: zu, mask(e, r, i, n, s) {
          s < 48 ? Wu(e, r, i, n, s) : t.mask(e, r, i, n, s);
        }, toArrayBuffer: Ku, toBuffer: Ni, unmask(e, r) {
          e.length < 32 ? Yu(e, r) : t.unmask(e, r);
        } };
      } catch (e) {
        Hs.exports = { concat: zu, mask: Wu, toArrayBuffer: Ku, toBuffer: Ni, unmask: Yu };
      }
    });
    var Qu = x((ey, Xu) => {
      "use strict";
      var Zu = Symbol("kDone"), Vs = Symbol("kRun"), $s = class {
        constructor(e) {
          this[Zu] = () => {
            this.pending--, this[Vs]();
          }, this.concurrency = e || 1 / 0, this.jobs = [], this.pending = 0;
        }
        add(e) {
          this.jobs.push(e), this[Vs]();
        }
        [Vs]() {
          if (this.pending !== this.concurrency && this.jobs.length) {
            let e = this.jobs.shift();
            this.pending++, e(this[Zu]);
          }
        }
      };
      Xu.exports = $s;
    });
    var Jr = x((ty, rf) => {
      "use strict";
      var Xr = require("zlib"), Ju = Zr(), C0 = Qu(), { kStatusCode: ef } = St(), O0 = Buffer.from([0, 0, 255, 255]), Mi = Symbol("permessage-deflate"), pt = Symbol("total-length"), Qr = Symbol("callback"), kt = Symbol("buffers"), Fi = Symbol("error"), Pi, Gs = class {
        constructor(e, r, i) {
          if (this._maxPayload = i | 0, this._options = e || {}, this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024, this._isServer = !!r, this._deflate = null, this._inflate = null, this.params = null, !Pi) {
            let n = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
            Pi = new C0(n);
          }
        }
        static get extensionName() {
          return "permessage-deflate";
        }
        offer() {
          let e = {};
          return this._options.serverNoContextTakeover && (e.server_no_context_takeover = true), this._options.clientNoContextTakeover && (e.client_no_context_takeover = true), this._options.serverMaxWindowBits && (e.server_max_window_bits = this._options.serverMaxWindowBits), this._options.clientMaxWindowBits ? e.client_max_window_bits = this._options.clientMaxWindowBits : this._options.clientMaxWindowBits == null && (e.client_max_window_bits = true), e;
        }
        accept(e) {
          return e = this.normalizeParams(e), this.params = this._isServer ? this.acceptAsServer(e) : this.acceptAsClient(e), this.params;
        }
        cleanup() {
          if (this._inflate && (this._inflate.close(), this._inflate = null), this._deflate) {
            let e = this._deflate[Qr];
            this._deflate.close(), this._deflate = null, e && e(new Error("The deflate stream was closed while data was being processed"));
          }
        }
        acceptAsServer(e) {
          let r = this._options, i = e.find((n) => !(r.serverNoContextTakeover === false && n.server_no_context_takeover || n.server_max_window_bits && (r.serverMaxWindowBits === false || typeof r.serverMaxWindowBits == "number" && r.serverMaxWindowBits > n.server_max_window_bits) || typeof r.clientMaxWindowBits == "number" && !n.client_max_window_bits));
          if (!i)
            throw new Error("None of the extension offers can be accepted");
          return r.serverNoContextTakeover && (i.server_no_context_takeover = true), r.clientNoContextTakeover && (i.client_no_context_takeover = true), typeof r.serverMaxWindowBits == "number" && (i.server_max_window_bits = r.serverMaxWindowBits), typeof r.clientMaxWindowBits == "number" ? i.client_max_window_bits = r.clientMaxWindowBits : (i.client_max_window_bits === true || r.clientMaxWindowBits === false) && delete i.client_max_window_bits, i;
        }
        acceptAsClient(e) {
          let r = e[0];
          if (this._options.clientNoContextTakeover === false && r.client_no_context_takeover)
            throw new Error('Unexpected parameter "client_no_context_takeover"');
          if (!r.client_max_window_bits)
            typeof this._options.clientMaxWindowBits == "number" && (r.client_max_window_bits = this._options.clientMaxWindowBits);
          else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits == "number" && r.client_max_window_bits > this._options.clientMaxWindowBits)
            throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
          return r;
        }
        normalizeParams(e) {
          return e.forEach((r) => {
            Object.keys(r).forEach((i) => {
              let n = r[i];
              if (n.length > 1)
                throw new Error(`Parameter "${i}" must have only a single value`);
              if (n = n[0], i === "client_max_window_bits") {
                if (n !== true) {
                  let s = +n;
                  if (!Number.isInteger(s) || s < 8 || s > 15)
                    throw new TypeError(`Invalid value for parameter "${i}": ${n}`);
                  n = s;
                } else if (!this._isServer)
                  throw new TypeError(`Invalid value for parameter "${i}": ${n}`);
              } else if (i === "server_max_window_bits") {
                let s = +n;
                if (!Number.isInteger(s) || s < 8 || s > 15)
                  throw new TypeError(`Invalid value for parameter "${i}": ${n}`);
                n = s;
              } else if (i === "client_no_context_takeover" || i === "server_no_context_takeover") {
                if (n !== true)
                  throw new TypeError(`Invalid value for parameter "${i}": ${n}`);
              } else
                throw new Error(`Unknown parameter "${i}"`);
              r[i] = n;
            });
          }), e;
        }
        decompress(e, r, i) {
          Pi.add((n) => {
            this._decompress(e, r, (s, o) => {
              n(), i(s, o);
            });
          });
        }
        compress(e, r, i) {
          Pi.add((n) => {
            this._compress(e, r, (s, o) => {
              n(), i(s, o);
            });
          });
        }
        _decompress(e, r, i) {
          let n = this._isServer ? "client" : "server";
          if (!this._inflate) {
            let s = `${n}_max_window_bits`, o = typeof this.params[s] != "number" ? Xr.Z_DEFAULT_WINDOWBITS : this.params[s];
            this._inflate = Xr.createInflateRaw(__spreadProps(__spreadValues({}, this._options.zlibInflateOptions), { windowBits: o })), this._inflate[Mi] = this, this._inflate[pt] = 0, this._inflate[kt] = [], this._inflate.on("error", T0), this._inflate.on("data", tf);
          }
          this._inflate[Qr] = i, this._inflate.write(e), r && this._inflate.write(O0), this._inflate.flush(() => {
            let s = this._inflate[Fi];
            if (s) {
              this._inflate.close(), this._inflate = null, i(s);
              return;
            }
            let o = Ju.concat(this._inflate[kt], this._inflate[pt]);
            this._inflate._readableState.endEmitted ? (this._inflate.close(), this._inflate = null) : (this._inflate[pt] = 0, this._inflate[kt] = [], r && this.params[`${n}_no_context_takeover`] && this._inflate.reset()), i(null, o);
          });
        }
        _compress(e, r, i) {
          let n = this._isServer ? "server" : "client";
          if (!this._deflate) {
            let s = `${n}_max_window_bits`, o = typeof this.params[s] != "number" ? Xr.Z_DEFAULT_WINDOWBITS : this.params[s];
            this._deflate = Xr.createDeflateRaw(__spreadProps(__spreadValues({}, this._options.zlibDeflateOptions), { windowBits: o })), this._deflate[pt] = 0, this._deflate[kt] = [], this._deflate.on("data", I0);
          }
          this._deflate[Qr] = i, this._deflate.write(e), this._deflate.flush(Xr.Z_SYNC_FLUSH, () => {
            if (!this._deflate)
              return;
            let s = Ju.concat(this._deflate[kt], this._deflate[pt]);
            r && (s = s.slice(0, s.length - 4)), this._deflate[Qr] = null, this._deflate[pt] = 0, this._deflate[kt] = [], r && this.params[`${n}_no_context_takeover`] && this._deflate.reset(), i(null, s);
          });
        }
      };
      rf.exports = Gs;
      function I0(t) {
        this[kt].push(t), this[pt] += t.length;
      }
      function tf(t) {
        if (this[pt] += t.length, this[Mi]._maxPayload < 1 || this[pt] <= this[Mi]._maxPayload) {
          this[kt].push(t);
          return;
        }
        this[Fi] = new RangeError("Max payload size exceeded"), this[Fi].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH", this[Fi][ef] = 1009, this.removeListener("data", tf), this.reset();
      }
      function T0(t) {
        this[Mi]._inflate = null, t[ef] = 1007, this[Qr](t);
      }
    });
    var ei = x((ry, zs) => {
      "use strict";
      var nf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0];
      function sf(t) {
        return t >= 1e3 && t <= 1014 && t !== 1004 && t !== 1005 && t !== 1006 || t >= 3e3 && t <= 4999;
      }
      function of(t) {
        let e = t.length, r = 0;
        for (; r < e; )
          if ((t[r] & 128) === 0)
            r++;
          else if ((t[r] & 224) === 192) {
            if (r + 1 === e || (t[r + 1] & 192) !== 128 || (t[r] & 254) === 192)
              return false;
            r += 2;
          } else if ((t[r] & 240) === 224) {
            if (r + 2 >= e || (t[r + 1] & 192) !== 128 || (t[r + 2] & 192) !== 128 || t[r] === 224 && (t[r + 1] & 224) === 128 || t[r] === 237 && (t[r + 1] & 224) === 160)
              return false;
            r += 3;
          } else if ((t[r] & 248) === 240) {
            if (r + 3 >= e || (t[r + 1] & 192) !== 128 || (t[r + 2] & 192) !== 128 || (t[r + 3] & 192) !== 128 || t[r] === 240 && (t[r + 1] & 240) === 128 || t[r] === 244 && t[r + 1] > 143 || t[r] > 244)
              return false;
            r += 4;
          } else
            return false;
        return true;
      }
      try {
        let t = require("utf-8-validate");
        zs.exports = { isValidStatusCode: sf, isValidUTF8(e) {
          return e.length < 150 ? of(e) : t(e);
        }, tokenChars: nf };
      } catch (e) {
        zs.exports = { isValidStatusCode: sf, isValidUTF8: of, tokenChars: nf };
      }
    });
    var Zs = x((iy, pf) => {
      "use strict";
      var { Writable: A0 } = require("stream"), af = Jr(), { BINARY_TYPES: R0, EMPTY_BUFFER: lf, kStatusCode: B0, kWebSocket: L0 } = St(), { concat: Ws, toArrayBuffer: N0, unmask: P0 } = Zr(), { isValidStatusCode: F0, isValidUTF8: cf } = ei(), ti = 0, uf = 1, ff = 2, hf = 3, Ys = 4, M0 = 5, Ks = class extends A0 {
        constructor(e = {}) {
          super(), this._binaryType = e.binaryType || R0[0], this._extensions = e.extensions || {}, this._isServer = !!e.isServer, this._maxPayload = e.maxPayload | 0, this._skipUTF8Validation = !!e.skipUTF8Validation, this[L0] = void 0, this._bufferedBytes = 0, this._buffers = [], this._compressed = false, this._payloadLength = 0, this._mask = void 0, this._fragmented = 0, this._masked = false, this._fin = false, this._opcode = 0, this._totalPayloadLength = 0, this._messageLength = 0, this._fragments = [], this._state = ti, this._loop = false;
        }
        _write(e, r, i) {
          if (this._opcode === 8 && this._state == ti)
            return i();
          this._bufferedBytes += e.length, this._buffers.push(e), this.startLoop(i);
        }
        consume(e) {
          if (this._bufferedBytes -= e, e === this._buffers[0].length)
            return this._buffers.shift();
          if (e < this._buffers[0].length) {
            let i = this._buffers[0];
            return this._buffers[0] = i.slice(e), i.slice(0, e);
          }
          let r = Buffer.allocUnsafe(e);
          do {
            let i = this._buffers[0], n = r.length - e;
            e >= i.length ? r.set(this._buffers.shift(), n) : (r.set(new Uint8Array(i.buffer, i.byteOffset, e), n), this._buffers[0] = i.slice(e)), e -= i.length;
          } while (e > 0);
          return r;
        }
        startLoop(e) {
          let r;
          this._loop = true;
          do
            switch (this._state) {
              case ti:
                r = this.getInfo();
                break;
              case uf:
                r = this.getPayloadLength16();
                break;
              case ff:
                r = this.getPayloadLength64();
                break;
              case hf:
                this.getMask();
                break;
              case Ys:
                r = this.getData(e);
                break;
              default:
                this._loop = false;
                return;
            }
          while (this._loop);
          e(r);
        }
        getInfo() {
          if (this._bufferedBytes < 2) {
            this._loop = false;
            return;
          }
          let e = this.consume(2);
          if ((e[0] & 48) !== 0)
            return this._loop = false, Be(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
          let r = (e[0] & 64) === 64;
          if (r && !this._extensions[af.extensionName])
            return this._loop = false, Be(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          if (this._fin = (e[0] & 128) === 128, this._opcode = e[0] & 15, this._payloadLength = e[1] & 127, this._opcode === 0) {
            if (r)
              return this._loop = false, Be(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
            if (!this._fragmented)
              return this._loop = false, Be(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
            this._opcode = this._fragmented;
          } else if (this._opcode === 1 || this._opcode === 2) {
            if (this._fragmented)
              return this._loop = false, Be(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
            this._compressed = r;
          } else if (this._opcode > 7 && this._opcode < 11) {
            if (!this._fin)
              return this._loop = false, Be(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
            if (r)
              return this._loop = false, Be(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
            if (this._payloadLength > 125)
              return this._loop = false, Be(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else
            return this._loop = false, Be(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          if (!this._fin && !this._fragmented && (this._fragmented = this._opcode), this._masked = (e[1] & 128) === 128, this._isServer) {
            if (!this._masked)
              return this._loop = false, Be(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          } else if (this._masked)
            return this._loop = false, Be(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
          if (this._payloadLength === 126)
            this._state = uf;
          else if (this._payloadLength === 127)
            this._state = ff;
          else
            return this.haveLength();
        }
        getPayloadLength16() {
          if (this._bufferedBytes < 2) {
            this._loop = false;
            return;
          }
          return this._payloadLength = this.consume(2).readUInt16BE(0), this.haveLength();
        }
        getPayloadLength64() {
          if (this._bufferedBytes < 8) {
            this._loop = false;
            return;
          }
          let e = this.consume(8), r = e.readUInt32BE(0);
          return r > Math.pow(2, 53 - 32) - 1 ? (this._loop = false, Be(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH")) : (this._payloadLength = r * Math.pow(2, 32) + e.readUInt32BE(4), this.haveLength());
        }
        haveLength() {
          if (this._payloadLength && this._opcode < 8 && (this._totalPayloadLength += this._payloadLength, this._totalPayloadLength > this._maxPayload && this._maxPayload > 0))
            return this._loop = false, Be(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          this._masked ? this._state = hf : this._state = Ys;
        }
        getMask() {
          if (this._bufferedBytes < 4) {
            this._loop = false;
            return;
          }
          this._mask = this.consume(4), this._state = Ys;
        }
        getData(e) {
          let r = lf;
          if (this._payloadLength) {
            if (this._bufferedBytes < this._payloadLength) {
              this._loop = false;
              return;
            }
            r = this.consume(this._payloadLength), this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0 && P0(r, this._mask);
          }
          if (this._opcode > 7)
            return this.controlMessage(r);
          if (this._compressed) {
            this._state = M0, this.decompress(r, e);
            return;
          }
          return r.length && (this._messageLength = this._totalPayloadLength, this._fragments.push(r)), this.dataMessage();
        }
        decompress(e, r) {
          this._extensions[af.extensionName].decompress(e, this._fin, (n, s) => {
            if (n)
              return r(n);
            if (s.length) {
              if (this._messageLength += s.length, this._messageLength > this._maxPayload && this._maxPayload > 0)
                return r(Be(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
              this._fragments.push(s);
            }
            let o = this.dataMessage();
            if (o)
              return r(o);
            this.startLoop(r);
          });
        }
        dataMessage() {
          if (this._fin) {
            let e = this._messageLength, r = this._fragments;
            if (this._totalPayloadLength = 0, this._messageLength = 0, this._fragmented = 0, this._fragments = [], this._opcode === 2) {
              let i;
              this._binaryType === "nodebuffer" ? i = Ws(r, e) : this._binaryType === "arraybuffer" ? i = N0(Ws(r, e)) : i = r, this.emit("message", i, true);
            } else {
              let i = Ws(r, e);
              if (!this._skipUTF8Validation && !cf(i))
                return this._loop = false, Be(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
              this.emit("message", i, false);
            }
          }
          this._state = ti;
        }
        controlMessage(e) {
          if (this._opcode === 8)
            if (this._loop = false, e.length === 0)
              this.emit("conclude", 1005, lf), this.end();
            else {
              if (e.length === 1)
                return Be(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
              {
                let r = e.readUInt16BE(0);
                if (!F0(r))
                  return Be(RangeError, `invalid status code ${r}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
                let i = e.slice(2);
                if (!this._skipUTF8Validation && !cf(i))
                  return Be(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
                this.emit("conclude", r, i), this.end();
              }
            }
          else
            this._opcode === 9 ? this.emit("ping", e) : this.emit("pong", e);
          this._state = ti;
        }
      };
      pf.exports = Ks;
      function Be(t, e, r, i, n) {
        let s = new t(r ? `Invalid WebSocket frame: ${e}` : e);
        return Error.captureStackTrace(s, Be), s.code = n, s[B0] = i, s;
      }
    });
    var Xs = x((oy, gf) => {
      "use strict";
      var ny = require("net"), sy = require("tls"), { randomFillSync: U0 } = require("crypto"), df = Jr(), { EMPTY_BUFFER: D0 } = St(), { isValidStatusCode: j0 } = ei(), { mask: mf, toBuffer: _r } = Zr(), ot = Symbol("kByteLength"), q0 = Buffer.alloc(4), ct = class {
        constructor(e, r, i) {
          this._extensions = r || {}, i && (this._generateMask = i, this._maskBuffer = Buffer.alloc(4)), this._socket = e, this._firstFragment = true, this._compress = false, this._bufferedBytes = 0, this._deflating = false, this._queue = [];
        }
        static frame(e, r) {
          let i, n = false, s = 2, o = false;
          r.mask && (i = r.maskBuffer || q0, r.generateMask ? r.generateMask(i) : U0(i, 0, 4), o = (i[0] | i[1] | i[2] | i[3]) === 0, s = 6);
          let a;
          typeof e == "string" ? (!r.mask || o) && r[ot] !== void 0 ? a = r[ot] : (e = Buffer.from(e), a = e.length) : (a = e.length, n = r.mask && r.readOnly && !o);
          let l = a;
          a >= 65536 ? (s += 8, l = 127) : a > 125 && (s += 2, l = 126);
          let c = Buffer.allocUnsafe(n ? a + s : s);
          return c[0] = r.fin ? r.opcode | 128 : r.opcode, r.rsv1 && (c[0] |= 64), c[1] = l, l === 126 ? c.writeUInt16BE(a, 2) : l === 127 && (c[2] = c[3] = 0, c.writeUIntBE(a, 4, 6)), r.mask ? (c[1] |= 128, c[s - 4] = i[0], c[s - 3] = i[1], c[s - 2] = i[2], c[s - 1] = i[3], o ? [c, e] : n ? (mf(e, i, c, s, a), [c]) : (mf(e, i, e, 0, a), [c, e])) : [c, e];
        }
        close(e, r, i, n) {
          let s;
          if (e === void 0)
            s = D0;
          else {
            if (typeof e != "number" || !j0(e))
              throw new TypeError("First argument must be a valid error code number");
            if (r === void 0 || !r.length)
              s = Buffer.allocUnsafe(2), s.writeUInt16BE(e, 0);
            else {
              let a = Buffer.byteLength(r);
              if (a > 123)
                throw new RangeError("The message must not be greater than 123 bytes");
              s = Buffer.allocUnsafe(2 + a), s.writeUInt16BE(e, 0), typeof r == "string" ? s.write(r, 2) : s.set(r, 2);
            }
          }
          let o = { [ot]: s.length, fin: true, generateMask: this._generateMask, mask: i, maskBuffer: this._maskBuffer, opcode: 8, readOnly: false, rsv1: false };
          this._deflating ? this.enqueue([this.dispatch, s, false, o, n]) : this.sendFrame(ct.frame(s, o), n);
        }
        ping(e, r, i) {
          let n, s;
          if (typeof e == "string" ? (n = Buffer.byteLength(e), s = false) : (e = _r(e), n = e.length, s = _r.readOnly), n > 125)
            throw new RangeError("The data size must not be greater than 125 bytes");
          let o = { [ot]: n, fin: true, generateMask: this._generateMask, mask: r, maskBuffer: this._maskBuffer, opcode: 9, readOnly: s, rsv1: false };
          this._deflating ? this.enqueue([this.dispatch, e, false, o, i]) : this.sendFrame(ct.frame(e, o), i);
        }
        pong(e, r, i) {
          let n, s;
          if (typeof e == "string" ? (n = Buffer.byteLength(e), s = false) : (e = _r(e), n = e.length, s = _r.readOnly), n > 125)
            throw new RangeError("The data size must not be greater than 125 bytes");
          let o = { [ot]: n, fin: true, generateMask: this._generateMask, mask: r, maskBuffer: this._maskBuffer, opcode: 10, readOnly: s, rsv1: false };
          this._deflating ? this.enqueue([this.dispatch, e, false, o, i]) : this.sendFrame(ct.frame(e, o), i);
        }
        send(e, r, i) {
          let n = this._extensions[df.extensionName], s = r.binary ? 2 : 1, o = r.compress, a, l;
          if (typeof e == "string" ? (a = Buffer.byteLength(e), l = false) : (e = _r(e), a = e.length, l = _r.readOnly), this._firstFragment ? (this._firstFragment = false, o && n && n.params[n._isServer ? "server_no_context_takeover" : "client_no_context_takeover"] && (o = a >= n._threshold), this._compress = o) : (o = false, s = 0), r.fin && (this._firstFragment = true), n) {
            let c = { [ot]: a, fin: r.fin, generateMask: this._generateMask, mask: r.mask, maskBuffer: this._maskBuffer, opcode: s, readOnly: l, rsv1: o };
            this._deflating ? this.enqueue([this.dispatch, e, this._compress, c, i]) : this.dispatch(e, this._compress, c, i);
          } else
            this.sendFrame(ct.frame(e, { [ot]: a, fin: r.fin, generateMask: this._generateMask, mask: r.mask, maskBuffer: this._maskBuffer, opcode: s, readOnly: l, rsv1: false }), i);
        }
        dispatch(e, r, i, n) {
          if (!r) {
            this.sendFrame(ct.frame(e, i), n);
            return;
          }
          let s = this._extensions[df.extensionName];
          this._bufferedBytes += i[ot], this._deflating = true, s.compress(e, i.fin, (o, a) => {
            if (this._socket.destroyed) {
              let l = new Error("The socket was closed while data was being compressed");
              typeof n == "function" && n(l);
              for (let c = 0; c < this._queue.length; c++) {
                let u = this._queue[c], f = u[u.length - 1];
                typeof f == "function" && f(l);
              }
              return;
            }
            this._bufferedBytes -= i[ot], this._deflating = false, i.readOnly = false, this.sendFrame(ct.frame(a, i), n), this.dequeue();
          });
        }
        dequeue() {
          for (; !this._deflating && this._queue.length; ) {
            let e = this._queue.shift();
            this._bufferedBytes -= e[3][ot], Reflect.apply(e[0], this, e.slice(1));
          }
        }
        enqueue(e) {
          this._bufferedBytes += e[3][ot], this._queue.push(e);
        }
        sendFrame(e, r) {
          e.length === 2 ? (this._socket.cork(), this._socket.write(e[0]), this._socket.write(e[1], r), this._socket.uncork()) : this._socket.write(e[0], r);
        }
      };
      gf.exports = ct;
    });
    var Cf = x((ay, kf) => {
      "use strict";
      var { kForOnEventAttribute: Qs, kListener: vf } = St(), _f = Symbol("kCode"), xf = Symbol("kData"), yf = Symbol("kError"), bf = Symbol("kMessage"), wf = Symbol("kReason"), xr = Symbol("kTarget"), Ef = Symbol("kType"), Sf = Symbol("kWasClean"), dt = class {
        constructor(e) {
          this[xr] = null, this[Ef] = e;
        }
        get target() {
          return this[xr];
        }
        get type() {
          return this[Ef];
        }
      };
      Object.defineProperty(dt.prototype, "target", { enumerable: true });
      Object.defineProperty(dt.prototype, "type", { enumerable: true });
      var Ht = class extends dt {
        constructor(e, r = {}) {
          super(e), this[_f] = r.code === void 0 ? 0 : r.code, this[wf] = r.reason === void 0 ? "" : r.reason, this[Sf] = r.wasClean === void 0 ? false : r.wasClean;
        }
        get code() {
          return this[_f];
        }
        get reason() {
          return this[wf];
        }
        get wasClean() {
          return this[Sf];
        }
      };
      Object.defineProperty(Ht.prototype, "code", { enumerable: true });
      Object.defineProperty(Ht.prototype, "reason", { enumerable: true });
      Object.defineProperty(Ht.prototype, "wasClean", { enumerable: true });
      var yr = class extends dt {
        constructor(e, r = {}) {
          super(e), this[yf] = r.error === void 0 ? null : r.error, this[bf] = r.message === void 0 ? "" : r.message;
        }
        get error() {
          return this[yf];
        }
        get message() {
          return this[bf];
        }
      };
      Object.defineProperty(yr.prototype, "error", { enumerable: true });
      Object.defineProperty(yr.prototype, "message", { enumerable: true });
      var ri = class extends dt {
        constructor(e, r = {}) {
          super(e), this[xf] = r.data === void 0 ? null : r.data;
        }
        get data() {
          return this[xf];
        }
      };
      Object.defineProperty(ri.prototype, "data", { enumerable: true });
      var H0 = { addEventListener(t, e, r = {}) {
        let i;
        if (t === "message")
          i = function(s, o) {
            let a = new ri("message", { data: o ? s : s.toString() });
            a[xr] = this, e.call(this, a);
          };
        else if (t === "close")
          i = function(s, o) {
            let a = new Ht("close", { code: s, reason: o.toString(), wasClean: this._closeFrameReceived && this._closeFrameSent });
            a[xr] = this, e.call(this, a);
          };
        else if (t === "error")
          i = function(s) {
            let o = new yr("error", { error: s, message: s.message });
            o[xr] = this, e.call(this, o);
          };
        else if (t === "open")
          i = function() {
            let s = new dt("open");
            s[xr] = this, e.call(this, s);
          };
        else
          return;
        i[Qs] = !!r[Qs], i[vf] = e, r.once ? this.once(t, i) : this.on(t, i);
      }, removeEventListener(t, e) {
        for (let r of this.listeners(t))
          if (r[vf] === e && !r[Qs]) {
            this.removeListener(t, r);
            break;
          }
      } };
      kf.exports = { CloseEvent: Ht, ErrorEvent: yr, Event: dt, EventTarget: H0, MessageEvent: ri };
    });
    var Js = x((ly, Of) => {
      "use strict";
      var { tokenChars: ii } = ei();
      function ut(t, e, r) {
        t[e] === void 0 ? t[e] = [r] : t[e].push(r);
      }
      function V0(t) {
        let e = Object.create(null), r = Object.create(null), i = false, n = false, s = false, o, a, l = -1, c = -1, u = -1, f = 0;
        for (; f < t.length; f++)
          if (c = t.charCodeAt(f), o === void 0)
            if (u === -1 && ii[c] === 1)
              l === -1 && (l = f);
            else if (f !== 0 && (c === 32 || c === 9))
              u === -1 && l !== -1 && (u = f);
            else if (c === 59 || c === 44) {
              if (l === -1)
                throw new SyntaxError(`Unexpected character at index ${f}`);
              u === -1 && (u = f);
              let p = t.slice(l, u);
              c === 44 ? (ut(e, p, r), r = Object.create(null)) : o = p, l = u = -1;
            } else
              throw new SyntaxError(`Unexpected character at index ${f}`);
          else if (a === void 0)
            if (u === -1 && ii[c] === 1)
              l === -1 && (l = f);
            else if (c === 32 || c === 9)
              u === -1 && l !== -1 && (u = f);
            else if (c === 59 || c === 44) {
              if (l === -1)
                throw new SyntaxError(`Unexpected character at index ${f}`);
              u === -1 && (u = f), ut(r, t.slice(l, u), true), c === 44 && (ut(e, o, r), r = Object.create(null), o = void 0), l = u = -1;
            } else if (c === 61 && l !== -1 && u === -1)
              a = t.slice(l, f), l = u = -1;
            else
              throw new SyntaxError(`Unexpected character at index ${f}`);
          else if (n) {
            if (ii[c] !== 1)
              throw new SyntaxError(`Unexpected character at index ${f}`);
            l === -1 ? l = f : i || (i = true), n = false;
          } else if (s)
            if (ii[c] === 1)
              l === -1 && (l = f);
            else if (c === 34 && l !== -1)
              s = false, u = f;
            else if (c === 92)
              n = true;
            else
              throw new SyntaxError(`Unexpected character at index ${f}`);
          else if (c === 34 && t.charCodeAt(f - 1) === 61)
            s = true;
          else if (u === -1 && ii[c] === 1)
            l === -1 && (l = f);
          else if (l !== -1 && (c === 32 || c === 9))
            u === -1 && (u = f);
          else if (c === 59 || c === 44) {
            if (l === -1)
              throw new SyntaxError(`Unexpected character at index ${f}`);
            u === -1 && (u = f);
            let p = t.slice(l, u);
            i && (p = p.replace(/\\/g, ""), i = false), ut(r, a, p), c === 44 && (ut(e, o, r), r = Object.create(null), o = void 0), a = void 0, l = u = -1;
          } else
            throw new SyntaxError(`Unexpected character at index ${f}`);
        if (l === -1 || s || c === 32 || c === 9)
          throw new SyntaxError("Unexpected end of input");
        u === -1 && (u = f);
        let h = t.slice(l, u);
        return o === void 0 ? ut(e, h, r) : (a === void 0 ? ut(r, h, true) : i ? ut(r, a, h.replace(/\\/g, "")) : ut(r, a, h), ut(e, o, r)), e;
      }
      function $0(t) {
        return Object.keys(t).map((e) => {
          let r = t[e];
          return Array.isArray(r) || (r = [r]), r.map((i) => [e].concat(Object.keys(i).map((n) => {
            let s = i[n];
            return Array.isArray(s) || (s = [s]), s.map((o) => o === true ? n : `${n}=${o}`).join("; ");
          })).join("; ")).join(", ");
        }).join(", ");
      }
      Of.exports = { format: $0, parse: V0 };
    });
    var so = x((uy, Mf) => {
      "use strict";
      var G0 = require("events"), z0 = require("https"), W0 = require("http"), Af = require("net"), Y0 = require("tls"), { randomBytes: K0, createHash: Z0 } = require("crypto"), { Readable: cy } = require("stream"), { URL: eo } = require("url"), Ct = Jr(), X0 = Zs(), Q0 = Xs(), { BINARY_TYPES: If, EMPTY_BUFFER: Ui, GUID: J0, kForOnEventAttribute: to, kListener: ev, kStatusCode: tv, kWebSocket: He, NOOP: Rf } = St(), { EventTarget: { addEventListener: rv, removeEventListener: iv } } = Cf(), { format: nv, parse: sv } = Js(), { toBuffer: ov } = Zr(), mt = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"], av = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/, ro = [8, 13], lv = 30 * 1e3, X = class extends G0 {
        constructor(e, r, i) {
          super(), this._binaryType = If[0], this._closeCode = 1006, this._closeFrameReceived = false, this._closeFrameSent = false, this._closeMessage = Ui, this._closeTimer = null, this._extensions = {}, this._paused = false, this._protocol = "", this._readyState = X.CONNECTING, this._receiver = null, this._sender = null, this._socket = null, e !== null ? (this._bufferedAmount = 0, this._isServer = false, this._redirects = 0, r === void 0 ? r = [] : Array.isArray(r) || (typeof r == "object" && r !== null ? (i = r, r = []) : r = [r]), Bf(this, e, r, i)) : this._isServer = true;
        }
        get binaryType() {
          return this._binaryType;
        }
        set binaryType(e) {
          !If.includes(e) || (this._binaryType = e, this._receiver && (this._receiver._binaryType = e));
        }
        get bufferedAmount() {
          return this._socket ? this._socket._writableState.length + this._sender._bufferedBytes : this._bufferedAmount;
        }
        get extensions() {
          return Object.keys(this._extensions).join();
        }
        get isPaused() {
          return this._paused;
        }
        get onclose() {
          return null;
        }
        get onerror() {
          return null;
        }
        get onopen() {
          return null;
        }
        get onmessage() {
          return null;
        }
        get protocol() {
          return this._protocol;
        }
        get readyState() {
          return this._readyState;
        }
        get url() {
          return this._url;
        }
        setSocket(e, r, i) {
          let n = new X0({ binaryType: this.binaryType, extensions: this._extensions, isServer: this._isServer, maxPayload: i.maxPayload, skipUTF8Validation: i.skipUTF8Validation });
          this._sender = new Q0(e, this._extensions, i.generateMask), this._receiver = n, this._socket = e, n[He] = this, e[He] = this, n.on("conclude", fv), n.on("drain", hv), n.on("error", pv), n.on("message", dv), n.on("ping", mv), n.on("pong", gv), e.setTimeout(0), e.setNoDelay(), r.length > 0 && e.unshift(r), e.on("close", Nf), e.on("data", Di), e.on("end", Pf), e.on("error", Ff), this._readyState = X.OPEN, this.emit("open");
        }
        emitClose() {
          if (!this._socket) {
            this._readyState = X.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
            return;
          }
          this._extensions[Ct.extensionName] && this._extensions[Ct.extensionName].cleanup(), this._receiver.removeAllListeners(), this._readyState = X.CLOSED, this.emit("close", this._closeCode, this._closeMessage);
        }
        close(e, r) {
          if (this.readyState !== X.CLOSED) {
            if (this.readyState === X.CONNECTING) {
              let i = "WebSocket was closed before the connection was established";
              return Je(this, this._req, i);
            }
            if (this.readyState === X.CLOSING) {
              this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end();
              return;
            }
            this._readyState = X.CLOSING, this._sender.close(e, r, !this._isServer, (i) => {
              i || (this._closeFrameSent = true, (this._closeFrameReceived || this._receiver._writableState.errorEmitted) && this._socket.end());
            }), this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), lv);
          }
        }
        pause() {
          this.readyState === X.CONNECTING || this.readyState === X.CLOSED || (this._paused = true, this._socket.pause());
        }
        ping(e, r, i) {
          if (this.readyState === X.CONNECTING)
            throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
          if (typeof e == "function" ? (i = e, e = r = void 0) : typeof r == "function" && (i = r, r = void 0), typeof e == "number" && (e = e.toString()), this.readyState !== X.OPEN) {
            no(this, e, i);
            return;
          }
          r === void 0 && (r = !this._isServer), this._sender.ping(e || Ui, r, i);
        }
        pong(e, r, i) {
          if (this.readyState === X.CONNECTING)
            throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
          if (typeof e == "function" ? (i = e, e = r = void 0) : typeof r == "function" && (i = r, r = void 0), typeof e == "number" && (e = e.toString()), this.readyState !== X.OPEN) {
            no(this, e, i);
            return;
          }
          r === void 0 && (r = !this._isServer), this._sender.pong(e || Ui, r, i);
        }
        resume() {
          this.readyState === X.CONNECTING || this.readyState === X.CLOSED || (this._paused = false, this._receiver._writableState.needDrain || this._socket.resume());
        }
        send(e, r, i) {
          if (this.readyState === X.CONNECTING)
            throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
          if (typeof r == "function" && (i = r, r = {}), typeof e == "number" && (e = e.toString()), this.readyState !== X.OPEN) {
            no(this, e, i);
            return;
          }
          let n = __spreadValues({ binary: typeof e != "string", mask: !this._isServer, compress: true, fin: true }, r);
          this._extensions[Ct.extensionName] || (n.compress = false), this._sender.send(e || Ui, n, i);
        }
        terminate() {
          if (this.readyState !== X.CLOSED) {
            if (this.readyState === X.CONNECTING) {
              let e = "WebSocket was closed before the connection was established";
              return Je(this, this._req, e);
            }
            this._socket && (this._readyState = X.CLOSING, this._socket.destroy());
          }
        }
      };
      Object.defineProperty(X, "CONNECTING", { enumerable: true, value: mt.indexOf("CONNECTING") });
      Object.defineProperty(X.prototype, "CONNECTING", { enumerable: true, value: mt.indexOf("CONNECTING") });
      Object.defineProperty(X, "OPEN", { enumerable: true, value: mt.indexOf("OPEN") });
      Object.defineProperty(X.prototype, "OPEN", { enumerable: true, value: mt.indexOf("OPEN") });
      Object.defineProperty(X, "CLOSING", { enumerable: true, value: mt.indexOf("CLOSING") });
      Object.defineProperty(X.prototype, "CLOSING", { enumerable: true, value: mt.indexOf("CLOSING") });
      Object.defineProperty(X, "CLOSED", { enumerable: true, value: mt.indexOf("CLOSED") });
      Object.defineProperty(X.prototype, "CLOSED", { enumerable: true, value: mt.indexOf("CLOSED") });
      ["binaryType", "bufferedAmount", "extensions", "isPaused", "protocol", "readyState", "url"].forEach((t) => {
        Object.defineProperty(X.prototype, t, { enumerable: true });
      });
      ["open", "error", "close", "message"].forEach((t) => {
        Object.defineProperty(X.prototype, `on${t}`, { enumerable: true, get() {
          for (let e of this.listeners(t))
            if (e[to])
              return e[ev];
          return null;
        }, set(e) {
          for (let r of this.listeners(t))
            if (r[to]) {
              this.removeListener(t, r);
              break;
            }
          typeof e == "function" && this.addEventListener(t, e, { [to]: true });
        } });
      });
      X.prototype.addEventListener = rv;
      X.prototype.removeEventListener = iv;
      Mf.exports = X;
      function Bf(t, e, r, i) {
        let n = __spreadProps(__spreadValues({ protocolVersion: ro[1], maxPayload: 104857600, skipUTF8Validation: false, perMessageDeflate: true, followRedirects: false, maxRedirects: 10 }, i), { createConnection: void 0, socketPath: void 0, hostname: void 0, protocol: void 0, timeout: void 0, method: void 0, host: void 0, path: void 0, port: void 0 });
        if (!ro.includes(n.protocolVersion))
          throw new RangeError(`Unsupported protocol version: ${n.protocolVersion} (supported versions: ${ro.join(", ")})`);
        let s;
        if (e instanceof eo)
          s = e, t._url = e.href;
        else {
          try {
            s = new eo(e);
          } catch (e2) {
            throw new SyntaxError(`Invalid URL: ${e}`);
          }
          t._url = e;
        }
        let o = s.protocol === "wss:", a = s.protocol === "ws+unix:", l;
        if (s.protocol !== "ws:" && !o && !a ? l = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"` : a && !s.pathname ? l = "The URL's pathname is empty" : s.hash && (l = "The URL contains a fragment identifier"), l) {
          let m = new SyntaxError(l);
          if (t._redirects === 0)
            throw m;
          io(t, m);
          return;
        }
        let c = o ? 443 : 80, u = K0(16).toString("base64"), f = o ? z0.get : W0.get, h = /* @__PURE__ */ new Set(), p;
        if (n.createConnection = o ? uv : cv, n.defaultPort = n.defaultPort || c, n.port = s.port || c, n.host = s.hostname.startsWith("[") ? s.hostname.slice(1, -1) : s.hostname, n.headers = __spreadValues({ "Sec-WebSocket-Version": n.protocolVersion, "Sec-WebSocket-Key": u, Connection: "Upgrade", Upgrade: "websocket" }, n.headers), n.path = s.pathname + s.search, n.timeout = n.handshakeTimeout, n.perMessageDeflate && (p = new Ct(n.perMessageDeflate !== true ? n.perMessageDeflate : {}, false, n.maxPayload), n.headers["Sec-WebSocket-Extensions"] = nv({ [Ct.extensionName]: p.offer() })), r.length) {
          for (let m of r) {
            if (typeof m != "string" || !av.test(m) || h.has(m))
              throw new SyntaxError("An invalid or duplicated subprotocol was specified");
            h.add(m);
          }
          n.headers["Sec-WebSocket-Protocol"] = r.join(",");
        }
        if (n.origin && (n.protocolVersion < 13 ? n.headers["Sec-WebSocket-Origin"] = n.origin : n.headers.Origin = n.origin), (s.username || s.password) && (n.auth = `${s.username}:${s.password}`), a) {
          let m = n.path.split(":");
          n.socketPath = m[0], n.path = m[1];
        }
        let d = t._req = f(n);
        n.timeout && d.on("timeout", () => {
          Je(t, d, "Opening handshake has timed out");
        }), d.on("error", (m) => {
          d === null || d.aborted || (d = t._req = null, io(t, m));
        }), d.on("response", (m) => {
          let g = m.headers.location, y = m.statusCode;
          if (g && n.followRedirects && y >= 300 && y < 400) {
            if (++t._redirects > n.maxRedirects) {
              Je(t, d, "Maximum redirects exceeded");
              return;
            }
            d.abort();
            let I;
            try {
              I = new eo(g, e);
            } catch (e2) {
              let S = new SyntaxError(`Invalid URL: ${g}`);
              io(t, S);
              return;
            }
            Bf(t, I, r, i);
          } else
            t.emit("unexpected-response", d, m) || Je(t, d, `Unexpected server response: ${m.statusCode}`);
        }), d.on("upgrade", (m, g, y) => {
          if (t.emit("upgrade", m), t.readyState !== X.CONNECTING)
            return;
          d = t._req = null;
          let I = Z0("sha1").update(u + J0).digest("base64");
          if (m.headers["sec-websocket-accept"] !== I) {
            Je(t, g, "Invalid Sec-WebSocket-Accept header");
            return;
          }
          let w = m.headers["sec-websocket-protocol"], S;
          if (w !== void 0 ? h.size ? h.has(w) || (S = "Server sent an invalid subprotocol") : S = "Server sent a subprotocol but none was requested" : h.size && (S = "Server sent no subprotocol"), S) {
            Je(t, g, S);
            return;
          }
          w && (t._protocol = w);
          let b = m.headers["sec-websocket-extensions"];
          if (b !== void 0) {
            if (!p) {
              Je(t, g, "Server sent a Sec-WebSocket-Extensions header but no extension was requested");
              return;
            }
            let $;
            try {
              $ = sv(b);
            } catch (e2) {
              Je(t, g, "Invalid Sec-WebSocket-Extensions header");
              return;
            }
            let C = Object.keys($);
            if (C.length !== 1 || C[0] !== Ct.extensionName) {
              Je(t, g, "Server indicated an extension that was not requested");
              return;
            }
            try {
              p.accept($[Ct.extensionName]);
            } catch (e2) {
              Je(t, g, "Invalid Sec-WebSocket-Extensions header");
              return;
            }
            t._extensions[Ct.extensionName] = p;
          }
          t.setSocket(g, y, { generateMask: n.generateMask, maxPayload: n.maxPayload, skipUTF8Validation: n.skipUTF8Validation });
        });
      }
      function io(t, e) {
        t._readyState = X.CLOSING, t.emit("error", e), t.emitClose();
      }
      function cv(t) {
        return t.path = t.socketPath, Af.connect(t);
      }
      function uv(t) {
        return t.path = void 0, !t.servername && t.servername !== "" && (t.servername = Af.isIP(t.host) ? "" : t.host), Y0.connect(t);
      }
      function Je(t, e, r) {
        t._readyState = X.CLOSING;
        let i = new Error(r);
        Error.captureStackTrace(i, Je), e.setHeader ? (e.abort(), e.socket && !e.socket.destroyed && e.socket.destroy(), e.once("abort", t.emitClose.bind(t)), t.emit("error", i)) : (e.destroy(i), e.once("error", t.emit.bind(t, "error")), e.once("close", t.emitClose.bind(t)));
      }
      function no(t, e, r) {
        if (e) {
          let i = ov(e).length;
          t._socket ? t._sender._bufferedBytes += i : t._bufferedAmount += i;
        }
        if (r) {
          let i = new Error(`WebSocket is not open: readyState ${t.readyState} (${mt[t.readyState]})`);
          r(i);
        }
      }
      function fv(t, e) {
        let r = this[He];
        r._closeFrameReceived = true, r._closeMessage = e, r._closeCode = t, r._socket[He] !== void 0 && (r._socket.removeListener("data", Di), process.nextTick(Lf, r._socket), t === 1005 ? r.close() : r.close(t, e));
      }
      function hv() {
        let t = this[He];
        t.isPaused || t._socket.resume();
      }
      function pv(t) {
        let e = this[He];
        e._socket[He] !== void 0 && (e._socket.removeListener("data", Di), process.nextTick(Lf, e._socket), e.close(t[tv])), e.emit("error", t);
      }
      function Tf() {
        this[He].emitClose();
      }
      function dv(t, e) {
        this[He].emit("message", t, e);
      }
      function mv(t) {
        let e = this[He];
        e.pong(t, !e._isServer, Rf), e.emit("ping", t);
      }
      function gv(t) {
        this[He].emit("pong", t);
      }
      function Lf(t) {
        t.resume();
      }
      function Nf() {
        let t = this[He];
        this.removeListener("close", Nf), this.removeListener("data", Di), this.removeListener("end", Pf), t._readyState = X.CLOSING;
        let e;
        !this._readableState.endEmitted && !t._closeFrameReceived && !t._receiver._writableState.errorEmitted && (e = t._socket.read()) !== null && t._receiver.write(e), t._receiver.end(), this[He] = void 0, clearTimeout(t._closeTimer), t._receiver._writableState.finished || t._receiver._writableState.errorEmitted ? t.emitClose() : (t._receiver.on("error", Tf), t._receiver.on("finish", Tf));
      }
      function Di(t) {
        this[He]._receiver.write(t) || this.pause();
      }
      function Pf() {
        let t = this[He];
        t._readyState = X.CLOSING, t._receiver.end(), this.end();
      }
      function Ff() {
        let t = this[He];
        this.removeListener("error", Ff), this.on("error", Rf), t && (t._readyState = X.CLOSING, this.destroy());
      }
    });
    var Df = x((fy, Uf) => {
      "use strict";
      var { tokenChars: vv } = ei();
      function _v(t) {
        let e = /* @__PURE__ */ new Set(), r = -1, i = -1, n = 0;
        for (n; n < t.length; n++) {
          let o = t.charCodeAt(n);
          if (i === -1 && vv[o] === 1)
            r === -1 && (r = n);
          else if (n !== 0 && (o === 32 || o === 9))
            i === -1 && r !== -1 && (i = n);
          else if (o === 44) {
            if (r === -1)
              throw new SyntaxError(`Unexpected character at index ${n}`);
            i === -1 && (i = n);
            let a = t.slice(r, i);
            if (e.has(a))
              throw new SyntaxError(`The "${a}" subprotocol is duplicated`);
            e.add(a), r = i = -1;
          } else
            throw new SyntaxError(`Unexpected character at index ${n}`);
        }
        if (r === -1 || i !== -1)
          throw new SyntaxError("Unexpected end of input");
        let s = t.slice(r, n);
        if (e.has(s))
          throw new SyntaxError(`The "${s}" subprotocol is duplicated`);
        return e.add(s), e;
      }
      Uf.exports = { parse: _v };
    });
    var Gf = x((my, $f) => {
      "use strict";
      var xv = require("events"), ji = require("http"), hy = require("https"), py = require("net"), dy = require("tls"), { createHash: yv } = require("crypto"), jf = Js(), Vt = Jr(), bv = Df(), wv = so(), { GUID: Ev, kWebSocket: Sv } = St(), kv = /^[+/0-9A-Za-z]{22}==$/, qf = 0, Hf = 1, Vf = 2, oo = class extends xv {
        constructor(e, r) {
          if (super(), e = __spreadValues({ maxPayload: 100 * 1024 * 1024, skipUTF8Validation: false, perMessageDeflate: false, handleProtocols: null, clientTracking: true, verifyClient: null, noServer: false, backlog: null, server: null, host: null, path: null, port: null }, e), e.port == null && !e.server && !e.noServer || e.port != null && (e.server || e.noServer) || e.server && e.noServer)
            throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
          if (e.port != null ? (this._server = ji.createServer((i, n) => {
            let s = ji.STATUS_CODES[426];
            n.writeHead(426, { "Content-Length": s.length, "Content-Type": "text/plain" }), n.end(s);
          }), this._server.listen(e.port, e.host, e.backlog, r)) : e.server && (this._server = e.server), this._server) {
            let i = this.emit.bind(this, "connection");
            this._removeListeners = Cv(this._server, { listening: this.emit.bind(this, "listening"), error: this.emit.bind(this, "error"), upgrade: (n, s, o) => {
              this.handleUpgrade(n, s, o, i);
            } });
          }
          e.perMessageDeflate === true && (e.perMessageDeflate = {}), e.clientTracking && (this.clients = /* @__PURE__ */ new Set(), this._shouldEmitClose = false), this.options = e, this._state = qf;
        }
        address() {
          if (this.options.noServer)
            throw new Error('The server is operating in "noServer" mode');
          return this._server ? this._server.address() : null;
        }
        close(e) {
          if (this._state === Vf) {
            e && this.once("close", () => {
              e(new Error("The server is not running"));
            }), process.nextTick(ni, this);
            return;
          }
          if (e && this.once("close", e), this._state !== Hf)
            if (this._state = Hf, this.options.noServer || this.options.server)
              this._server && (this._removeListeners(), this._removeListeners = this._server = null), this.clients ? this.clients.size ? this._shouldEmitClose = true : process.nextTick(ni, this) : process.nextTick(ni, this);
            else {
              let r = this._server;
              this._removeListeners(), this._removeListeners = this._server = null, r.close(() => {
                ni(this);
              });
            }
        }
        shouldHandle(e) {
          if (this.options.path) {
            let r = e.url.indexOf("?");
            if ((r !== -1 ? e.url.slice(0, r) : e.url) !== this.options.path)
              return false;
          }
          return true;
        }
        handleUpgrade(e, r, i, n) {
          r.on("error", ao);
          let s = e.headers["sec-websocket-key"] !== void 0 ? e.headers["sec-websocket-key"] : false, o = +e.headers["sec-websocket-version"];
          if (e.method !== "GET" || e.headers.upgrade.toLowerCase() !== "websocket" || !s || !kv.test(s) || o !== 8 && o !== 13 || !this.shouldHandle(e))
            return br(r, 400);
          let a = e.headers["sec-websocket-protocol"], l = /* @__PURE__ */ new Set();
          if (a !== void 0)
            try {
              l = bv.parse(a);
            } catch (e2) {
              return br(r, 400);
            }
          let c = e.headers["sec-websocket-extensions"], u = {};
          if (this.options.perMessageDeflate && c !== void 0) {
            let f = new Vt(this.options.perMessageDeflate, true, this.options.maxPayload);
            try {
              let h = jf.parse(c);
              h[Vt.extensionName] && (f.accept(h[Vt.extensionName]), u[Vt.extensionName] = f);
            } catch (e2) {
              return br(r, 400);
            }
          }
          if (this.options.verifyClient) {
            let f = { origin: e.headers[`${o === 8 ? "sec-websocket-origin" : "origin"}`], secure: !!(e.socket.authorized || e.socket.encrypted), req: e };
            if (this.options.verifyClient.length === 2) {
              this.options.verifyClient(f, (h, p, d, m) => {
                if (!h)
                  return br(r, p || 401, d, m);
                this.completeUpgrade(u, s, l, e, r, i, n);
              });
              return;
            }
            if (!this.options.verifyClient(f))
              return br(r, 401);
          }
          this.completeUpgrade(u, s, l, e, r, i, n);
        }
        completeUpgrade(e, r, i, n, s, o, a) {
          if (!s.readable || !s.writable)
            return s.destroy();
          if (s[Sv])
            throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
          if (this._state > qf)
            return br(s, 503);
          let l = yv("sha1").update(r + Ev).digest("base64"), c = ["HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", `Sec-WebSocket-Accept: ${l}`], u = new wv(null);
          if (i.size) {
            let f = this.options.handleProtocols ? this.options.handleProtocols(i, n) : i.values().next().value;
            f && (c.push(`Sec-WebSocket-Protocol: ${f}`), u._protocol = f);
          }
          if (e[Vt.extensionName]) {
            let f = e[Vt.extensionName].params, h = jf.format({ [Vt.extensionName]: [f] });
            c.push(`Sec-WebSocket-Extensions: ${h}`), u._extensions = e;
          }
          this.emit("headers", c, n), s.write(c.concat(`\r
`).join(`\r
`)), s.removeListener("error", ao), u.setSocket(s, o, { maxPayload: this.options.maxPayload, skipUTF8Validation: this.options.skipUTF8Validation }), this.clients && (this.clients.add(u), u.on("close", () => {
            this.clients.delete(u), this._shouldEmitClose && !this.clients.size && process.nextTick(ni, this);
          })), a(u, n);
        }
      };
      $f.exports = oo;
      function Cv(t, e) {
        for (let r of Object.keys(e))
          t.on(r, e[r]);
        return function() {
          for (let i of Object.keys(e))
            t.removeListener(i, e[i]);
        };
      }
      function ni(t) {
        t._state = Vf, t.emit("close");
      }
      function ao() {
        this.destroy();
      }
      function br(t, e, r, i) {
        t.writable && (r = r || ji.STATUS_CODES[e], i = __spreadValues({ Connection: "close", "Content-Type": "text/html", "Content-Length": Buffer.byteLength(r) }, i), t.write(`HTTP/1.1 ${e} ${ji.STATUS_CODES[e]}\r
` + Object.keys(i).map((n) => `${n}: ${i[n]}`).join(`\r
`) + `\r
\r
` + r)), t.removeListener("error", ao), t.destroy();
      }
    });
    var Kf = x((vy, Yf) => {
      var Ot = require("constants"), Iv = process.cwd, qi = null, Tv = process.env.GRACEFUL_FS_PLATFORM || process.platform;
      process.cwd = function() {
        return qi || (qi = Iv.call(process)), qi;
      };
      try {
        process.cwd();
      } catch (e) {
      }
      typeof process.chdir == "function" && (fo = process.chdir, process.chdir = function(t) {
        qi = null, fo.call(process, t);
      }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, fo));
      var fo;
      Yf.exports = Av;
      function Av(t) {
        Ot.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && e(t), t.lutimes || r(t), t.chown = s(t.chown), t.fchown = s(t.fchown), t.lchown = s(t.lchown), t.chmod = i(t.chmod), t.fchmod = i(t.fchmod), t.lchmod = i(t.lchmod), t.chownSync = o(t.chownSync), t.fchownSync = o(t.fchownSync), t.lchownSync = o(t.lchownSync), t.chmodSync = n(t.chmodSync), t.fchmodSync = n(t.fchmodSync), t.lchmodSync = n(t.lchmodSync), t.stat = a(t.stat), t.fstat = a(t.fstat), t.lstat = a(t.lstat), t.statSync = l(t.statSync), t.fstatSync = l(t.fstatSync), t.lstatSync = l(t.lstatSync), t.chmod && !t.lchmod && (t.lchmod = function(u, f, h) {
          h && process.nextTick(h);
        }, t.lchmodSync = function() {
        }), t.chown && !t.lchown && (t.lchown = function(u, f, h, p) {
          p && process.nextTick(p);
        }, t.lchownSync = function() {
        }), Tv === "win32" && (t.rename = typeof t.rename != "function" ? t.rename : function(u) {
          function f(h, p, d) {
            var m = Date.now(), g = 0;
            u(h, p, function y(I) {
              if (I && (I.code === "EACCES" || I.code === "EPERM") && Date.now() - m < 6e4) {
                setTimeout(function() {
                  t.stat(p, function(w, S) {
                    w && w.code === "ENOENT" ? u(h, p, y) : d(I);
                  });
                }, g), g < 100 && (g += 10);
                return;
              }
              d && d(I);
            });
          }
          return Object.setPrototypeOf && Object.setPrototypeOf(f, u), f;
        }(t.rename)), t.read = typeof t.read != "function" ? t.read : function(u) {
          function f(h, p, d, m, g, y) {
            var I;
            if (y && typeof y == "function") {
              var w = 0;
              I = function(S, b, $) {
                if (S && S.code === "EAGAIN" && w < 10)
                  return w++, u.call(t, h, p, d, m, g, I);
                y.apply(this, arguments);
              };
            }
            return u.call(t, h, p, d, m, g, I);
          }
          return Object.setPrototypeOf && Object.setPrototypeOf(f, u), f;
        }(t.read), t.readSync = typeof t.readSync != "function" ? t.readSync : function(u) {
          return function(f, h, p, d, m) {
            for (var g = 0; ; )
              try {
                return u.call(t, f, h, p, d, m);
              } catch (y) {
                if (y.code === "EAGAIN" && g < 10) {
                  g++;
                  continue;
                }
                throw y;
              }
          };
        }(t.readSync);
        function e(u) {
          u.lchmod = function(f, h, p) {
            u.open(f, Ot.O_WRONLY | Ot.O_SYMLINK, h, function(d, m) {
              if (d) {
                p && p(d);
                return;
              }
              u.fchmod(m, h, function(g) {
                u.close(m, function(y) {
                  p && p(g || y);
                });
              });
            });
          }, u.lchmodSync = function(f, h) {
            var p = u.openSync(f, Ot.O_WRONLY | Ot.O_SYMLINK, h), d = true, m;
            try {
              m = u.fchmodSync(p, h), d = false;
            } finally {
              if (d)
                try {
                  u.closeSync(p);
                } catch (e2) {
                }
              else
                u.closeSync(p);
            }
            return m;
          };
        }
        function r(u) {
          Ot.hasOwnProperty("O_SYMLINK") && u.futimes ? (u.lutimes = function(f, h, p, d) {
            u.open(f, Ot.O_SYMLINK, function(m, g) {
              if (m) {
                d && d(m);
                return;
              }
              u.futimes(g, h, p, function(y) {
                u.close(g, function(I) {
                  d && d(y || I);
                });
              });
            });
          }, u.lutimesSync = function(f, h, p) {
            var d = u.openSync(f, Ot.O_SYMLINK), m, g = true;
            try {
              m = u.futimesSync(d, h, p), g = false;
            } finally {
              if (g)
                try {
                  u.closeSync(d);
                } catch (e2) {
                }
              else
                u.closeSync(d);
            }
            return m;
          }) : u.futimes && (u.lutimes = function(f, h, p, d) {
            d && process.nextTick(d);
          }, u.lutimesSync = function() {
          });
        }
        function i(u) {
          return u && function(f, h, p) {
            return u.call(t, f, h, function(d) {
              c(d) && (d = null), p && p.apply(this, arguments);
            });
          };
        }
        function n(u) {
          return u && function(f, h) {
            try {
              return u.call(t, f, h);
            } catch (p) {
              if (!c(p))
                throw p;
            }
          };
        }
        function s(u) {
          return u && function(f, h, p, d) {
            return u.call(t, f, h, p, function(m) {
              c(m) && (m = null), d && d.apply(this, arguments);
            });
          };
        }
        function o(u) {
          return u && function(f, h, p) {
            try {
              return u.call(t, f, h, p);
            } catch (d) {
              if (!c(d))
                throw d;
            }
          };
        }
        function a(u) {
          return u && function(f, h, p) {
            typeof h == "function" && (p = h, h = null);
            function d(m, g) {
              g && (g.uid < 0 && (g.uid += 4294967296), g.gid < 0 && (g.gid += 4294967296)), p && p.apply(this, arguments);
            }
            return h ? u.call(t, f, h, d) : u.call(t, f, d);
          };
        }
        function l(u) {
          return u && function(f, h) {
            var p = h ? u.call(t, f, h) : u.call(t, f);
            return p && (p.uid < 0 && (p.uid += 4294967296), p.gid < 0 && (p.gid += 4294967296)), p;
          };
        }
        function c(u) {
          if (!u || u.code === "ENOSYS")
            return true;
          var f = !process.getuid || process.getuid() !== 0;
          return !!(f && (u.code === "EINVAL" || u.code === "EPERM"));
        }
      }
    });
    var Qf = x((_y, Xf) => {
      var Zf = require("stream").Stream;
      Xf.exports = Rv;
      function Rv(t) {
        return { ReadStream: e, WriteStream: r };
        function e(i, n) {
          if (!(this instanceof e))
            return new e(i, n);
          Zf.call(this);
          var s = this;
          this.path = i, this.fd = null, this.readable = true, this.paused = false, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, n = n || {};
          for (var o = Object.keys(n), a = 0, l = o.length; a < l; a++) {
            var c = o[a];
            this[c] = n[c];
          }
          if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
            if (typeof this.start != "number")
              throw TypeError("start must be a Number");
            if (this.end === void 0)
              this.end = 1 / 0;
            else if (typeof this.end != "number")
              throw TypeError("end must be a Number");
            if (this.start > this.end)
              throw new Error("start must be <= end");
            this.pos = this.start;
          }
          if (this.fd !== null) {
            process.nextTick(function() {
              s._read();
            });
            return;
          }
          t.open(this.path, this.flags, this.mode, function(u, f) {
            if (u) {
              s.emit("error", u), s.readable = false;
              return;
            }
            s.fd = f, s.emit("open", f), s._read();
          });
        }
        function r(i, n) {
          if (!(this instanceof r))
            return new r(i, n);
          Zf.call(this), this.path = i, this.fd = null, this.writable = true, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, n = n || {};
          for (var s = Object.keys(n), o = 0, a = s.length; o < a; o++) {
            var l = s[o];
            this[l] = n[l];
          }
          if (this.start !== void 0) {
            if (typeof this.start != "number")
              throw TypeError("start must be a Number");
            if (this.start < 0)
              throw new Error("start must be >= zero");
            this.pos = this.start;
          }
          this.busy = false, this._queue = [], this.fd === null && (this._open = t.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
        }
      }
    });
    var eh = x((xy, Jf) => {
      "use strict";
      Jf.exports = Lv;
      var Bv = Object.getPrototypeOf || function(t) {
        return t.__proto__;
      };
      function Lv(t) {
        if (t === null || typeof t != "object")
          return t;
        if (t instanceof Object)
          var e = { __proto__: Bv(t) };
        else
          var e = Object.create(null);
        return Object.getOwnPropertyNames(t).forEach(function(r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        }), e;
      }
    });
    var nh = x((yy, mo) => {
      var Ie = require("fs"), Nv = Kf(), Pv = Qf(), Fv = eh(), Hi = require("util"), De, $i;
      typeof Symbol == "function" && typeof Symbol.for == "function" ? (De = Symbol.for("graceful-fs.queue"), $i = Symbol.for("graceful-fs.previous")) : (De = "___graceful-fs.queue", $i = "___graceful-fs.previous");
      function Mv() {
      }
      function ih(t, e) {
        Object.defineProperty(t, De, { get: function() {
          return e;
        } });
      }
      var $t = Mv;
      Hi.debuglog ? $t = Hi.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && ($t = function() {
        var t = Hi.format.apply(Hi, arguments);
        t = "GFS4: " + t.split(/\n/).join(`
GFS4: `), console.error(t);
      });
      Ie[De] || (th = global[De] || [], ih(Ie, th), Ie.close = function(t) {
        function e(r, i) {
          return t.call(Ie, r, function(n) {
            n || rh(), typeof i == "function" && i.apply(this, arguments);
          });
        }
        return Object.defineProperty(e, $i, { value: t }), e;
      }(Ie.close), Ie.closeSync = function(t) {
        function e(r) {
          t.apply(Ie, arguments), rh();
        }
        return Object.defineProperty(e, $i, { value: t }), e;
      }(Ie.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
        $t(Ie[De]), require("assert").equal(Ie[De].length, 0);
      }));
      var th;
      global[De] || ih(global, Ie[De]);
      mo.exports = ho(Fv(Ie));
      process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !Ie.__patched && (mo.exports = ho(Ie), Ie.__patched = true);
      function ho(t) {
        Nv(t), t.gracefulify = ho, t.createReadStream = b, t.createWriteStream = $;
        var e = t.readFile;
        t.readFile = r;
        function r(E, T, B) {
          return typeof T == "function" && (B = T, T = null), G(E, T, B);
          function G(L, Q, R, F) {
            return e(L, Q, function(j) {
              j && (j.code === "EMFILE" || j.code === "ENFILE") ? wr([G, [L, Q, R], j, F || Date.now(), Date.now()]) : typeof R == "function" && R.apply(this, arguments);
            });
          }
        }
        var i = t.writeFile;
        t.writeFile = n;
        function n(E, T, B, G) {
          return typeof B == "function" && (G = B, B = null), L(E, T, B, G);
          function L(Q, R, F, j, z) {
            return i(Q, R, F, function(N) {
              N && (N.code === "EMFILE" || N.code === "ENFILE") ? wr([L, [Q, R, F, j], N, z || Date.now(), Date.now()]) : typeof j == "function" && j.apply(this, arguments);
            });
          }
        }
        var s = t.appendFile;
        s && (t.appendFile = o);
        function o(E, T, B, G) {
          return typeof B == "function" && (G = B, B = null), L(E, T, B, G);
          function L(Q, R, F, j, z) {
            return s(Q, R, F, function(N) {
              N && (N.code === "EMFILE" || N.code === "ENFILE") ? wr([L, [Q, R, F, j], N, z || Date.now(), Date.now()]) : typeof j == "function" && j.apply(this, arguments);
            });
          }
        }
        var a = t.copyFile;
        a && (t.copyFile = l);
        function l(E, T, B, G) {
          return typeof B == "function" && (G = B, B = 0), L(E, T, B, G);
          function L(Q, R, F, j, z) {
            return a(Q, R, F, function(N) {
              N && (N.code === "EMFILE" || N.code === "ENFILE") ? wr([L, [Q, R, F, j], N, z || Date.now(), Date.now()]) : typeof j == "function" && j.apply(this, arguments);
            });
          }
        }
        var c = t.readdir;
        t.readdir = f;
        var u = /^v[0-5]\./;
        function f(E, T, B) {
          typeof T == "function" && (B = T, T = null);
          var G = u.test(process.version) ? function(R, F, j, z) {
            return c(R, L(R, F, j, z));
          } : function(R, F, j, z) {
            return c(R, F, L(R, F, j, z));
          };
          return G(E, T, B);
          function L(Q, R, F, j) {
            return function(z, N) {
              z && (z.code === "EMFILE" || z.code === "ENFILE") ? wr([G, [Q, R, F], z, j || Date.now(), Date.now()]) : (N && N.sort && N.sort(), typeof F == "function" && F.call(this, z, N));
            };
          }
        }
        if (process.version.substr(0, 4) === "v0.8") {
          var h = Pv(t);
          y = h.ReadStream, w = h.WriteStream;
        }
        var p = t.ReadStream;
        p && (y.prototype = Object.create(p.prototype), y.prototype.open = I);
        var d = t.WriteStream;
        d && (w.prototype = Object.create(d.prototype), w.prototype.open = S), Object.defineProperty(t, "ReadStream", { get: function() {
          return y;
        }, set: function(E) {
          y = E;
        }, enumerable: true, configurable: true }), Object.defineProperty(t, "WriteStream", { get: function() {
          return w;
        }, set: function(E) {
          w = E;
        }, enumerable: true, configurable: true });
        var m = y;
        Object.defineProperty(t, "FileReadStream", { get: function() {
          return m;
        }, set: function(E) {
          m = E;
        }, enumerable: true, configurable: true });
        var g = w;
        Object.defineProperty(t, "FileWriteStream", { get: function() {
          return g;
        }, set: function(E) {
          g = E;
        }, enumerable: true, configurable: true });
        function y(E, T) {
          return this instanceof y ? (p.apply(this, arguments), this) : y.apply(Object.create(y.prototype), arguments);
        }
        function I() {
          var E = this;
          U(E.path, E.flags, E.mode, function(T, B) {
            T ? (E.autoClose && E.destroy(), E.emit("error", T)) : (E.fd = B, E.emit("open", B), E.read());
          });
        }
        function w(E, T) {
          return this instanceof w ? (d.apply(this, arguments), this) : w.apply(Object.create(w.prototype), arguments);
        }
        function S() {
          var E = this;
          U(E.path, E.flags, E.mode, function(T, B) {
            T ? (E.destroy(), E.emit("error", T)) : (E.fd = B, E.emit("open", B));
          });
        }
        function b(E, T) {
          return new t.ReadStream(E, T);
        }
        function $(E, T) {
          return new t.WriteStream(E, T);
        }
        var C = t.open;
        t.open = U;
        function U(E, T, B, G) {
          return typeof B == "function" && (G = B, B = null), L(E, T, B, G);
          function L(Q, R, F, j, z) {
            return C(Q, R, F, function(N, Se) {
              N && (N.code === "EMFILE" || N.code === "ENFILE") ? wr([L, [Q, R, F, j], N, z || Date.now(), Date.now()]) : typeof j == "function" && j.apply(this, arguments);
            });
          }
        }
        return t;
      }
      function wr(t) {
        $t("ENQUEUE", t[0].name, t[1]), Ie[De].push(t), po();
      }
      var Vi;
      function rh() {
        for (var t = Date.now(), e = 0; e < Ie[De].length; ++e)
          Ie[De][e].length > 2 && (Ie[De][e][3] = t, Ie[De][e][4] = t);
        po();
      }
      function po() {
        if (clearTimeout(Vi), Vi = void 0, Ie[De].length !== 0) {
          var t = Ie[De].shift(), e = t[0], r = t[1], i = t[2], n = t[3], s = t[4];
          if (n === void 0)
            $t("RETRY", e.name, r), e.apply(null, r);
          else if (Date.now() - n >= 6e4) {
            $t("TIMEOUT", e.name, r);
            var o = r.pop();
            typeof o == "function" && o.call(null, i);
          } else {
            var a = Date.now() - s, l = Math.max(s - n, 1), c = Math.min(l * 1.2, 100);
            a >= c ? ($t("RETRY", e.name, r), e.apply(null, r.concat([n]))) : Ie[De].push(t);
          }
          Vi === void 0 && (Vi = setTimeout(po, 0));
        }
      }
    });
    var oh = x((by, sh) => {
      function et(t, e) {
        typeof e == "boolean" && (e = { forever: e }), this._originalTimeouts = JSON.parse(JSON.stringify(t)), this._timeouts = t, this._options = e || {}, this._maxRetryTime = e && e.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
      }
      sh.exports = et;
      et.prototype.reset = function() {
        this._attempts = 1, this._timeouts = this._originalTimeouts;
      };
      et.prototype.stop = function() {
        this._timeout && clearTimeout(this._timeout), this._timeouts = [], this._cachedTimeouts = null;
      };
      et.prototype.retry = function(t) {
        if (this._timeout && clearTimeout(this._timeout), !t)
          return false;
        var e = new Date().getTime();
        if (t && e - this._operationStart >= this._maxRetryTime)
          return this._errors.unshift(new Error("RetryOperation timeout occurred")), false;
        this._errors.push(t);
        var r = this._timeouts.shift();
        if (r === void 0)
          if (this._cachedTimeouts)
            this._errors.splice(this._errors.length - 1, this._errors.length), this._timeouts = this._cachedTimeouts.slice(0), r = this._timeouts.shift();
          else
            return false;
        var i = this, n = setTimeout(function() {
          i._attempts++, i._operationTimeoutCb && (i._timeout = setTimeout(function() {
            i._operationTimeoutCb(i._attempts);
          }, i._operationTimeout), i._options.unref && i._timeout.unref()), i._fn(i._attempts);
        }, r);
        return this._options.unref && n.unref(), true;
      };
      et.prototype.attempt = function(t, e) {
        this._fn = t, e && (e.timeout && (this._operationTimeout = e.timeout), e.cb && (this._operationTimeoutCb = e.cb));
        var r = this;
        this._operationTimeoutCb && (this._timeout = setTimeout(function() {
          r._operationTimeoutCb();
        }, r._operationTimeout)), this._operationStart = new Date().getTime(), this._fn(this._attempts);
      };
      et.prototype.try = function(t) {
        console.log("Using RetryOperation.try() is deprecated"), this.attempt(t);
      };
      et.prototype.start = function(t) {
        console.log("Using RetryOperation.start() is deprecated"), this.attempt(t);
      };
      et.prototype.start = et.prototype.try;
      et.prototype.errors = function() {
        return this._errors;
      };
      et.prototype.attempts = function() {
        return this._attempts;
      };
      et.prototype.mainError = function() {
        if (this._errors.length === 0)
          return null;
        for (var t = {}, e = null, r = 0, i = 0; i < this._errors.length; i++) {
          var n = this._errors[i], s = n.message, o = (t[s] || 0) + 1;
          t[s] = o, o >= r && (e = n, r = o);
        }
        return e;
      };
    });
    var ah = x((Gt) => {
      var Uv = oh();
      Gt.operation = function(t) {
        var e = Gt.timeouts(t);
        return new Uv(e, { forever: t && t.forever, unref: t && t.unref, maxRetryTime: t && t.maxRetryTime });
      };
      Gt.timeouts = function(t) {
        if (t instanceof Array)
          return [].concat(t);
        var e = { retries: 10, factor: 2, minTimeout: 1 * 1e3, maxTimeout: 1 / 0, randomize: false };
        for (var r in t)
          e[r] = t[r];
        if (e.minTimeout > e.maxTimeout)
          throw new Error("minTimeout is greater than maxTimeout");
        for (var i = [], n = 0; n < e.retries; n++)
          i.push(this.createTimeout(n, e));
        return t && t.forever && !i.length && i.push(this.createTimeout(n, e)), i.sort(function(s, o) {
          return s - o;
        }), i;
      };
      Gt.createTimeout = function(t, e) {
        var r = e.randomize ? Math.random() + 1 : 1, i = Math.round(r * e.minTimeout * Math.pow(e.factor, t));
        return i = Math.min(i, e.maxTimeout), i;
      };
      Gt.wrap = function(t, e, r) {
        if (e instanceof Array && (r = e, e = null), !r) {
          r = [];
          for (var i in t)
            typeof t[i] == "function" && r.push(i);
        }
        for (var n = 0; n < r.length; n++) {
          var s = r[n], o = t[s];
          t[s] = function(l) {
            var c = Gt.operation(e), u = Array.prototype.slice.call(arguments, 1), f = u.pop();
            u.push(function(h) {
              c.retry(h) || (h && (arguments[0] = c.mainError()), f.apply(this, arguments));
            }), c.attempt(function() {
              l.apply(t, u);
            });
          }.bind(t, o), t[s].options = e;
        }
      };
    });
    var ch = x((Ey, lh) => {
      lh.exports = ah();
    });
    var uh = x((Sy, Gi) => {
      Gi.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];
      process.platform !== "win32" && Gi.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
      process.platform === "linux" && Gi.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    });
    var mh = x((ky, kr) => {
      var Ce = global.process, zt = function(t) {
        return t && typeof t == "object" && typeof t.removeListener == "function" && typeof t.emit == "function" && typeof t.reallyExit == "function" && typeof t.listeners == "function" && typeof t.kill == "function" && typeof t.pid == "number" && typeof t.on == "function";
      };
      zt(Ce) ? (fh = require("assert"), Er = uh(), hh = /^win/i.test(Ce.platform), si = require("events"), typeof si != "function" && (si = si.EventEmitter), Ce.__signal_exit_emitter__ ? Pe = Ce.__signal_exit_emitter__ : (Pe = Ce.__signal_exit_emitter__ = new si(), Pe.count = 0, Pe.emitted = {}), Pe.infinite || (Pe.setMaxListeners(1 / 0), Pe.infinite = true), kr.exports = function(t, e) {
        if (!zt(global.process))
          return function() {
          };
        fh.equal(typeof t, "function", "a callback must be provided for exit handler"), Sr === false && go();
        var r = "exit";
        e && e.alwaysLast && (r = "afterexit");
        var i = function() {
          Pe.removeListener(r, t), Pe.listeners("exit").length === 0 && Pe.listeners("afterexit").length === 0 && zi();
        };
        return Pe.on(r, t), i;
      }, zi = function() {
        !Sr || !zt(global.process) || (Sr = false, Er.forEach(function(e) {
          try {
            Ce.removeListener(e, Wi[e]);
          } catch (e2) {
          }
        }), Ce.emit = Yi, Ce.reallyExit = vo, Pe.count -= 1);
      }, kr.exports.unload = zi, Wt = function(e, r, i) {
        Pe.emitted[e] || (Pe.emitted[e] = true, Pe.emit(e, r, i));
      }, Wi = {}, Er.forEach(function(t) {
        Wi[t] = function() {
          if (!!zt(global.process)) {
            var r = Ce.listeners(t);
            r.length === Pe.count && (zi(), Wt("exit", null, t), Wt("afterexit", null, t), hh && t === "SIGHUP" && (t = "SIGINT"), Ce.kill(Ce.pid, t));
          }
        };
      }), kr.exports.signals = function() {
        return Er;
      }, Sr = false, go = function() {
        Sr || !zt(global.process) || (Sr = true, Pe.count += 1, Er = Er.filter(function(e) {
          try {
            return Ce.on(e, Wi[e]), true;
          } catch (e2) {
            return false;
          }
        }), Ce.emit = dh, Ce.reallyExit = ph);
      }, kr.exports.load = go, vo = Ce.reallyExit, ph = function(e) {
        !zt(global.process) || (Ce.exitCode = e || 0, Wt("exit", Ce.exitCode, null), Wt("afterexit", Ce.exitCode, null), vo.call(Ce, Ce.exitCode));
      }, Yi = Ce.emit, dh = function(e, r) {
        if (e === "exit" && zt(global.process)) {
          r !== void 0 && (Ce.exitCode = r);
          var i = Yi.apply(this, arguments);
          return Wt("exit", Ce.exitCode, null), Wt("afterexit", Ce.exitCode, null), i;
        } else
          return Yi.apply(this, arguments);
      }) : kr.exports = function() {
        return function() {
        };
      };
      var fh, Er, hh, si, Pe, zi, Wt, Wi, Sr, go, vo, ph, Yi, dh;
    });
    var Eh = x((Cy, wh) => {
      "use strict";
      var Dv = require("path"), xh = nh(), jv = ch(), qv = mh(), It = {}, gh = Symbol();
      function Hv(t, e, r) {
        let i = e[gh];
        if (i)
          return e.stat(t, (s, o) => {
            if (s)
              return r(s);
            r(null, o.mtime, i);
          });
        let n = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
        e.utimes(t, n, n, (s) => {
          if (s)
            return r(s);
          e.stat(t, (o, a) => {
            if (o)
              return r(o);
            let l = a.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
            Object.defineProperty(e, gh, { value: l }), r(null, a.mtime, l);
          });
        });
      }
      function Vv(t) {
        let e = Date.now();
        return t === "s" && (e = Math.ceil(e / 1e3) * 1e3), new Date(e);
      }
      function Zi(t, e) {
        return e.lockfilePath || `${t}.lock`;
      }
      function yh(t, e, r) {
        if (!e.realpath)
          return r(null, Dv.resolve(t));
        e.fs.realpath(t, r);
      }
      function xo(t, e, r) {
        let i = Zi(t, e);
        e.fs.mkdir(i, (n) => {
          if (!n)
            return Hv(i, e.fs, (s, o, a) => {
              if (s)
                return e.fs.rmdir(i, () => {
                }), r(s);
              r(null, o, a);
            });
          if (n.code !== "EEXIST")
            return r(n);
          if (e.stale <= 0)
            return r(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file: t }));
          e.fs.stat(i, (s, o) => {
            if (s)
              return s.code === "ENOENT" ? xo(t, __spreadProps(__spreadValues({}, e), { stale: 0 }), r) : r(s);
            if (!$v(o, e))
              return r(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file: t }));
            bh(t, e, (a) => {
              if (a)
                return r(a);
              xo(t, __spreadProps(__spreadValues({}, e), { stale: 0 }), r);
            });
          });
        });
      }
      function $v(t, e) {
        return t.mtime.getTime() < Date.now() - e.stale;
      }
      function bh(t, e, r) {
        e.fs.rmdir(Zi(t, e), (i) => {
          if (i && i.code !== "ENOENT")
            return r(i);
          r();
        });
      }
      function Ki(t, e) {
        let r = It[t];
        r.updateTimeout || (r.updateDelay = r.updateDelay || e.update, r.updateTimeout = setTimeout(() => {
          r.updateTimeout = null, e.fs.stat(r.lockfilePath, (i, n) => {
            let s = r.lastUpdate + e.stale < Date.now();
            if (i)
              return i.code === "ENOENT" || s ? _o(t, r, Object.assign(i, { code: "ECOMPROMISED" })) : (r.updateDelay = 1e3, Ki(t, e));
            if (!(r.mtime.getTime() === n.mtime.getTime()))
              return _o(t, r, Object.assign(new Error("Unable to update lock within the stale threshold"), { code: "ECOMPROMISED" }));
            let a = Vv(r.mtimePrecision);
            e.fs.utimes(r.lockfilePath, a, a, (l) => {
              let c = r.lastUpdate + e.stale < Date.now();
              if (!r.released) {
                if (l)
                  return l.code === "ENOENT" || c ? _o(t, r, Object.assign(l, { code: "ECOMPROMISED" })) : (r.updateDelay = 1e3, Ki(t, e));
                r.mtime = a, r.lastUpdate = Date.now(), r.updateDelay = null, Ki(t, e);
              }
            });
          });
        }, r.updateDelay), r.updateTimeout.unref && r.updateTimeout.unref());
      }
      function _o(t, e, r) {
        e.released = true, e.updateTimeout && clearTimeout(e.updateTimeout), It[t] === e && delete It[t], e.options.onCompromised(r);
      }
      function Gv(t, e, r) {
        e = __spreadValues({ stale: 1e4, update: null, realpath: true, retries: 0, fs: xh, onCompromised: (i) => {
          throw i;
        } }, e), e.retries = e.retries || 0, e.retries = typeof e.retries == "number" ? { retries: e.retries } : e.retries, e.stale = Math.max(e.stale || 0, 2e3), e.update = e.update == null ? e.stale / 2 : e.update || 0, e.update = Math.max(Math.min(e.update, e.stale / 2), 1e3), yh(t, e, (i, n) => {
          if (i)
            return r(i);
          let s = jv.operation(e.retries);
          s.attempt(() => {
            xo(n, e, (o, a, l) => {
              if (s.retry(o))
                return;
              if (o)
                return r(s.mainError());
              let c = It[n] = { lockfilePath: Zi(n, e), mtime: a, mtimePrecision: l, options: e, lastUpdate: Date.now() };
              Ki(n, e), r(null, (u) => {
                if (c.released)
                  return u && u(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
                zv(n, __spreadProps(__spreadValues({}, e), { realpath: false }), u);
              });
            });
          });
        });
      }
      function zv(t, e, r) {
        e = __spreadValues({ fs: xh, realpath: true }, e), yh(t, e, (i, n) => {
          if (i)
            return r(i);
          let s = It[n];
          if (!s)
            return r(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
          s.updateTimeout && clearTimeout(s.updateTimeout), s.released = true, delete It[n], bh(n, e, r);
        });
      }
      function vh(t) {
        return (...e) => new Promise((r, i) => {
          e.push((n, s) => {
            n ? i(n) : r(s);
          }), t(...e);
        });
      }
      var _h = false;
      function Wv() {
        _h || (_h = true, qv(() => {
          for (let t in It) {
            let e = It[t].options;
            try {
              e.fs.rmdirSync(Zi(t, e));
            } catch (e2) {
            }
          }
        }));
      }
      wh.exports.lock = (t, e) => __async(exports2, null, function* () {
        Wv();
        let r = yield vh(Gv)(t, e);
        return vh(r);
      });
    });
    var c_ = {};
    $h(c_, { HttpsProxyAgent: () => Nh.HttpsProxyAgent, PNG: () => Ph.PNG, SocksProxyAgent: () => Mh.SocksProxyAgent, StackUtils: () => n_, colors: () => Yv, debug: () => Kv, getProxyForUrl: () => Lh.getProxyForUrl, jpegjs: () => Zv, lockfile: () => Qv, mime: () => Jv, minimatch: () => e_, open: () => t_, program: () => Fh.program, progress: () => r_, rimraf: () => i_, ws: () => s_, wsReceiver: () => a_, wsSender: () => l_, wsServer: () => o_ });
    module2.exports = Gh(c_);
    var Sh = Te(aa());
    var kh = Te(tr());
    var Lh = Te(xa());
    var Nh = Te(Ia());
    var Ch = Te(Pa());
    var Oh = Te(Va());
    var Ih = Te(Ur());
    var Th = Te(El());
    var Ph = Te(_c());
    var Fh = Te(Rc());
    var Ah = Te(Fc());
    var Rh = Te(mu());
    var Mh = Te(Nu());
    var Bh = Te(ju());
    var Ov = Te($u(), 1);
    var lo = Te(Zs(), 1);
    var co = Te(Xs(), 1);
    var zf = Te(so(), 1);
    var uo = Te(Gf(), 1);
    var Wf = zf.default;
    var Yv = Sh.default;
    var Kv = kh.default;
    var Zv = Ch.default;
    var Xv = Eh();
    var Qv = Xv;
    var Jv = Oh.default;
    var e_ = Ih.default;
    var t_ = Th.default;
    var r_ = Ah.default;
    var i_ = Rh.default;
    var n_ = Bh.default;
    var s_ = Wf;
    var o_ = uo.default;
    var a_ = lo.default;
    var l_ = co.default;
  }
});

// node_modules/playwright-core/lib/utilsBundle.js
var require_utilsBundle = __commonJS({
  "node_modules/playwright-core/lib/utilsBundle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.minimatch = exports2.mime = exports2.lockfile = exports2.jpegjs = exports2.getProxyForUrl = exports2.debug = exports2.colors = exports2.SocksProxyAgent = exports2.PNG = exports2.HttpsProxyAgent = void 0;
    exports2.ms = ms;
    exports2.open = void 0;
    exports2.parseStackTraceLine = parseStackTraceLine;
    exports2.wsServer = exports2.wsSender = exports2.wsReceiver = exports2.ws = exports2.rimraf = exports2.progress = exports2.program = void 0;
    var _url = _interopRequireDefault(require("url"));
    var _path = _interopRequireDefault(require("path"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var colors2 = require_utilsBundleImpl().colors;
    exports2.colors = colors2;
    var debug2 = require_utilsBundleImpl().debug;
    exports2.debug = debug2;
    var getProxyForUrl2 = require_utilsBundleImpl().getProxyForUrl;
    exports2.getProxyForUrl = getProxyForUrl2;
    var HttpsProxyAgent2 = require_utilsBundleImpl().HttpsProxyAgent;
    exports2.HttpsProxyAgent = HttpsProxyAgent2;
    var jpegjs2 = require_utilsBundleImpl().jpegjs;
    exports2.jpegjs = jpegjs2;
    var lockfile2 = require_utilsBundleImpl().lockfile;
    exports2.lockfile = lockfile2;
    var mime2 = require_utilsBundleImpl().mime;
    exports2.mime = mime2;
    var minimatch2 = require_utilsBundleImpl().minimatch;
    exports2.minimatch = minimatch2;
    var open2 = require_utilsBundleImpl().open;
    exports2.open = open2;
    var PNG2 = require_utilsBundleImpl().PNG;
    exports2.PNG = PNG2;
    var program2 = require_utilsBundleImpl().program;
    exports2.program = program2;
    var progress2 = require_utilsBundleImpl().progress;
    exports2.progress = progress2;
    var rimraf2 = require_utilsBundleImpl().rimraf;
    exports2.rimraf = rimraf2;
    var SocksProxyAgent2 = require_utilsBundleImpl().SocksProxyAgent;
    exports2.SocksProxyAgent = SocksProxyAgent2;
    var ws2 = require_utilsBundleImpl().ws;
    exports2.ws = ws2;
    var wsServer2 = require_utilsBundleImpl().wsServer;
    exports2.wsServer = wsServer2;
    var wsReceiver2 = require_utilsBundleImpl().wsReceiver;
    exports2.wsReceiver = wsReceiver2;
    var wsSender2 = require_utilsBundleImpl().wsSender;
    exports2.wsSender = wsSender2;
    var StackUtils2 = require_utilsBundleImpl().StackUtils;
    var stackUtils = new StackUtils2({
      internals: StackUtils2.nodeInternals()
    });
    var nodeInternals = StackUtils2.nodeInternals();
    var nodeMajorVersion = +process.versions.node.split(".")[0];
    function parseStackTraceLine(line) {
      var _frame$file, _frame$file2;
      if (!process.env.PWDEBUGIMPL && nodeMajorVersion < 16 && nodeInternals.some((internal) => internal.test(line)))
        return null;
      const frame = stackUtils.parseLine(line);
      if (!frame)
        return null;
      if (!process.env.PWDEBUGIMPL && ((_frame$file = frame.file) !== null && _frame$file !== void 0 && _frame$file.startsWith("internal") || (_frame$file2 = frame.file) !== null && _frame$file2 !== void 0 && _frame$file2.startsWith("node:")))
        return null;
      if (!frame.file)
        return null;
      const file = frame.file.startsWith("file://") ? _url.default.fileURLToPath(frame.file) : _path.default.resolve(process.cwd(), frame.file);
      return {
        file,
        line: frame.line || 0,
        column: frame.column || 0,
        function: frame.function
      };
    }
    function ms(ms2) {
      if (!isFinite(ms2))
        return "-";
      if (ms2 === 0)
        return "0ms";
      if (ms2 < 1e3)
        return ms2.toFixed(0) + "ms";
      const seconds = ms2 / 1e3;
      if (seconds < 60)
        return seconds.toFixed(1) + "s";
      const minutes = seconds / 60;
      if (minutes < 60)
        return minutes.toFixed(1) + "m";
      const hours = minutes / 60;
      if (hours < 24)
        return hours.toFixed(1) + "h";
      const days = hours / 24;
      return days.toFixed(1) + "d";
    }
  }
});

// node_modules/playwright-core/lib/image_tools/colorUtils.js
var require_colorUtils = __commonJS({
  "node_modules/playwright-core/lib/image_tools/colorUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.blendWithWhite = blendWithWhite;
    exports2.colorDeltaE94 = colorDeltaE94;
    exports2.rgb2gray = rgb2gray;
    exports2.srgb2xyz = srgb2xyz;
    exports2.xyz2lab = xyz2lab;
    function blendWithWhite(c, a) {
      return 255 + (c - 255) * a;
    }
    function rgb2gray(r, g, b) {
      return 77 * r + 150 * g + 29 * b + 128 >> 8;
    }
    function colorDeltaE94(rgb1, rgb2) {
      const [l1, a1, b1] = xyz2lab(srgb2xyz(rgb1));
      const [l2, a2, b2] = xyz2lab(srgb2xyz(rgb2));
      const deltaL = l1 - l2;
      const deltaA = a1 - a2;
      const deltaB = b1 - b2;
      const c1 = Math.sqrt(a1 ** 2 + b1 ** 2);
      const c2 = Math.sqrt(a2 ** 2 + b2 ** 2);
      const deltaC = c1 - c2;
      let deltaH = deltaA ** 2 + deltaB ** 2 - deltaC ** 2;
      deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
      const k1 = 0.045;
      const k2 = 0.015;
      const kL = 1;
      const kC = 1;
      const kH = 1;
      const sC = 1 + k1 * c1;
      const sH = 1 + k2 * c1;
      const sL = 1;
      return Math.sqrt((deltaL / sL / kL) ** 2 + (deltaC / sC / kC) ** 2 + (deltaH / sH / kH) ** 2);
    }
    function srgb2xyz(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      return [r * 0.4124 + g * 0.3576 + b * 0.1805, r * 0.2126 + g * 0.7152 + b * 0.0722, r * 0.0193 + g * 0.1192 + b * 0.9505];
    }
    var sigma_pow2 = 6 * 6 / 29 / 29;
    var sigma_pow3 = 6 * 6 * 6 / 29 / 29 / 29;
    function xyz2lab(xyz) {
      const x = xyz[0] / 0.950489;
      const y = xyz[1];
      const z = xyz[2] / 1.08884;
      const fx = x > sigma_pow3 ? x ** (1 / 3) : x / 3 / sigma_pow2 + 4 / 29;
      const fy = y > sigma_pow3 ? y ** (1 / 3) : y / 3 / sigma_pow2 + 4 / 29;
      const fz = z > sigma_pow3 ? z ** (1 / 3) : z / 3 / sigma_pow2 + 4 / 29;
      const l = 116 * fy - 16;
      const a = 500 * (fx - fy);
      const b = 200 * (fy - fz);
      return [l, a, b];
    }
  }
});

// node_modules/playwright-core/lib/image_tools/imageChannel.js
var require_imageChannel = __commonJS({
  "node_modules/playwright-core/lib/image_tools/imageChannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ImageChannel = void 0;
    var _colorUtils = require_colorUtils();
    var ImageChannel = class {
      static intoRGB(width, height, data, options = {}) {
        const {
          paddingSize = 0,
          paddingColorOdd = [255, 0, 255],
          paddingColorEven = [0, 255, 0]
        } = options;
        const newWidth = width + 2 * paddingSize;
        const newHeight = height + 2 * paddingSize;
        const r = new Uint8Array(newWidth * newHeight);
        const g = new Uint8Array(newWidth * newHeight);
        const b = new Uint8Array(newWidth * newHeight);
        for (let y = 0; y < newHeight; ++y) {
          for (let x = 0; x < newWidth; ++x) {
            const index = y * newWidth + x;
            if (y >= paddingSize && y < newHeight - paddingSize && x >= paddingSize && x < newWidth - paddingSize) {
              const offset = ((y - paddingSize) * width + (x - paddingSize)) * 4;
              const alpha = data[offset + 3] === 255 ? 1 : data[offset + 3] / 255;
              r[index] = (0, _colorUtils.blendWithWhite)(data[offset], alpha);
              g[index] = (0, _colorUtils.blendWithWhite)(data[offset + 1], alpha);
              b[index] = (0, _colorUtils.blendWithWhite)(data[offset + 2], alpha);
            } else {
              const color = (y + x) % 2 === 0 ? paddingColorEven : paddingColorOdd;
              r[index] = color[0];
              g[index] = color[1];
              b[index] = color[2];
            }
          }
        }
        return [new ImageChannel(newWidth, newHeight, r), new ImageChannel(newWidth, newHeight, g), new ImageChannel(newWidth, newHeight, b)];
      }
      constructor(width, height, data) {
        this.data = void 0;
        this.width = void 0;
        this.height = void 0;
        this.data = data;
        this.width = width;
        this.height = height;
      }
      get(x, y) {
        return this.data[y * this.width + x];
      }
      boundXY(x, y) {
        return [Math.min(Math.max(x, 0), this.width - 1), Math.min(Math.max(y, 0), this.height - 1)];
      }
    };
    exports2.ImageChannel = ImageChannel;
  }
});

// node_modules/playwright-core/lib/image_tools/stats.js
var require_stats = __commonJS({
  "node_modules/playwright-core/lib/image_tools/stats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FastStats = void 0;
    exports2.ssim = ssim;
    var DYNAMIC_RANGE = 2 ** 8 - 1;
    function ssim(stats, x1, y1, x2, y2) {
      const mean1 = stats.meanC1(x1, y1, x2, y2);
      const mean2 = stats.meanC2(x1, y1, x2, y2);
      const var1 = stats.varianceC1(x1, y1, x2, y2);
      const var2 = stats.varianceC2(x1, y1, x2, y2);
      const cov = stats.covariance(x1, y1, x2, y2);
      const c1 = (0.01 * DYNAMIC_RANGE) ** 2;
      const c2 = (0.03 * DYNAMIC_RANGE) ** 2;
      return (2 * mean1 * mean2 + c1) * (2 * cov + c2) / (mean1 ** 2 + mean2 ** 2 + c1) / (var1 + var2 + c2);
    }
    var FastStats = class {
      constructor(c1, c2) {
        this.c1 = void 0;
        this.c2 = void 0;
        this._partialSumC1 = void 0;
        this._partialSumC2 = void 0;
        this._partialSumMult = void 0;
        this._partialSumSq1 = void 0;
        this._partialSumSq2 = void 0;
        this.c1 = c1;
        this.c2 = c2;
        const {
          width,
          height
        } = c1;
        this._partialSumC1 = new Array(width * height);
        this._partialSumC2 = new Array(width * height);
        this._partialSumSq1 = new Array(width * height);
        this._partialSumSq2 = new Array(width * height);
        this._partialSumMult = new Array(width * height);
        const recalc = (mx, idx, initial, x, y) => {
          mx[idx] = initial;
          if (y > 0)
            mx[idx] += mx[(y - 1) * width + x];
          if (x > 0)
            mx[idx] += mx[y * width + x - 1];
          if (x > 0 && y > 0)
            mx[idx] -= mx[(y - 1) * width + x - 1];
        };
        for (let y = 0; y < height; ++y) {
          for (let x = 0; x < width; ++x) {
            const idx = y * width + x;
            recalc(this._partialSumC1, idx, this.c1.data[idx], x, y);
            recalc(this._partialSumC2, idx, this.c2.data[idx], x, y);
            recalc(this._partialSumSq1, idx, this.c1.data[idx] * this.c1.data[idx], x, y);
            recalc(this._partialSumSq2, idx, this.c2.data[idx] * this.c2.data[idx], x, y);
            recalc(this._partialSumMult, idx, this.c1.data[idx] * this.c2.data[idx], x, y);
          }
        }
      }
      _sum(partialSum, x1, y1, x2, y2) {
        const width = this.c1.width;
        let result = partialSum[y2 * width + x2];
        if (y1 > 0)
          result -= partialSum[(y1 - 1) * width + x2];
        if (x1 > 0)
          result -= partialSum[y2 * width + x1 - 1];
        if (x1 > 0 && y1 > 0)
          result += partialSum[(y1 - 1) * width + x1 - 1];
        return result;
      }
      meanC1(x1, y1, x2, y2) {
        const N = (y2 - y1 + 1) * (x2 - x1 + 1);
        return this._sum(this._partialSumC1, x1, y1, x2, y2) / N;
      }
      meanC2(x1, y1, x2, y2) {
        const N = (y2 - y1 + 1) * (x2 - x1 + 1);
        return this._sum(this._partialSumC2, x1, y1, x2, y2) / N;
      }
      varianceC1(x1, y1, x2, y2) {
        const N = (y2 - y1 + 1) * (x2 - x1 + 1);
        return (this._sum(this._partialSumSq1, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) ** 2 / N) / N;
      }
      varianceC2(x1, y1, x2, y2) {
        const N = (y2 - y1 + 1) * (x2 - x1 + 1);
        return (this._sum(this._partialSumSq2, x1, y1, x2, y2) - this._sum(this._partialSumC2, x1, y1, x2, y2) ** 2 / N) / N;
      }
      covariance(x1, y1, x2, y2) {
        const N = (y2 - y1 + 1) * (x2 - x1 + 1);
        return (this._sum(this._partialSumMult, x1, y1, x2, y2) - this._sum(this._partialSumC1, x1, y1, x2, y2) * this._sum(this._partialSumC2, x1, y1, x2, y2) / N) / N;
      }
    };
    exports2.FastStats = FastStats;
  }
});

// node_modules/playwright-core/lib/image_tools/compare.js
var require_compare = __commonJS({
  "node_modules/playwright-core/lib/image_tools/compare.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.compare = compare;
    var _colorUtils = require_colorUtils();
    var _imageChannel = require_imageChannel();
    var _stats = require_stats();
    var SSIM_WINDOW_RADIUS = 15;
    var VARIANCE_WINDOW_RADIUS = 1;
    function drawPixel(width, data, x, y, r, g, b) {
      const idx = (y * width + x) * 4;
      data[idx + 0] = r;
      data[idx + 1] = g;
      data[idx + 2] = b;
      data[idx + 3] = 255;
    }
    function compare(actual, expected, diff, width, height, options = {}) {
      const {
        maxColorDeltaE94 = 1
      } = options;
      const paddingSize = Math.max(VARIANCE_WINDOW_RADIUS, SSIM_WINDOW_RADIUS);
      const paddingColorEven = [255, 0, 255];
      const paddingColorOdd = [0, 255, 0];
      const [r1, g1, b1] = _imageChannel.ImageChannel.intoRGB(width, height, expected, {
        paddingSize,
        paddingColorEven,
        paddingColorOdd
      });
      const [r2, g2, b2] = _imageChannel.ImageChannel.intoRGB(width, height, actual, {
        paddingSize,
        paddingColorEven,
        paddingColorOdd
      });
      const noop = (x, y) => {
      };
      const drawRedPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 0, 0) : noop;
      const drawYellowPixel = diff ? (x, y) => drawPixel(width, diff, x - paddingSize, y - paddingSize, 255, 255, 0) : noop;
      const drawGrayPixel = diff ? (x, y) => {
        const gray = (0, _colorUtils.rgb2gray)(r1.get(x, y), g1.get(x, y), b1.get(x, y));
        const value = (0, _colorUtils.blendWithWhite)(gray, 0.1);
        drawPixel(width, diff, x - paddingSize, y - paddingSize, value, value, value);
      } : noop;
      let fastR, fastG, fastB;
      let diffCount = 0;
      for (let y = paddingSize; y < r1.height - paddingSize; ++y) {
        for (let x = paddingSize; x < r1.width - paddingSize; ++x) {
          if (r1.get(x, y) === r2.get(x, y) && g1.get(x, y) === g2.get(x, y) && b1.get(x, y) === b2.get(x, y)) {
            drawGrayPixel(x, y);
            continue;
          }
          const delta = (0, _colorUtils.colorDeltaE94)([r1.get(x, y), g1.get(x, y), b1.get(x, y)], [r2.get(x, y), g2.get(x, y), b2.get(x, y)]);
          if (delta <= maxColorDeltaE94) {
            drawGrayPixel(x, y);
            continue;
          }
          if (!fastR || !fastG || !fastB) {
            fastR = new _stats.FastStats(r1, r2);
            fastG = new _stats.FastStats(g1, g2);
            fastB = new _stats.FastStats(b1, b2);
          }
          const [varX1, varY1] = r1.boundXY(x - VARIANCE_WINDOW_RADIUS, y - VARIANCE_WINDOW_RADIUS);
          const [varX2, varY2] = r1.boundXY(x + VARIANCE_WINDOW_RADIUS, y + VARIANCE_WINDOW_RADIUS);
          const var1 = fastR.varianceC1(varX1, varY1, varX2, varY2) + fastG.varianceC1(varX1, varY1, varX2, varY2) + fastB.varianceC1(varX1, varY1, varX2, varY2);
          const var2 = fastR.varianceC2(varX1, varY1, varX2, varY2) + fastG.varianceC2(varX1, varY1, varX2, varY2) + fastB.varianceC2(varX1, varY1, varX2, varY2);
          if (var1 === 0 && var2 === 0) {
            drawRedPixel(x, y);
            ++diffCount;
            continue;
          }
          const [ssimX1, ssimY1] = r1.boundXY(x - SSIM_WINDOW_RADIUS, y - SSIM_WINDOW_RADIUS);
          const [ssimX2, ssimY2] = r1.boundXY(x + SSIM_WINDOW_RADIUS, y + SSIM_WINDOW_RADIUS);
          const ssimRGB = ((0, _stats.ssim)(fastR, ssimX1, ssimY1, ssimX2, ssimY2) + (0, _stats.ssim)(fastG, ssimX1, ssimY1, ssimX2, ssimY2) + (0, _stats.ssim)(fastB, ssimX1, ssimY1, ssimX2, ssimY2)) / 3;
          const isAntialiassed = ssimRGB >= 0.99;
          if (isAntialiassed) {
            drawYellowPixel(x, y);
          } else {
            drawRedPixel(x, y);
            ++diffCount;
          }
        }
      }
      return diffCount;
    }
  }
});

// node_modules/playwright-core/lib/third_party/pixelmatch.js
var require_pixelmatch = __commonJS({
  "node_modules/playwright-core/lib/third_party/pixelmatch.js"(exports2, module2) {
    "use strict";
    module2.exports = pixelmatch;
    var defaultOptions = {
      threshold: 0.1,
      includeAA: false,
      alpha: 0.1,
      aaColor: [255, 255, 0],
      diffColor: [255, 0, 0],
      diffColorAlt: null,
      diffMask: false
    };
    function pixelmatch(img1, img2, output, width, height, options) {
      if (!isPixelData(img1) || !isPixelData(img2) || output && !isPixelData(output))
        throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
      if (img1.length !== img2.length || output && output.length !== img1.length)
        throw new Error("Image sizes do not match.");
      if (img1.length !== width * height * 4)
        throw new Error("Image data size does not match width/height.");
      options = Object.assign({}, defaultOptions, options);
      const len = width * height;
      const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);
      const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);
      let identical = true;
      for (let i = 0; i < len; i++) {
        if (a32[i] !== b32[i]) {
          identical = false;
          break;
        }
      }
      if (identical) {
        if (output && !options.diffMask) {
          for (let i = 0; i < len; i++)
            drawGrayPixel(img1, 4 * i, options.alpha, output);
        }
        return 0;
      }
      const maxDelta = 35215 * options.threshold * options.threshold;
      let diff = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const pos = (y * width + x) * 4;
          const delta = colorDelta(img1, img2, pos, pos);
          if (Math.abs(delta) > maxDelta) {
            if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
              if (output && !options.diffMask)
                drawPixel(output, pos, ...options.aaColor);
            } else {
              if (output) {
                drawPixel(output, pos, ...delta < 0 && options.diffColorAlt || options.diffColor);
              }
              diff++;
            }
          } else if (output) {
            if (!options.diffMask)
              drawGrayPixel(img1, pos, options.alpha, output);
          }
        }
      }
      return diff;
    }
    function isPixelData(arr) {
      return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;
    }
    function antialiased(img, x1, y1, width, height, img2) {
      const x0 = Math.max(x1 - 1, 0);
      const y0 = Math.max(y1 - 1, 0);
      const x2 = Math.min(x1 + 1, width - 1);
      const y2 = Math.min(y1 + 1, height - 1);
      const pos = (y1 * width + x1) * 4;
      let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
      let min = 0;
      let max = 0;
      let minX, minY, maxX, maxY;
      for (let x = x0; x <= x2; x++) {
        for (let y = y0; y <= y2; y++) {
          if (x === x1 && y === y1)
            continue;
          const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
          if (delta === 0) {
            zeroes++;
            if (zeroes > 2)
              return false;
          } else if (delta < min) {
            min = delta;
            minX = x;
            minY = y;
          } else if (delta > max) {
            max = delta;
            maxX = x;
            maxY = y;
          }
        }
      }
      if (min === 0 || max === 0)
        return false;
      return hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height) || hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height);
    }
    function hasManySiblings(img, x1, y1, width, height) {
      const x0 = Math.max(x1 - 1, 0);
      const y0 = Math.max(y1 - 1, 0);
      const x2 = Math.min(x1 + 1, width - 1);
      const y2 = Math.min(y1 + 1, height - 1);
      const pos = (y1 * width + x1) * 4;
      let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
      for (let x = x0; x <= x2; x++) {
        for (let y = y0; y <= y2; y++) {
          if (x === x1 && y === y1)
            continue;
          const pos2 = (y * width + x) * 4;
          if (img[pos] === img[pos2] && img[pos + 1] === img[pos2 + 1] && img[pos + 2] === img[pos2 + 2] && img[pos + 3] === img[pos2 + 3])
            zeroes++;
          if (zeroes > 2)
            return true;
        }
      }
      return false;
    }
    function colorDelta(img1, img2, k, m, yOnly) {
      let r1 = img1[k + 0];
      let g1 = img1[k + 1];
      let b1 = img1[k + 2];
      let a1 = img1[k + 3];
      let r2 = img2[m + 0];
      let g2 = img2[m + 1];
      let b2 = img2[m + 2];
      let a2 = img2[m + 3];
      if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2)
        return 0;
      if (a1 < 255) {
        a1 /= 255;
        r1 = blend(r1, a1);
        g1 = blend(g1, a1);
        b1 = blend(b1, a1);
      }
      if (a2 < 255) {
        a2 /= 255;
        r2 = blend(r2, a2);
        g2 = blend(g2, a2);
        b2 = blend(b2, a2);
      }
      const y1 = rgb2y(r1, g1, b1);
      const y2 = rgb2y(r2, g2, b2);
      const y = y1 - y2;
      if (yOnly)
        return y;
      const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);
      const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
      const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
      return y1 > y2 ? -delta : delta;
    }
    function rgb2y(r, g, b) {
      return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
    }
    function rgb2i(r, g, b) {
      return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
    }
    function rgb2q(r, g, b) {
      return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
    }
    function blend(c, a) {
      return 255 + (c - 255) * a;
    }
    function drawPixel(output, pos, r, g, b) {
      output[pos + 0] = r;
      output[pos + 1] = g;
      output[pos + 2] = b;
      output[pos + 3] = 255;
    }
    function drawGrayPixel(img, i, alpha, output) {
      const r = img[i + 0];
      const g = img[i + 1];
      const b = img[i + 2];
      const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);
      drawPixel(output, i, val, val, val);
    }
  }
});

// node_modules/playwright-core/lib/third_party/diff_match_patch.js
var require_diff_match_patch = __commonJS({
  "node_modules/playwright-core/lib/third_party/diff_match_patch.js"(exports2, module2) {
    var diff_match_patch = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = 0.5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = 0.5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    };
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    diff_match_patch.Diff = function(op, text) {
      this[0] = op;
      this[1] = text;
    };
    diff_match_patch.Diff.prototype.length = 2;
    diff_match_patch.Diff.prototype.toString = function() {
      return this[0] + "," + this[1];
    };
    diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
      if (typeof opt_deadline == "undefined") {
        if (this.Diff_Timeout <= 0) {
          opt_deadline = Number.MAX_VALUE;
        } else {
          opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
        }
      }
      var deadline = opt_deadline;
      if (text1 == null || text2 == null) {
        throw new Error("Null input. (diff_main)");
      }
      if (text1 == text2) {
        if (text1) {
          return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
        }
        return [];
      }
      if (typeof opt_checklines == "undefined") {
        opt_checklines = true;
      }
      var checklines = opt_checklines;
      var commonlength = this.diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = this.diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = this.diff_compute_(text1, text2, checklines, deadline);
      if (commonprefix) {
        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
      }
      if (commonsuffix) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
      }
      this.diff_cleanupMerge(diffs);
      return diffs;
    };
    diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
      var diffs;
      if (!text1) {
        return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
      }
      if (!text2) {
        return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i != -1) {
        diffs = [
          new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
          new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
          new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(i + shorttext.length))
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [
          new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)
        ];
      }
      var hm = this.diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)], diffs_b);
      }
      if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
      }
      return this.diff_bisect_(text1, text2, deadline);
    };
    diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
      var a = this.diff_linesToChars_(text1, text2);
      text1 = a.chars1;
      text2 = a.chars2;
      var linearray = a.lineArray;
      var diffs = this.diff_main(text1, text2, false, deadline);
      this.diff_charsToLines_(diffs, linearray);
      this.diff_cleanupSemantic(diffs);
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            break;
          case DIFF_EQUAL:
            if (count_delete >= 1 && count_insert >= 1) {
              diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
              pointer = pointer - count_delete - count_insert;
              var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
              for (var j = subDiff.length - 1; j >= 0; j--) {
                diffs.splice(pointer, 0, subDiff[j]);
              }
              pointer = pointer + subDiff.length;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
        pointer++;
      }
      diffs.pop();
      return diffs;
    };
    diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        if (new Date().getTime() > deadline) {
          break;
        }
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
      }
      return [
        new diff_match_patch.Diff(DIFF_DELETE, text1),
        new diff_match_patch.Diff(DIFF_INSERT, text2)
      ];
    };
    diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = this.diff_main(text1a, text2a, false, deadline);
      var diffsb = this.diff_main(text1b, text2b, false, deadline);
      return diffs.concat(diffsb);
    };
    diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
      var lineArray = [];
      var lineHash = {};
      lineArray[0] = "";
      function diff_linesToCharsMunge_(text) {
        var chars = "";
        var lineStart = 0;
        var lineEnd = -1;
        var lineArrayLength = lineArray.length;
        while (lineEnd < text.length - 1) {
          lineEnd = text.indexOf("\n", lineStart);
          if (lineEnd == -1) {
            lineEnd = text.length - 1;
          }
          var line = text.substring(lineStart, lineEnd + 1);
          if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
            chars += String.fromCharCode(lineHash[line]);
          } else {
            if (lineArrayLength == maxLines) {
              line = text.substring(lineStart);
              lineEnd = text.length;
            }
            chars += String.fromCharCode(lineArrayLength);
            lineHash[line] = lineArrayLength;
            lineArray[lineArrayLength++] = line;
          }
          lineStart = lineEnd + 1;
        }
        return chars;
      }
      var maxLines = 4e4;
      var chars1 = diff_linesToCharsMunge_(text1);
      maxLines = 65535;
      var chars2 = diff_linesToCharsMunge_(text2);
      return { chars1, chars2, lineArray };
    };
    diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
      for (var i = 0; i < diffs.length; i++) {
        var chars = diffs[i][1];
        var text = [];
        for (var j = 0; j < chars.length; j++) {
          text[j] = lineArray[chars.charCodeAt(j)];
        }
        diffs[i][1] = text.join("");
      }
    };
    diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    };
    diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
      if (this.Diff_Timeout <= 0) {
        return null;
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      var dmp = this;
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = dmp.diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
          var suffixLength = dmp.diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    };
    diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
      this.diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = this.diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch.whitespaceRegex_ = /\s/;
    diff_match_patch.linebreakRegex_ = /[\r\n]/;
    diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var pre_ins = false;
      var pre_del = false;
      var post_ins = false;
      var post_del = false;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
            equalities[equalitiesLength++] = pointer;
            pre_ins = post_ins;
            pre_del = post_del;
            lastEquality = diffs[pointer][1];
          } else {
            equalitiesLength = 0;
            lastEquality = null;
          }
          post_ins = post_del = false;
        } else {
          if (diffs[pointer][0] == DIFF_DELETE) {
            post_del = true;
          } else {
            post_ins = true;
          }
          if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            lastEquality = null;
            if (pre_ins && pre_del) {
              post_ins = post_del = true;
              equalitiesLength = 0;
            } else {
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              post_ins = post_del = false;
            }
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = this.diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = this.diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_DELETE, text_delete));
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_INSERT, text_insert));
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
      var chars1 = 0;
      var chars2 = 0;
      var last_chars1 = 0;
      var last_chars2 = 0;
      var x;
      for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE) {
          chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {
          break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
      }
      if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
        return last_chars2;
      }
      return last_chars2 + (loc - last_chars1);
    };
    diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
      var html = [];
      var pattern_amp = /&/g;
      var pattern_lt = /</g;
      var pattern_gt = />/g;
      var pattern_para = /\n/g;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
        switch (op) {
          case DIFF_INSERT:
            html[x] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
            break;
          case DIFF_DELETE:
            html[x] = '<del style="background:#ffe6e6;">' + text + "</del>";
            break;
          case DIFF_EQUAL:
            html[x] = "<span>" + text + "</span>";
            break;
        }
      }
      return html.join("");
    };
    diff_match_patch.prototype.diff_text1 = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          text[x] = diffs[x][1];
        }
      }
      return text.join("");
    };
    diff_match_patch.prototype.diff_text2 = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE) {
          text[x] = diffs[x][1];
        }
      }
      return text.join("");
    };
    diff_match_patch.prototype.diff_levenshtein = function(diffs) {
      var levenshtein = 0;
      var insertions = 0;
      var deletions = 0;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
          case DIFF_INSERT:
            insertions += data.length;
            break;
          case DIFF_DELETE:
            deletions += data.length;
            break;
          case DIFF_EQUAL:
            levenshtein += Math.max(insertions, deletions);
            insertions = 0;
            deletions = 0;
            break;
        }
      }
      levenshtein += Math.max(insertions, deletions);
      return levenshtein;
    };
    diff_match_patch.prototype.diff_toDelta = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
          case DIFF_INSERT:
            text[x] = "+" + encodeURI(diffs[x][1]);
            break;
          case DIFF_DELETE:
            text[x] = "-" + diffs[x][1].length;
            break;
          case DIFF_EQUAL:
            text[x] = "=" + diffs[x][1].length;
            break;
        }
      }
      return text.join("	").replace(/%20/g, " ");
    };
    diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
      var diffs = [];
      var diffsLength = 0;
      var pointer = 0;
      var tokens = delta.split(/\t/g);
      for (var x = 0; x < tokens.length; x++) {
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
          case "+":
            try {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
            } catch (ex) {
              throw new Error("Illegal escape in diff_fromDelta: " + param);
            }
            break;
          case "-":
          case "=":
            var n = parseInt(param, 10);
            if (isNaN(n) || n < 0) {
              throw new Error("Invalid number in diff_fromDelta: " + param);
            }
            var text = text1.substring(pointer, pointer += n);
            if (tokens[x].charAt(0) == "=") {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
            } else {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
            }
            break;
          default:
            if (tokens[x]) {
              throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
            }
        }
      }
      if (pointer != text1.length) {
        throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
      }
      return diffs;
    };
    diff_match_patch.prototype.match_main = function(text, pattern, loc) {
      if (text == null || pattern == null || loc == null) {
        throw new Error("Null input. (match_main)");
      }
      loc = Math.max(0, Math.min(loc, text.length));
      if (text == pattern) {
        return 0;
      } else if (!text.length) {
        return -1;
      } else if (text.substring(loc, loc + pattern.length) == pattern) {
        return loc;
      } else {
        return this.match_bitap_(text, pattern, loc);
      }
    };
    diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
      if (pattern.length > this.Match_MaxBits) {
        throw new Error("Pattern too long for this browser.");
      }
      var s = this.match_alphabet_(pattern);
      var dmp = this;
      function match_bitapScore_(e, x) {
        var accuracy = e / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
          return proximity ? 1 : accuracy;
        }
        return accuracy + proximity / dmp.Match_Distance;
      }
      var score_threshold = this.Match_Threshold;
      var best_loc = text.indexOf(pattern, loc);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        best_loc = text.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
      }
      var matchmask = 1 << pattern.length - 1;
      best_loc = -1;
      var bin_min, bin_mid;
      var bin_max = pattern.length + text.length;
      var last_rd;
      for (var d = 0; d < pattern.length; d++) {
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
          if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
            bin_min = bin_mid;
          } else {
            bin_max = bin_mid;
          }
          bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
          var charMatch = s[text.charAt(j - 1)];
          if (d === 0) {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
          } else {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
          }
          if (rd[j] & matchmask) {
            var score = match_bitapScore_(d, j - 1);
            if (score <= score_threshold) {
              score_threshold = score;
              best_loc = j - 1;
              if (best_loc > loc) {
                start = Math.max(1, 2 * loc - best_loc);
              } else {
                break;
              }
            }
          }
        }
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
          break;
        }
        last_rd = rd;
      }
      return best_loc;
    };
    diff_match_patch.prototype.match_alphabet_ = function(pattern) {
      var s = {};
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] = 0;
      }
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
      }
      return s;
    };
    diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
      if (text.length == 0) {
        return;
      }
      if (patch.start2 === null) {
        throw Error("patch not initialized");
      }
      var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
      var padding = 0;
      while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
      }
      padding += this.Patch_Margin;
      var prefix = text.substring(patch.start2 - padding, patch.start2);
      if (prefix) {
        patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
      }
      var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
      if (suffix) {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
      }
      patch.start1 -= prefix.length;
      patch.start2 -= prefix.length;
      patch.length1 += prefix.length + suffix.length;
      patch.length2 += prefix.length + suffix.length;
    };
    diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
      var text1, diffs;
      if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = this.diff_main(text1, opt_b, true);
        if (diffs.length > 2) {
          this.diff_cleanupSemantic(diffs);
          this.diff_cleanupEfficiency(diffs);
        }
      } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
        diffs = a;
        text1 = this.diff_text1(diffs);
      } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = opt_b;
      } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
        text1 = a;
        diffs = opt_c;
      } else {
        throw new Error("Unknown call format to patch_make.");
      }
      if (diffs.length === 0) {
        return [];
      }
      var patches = [];
      var patch = new diff_match_patch.patch_obj();
      var patchDiffLength = 0;
      var char_count1 = 0;
      var char_count2 = 0;
      var prepatch_text = text1;
      var postpatch_text = text1;
      for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];
        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
          patch.start1 = char_count1;
          patch.start2 = char_count2;
        }
        switch (diff_type) {
          case DIFF_INSERT:
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length2 += diff_text.length;
            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
            break;
          case DIFF_DELETE:
            patch.length1 += diff_text.length;
            patch.diffs[patchDiffLength++] = diffs[x];
            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
            break;
          case DIFF_EQUAL:
            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
              patch.diffs[patchDiffLength++] = diffs[x];
              patch.length1 += diff_text.length;
              patch.length2 += diff_text.length;
            } else if (diff_text.length >= 2 * this.Patch_Margin) {
              if (patchDiffLength) {
                this.patch_addContext_(patch, prepatch_text);
                patches.push(patch);
                patch = new diff_match_patch.patch_obj();
                patchDiffLength = 0;
                prepatch_text = postpatch_text;
                char_count1 = char_count2;
              }
            }
            break;
        }
        if (diff_type !== DIFF_INSERT) {
          char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE) {
          char_count2 += diff_text.length;
        }
      }
      if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
      }
      return patches;
    };
    diff_match_patch.prototype.patch_deepCopy = function(patches) {
      var patchesCopy = [];
      for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
          patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
      }
      return patchesCopy;
    };
    diff_match_patch.prototype.patch_apply = function(patches, text) {
      if (patches.length == 0) {
        return [text, []];
      }
      patches = this.patch_deepCopy(patches);
      var nullPadding = this.patch_addPadding(patches);
      text = nullPadding + text + nullPadding;
      this.patch_splitMax(patches);
      var delta = 0;
      var results = [];
      for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
          start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);
          if (start_loc != -1) {
            end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
            if (end_loc == -1 || start_loc >= end_loc) {
              start_loc = -1;
            }
          }
        } else {
          start_loc = this.match_main(text, text1, expected_loc);
        }
        if (start_loc == -1) {
          results[x] = false;
          delta -= patches[x].length2 - patches[x].length1;
        } else {
          results[x] = true;
          delta = start_loc - expected_loc;
          var text2;
          if (end_loc == -1) {
            text2 = text.substring(start_loc, start_loc + text1.length);
          } else {
            text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
          }
          if (text1 == text2) {
            text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);
          } else {
            var diffs = this.diff_main(text1, text2, false);
            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
              results[x] = false;
            } else {
              this.diff_cleanupSemanticLossless(diffs);
              var index1 = 0;
              var index2;
              for (var y = 0; y < patches[x].diffs.length; y++) {
                var mod = patches[x].diffs[y];
                if (mod[0] !== DIFF_EQUAL) {
                  index2 = this.diff_xIndex(diffs, index1);
                }
                if (mod[0] === DIFF_INSERT) {
                  text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
                } else if (mod[0] === DIFF_DELETE) {
                  text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));
                }
                if (mod[0] !== DIFF_DELETE) {
                  index1 += mod[1].length;
                }
              }
            }
          }
        }
      }
      text = text.substring(nullPadding.length, text.length - nullPadding.length);
      return [text, results];
    };
    diff_match_patch.prototype.patch_addPadding = function(patches) {
      var paddingLength = this.Patch_Margin;
      var nullPadding = "";
      for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
      }
      for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
      }
      var patch = patches[0];
      var diffs = patch.diffs;
      if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
        patch.start1 -= paddingLength;
        patch.start2 -= paddingLength;
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[0][1].length) {
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      patch = patches[patches.length - 1];
      diffs = patch.diffs;
      if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      return nullPadding;
    };
    diff_match_patch.prototype.patch_splitMax = function(patches) {
      var patch_size = this.Match_MaxBits;
      for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
          continue;
        }
        var bigpatch = patches[x];
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = "";
        while (bigpatch.diffs.length !== 0) {
          var patch = new diff_match_patch.patch_obj();
          var empty = true;
          patch.start1 = start1 - precontext.length;
          patch.start2 = start2 - precontext.length;
          if (precontext !== "") {
            patch.length1 = patch.length2 = precontext.length;
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
          }
          while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
            var diff_type = bigpatch.diffs[0][0];
            var diff_text = bigpatch.diffs[0][1];
            if (diff_type === DIFF_INSERT) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
              patch.diffs.push(bigpatch.diffs.shift());
              empty = false;
            } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              empty = false;
              patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
              bigpatch.diffs.shift();
            } else {
              diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              if (diff_type === DIFF_EQUAL) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
              } else {
                empty = false;
              }
              patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
              if (diff_text == bigpatch.diffs[0][1]) {
                bigpatch.diffs.shift();
              } else {
                bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
              }
            }
          }
          precontext = this.diff_text2(patch.diffs);
          precontext = precontext.substring(precontext.length - this.Patch_Margin);
          var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
          if (postcontext !== "") {
            patch.length1 += postcontext.length;
            patch.length2 += postcontext.length;
            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
              patch.diffs[patch.diffs.length - 1][1] += postcontext;
            } else {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
            }
          }
          if (!empty) {
            patches.splice(++x, 0, patch);
          }
        }
      }
    };
    diff_match_patch.prototype.patch_toText = function(patches) {
      var text = [];
      for (var x = 0; x < patches.length; x++) {
        text[x] = patches[x];
      }
      return text.join("");
    };
    diff_match_patch.prototype.patch_fromText = function(textline) {
      var patches = [];
      if (!textline) {
        return patches;
      }
      var text = textline.split("\n");
      var textPointer = 0;
      var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
      while (textPointer < text.length) {
        var m = text[textPointer].match(patchHeader);
        if (!m) {
          throw new Error("Invalid patch string: " + text[textPointer]);
        }
        var patch = new diff_match_patch.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === "") {
          patch.start1--;
          patch.length1 = 1;
        } else if (m[2] == "0") {
          patch.length1 = 0;
        } else {
          patch.start1--;
          patch.length1 = parseInt(m[2], 10);
        }
        patch.start2 = parseInt(m[3], 10);
        if (m[4] === "") {
          patch.start2--;
          patch.length2 = 1;
        } else if (m[4] == "0") {
          patch.length2 = 0;
        } else {
          patch.start2--;
          patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;
        while (textPointer < text.length) {
          var sign = text[textPointer].charAt(0);
          try {
            var line = decodeURI(text[textPointer].substring(1));
          } catch (ex) {
            throw new Error("Illegal escape in patch_fromText: " + line);
          }
          if (sign == "-") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
          } else if (sign == "+") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
          } else if (sign == " ") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
          } else if (sign == "@") {
            break;
          } else if (sign === "") {
          } else {
            throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
          }
          textPointer++;
        }
      }
      return patches;
    };
    diff_match_patch.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch.patch_obj.prototype.toString = function() {
      var coords1, coords2;
      if (this.length1 === 0) {
        coords1 = this.start1 + ",0";
      } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
      } else {
        coords1 = this.start1 + 1 + "," + this.length1;
      }
      if (this.length2 === 0) {
        coords2 = this.start2 + ",0";
      } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
      } else {
        coords2 = this.start2 + 1 + "," + this.length2;
      }
      var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
      var op;
      for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
          case DIFF_INSERT:
            op = "+";
            break;
          case DIFF_DELETE:
            op = "-";
            break;
          case DIFF_EQUAL:
            op = " ";
            break;
        }
        text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
      }
      return text.join("").replace(/%20/g, " ");
    };
    module2.exports = { diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL };
  }
});

// node_modules/playwright-core/lib/utils/comparators.js
var require_comparators = __commonJS({
  "node_modules/playwright-core/lib/utils/comparators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getComparator = getComparator;
    var _utilsBundle = require_utilsBundle();
    var _compare = require_compare();
    var pixelmatch = require_pixelmatch();
    var {
      diff_match_patch,
      DIFF_INSERT,
      DIFF_DELETE,
      DIFF_EQUAL
    } = require_diff_match_patch();
    function getComparator(mimeType) {
      if (mimeType === "image/png")
        return compareImages.bind(null, "image/png");
      if (mimeType === "image/jpeg")
        return compareImages.bind(null, "image/jpeg");
      if (mimeType === "text/plain")
        return compareText;
      return compareBuffersOrStrings;
    }
    var JPEG_JS_MAX_BUFFER_SIZE_IN_MB = 5 * 1024;
    function compareBuffersOrStrings(actualBuffer, expectedBuffer) {
      if (typeof actualBuffer === "string")
        return compareText(actualBuffer, expectedBuffer);
      if (!actualBuffer || !(actualBuffer instanceof Buffer))
        return {
          errorMessage: "Actual result should be a Buffer or a string."
        };
      if (Buffer.compare(actualBuffer, expectedBuffer))
        return {
          errorMessage: "Buffers differ"
        };
      return null;
    }
    function compareImages(mimeType, actualBuffer, expectedBuffer, options = {}) {
      var _options$_comparator, _ref;
      if (!actualBuffer || !(actualBuffer instanceof Buffer))
        return {
          errorMessage: "Actual result should be a Buffer."
        };
      validateBuffer(expectedBuffer, mimeType);
      let actual = mimeType === "image/png" ? _utilsBundle.PNG.sync.read(actualBuffer) : _utilsBundle.jpegjs.decode(actualBuffer, {
        maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB
      });
      let expected = mimeType === "image/png" ? _utilsBundle.PNG.sync.read(expectedBuffer) : _utilsBundle.jpegjs.decode(expectedBuffer, {
        maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB
      });
      const size = {
        width: Math.max(expected.width, actual.width),
        height: Math.max(expected.height, actual.height)
      };
      let sizesMismatchError = "";
      if (expected.width !== actual.width || expected.height !== actual.height) {
        sizesMismatchError = `Expected an image ${expected.width}px by ${expected.height}px, received ${actual.width}px by ${actual.height}px. `;
        actual = resizeImage(actual, size);
        expected = resizeImage(expected, size);
      }
      const diff = new _utilsBundle.PNG({
        width: size.width,
        height: size.height
      });
      let count;
      if (options._comparator === "ssim-cie94") {
        count = (0, _compare.compare)(expected.data, actual.data, diff.data, size.width, size.height, {
          maxColorDeltaE94: 1
        });
      } else if (((_options$_comparator = options._comparator) !== null && _options$_comparator !== void 0 ? _options$_comparator : "pixelmatch") === "pixelmatch") {
        var _options$threshold;
        count = pixelmatch(expected.data, actual.data, diff.data, size.width, size.height, {
          threshold: (_options$threshold = options.threshold) !== null && _options$threshold !== void 0 ? _options$threshold : 0.2
        });
      } else {
        throw new Error(`Configuration specifies unknown comparator "${options._comparator}"`);
      }
      const maxDiffPixels1 = options.maxDiffPixels;
      const maxDiffPixels2 = options.maxDiffPixelRatio !== void 0 ? expected.width * expected.height * options.maxDiffPixelRatio : void 0;
      let maxDiffPixels;
      if (maxDiffPixels1 !== void 0 && maxDiffPixels2 !== void 0)
        maxDiffPixels = Math.min(maxDiffPixels1, maxDiffPixels2);
      else
        maxDiffPixels = (_ref = maxDiffPixels1 !== null && maxDiffPixels1 !== void 0 ? maxDiffPixels1 : maxDiffPixels2) !== null && _ref !== void 0 ? _ref : 0;
      const ratio = Math.ceil(count / (expected.width * expected.height) * 100) / 100;
      const pixelsMismatchError = count > maxDiffPixels ? `${count} pixels (ratio ${ratio.toFixed(2)} of all image pixels) are different.` : "";
      if (pixelsMismatchError || sizesMismatchError)
        return {
          errorMessage: sizesMismatchError + pixelsMismatchError,
          diff: _utilsBundle.PNG.sync.write(diff)
        };
      return null;
    }
    function validateBuffer(buffer, mimeType) {
      if (mimeType === "image/png") {
        const pngMagicNumber = [137, 80, 78, 71, 13, 10, 26, 10];
        if (buffer.length < pngMagicNumber.length || !pngMagicNumber.every((byte, index) => buffer[index] === byte))
          throw new Error("could not decode image as PNG.");
      } else if (mimeType === "image/jpeg") {
        const jpegMagicNumber = [255, 216];
        if (buffer.length < jpegMagicNumber.length || !jpegMagicNumber.every((byte, index) => buffer[index] === byte))
          throw new Error("could not decode image as JPEG.");
      }
    }
    function compareText(actual, expectedBuffer) {
      if (typeof actual !== "string")
        return {
          errorMessage: "Actual result should be a string"
        };
      const expected = expectedBuffer.toString("utf-8");
      if (expected === actual)
        return null;
      const dmp = new diff_match_patch();
      const d = dmp.diff_main(expected, actual);
      dmp.diff_cleanupSemantic(d);
      return {
        errorMessage: diff_prettyTerminal(d)
      };
    }
    function diff_prettyTerminal(diffs) {
      const html = [];
      for (let x = 0; x < diffs.length; x++) {
        const op = diffs[x][0];
        const data = diffs[x][1];
        const text = data;
        switch (op) {
          case DIFF_INSERT:
            html[x] = _utilsBundle.colors.green(text);
            break;
          case DIFF_DELETE:
            html[x] = _utilsBundle.colors.reset(_utilsBundle.colors.strikethrough(_utilsBundle.colors.red(text)));
            break;
          case DIFF_EQUAL:
            html[x] = text;
            break;
        }
      }
      return html.join("");
    }
    function resizeImage(image, size) {
      if (image.width === size.width && image.height === size.height)
        return image;
      const buffer = new Uint8Array(size.width * size.height * 4);
      for (let y = 0; y < size.height; y++) {
        for (let x = 0; x < size.width; x++) {
          const to = (y * size.width + x) * 4;
          if (y < image.height && x < image.width) {
            const from = (y * image.width + x) * 4;
            buffer[to] = image.data[from];
            buffer[to + 1] = image.data[from + 1];
            buffer[to + 2] = image.data[from + 2];
            buffer[to + 3] = image.data[from + 3];
          } else {
            buffer[to] = 0;
            buffer[to + 1] = 0;
            buffer[to + 2] = 0;
            buffer[to + 3] = 0;
          }
        }
      }
      return {
        data: Buffer.from(buffer),
        width: size.width,
        height: size.height
      };
    }
  }
});

// node_modules/playwright-core/lib/utils/crypto.js
var require_crypto = __commonJS({
  "node_modules/playwright-core/lib/utils/crypto.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.calculateSha1 = calculateSha1;
    exports2.createGuid = createGuid;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createGuid() {
      return _crypto.default.randomBytes(16).toString("hex");
    }
    function calculateSha1(buffer) {
      const hash = _crypto.default.createHash("sha1");
      hash.update(buffer);
      return hash.digest("hex");
    }
  }
});

// node_modules/playwright-core/lib/utils/env.js
var require_env = __commonJS({
  "node_modules/playwright-core/lib/utils/env.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAsBooleanFromENV = getAsBooleanFromENV;
    exports2.getFromENV = getFromENV;
    exports2.getPackageManager = getPackageManager;
    function getFromENV(name) {
      let value = process.env[name];
      value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
      value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
      return value;
    }
    function getAsBooleanFromENV(name) {
      const value = getFromENV(name);
      return !!value && value !== "false" && value !== "0";
    }
    function getPackageManager() {
      const env = process.env.npm_config_user_agent || "";
      if (env.includes("yarn"))
        return "yarn";
      if (env.includes("pnpm"))
        return "pnpm";
      return "npm";
    }
  }
});

// node_modules/playwright-core/lib/utils/debug.js
var require_debug = __commonJS({
  "node_modules/playwright-core/lib/utils/debug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assert = assert;
    exports2.debugAssert = debugAssert;
    exports2.debugMode = debugMode;
    exports2.isUnderTest = isUnderTest;
    exports2.setUnderTest = setUnderTest;
    var _env = require_env();
    function assert(value, message) {
      if (!value)
        throw new Error(message || "Assertion error");
    }
    function debugAssert(value, message) {
      if (isUnderTest() && !value)
        throw new Error(message);
    }
    var debugEnv = (0, _env.getFromENV)("PWDEBUG") || "";
    function debugMode() {
      if (debugEnv === "console")
        return "console";
      if (debugEnv === "0" || debugEnv === "false")
        return "";
      return debugEnv ? "inspector" : "";
    }
    var _isUnderTest = !!process.env.PWTEST_UNDER_TEST;
    function setUnderTest() {
      _isUnderTest = true;
    }
    function isUnderTest() {
      return _isUnderTest;
    }
  }
});

// node_modules/playwright-core/lib/utils/eventsHelper.js
var require_eventsHelper = __commonJS({
  "node_modules/playwright-core/lib/utils/eventsHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.eventsHelper = void 0;
    var EventsHelper = class {
      static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return {
          emitter,
          eventName,
          handler
        };
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
    };
    var eventsHelper = EventsHelper;
    exports2.eventsHelper = eventsHelper;
  }
});

// node_modules/playwright-core/lib/utils/fileUtils.js
var require_fileUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/fileUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.canAccessFile = canAccessFile;
    exports2.copyFileAndMakeWritable = copyFileAndMakeWritable;
    exports2.existsAsync = void 0;
    exports2.mkdirIfNeeded = mkdirIfNeeded;
    exports2.removeFolders = removeFolders;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _utilsBundle = require_utilsBundle();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var existsAsync = (path) => new Promise((resolve) => _fs.default.stat(path, (err) => resolve(!err)));
    exports2.existsAsync = existsAsync;
    function mkdirIfNeeded(filePath) {
      return __async(this, null, function* () {
        yield _fs.default.promises.mkdir(_path.default.dirname(filePath), {
          recursive: true
        }).catch(() => {
        });
      });
    }
    function removeFolders(dirs) {
      return __async(this, null, function* () {
        return yield Promise.all(dirs.map((dir) => {
          return new Promise((fulfill) => {
            (0, _utilsBundle.rimraf)(dir, {
              maxBusyTries: 10
            }, (error) => {
              fulfill(error !== null && error !== void 0 ? error : void 0);
            });
          });
        }));
      });
    }
    function canAccessFile(file) {
      if (!file)
        return false;
      try {
        _fs.default.accessSync(file);
        return true;
      } catch (e) {
        return false;
      }
    }
    function copyFileAndMakeWritable(from, to) {
      return __async(this, null, function* () {
        yield _fs.default.promises.copyFile(from, to);
        yield _fs.default.promises.chmod(to, 436);
      });
    }
  }
});

// node_modules/playwright-core/lib/utils/glob.js
var require_glob = __commonJS({
  "node_modules/playwright-core/lib/utils/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.globToRegex = globToRegex;
    var escapedChars = /* @__PURE__ */ new Set(["$", "^", "+", ".", "*", "(", ")", "|", "\\", "?", "{", "}", "[", "]"]);
    function globToRegex(glob) {
      const tokens = ["^"];
      let inGroup = false;
      for (let i = 0; i < glob.length; ++i) {
        const c = glob[i];
        if (c === "\\" && i + 1 < glob.length) {
          const char = glob[++i];
          tokens.push(escapedChars.has(char) ? "\\" + char : char);
          continue;
        }
        if (c === "*") {
          const beforeDeep = glob[i - 1];
          let starCount = 1;
          while (glob[i + 1] === "*") {
            starCount++;
            i++;
          }
          const afterDeep = glob[i + 1];
          const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
          if (isDeep) {
            tokens.push("((?:[^/]*(?:/|$))*)");
            i++;
          } else {
            tokens.push("([^/]*)");
          }
          continue;
        }
        switch (c) {
          case "?":
            tokens.push(".");
            break;
          case "{":
            inGroup = true;
            tokens.push("(");
            break;
          case "}":
            inGroup = false;
            tokens.push(")");
            break;
          case ",":
            if (inGroup) {
              tokens.push("|");
              break;
            }
            tokens.push("\\" + c);
            break;
          default:
            tokens.push(escapedChars.has(c) ? "\\" + c : c);
        }
      }
      tokens.push("$");
      return new RegExp(tokens.join(""));
    }
  }
});

// node_modules/playwright-core/lib/utils/headers.js
var require_headers = __commonJS({
  "node_modules/playwright-core/lib/utils/headers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.headersArrayToObject = headersArrayToObject;
    exports2.headersObjectToArray = headersObjectToArray;
    function headersObjectToArray(headers, separator, setCookieSeparator) {
      if (!setCookieSeparator)
        setCookieSeparator = separator;
      const result = [];
      for (const name in headers) {
        const values = headers[name];
        if (values === void 0)
          continue;
        if (separator) {
          const sep = name.toLowerCase() === "set-cookie" ? setCookieSeparator : separator;
          for (const value of values.split(sep))
            result.push({
              name,
              value: value.trim()
            });
        } else {
          result.push({
            name,
            value: values
          });
        }
      }
      return result;
    }
    function headersArrayToObject(headers, lowerCase) {
      const result = {};
      for (const {
        name,
        value
      } of headers)
        result[lowerCase ? name.toLowerCase() : name] = value;
      return result;
    }
  }
});

// node_modules/playwright-core/lib/utils/rtti.js
var require_rtti = __commonJS({
  "node_modules/playwright-core/lib/utils/rtti.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isError = isError;
    exports2.isLikelyNpxGlobal = void 0;
    exports2.isObject = isObject;
    exports2.isRegExp = isRegExp;
    exports2.isString = isString;
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isObject(obj) {
      return typeof obj === "object" && obj !== null;
    }
    function isError(obj) {
      var _Object$getPrototypeO;
      return obj instanceof Error || obj && ((_Object$getPrototypeO = Object.getPrototypeOf(obj)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.name) === "Error";
    }
    var isLikelyNpxGlobal = () => process.argv.length >= 2 && process.argv[1].includes("_npx");
    exports2.isLikelyNpxGlobal = isLikelyNpxGlobal;
  }
});

// node_modules/playwright-core/lib/utils/stackTrace.js
var require_stackTrace = __commonJS({
  "node_modules/playwright-core/lib/utils/stackTrace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addInternalStackPrefix = void 0;
    exports2.captureLibraryStackTrace = captureLibraryStackTrace;
    exports2.captureRawStack = captureRawStack;
    exports2.rewriteErrorMessage = rewriteErrorMessage;
    exports2.splitErrorMessage = splitErrorMessage;
    var _path = _interopRequireDefault(require("path"));
    var _utilsBundle = require_utilsBundle();
    var _ = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rewriteErrorMessage(e, newMessage) {
      var _e$stack;
      const lines = (((_e$stack = e.stack) === null || _e$stack === void 0 ? void 0 : _e$stack.split("\n")) || []).filter((l) => l.startsWith("    at "));
      e.message = newMessage;
      const errorTitle = `${e.name}: ${e.message}`;
      if (lines.length)
        e.stack = `${errorTitle}
${lines.join("\n")}`;
      return e;
    }
    var CORE_DIR = _path.default.resolve(__dirname, "..", "..");
    var COVERAGE_PATH = _path.default.join(CORE_DIR, "..", "..", "tests", "config", "coverage.js");
    var internalStackPrefixes = [CORE_DIR];
    var addInternalStackPrefix = (prefix) => internalStackPrefixes.push(prefix);
    exports2.addInternalStackPrefix = addInternalStackPrefix;
    function captureRawStack() {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 50;
      const error = new Error();
      const stack = error.stack || "";
      Error.stackTraceLimit = stackTraceLimit;
      return stack.split("\n");
    }
    function captureLibraryStackTrace(rawStack) {
      const stack = rawStack || captureRawStack();
      const isTesting = (0, _.isUnderTest)();
      let parsedFrames = stack.map((line) => {
        const frame = (0, _utilsBundle.parseStackTraceLine)(line);
        if (!frame || !frame.file)
          return null;
        if (!process.env.PWDEBUGIMPL && isTesting && frame.file.includes(COVERAGE_PATH))
          return null;
        const isPlaywrightLibrary = frame.file.startsWith(CORE_DIR);
        const parsed = {
          frame,
          frameText: line,
          isPlaywrightLibrary
        };
        return parsed;
      }).filter(Boolean);
      let apiName = "";
      const allFrames = parsedFrames;
      for (let i = 0; i < parsedFrames.length - 1; i++) {
        const parsedFrame = parsedFrames[i];
        if (parsedFrame.isPlaywrightLibrary && !parsedFrames[i + 1].isPlaywrightLibrary) {
          apiName = apiName || normalizeAPIName(parsedFrame.frame.function);
          break;
        }
      }
      function normalizeAPIName(name) {
        if (!name)
          return "";
        const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);
        if (!match)
          return name;
        return match[1].toLowerCase() + match[2];
      }
      parsedFrames = parsedFrames.filter((f) => {
        if (process.env.PWDEBUGIMPL)
          return true;
        if (internalStackPrefixes.some((prefix) => f.frame.file.startsWith(prefix)))
          return false;
        return true;
      });
      return {
        allFrames: allFrames.map((p) => p.frame),
        frames: parsedFrames.map((p) => p.frame),
        frameTexts: parsedFrames.map((p) => p.frameText),
        apiName
      };
    }
    function splitErrorMessage(message) {
      const separationIdx = message.indexOf(":");
      return {
        name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
        message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
      };
    }
  }
});

// node_modules/playwright-core/lib/utils/manualPromise.js
var require_manualPromise = __commonJS({
  "node_modules/playwright-core/lib/utils/manualPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ScopedRace = exports2.ManualPromise = void 0;
    var _stackTrace = require_stackTrace();
    var _Symbol$species;
    var _Symbol$toStringTag;
    _Symbol$species = Symbol.species;
    _Symbol$toStringTag = Symbol.toStringTag;
    var ManualPromise = class extends Promise {
      constructor() {
        let resolve;
        let reject;
        super((f, r) => {
          resolve = f;
          reject = r;
        });
        this._resolve = void 0;
        this._reject = void 0;
        this._isDone = void 0;
        this._isDone = false;
        this._resolve = resolve;
        this._reject = reject;
      }
      isDone() {
        return this._isDone;
      }
      resolve(t) {
        this._isDone = true;
        this._resolve(t);
      }
      reject(e) {
        this._isDone = true;
        this._reject(e);
      }
      static get [_Symbol$species]() {
        return Promise;
      }
      get [_Symbol$toStringTag]() {
        return "ManualPromise";
      }
    };
    exports2.ManualPromise = ManualPromise;
    var ScopedRace = class {
      constructor() {
        this._terminateError = void 0;
        this._terminatePromises = /* @__PURE__ */ new Map();
      }
      scopeClosed(error) {
        this._terminateError = error;
        for (const [p, e] of this._terminatePromises) {
          (0, _stackTrace.rewriteErrorMessage)(e, error.message);
          p.resolve(e);
        }
      }
      race(promise) {
        return __async(this, null, function* () {
          return this._race([promise], false);
        });
      }
      safeRace(promise, defaultValue) {
        return __async(this, null, function* () {
          return this._race([promise], true, defaultValue);
        });
      }
      _race(promises, safe, defaultValue) {
        return __async(this, null, function* () {
          const terminatePromise = new ManualPromise();
          if (this._terminateError)
            terminatePromise.resolve(this._terminateError);
          const error = new Error("");
          this._terminatePromises.set(terminatePromise, error);
          try {
            return yield Promise.race([terminatePromise.then((e) => safe ? defaultValue : Promise.reject(e)), ...promises]);
          } finally {
            this._terminatePromises.delete(terminatePromise);
          }
        });
      }
    };
    exports2.ScopedRace = ScopedRace;
  }
});

// node_modules/playwright-core/lib/utils/happy-eyeballs.js
var require_happy_eyeballs = __commonJS({
  "node_modules/playwright-core/lib/utils/happy-eyeballs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSocket = createSocket;
    exports2.httpsHappyEyeballsAgent = exports2.httpHappyEyeballsAgent = void 0;
    var dns = _interopRequireWildcard(require("dns"));
    var http = _interopRequireWildcard(require("http"));
    var https = _interopRequireWildcard(require("https"));
    var net = _interopRequireWildcard(require("net"));
    var tls = _interopRequireWildcard(require("tls"));
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var connectionAttemptDelayMs = 300;
    var HttpHappyEyeballsAgent = class extends http.Agent {
      createConnection(options, oncreate) {
        if (net.isIP(clientRequestArgsToHostName(options)))
          return net.createConnection(options);
        createConnectionAsync(options, oncreate, false).catch((err) => oncreate === null || oncreate === void 0 ? void 0 : oncreate(err));
      }
    };
    var HttpsHappyEyeballsAgent = class extends https.Agent {
      createConnection(options, oncreate) {
        if (net.isIP(clientRequestArgsToHostName(options)))
          return tls.connect(options);
        createConnectionAsync(options, oncreate, true).catch((err) => oncreate === null || oncreate === void 0 ? void 0 : oncreate(err));
      }
    };
    var httpsHappyEyeballsAgent = new HttpsHappyEyeballsAgent();
    exports2.httpsHappyEyeballsAgent = httpsHappyEyeballsAgent;
    var httpHappyEyeballsAgent = new HttpHappyEyeballsAgent();
    exports2.httpHappyEyeballsAgent = httpHappyEyeballsAgent;
    function createSocket(host, port) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => {
          if (net.isIP(host)) {
            const socket = net.createConnection({
              host,
              port
            });
            socket.on("connect", () => resolve(socket));
            socket.on("error", (error) => reject(error));
          } else {
            createConnectionAsync({
              host,
              port
            }, (err, socket) => {
              if (err)
                reject(err);
              if (socket)
                resolve(socket);
            }, false).catch((err) => reject(err));
          }
        });
      });
    }
    function createConnectionAsync(options, oncreate, useTLS) {
      return __async(this, null, function* () {
        const lookup = options.__testHookLookup || lookupAddresses;
        const hostname = clientRequestArgsToHostName(options);
        const addresses = yield lookup(hostname);
        const sockets = /* @__PURE__ */ new Set();
        let firstError;
        let errorCount = 0;
        const handleError = (socket, err) => {
          var _firstError;
          if (!sockets.delete(socket))
            return;
          ++errorCount;
          (_firstError = firstError) !== null && _firstError !== void 0 ? _firstError : firstError = err;
          if (errorCount === addresses.length)
            oncreate === null || oncreate === void 0 ? void 0 : oncreate(firstError);
        };
        const connected = new _manualPromise.ManualPromise();
        for (const {
          address
        } of addresses) {
          const socket = useTLS ? tls.connect(__spreadProps(__spreadValues({}, options), {
            port: options.port,
            host: address,
            servername: hostname
          })) : net.createConnection(__spreadProps(__spreadValues({}, options), {
            port: options.port,
            host: address
          }));
          socket.on("connect", () => {
            connected.resolve();
            oncreate === null || oncreate === void 0 ? void 0 : oncreate(null, socket);
            sockets.delete(socket);
            for (const s of sockets)
              s.destroy();
            sockets.clear();
          });
          socket.on("timeout", () => {
            socket.destroy();
            handleError(socket, new Error("Connection timeout"));
          });
          socket.on("error", (e) => handleError(socket, e));
          sockets.add(socket);
          yield Promise.race([connected, new Promise((f) => setTimeout(f, connectionAttemptDelayMs))]);
          if (connected.isDone())
            break;
        }
      });
    }
    function lookupAddresses(hostname) {
      return __async(this, null, function* () {
        const addresses = yield dns.promises.lookup(hostname, {
          all: true,
          family: 0,
          verbatim: true
        });
        let firstFamily = addresses.filter(({
          family
        }) => family === 6);
        let secondFamily = addresses.filter(({
          family
        }) => family === 4);
        if (firstFamily.length && firstFamily[0] !== addresses[0]) {
          const tmp = firstFamily;
          firstFamily = secondFamily;
          secondFamily = tmp;
        }
        const result = [];
        for (let i = 0; i < Math.max(firstFamily.length, secondFamily.length); i++) {
          if (firstFamily[i])
            result.push(firstFamily[i]);
          if (secondFamily[i])
            result.push(secondFamily[i]);
        }
        return result;
      });
    }
    function clientRequestArgsToHostName(options) {
      if (options.hostname)
        return options.hostname;
      if (options.host)
        return options.host;
      throw new Error("Either options.hostname or options.host must be provided");
    }
  }
});

// node_modules/playwright-core/lib/utils/network.js
var require_network = __commonJS({
  "node_modules/playwright-core/lib/utils/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NET_DEFAULT_TIMEOUT = void 0;
    exports2.constructURLBasedOnBaseURL = constructURLBasedOnBaseURL;
    exports2.createHttpServer = createHttpServer;
    exports2.createHttpsServer = createHttpsServer;
    exports2.fetchData = fetchData;
    exports2.httpRequest = httpRequest;
    exports2.urlMatches = urlMatches;
    exports2.urlMatchesEqual = urlMatchesEqual;
    var _http = _interopRequireDefault(require("http"));
    var _https = _interopRequireDefault(require("https"));
    var _utilsBundle = require_utilsBundle();
    var URL2 = _interopRequireWildcard(require("url"));
    var _rtti = require_rtti();
    var _glob = require_glob();
    var _happyEyeballs = require_happy_eyeballs();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NET_DEFAULT_TIMEOUT = 3e4;
    exports2.NET_DEFAULT_TIMEOUT = NET_DEFAULT_TIMEOUT;
    function httpRequest(params, onResponse, onError) {
      var _params$timeout;
      const parsedUrl = URL2.parse(params.url);
      let options = __spreadProps(__spreadValues({}, parsedUrl), {
        agent: parsedUrl.protocol === "https:" ? _happyEyeballs.httpsHappyEyeballsAgent : _happyEyeballs.httpHappyEyeballsAgent,
        method: params.method || "GET",
        headers: params.headers
      });
      if (params.rejectUnauthorized !== void 0)
        options.rejectUnauthorized = params.rejectUnauthorized;
      const timeout = (_params$timeout = params.timeout) !== null && _params$timeout !== void 0 ? _params$timeout : NET_DEFAULT_TIMEOUT;
      const proxyURL = (0, _utilsBundle.getProxyForUrl)(params.url);
      if (proxyURL) {
        const parsedProxyURL = URL2.parse(proxyURL);
        if (params.url.startsWith("http:")) {
          options = {
            path: parsedUrl.href,
            host: parsedProxyURL.hostname,
            port: parsedProxyURL.port,
            headers: options.headers,
            method: options.method
          };
        } else {
          parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
          options.agent = new _utilsBundle.HttpsProxyAgent(parsedProxyURL);
          options.rejectUnauthorized = false;
        }
      }
      const requestCallback = (res) => {
        const statusCode = res.statusCode || 0;
        if (statusCode >= 300 && statusCode < 400 && res.headers.location)
          httpRequest(__spreadProps(__spreadValues({}, params), {
            url: new URL2.URL(res.headers.location, params.url).toString()
          }), onResponse, onError);
        else
          onResponse(res);
      };
      const request = options.protocol === "https:" ? _https.default.request(options, requestCallback) : _http.default.request(options, requestCallback);
      request.on("error", onError);
      if (timeout !== void 0) {
        const rejectOnTimeout = () => {
          onError(new Error(`Request to ${params.url} timed out after ${timeout}ms`));
          request.abort();
        };
        if (timeout <= 0) {
          rejectOnTimeout();
          return;
        }
        request.setTimeout(timeout, rejectOnTimeout);
      }
      request.end(params.data);
    }
    function fetchData(params, onError) {
      return new Promise((resolve, reject) => {
        httpRequest(params, (response) => __async(this, null, function* () {
          if (response.statusCode !== 200) {
            const error = onError ? yield onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
            reject(error);
            return;
          }
          let body = "";
          response.on("data", (chunk) => body += chunk);
          response.on("error", (error) => reject(error));
          response.on("end", () => resolve(body));
        }), reject);
      });
    }
    function urlMatchesEqual(match1, match2) {
      if ((0, _rtti.isRegExp)(match1) && (0, _rtti.isRegExp)(match2))
        return match1.source === match2.source && match1.flags === match2.flags;
      return match1 === match2;
    }
    function urlMatches(baseURL, urlString, match) {
      if (match === void 0 || match === "")
        return true;
      if ((0, _rtti.isString)(match) && !match.startsWith("*"))
        match = constructURLBasedOnBaseURL(baseURL, match);
      if ((0, _rtti.isString)(match))
        match = (0, _glob.globToRegex)(match);
      if ((0, _rtti.isRegExp)(match))
        return match.test(urlString);
      if (typeof match === "string" && match === urlString)
        return true;
      const url = parsedURL(urlString);
      if (!url)
        return false;
      if (typeof match === "string")
        return url.pathname === match;
      if (typeof match !== "function")
        throw new Error("url parameter should be string, RegExp or function");
      return match(url);
    }
    function parsedURL(url) {
      try {
        return new URL2.URL(url);
      } catch (e) {
        return null;
      }
    }
    function constructURLBasedOnBaseURL(baseURL, givenURL) {
      try {
        return new URL2.URL(givenURL, baseURL).toString();
      } catch (e) {
        return givenURL;
      }
    }
    function createHttpServer(...args) {
      const server = _http.default.createServer(...args);
      decorateServer(server);
      return server;
    }
    function createHttpsServer(...args) {
      const server = _https.default.createServer(...args);
      decorateServer(server);
      return server;
    }
    function decorateServer(server) {
      const sockets = /* @__PURE__ */ new Set();
      server.on("connection", (socket) => {
        sockets.add(socket);
        socket.once("close", () => sockets.delete(socket));
      });
      const close = server.close;
      server.close = (callback) => {
        for (const socket of sockets)
          socket.destroy();
        sockets.clear();
        return close.call(server, callback);
      };
    }
  }
});

// node_modules/playwright-core/lib/utils/httpServer.js
var require_httpServer = __commonJS({
  "node_modules/playwright-core/lib/utils/httpServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HttpServer = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _utilsBundle = require_utilsBundle();
    var _debug = require_debug();
    var _network = require_network();
    var _manualPromise = require_manualPromise();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var HttpServer = class {
      constructor(address = "") {
        this._server = void 0;
        this._urlPrefix = void 0;
        this._port = 0;
        this._started = false;
        this._routes = [];
        this._urlPrefix = address;
        this._server = (0, _network.createHttpServer)(this._onRequest.bind(this));
      }
      server() {
        return this._server;
      }
      routePrefix(prefix, handler) {
        this._routes.push({
          prefix,
          handler
        });
      }
      routePath(path, handler) {
        this._routes.push({
          exact: path,
          handler
        });
      }
      port() {
        return this._port;
      }
      _tryStart(port, host) {
        return __async(this, null, function* () {
          const errorPromise = new _manualPromise.ManualPromise();
          const errorListener = (error) => errorPromise.reject(error);
          this._server.on("error", errorListener);
          try {
            this._server.listen(port, host);
            yield Promise.race([new Promise((cb) => this._server.once("listening", cb)), errorPromise]);
          } finally {
            this._server.removeListener("error", errorListener);
          }
        });
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          (0, _debug.assert)(!this._started, "server already started");
          this._started = true;
          const host = options.host || "localhost";
          if (options.preferredPort) {
            try {
              yield this._tryStart(options.preferredPort, host);
            } catch (e) {
              if (!e || !e.message || !e.message.includes("EADDRINUSE"))
                throw e;
              yield this._tryStart(void 0, host);
            }
          } else {
            yield this._tryStart(options.port, host);
          }
          const address = this._server.address();
          (0, _debug.assert)(address, "Could not bind server socket");
          if (!this._urlPrefix) {
            if (typeof address === "string") {
              this._urlPrefix = address;
            } else {
              this._port = address.port;
              this._urlPrefix = `http://${host}:${address.port}`;
            }
          }
          return this._urlPrefix;
        });
      }
      stop() {
        return __async(this, null, function* () {
          yield new Promise((cb) => this._server.close(cb));
        });
      }
      urlPrefix() {
        return this._urlPrefix;
      }
      serveFile(request, response, absoluteFilePath, headers) {
        try {
          for (const [name, value] of Object.entries(headers || {}))
            response.setHeader(name, value);
          if (request.headers.range)
            this._serveRangeFile(request, response, absoluteFilePath);
          else
            this._serveFile(response, absoluteFilePath);
          return true;
        } catch (e) {
          return false;
        }
      }
      _serveFile(response, absoluteFilePath) {
        const content = _fs.default.readFileSync(absoluteFilePath);
        response.statusCode = 200;
        const contentType = _utilsBundle.mime.getType(_path.default.extname(absoluteFilePath)) || "application/octet-stream";
        response.setHeader("Content-Type", contentType);
        response.setHeader("Content-Length", content.byteLength);
        response.end(content);
      }
      _serveRangeFile(request, response, absoluteFilePath) {
        const range = request.headers.range;
        if (!range || !range.startsWith("bytes=") || range.includes(", ") || [...range].filter((char) => char === "-").length !== 1) {
          response.statusCode = 400;
          return response.end("Bad request");
        }
        const [startStr, endStr] = range.replace(/bytes=/, "").split("-");
        let start;
        let end;
        const size = _fs.default.statSync(absoluteFilePath).size;
        if (startStr !== "" && endStr === "") {
          start = +startStr;
          end = size - 1;
        } else if (startStr === "" && endStr !== "") {
          start = size - +endStr;
          end = size - 1;
        } else {
          start = +startStr;
          end = +endStr;
        }
        if (Number.isNaN(start) || Number.isNaN(end) || start >= size || end >= size || start > end) {
          response.writeHead(416, {
            "Content-Range": `bytes */${size}`
          });
          return response.end();
        }
        response.writeHead(206, {
          "Content-Range": `bytes ${start}-${end}/${size}`,
          "Accept-Ranges": "bytes",
          "Content-Length": end - start + 1,
          "Content-Type": _utilsBundle.mime.getType(_path.default.extname(absoluteFilePath))
        });
        const readable = _fs.default.createReadStream(absoluteFilePath, {
          start,
          end
        });
        readable.pipe(response);
      }
      _onRequest(request, response) {
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Request-Method", "*");
        response.setHeader("Access-Control-Allow-Methods", "OPTIONS, GET");
        if (request.headers.origin)
          response.setHeader("Access-Control-Allow-Headers", request.headers.origin);
        if (request.method === "OPTIONS") {
          response.writeHead(200);
          response.end();
          return;
        }
        request.on("error", () => response.end());
        try {
          if (!request.url) {
            response.end();
            return;
          }
          const url = new URL("http://localhost" + request.url);
          for (const route of this._routes) {
            if (route.exact && url.pathname === route.exact && route.handler(request, response))
              return;
            if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response))
              return;
          }
          response.statusCode = 404;
          response.end();
        } catch (e) {
          response.end();
        }
      }
    };
    exports2.HttpServer = HttpServer;
  }
});

// node_modules/playwright-core/lib/utils/mimeType.js
var require_mimeType = __commonJS({
  "node_modules/playwright-core/lib/utils/mimeType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isJsonMimeType = isJsonMimeType;
    exports2.isTextualMimeType = isTextualMimeType;
    function isJsonMimeType(mimeType) {
      return !!mimeType.match(/^(application\/json|application\/.*?\+json|text\/(x-)?json)(;\s*charset=.*)?$/);
    }
    function isTextualMimeType(mimeType) {
      return !!mimeType.match(/^(text\/.*?|application\/(json|(x-)?javascript|xml.*?|ecmascript|graphql|x-www-form-urlencoded)|image\/svg(\+xml)?|application\/.*?(\+json|\+xml))(;\s*charset=.*)?$/);
    }
  }
});

// node_modules/playwright-core/lib/utils/multimap.js
var require_multimap = __commonJS({
  "node_modules/playwright-core/lib/utils/multimap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MultiMap = void 0;
    var _Symbol$iterator;
    _Symbol$iterator = Symbol.iterator;
    var MultiMap = class {
      constructor() {
        this._map = void 0;
        this._map = /* @__PURE__ */ new Map();
      }
      set(key, value) {
        let values = this._map.get(key);
        if (!values) {
          values = [];
          this._map.set(key, values);
        }
        values.push(value);
      }
      get(key) {
        return this._map.get(key) || [];
      }
      has(key) {
        return this._map.has(key);
      }
      delete(key, value) {
        const values = this._map.get(key);
        if (!values)
          return;
        if (values.includes(value))
          this._map.set(key, values.filter((v) => value !== v));
      }
      deleteAll(key) {
        this._map.delete(key);
      }
      hasValue(key, value) {
        const values = this._map.get(key);
        if (!values)
          return false;
        return values.includes(value);
      }
      get size() {
        return this._map.size;
      }
      [_Symbol$iterator]() {
        return this._map[Symbol.iterator]();
      }
      keys() {
        return this._map.keys();
      }
      values() {
        const result = [];
        for (const key of this.keys())
          result.push(...this.get(key));
        return result;
      }
      clear() {
        this._map.clear();
      }
    };
    exports2.MultiMap = MultiMap;
  }
});

// node_modules/playwright-core/lib/utils/processLauncher.js
var require_processLauncher = __commonJS({
  "node_modules/playwright-core/lib/utils/processLauncher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.envArrayToObject = envArrayToObject;
    exports2.gracefullyCloseAll = gracefullyCloseAll;
    exports2.gracefullyCloseSet = void 0;
    exports2.launchProcess = launchProcess;
    var childProcess = _interopRequireWildcard(require("child_process"));
    var readline = _interopRequireWildcard(require("readline"));
    var path = _interopRequireWildcard(require("path"));
    var _ = require_utils();
    var _fileUtils = require_fileUtils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var gracefullyCloseSet = /* @__PURE__ */ new Set();
    exports2.gracefullyCloseSet = gracefullyCloseSet;
    var killSet = /* @__PURE__ */ new Set();
    function gracefullyCloseAll() {
      return __async(this, null, function* () {
        yield Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
        })));
      });
    }
    function exitHandler() {
      for (const kill of killSet)
        kill();
    }
    var sigintHandlerCalled = false;
    function sigintHandler() {
      const exitWithCode130 = () => {
        if ((0, _.isUnderTest)())
          setTimeout(() => process.exit(130), 1e3);
        else
          process.exit(130);
      };
      if (sigintHandlerCalled) {
        process.off("SIGINT", sigintHandler);
        for (const kill of killSet)
          kill();
        exitWithCode130();
      } else {
        sigintHandlerCalled = true;
        gracefullyCloseAll().then(() => exitWithCode130());
      }
    }
    function sigtermHandler() {
      gracefullyCloseAll();
    }
    function sighupHandler() {
      gracefullyCloseAll();
    }
    var installedHandlers = /* @__PURE__ */ new Set();
    var processHandlers = {
      exit: exitHandler,
      SIGINT: sigintHandler,
      SIGTERM: sigtermHandler,
      SIGHUP: sighupHandler
    };
    function addProcessHandlerIfNeeded(name) {
      if (!installedHandlers.has(name)) {
        installedHandlers.add(name);
        process.on(name, processHandlers[name]);
      }
    }
    function launchProcess(options) {
      return __async(this, null, function* () {
        const stdio = options.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
        options.log(`<launching> ${options.command} ${options.args ? options.args.join(" ") : ""}`);
        const spawnOptions = {
          detached: process.platform !== "win32",
          env: options.env,
          cwd: options.cwd,
          shell: options.shell,
          stdio
        };
        const spawnedProcess = childProcess.spawn(options.command, options.args || [], spawnOptions);
        const cleanup = () => __async(this, null, function* () {
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
          const errors = yield (0, _fileUtils.removeFolders)(options.tempDirectories);
          for (let i = 0; i < options.tempDirectories.length; ++i) {
            if (errors[i])
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);
          }
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
        });
        spawnedProcess.on("error", () => {
        });
        if (!spawnedProcess.pid) {
          let failed;
          const failedPromise = new Promise((f, r) => failed = f);
          spawnedProcess.once("error", (error) => {
            failed(new Error("Failed to launch: " + error));
          });
          return cleanup().then(() => failedPromise).then((e) => Promise.reject(e));
        }
        options.log(`<launched> pid=${spawnedProcess.pid}`);
        const stdout = readline.createInterface({
          input: spawnedProcess.stdout
        });
        stdout.on("line", (data) => {
          options.log(`[pid=${spawnedProcess.pid}][out] ` + data);
        });
        const stderr = readline.createInterface({
          input: spawnedProcess.stderr
        });
        stderr.on("line", (data) => {
          options.log(`[pid=${spawnedProcess.pid}][err] ` + data);
        });
        let processClosed = false;
        let fulfillCleanup = () => {
        };
        const waitForCleanup = new Promise((f) => fulfillCleanup = f);
        spawnedProcess.once("exit", (exitCode, signal) => {
          options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
          processClosed = true;
          gracefullyCloseSet.delete(gracefullyClose);
          killSet.delete(killProcessAndCleanup);
          options.onExit(exitCode, signal);
          cleanup().then(fulfillCleanup);
        });
        addProcessHandlerIfNeeded("exit");
        if (options.handleSIGINT)
          addProcessHandlerIfNeeded("SIGINT");
        if (options.handleSIGTERM)
          addProcessHandlerIfNeeded("SIGTERM");
        if (options.handleSIGHUP)
          addProcessHandlerIfNeeded("SIGHUP");
        gracefullyCloseSet.add(gracefullyClose);
        killSet.add(killProcessAndCleanup);
        let gracefullyClosing = false;
        function gracefullyClose() {
          return __async(this, null, function* () {
            if (gracefullyClosing) {
              options.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
              killProcess();
              yield waitForCleanup;
              return;
            }
            gracefullyClosing = true;
            options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
            yield options.attemptToGracefullyClose().catch(() => killProcess());
            yield waitForCleanup;
            options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
          });
        }
        function killProcess() {
          gracefullyCloseSet.delete(gracefullyClose);
          killSet.delete(killProcessAndCleanup);
          options.log(`[pid=${spawnedProcess.pid}] <kill>`);
          if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
            options.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
            try {
              if (process.platform === "win32") {
                const taskkillProcess = childProcess.spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F`, {
                  shell: true
                });
                const [stdout2, stderr2] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];
                if (stdout2)
                  options.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout2}`);
                if (stderr2)
                  options.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr2}`);
              } else {
                process.kill(-spawnedProcess.pid, "SIGKILL");
              }
            } catch (e) {
              options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
            }
          } else {
            options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
          }
        }
        function killProcessAndCleanup() {
          killProcess();
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
          if (options.tempDirectories.length) {
            const cleanupProcess = childProcess.spawnSync(process.argv0, [path.join(__dirname, "processLauncherCleanupEntrypoint.js"), ...options.tempDirectories]);
            const [stdout2, stderr2] = [cleanupProcess.stdout.toString(), cleanupProcess.stderr.toString()];
            if (stdout2)
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] ${stdout2}`);
            if (stderr2)
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] ${stderr2}`);
          }
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
        }
        function killAndWait() {
          killProcess();
          return waitForCleanup;
        }
        return {
          launchedProcess: spawnedProcess,
          gracefullyClose,
          kill: killAndWait
        };
      });
    }
    function envArrayToObject(env) {
      const result = {};
      for (const {
        name,
        value
      } of env)
        result[name] = value;
      return result;
    }
  }
});

// node_modules/playwright-core/lib/utils/profiler.js
var require_profiler = __commonJS({
  "node_modules/playwright-core/lib/utils/profiler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.startProfiling = startProfiling;
    exports2.stopProfiling = stopProfiling;
    var fs = _interopRequireWildcard(require("fs"));
    var path = _interopRequireWildcard(require("path"));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var profileDir = process.env.PWTEST_PROFILE_DIR || "";
    var session;
    function startProfiling() {
      return __async(this, null, function* () {
        if (!profileDir)
          return;
        session = new (require("inspector")).Session();
        session.connect();
        yield new Promise((f) => {
          session.post("Profiler.enable", () => {
            session.post("Profiler.start", f);
          });
        });
      });
    }
    function stopProfiling(profileName) {
      return __async(this, null, function* () {
        if (!profileDir)
          return;
        yield new Promise((f) => session.post("Profiler.stop", (err, {
          profile
        }) => {
          if (!err) {
            fs.mkdirSync(profileDir, {
              recursive: true
            });
            fs.writeFileSync(path.join(profileDir, profileName + ".json"), JSON.stringify(profile));
          }
          f();
        }));
      });
    }
  }
});

// node_modules/playwright-core/lib/utils/spawnAsync.js
var require_spawnAsync = __commonJS({
  "node_modules/playwright-core/lib/utils/spawnAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.spawnAsync = spawnAsync;
    var _child_process = require("child_process");
    function spawnAsync(cmd, args, options = {}) {
      const process2 = (0, _child_process.spawn)(cmd, args, Object.assign({
        windowsHide: true
      }, options));
      return new Promise((resolve) => {
        let stdout = "";
        let stderr = "";
        if (process2.stdout)
          process2.stdout.on("data", (data) => stdout += data);
        if (process2.stderr)
          process2.stderr.on("data", (data) => stderr += data);
        process2.on("close", (code) => resolve({
          stdout,
          stderr,
          code
        }));
        process2.on("error", (error) => resolve({
          stdout,
          stderr,
          code: 0,
          error
        }));
      });
    }
  }
});

// node_modules/playwright-core/lib/utils/task.js
var require_task = __commonJS({
  "node_modules/playwright-core/lib/utils/task.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.makeWaitForNextTask = makeWaitForNextTask;
    function makeWaitForNextTask() {
      if (process.versions.electron)
        return (callback) => setTimeout(callback, 0);
      if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
      let spinning = false;
      const callbacks = [];
      const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
          spinning = false;
          return;
        }
        setImmediate(loop);
        callback();
      };
      return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
          spinning = true;
          setImmediate(loop);
        }
      };
    }
  }
});

// node_modules/playwright-core/lib/utils/time.js
var require_time = __commonJS({
  "node_modules/playwright-core/lib/utils/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.monotonicTime = monotonicTime;
    function monotonicTime() {
      const [seconds, nanoseconds] = process.hrtime();
      return seconds * 1e3 + (nanoseconds / 1e3 | 0) / 1e3;
    }
  }
});

// node_modules/playwright-core/lib/utils/timeoutRunner.js
var require_timeoutRunner = __commonJS({
  "node_modules/playwright-core/lib/utils/timeoutRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutRunnerError = exports2.TimeoutRunner = void 0;
    exports2.pollAgainstTimeout = pollAgainstTimeout;
    exports2.raceAgainstTimeout = raceAgainstTimeout;
    var _manualPromise = require_manualPromise();
    var _ = require_utils();
    var TimeoutRunnerError = class extends Error {
    };
    exports2.TimeoutRunnerError = TimeoutRunnerError;
    var TimeoutRunner = class {
      constructor(timeout) {
        this._running = void 0;
        this._timeout = void 0;
        this._elapsed = void 0;
        this._timeout = timeout;
        this._elapsed = 0;
      }
      run(cb) {
        return __async(this, null, function* () {
          const running = this._running = {
            lastElapsedSync: (0, _.monotonicTime)(),
            timer: void 0,
            timeoutPromise: new _manualPromise.ManualPromise()
          };
          try {
            const resultPromise = Promise.race([cb(), running.timeoutPromise]);
            this._updateTimeout(running, this._timeout);
            return yield resultPromise;
          } finally {
            this._updateTimeout(running, 0);
            if (this._running === running)
              this._running = void 0;
          }
        });
      }
      interrupt() {
        if (this._running)
          this._updateTimeout(this._running, -1);
      }
      elapsed() {
        this._syncElapsedAndStart();
        return this._elapsed;
      }
      updateTimeout(timeout, elapsed) {
        this._timeout = timeout;
        if (elapsed !== void 0) {
          this._syncElapsedAndStart();
          this._elapsed = elapsed;
        }
        if (this._running)
          this._updateTimeout(this._running, timeout);
      }
      _syncElapsedAndStart() {
        if (this._running) {
          const now = (0, _.monotonicTime)();
          this._elapsed += now - this._running.lastElapsedSync;
          this._running.lastElapsedSync = now;
        }
      }
      _updateTimeout(running, timeout) {
        if (running.timer) {
          clearTimeout(running.timer);
          running.timer = void 0;
        }
        this._syncElapsedAndStart();
        if (timeout === 0)
          return;
        timeout = timeout - this._elapsed;
        if (timeout <= 0)
          running.timeoutPromise.reject(new TimeoutRunnerError());
        else
          running.timer = setTimeout(() => running.timeoutPromise.reject(new TimeoutRunnerError()), timeout);
      }
    };
    exports2.TimeoutRunner = TimeoutRunner;
    function raceAgainstTimeout(cb, timeout) {
      return __async(this, null, function* () {
        const runner = new TimeoutRunner(timeout);
        try {
          return {
            result: yield runner.run(cb),
            timedOut: false
          };
        } catch (e) {
          if (e instanceof TimeoutRunnerError)
            return {
              timedOut: true
            };
          throw e;
        }
      });
    }
    function pollAgainstTimeout(_0, _1) {
      return __async(this, arguments, function* (callback, timeout, pollIntervals = [100, 250, 500, 1e3]) {
        var _pollIntervals$pop;
        const startTime = (0, _.monotonicTime)();
        const lastPollInterval = (_pollIntervals$pop = pollIntervals.pop()) !== null && _pollIntervals$pop !== void 0 ? _pollIntervals$pop : 1e3;
        let lastResult;
        const wrappedCallback = () => Promise.resolve().then(callback);
        while (true) {
          var _shift;
          const elapsed = (0, _.monotonicTime)() - startTime;
          if (timeout !== 0 && elapsed >= timeout)
            break;
          const received = timeout !== 0 ? yield raceAgainstTimeout(wrappedCallback, timeout - elapsed) : yield wrappedCallback().then((value) => ({
            result: value,
            timedOut: false
          }));
          if (received.timedOut)
            break;
          lastResult = received.result.result;
          if (!received.result.continuePolling)
            return {
              result: lastResult,
              timedOut: false
            };
          const interval = (_shift = pollIntervals.shift()) !== null && _shift !== void 0 ? _shift : lastPollInterval;
          if (timeout !== 0 && startTime + timeout <= (0, _.monotonicTime)() + interval)
            break;
          yield new Promise((x) => setTimeout(x, interval));
        }
        return {
          timedOut: true,
          result: lastResult
        };
      });
    }
  }
});

// node_modules/playwright-core/lib/zipBundleImpl.js
var require_zipBundleImpl = __commonJS({
  "node_modules/playwright-core/lib/zipBundleImpl.js"(exports2, module2) {
    "use strict";
    var ht = Object.create;
    var ae = Object.defineProperty;
    var pt = Object.getOwnPropertyDescriptor;
    var mt = Object.getOwnPropertyNames;
    var xt = Object.getPrototypeOf;
    var vt = Object.prototype.hasOwnProperty;
    var E = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
    var Et = (e, r) => {
      for (var t in r)
        ae(e, t, { get: r[t], enumerable: true });
    };
    var or = (e, r, t, n) => {
      if (r && typeof r == "object" || typeof r == "function")
        for (let i of mt(r))
          !vt.call(e, i) && i !== t && ae(e, i, { get: () => r[i], enumerable: !(n = pt(r, i)) || n.enumerable });
      return e;
    };
    var Ue = (e, r, t) => (t = e != null ? ht(xt(e)) : {}, or(r || !e || !e.__esModule ? ae(t, "default", { value: e, enumerable: true }) : t, e));
    var wt = (e) => or(ae({}, "__esModule", { value: true }), e);
    var Be = E((An, fr) => {
      var T = require("buffer").Buffer, Te = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
      typeof Int32Array != "undefined" && (Te = new Int32Array(Te));
      function sr(e) {
        if (T.isBuffer(e))
          return e;
        var r = typeof T.alloc == "function" && typeof T.from == "function";
        if (typeof e == "number")
          return r ? T.alloc(e) : new T(e);
        if (typeof e == "string")
          return r ? T.from(e) : new T(e);
        throw new Error("input must be buffer, number, or string, received " + typeof e);
      }
      function gt(e) {
        var r = sr(4);
        return r.writeInt32BE(e, 0), r;
      }
      function Ne(e, r) {
        e = sr(e), T.isBuffer(r) && (r = r.readUInt32BE(0));
        for (var t = ~~r ^ -1, n = 0; n < e.length; n++)
          t = Te[(t ^ e[n]) & 255] ^ t >>> 8;
        return t ^ -1;
      }
      function Me() {
        return gt(Ne.apply(null, arguments));
      }
      Me.signed = function() {
        return Ne.apply(null, arguments);
      };
      Me.unsigned = function() {
        return Ne.apply(null, arguments) >>> 0;
      };
      fr.exports = Me;
    });
    var br = E((Ge) => {
      var ar = require("fs"), he = require("stream").Transform, ur = require("stream").PassThrough, cr = require("zlib"), We = require("util"), yt = require("events").EventEmitter, dr = Be();
      Ge.ZipFile = W;
      Ge.dateToDosDateTime = Cr;
      We.inherits(W, yt);
      function W() {
        this.outputStream = new ur(), this.entries = [], this.outputStreamCursor = 0, this.ended = false, this.allDone = false, this.forceZip64Eocd = false;
      }
      W.prototype.addFile = function(e, r, t) {
        var n = this;
        r = pe(r, false), t == null && (t = {});
        var i = new m(r, false, t);
        n.entries.push(i), ar.stat(e, function(o, s) {
          if (o)
            return n.emit("error", o);
          if (!s.isFile())
            return n.emit("error", new Error("not a file: " + e));
          i.uncompressedSize = s.size, t.mtime == null && i.setLastModDate(s.mtime), t.mode == null && i.setFileAttributesMode(s.mode), i.setFileDataPumpFunction(function() {
            var f = ar.createReadStream(e);
            i.state = m.FILE_DATA_IN_PROGRESS, f.on("error", function(u) {
              n.emit("error", u);
            }), lr(n, i, f);
          }), M(n);
        });
      };
      W.prototype.addReadStream = function(e, r, t) {
        var n = this;
        r = pe(r, false), t == null && (t = {});
        var i = new m(r, false, t);
        n.entries.push(i), i.setFileDataPumpFunction(function() {
          i.state = m.FILE_DATA_IN_PROGRESS, lr(n, i, e);
        }), M(n);
      };
      W.prototype.addBuffer = function(e, r, t) {
        var n = this;
        if (r = pe(r, false), e.length > 1073741823)
          throw new Error("buffer too large: " + e.length + " > " + 1073741823);
        if (t == null && (t = {}), t.size != null)
          throw new Error("options.size not allowed");
        var i = new m(r, false, t);
        i.uncompressedSize = e.length, i.crc32 = dr.unsigned(e), i.crcAndFileSizeKnown = true, n.entries.push(i), i.compress ? cr.deflateRaw(e, function(s, f) {
          o(f);
        }) : o(e);
        function o(s) {
          i.compressedSize = s.length, i.setFileDataPumpFunction(function() {
            Z(n, s), Z(n, i.getDataDescriptor()), i.state = m.FILE_DATA_DONE, setImmediate(function() {
              M(n);
            });
          }), M(n);
        }
      };
      W.prototype.addEmptyDirectory = function(e, r) {
        var t = this;
        if (e = pe(e, true), r == null && (r = {}), r.size != null)
          throw new Error("options.size not allowed");
        if (r.compress != null)
          throw new Error("options.compress not allowed");
        var n = new m(e, true, r);
        t.entries.push(n), n.setFileDataPumpFunction(function() {
          Z(t, n.getDataDescriptor()), n.state = m.FILE_DATA_DONE, M(t);
        }), M(t);
      };
      var Ct = N([80, 75, 5, 6]);
      W.prototype.end = function(e, r) {
        if (typeof e == "function" && (r = e, e = null), e == null && (e = {}), !this.ended) {
          if (this.ended = true, this.finalSizeCallback = r, this.forceZip64Eocd = !!e.forceZip64Format, e.comment) {
            if (typeof e.comment == "string" ? this.comment = St(e.comment) : this.comment = e.comment, this.comment.length > 65535)
              throw new Error("comment is too large");
            if (te(this.comment, Ct))
              throw new Error("comment contains end of central directory record signature");
          } else
            this.comment = me;
          M(this);
        }
      };
      function Z(e, r) {
        e.outputStream.write(r), e.outputStreamCursor += r.length;
      }
      function lr(e, r, t) {
        var n = new He(), i = new le(), o = r.compress ? new cr.DeflateRaw() : new ur(), s = new le();
        t.pipe(n).pipe(i).pipe(o).pipe(s).pipe(e.outputStream, { end: false }), s.on("end", function() {
          if (r.crc32 = n.crc32, r.uncompressedSize == null)
            r.uncompressedSize = i.byteCount;
          else if (r.uncompressedSize !== i.byteCount)
            return e.emit("error", new Error("file data stream has unexpected number of bytes"));
          r.compressedSize = s.byteCount, e.outputStreamCursor += r.compressedSize, Z(e, r.getDataDescriptor()), r.state = m.FILE_DATA_DONE, M(e);
        });
      }
      function M(e) {
        if (e.allDone)
          return;
        if (e.ended && e.finalSizeCallback != null) {
          var r = bt(e);
          r != null && (e.finalSizeCallback(r), e.finalSizeCallback = null);
        }
        var t = n();
        function n() {
          for (var o = 0; o < e.entries.length; o++) {
            var s = e.entries[o];
            if (s.state < m.FILE_DATA_DONE)
              return s;
          }
          return null;
        }
        if (t != null) {
          if (t.state < m.READY_TO_PUMP_FILE_DATA || t.state === m.FILE_DATA_IN_PROGRESS)
            return;
          t.relativeOffsetOfLocalHeader = e.outputStreamCursor;
          var i = t.getLocalFileHeader();
          Z(e, i), t.doFileDataPump();
        } else
          e.ended && (e.offsetOfStartOfCentralDirectory = e.outputStreamCursor, e.entries.forEach(function(o) {
            var s = o.getCentralDirectoryRecord();
            Z(e, s);
          }), Z(e, Ft(e)), e.outputStream.end(), e.allDone = true);
      }
      function bt(e) {
        for (var r = 0, t = 0, n = 0; n < e.entries.length; n++) {
          var i = e.entries[n];
          if (i.compress)
            return -1;
          if (i.state >= m.READY_TO_PUMP_FILE_DATA) {
            if (i.uncompressedSize == null)
              return -1;
          } else if (i.uncompressedSize == null)
            return null;
          i.relativeOffsetOfLocalHeader = r;
          var o = i.useZip64Format();
          r += hr + i.utf8FileName.length, r += i.uncompressedSize, i.crcAndFileSizeKnown || (o ? r += gr : r += wr), t += yr + i.utf8FileName.length + i.fileComment.length, o && (t += Pe);
        }
        var s = 0;
        return (e.forceZip64Eocd || e.entries.length >= 65535 || t >= 65535 || r >= 4294967295) && (s += ce + qe), s += de + e.comment.length, r + t + s;
      }
      var ce = 56, qe = 20, de = 22;
      function Ft(e, r) {
        var t = false, n = e.entries.length;
        (e.forceZip64Eocd || e.entries.length >= 65535) && (n = 65535, t = true);
        var i = e.outputStreamCursor - e.offsetOfStartOfCentralDirectory, o = i;
        (e.forceZip64Eocd || i >= 4294967295) && (o = 4294967295, t = true);
        var s = e.offsetOfStartOfCentralDirectory;
        if ((e.forceZip64Eocd || e.offsetOfStartOfCentralDirectory >= 4294967295) && (s = 4294967295, t = true), r)
          return t ? ce + qe + de : de;
        var f = F(de + e.comment.length);
        if (f.writeUInt32LE(101010256, 0), f.writeUInt16LE(0, 4), f.writeUInt16LE(0, 6), f.writeUInt16LE(n, 8), f.writeUInt16LE(n, 10), f.writeUInt32LE(o, 12), f.writeUInt32LE(s, 16), f.writeUInt16LE(e.comment.length, 20), e.comment.copy(f, 22), !t)
          return f;
        var u = F(ce);
        u.writeUInt32LE(101075792, 0), I(u, ce - 12, 4), u.writeUInt16LE(xr, 12), u.writeUInt16LE(mr, 14), u.writeUInt32LE(0, 16), u.writeUInt32LE(0, 20), I(u, e.entries.length, 24), I(u, e.entries.length, 32), I(u, i, 40), I(u, e.offsetOfStartOfCentralDirectory, 48);
        var d = F(qe);
        return d.writeUInt32LE(117853008, 0), d.writeUInt32LE(0, 4), I(d, e.outputStreamCursor, 8), d.writeUInt32LE(1, 16), Buffer.concat([u, d, f]);
      }
      function pe(e, r) {
        if (e === "")
          throw new Error("empty metadataPath");
        if (e = e.replace(/\\/g, "/"), /^[a-zA-Z]:/.test(e) || /^\//.test(e))
          throw new Error("absolute path: " + e);
        if (e.split("/").indexOf("..") !== -1)
          throw new Error("invalid relative path: " + e);
        var t = /\/$/.test(e);
        if (r)
          t || (e += "/");
        else if (t)
          throw new Error("file path cannot end with '/': " + e);
        return e;
      }
      var me = F(0);
      function m(e, r, t) {
        if (this.utf8FileName = N(e), this.utf8FileName.length > 65535)
          throw new Error("utf8 file name too long. " + utf8FileName.length + " > " + 65535);
        if (this.isDirectory = r, this.state = m.WAITING_FOR_METADATA, this.setLastModDate(t.mtime != null ? t.mtime : new Date()), t.mode != null ? this.setFileAttributesMode(t.mode) : this.setFileAttributesMode(r ? 16893 : 33204), r ? (this.crcAndFileSizeKnown = true, this.crc32 = 0, this.uncompressedSize = 0, this.compressedSize = 0) : (this.crcAndFileSizeKnown = false, this.crc32 = null, this.uncompressedSize = null, this.compressedSize = null, t.size != null && (this.uncompressedSize = t.size)), r ? this.compress = false : (this.compress = true, t.compress != null && (this.compress = !!t.compress)), this.forceZip64Format = !!t.forceZip64Format, t.fileComment) {
          if (typeof t.fileComment == "string" ? this.fileComment = N(t.fileComment, "utf-8") : this.fileComment = t.fileComment, this.fileComment.length > 65535)
            throw new Error("fileComment is too large");
        } else
          this.fileComment = me;
      }
      m.WAITING_FOR_METADATA = 0;
      m.READY_TO_PUMP_FILE_DATA = 1;
      m.FILE_DATA_IN_PROGRESS = 2;
      m.FILE_DATA_DONE = 3;
      m.prototype.setLastModDate = function(e) {
        var r = Cr(e);
        this.lastModFileTime = r.time, this.lastModFileDate = r.date;
      };
      m.prototype.setFileAttributesMode = function(e) {
        if ((e & 65535) !== e)
          throw new Error("invalid mode. expected: 0 <= " + e + " <= " + 65535);
        this.externalFileAttributes = e << 16 >>> 0;
      };
      m.prototype.setFileDataPumpFunction = function(e) {
        this.doFileDataPump = e, this.state = m.READY_TO_PUMP_FILE_DATA;
      };
      m.prototype.useZip64Format = function() {
        return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
      };
      var hr = 30, pr = 20, mr = 45, xr = 3 << 8 | 63, vr = 1 << 11, Er = 1 << 3;
      m.prototype.getLocalFileHeader = function() {
        var e = 0, r = 0, t = 0;
        this.crcAndFileSizeKnown && (e = this.crc32, r = this.compressedSize, t = this.uncompressedSize);
        var n = F(hr), i = vr;
        return this.crcAndFileSizeKnown || (i |= Er), n.writeUInt32LE(67324752, 0), n.writeUInt16LE(pr, 4), n.writeUInt16LE(i, 6), n.writeUInt16LE(this.getCompressionMethod(), 8), n.writeUInt16LE(this.lastModFileTime, 10), n.writeUInt16LE(this.lastModFileDate, 12), n.writeUInt32LE(e, 14), n.writeUInt32LE(r, 18), n.writeUInt32LE(t, 22), n.writeUInt16LE(this.utf8FileName.length, 26), n.writeUInt16LE(0, 28), Buffer.concat([n, this.utf8FileName]);
      };
      var wr = 16, gr = 24;
      m.prototype.getDataDescriptor = function() {
        if (this.crcAndFileSizeKnown)
          return me;
        if (this.useZip64Format()) {
          var e = F(gr);
          return e.writeUInt32LE(134695760, 0), e.writeUInt32LE(this.crc32, 4), I(e, this.compressedSize, 8), I(e, this.uncompressedSize, 16), e;
        } else {
          var e = F(wr);
          return e.writeUInt32LE(134695760, 0), e.writeUInt32LE(this.crc32, 4), e.writeUInt32LE(this.compressedSize, 8), e.writeUInt32LE(this.uncompressedSize, 12), e;
        }
      };
      var yr = 46, Pe = 28;
      m.prototype.getCentralDirectoryRecord = function() {
        var e = F(yr), r = vr;
        this.crcAndFileSizeKnown || (r |= Er);
        var t = this.compressedSize, n = this.uncompressedSize, i = this.relativeOffsetOfLocalHeader, o, s;
        return this.useZip64Format() ? (t = 4294967295, n = 4294967295, i = 4294967295, o = mr, s = F(Pe), s.writeUInt16LE(1, 0), s.writeUInt16LE(Pe - 4, 2), I(s, this.uncompressedSize, 4), I(s, this.compressedSize, 12), I(s, this.relativeOffsetOfLocalHeader, 20)) : (o = pr, s = me), e.writeUInt32LE(33639248, 0), e.writeUInt16LE(xr, 4), e.writeUInt16LE(o, 6), e.writeUInt16LE(r, 8), e.writeUInt16LE(this.getCompressionMethod(), 10), e.writeUInt16LE(this.lastModFileTime, 12), e.writeUInt16LE(this.lastModFileDate, 14), e.writeUInt32LE(this.crc32, 16), e.writeUInt32LE(t, 20), e.writeUInt32LE(n, 24), e.writeUInt16LE(this.utf8FileName.length, 28), e.writeUInt16LE(s.length, 30), e.writeUInt16LE(this.fileComment.length, 32), e.writeUInt16LE(0, 34), e.writeUInt16LE(0, 36), e.writeUInt32LE(this.externalFileAttributes, 38), e.writeUInt32LE(i, 42), Buffer.concat([e, this.utf8FileName, s, this.fileComment]);
      };
      m.prototype.getCompressionMethod = function() {
        var e = 0, r = 8;
        return this.compress ? r : e;
      };
      function Cr(e) {
        var r = 0;
        r |= e.getDate() & 31, r |= (e.getMonth() + 1 & 15) << 5, r |= (e.getFullYear() - 1980 & 127) << 9;
        var t = 0;
        return t |= Math.floor(e.getSeconds() / 2), t |= (e.getMinutes() & 63) << 5, t |= (e.getHours() & 31) << 11, { date: r, time: t };
      }
      function I(e, r, t) {
        var n = Math.floor(r / 4294967296), i = r % 4294967296;
        e.writeUInt32LE(i, t), e.writeUInt32LE(n, t + 4);
      }
      We.inherits(le, he);
      function le(e) {
        he.call(this, e), this.byteCount = 0;
      }
      le.prototype._transform = function(e, r, t) {
        this.byteCount += e.length, t(null, e);
      };
      We.inherits(He, he);
      function He(e) {
        he.call(this, e), this.crc32 = 0;
      }
      He.prototype._transform = function(e, r, t) {
        this.crc32 = dr.unsigned(e, this.crc32), t(null, e);
      };
      var Ze = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
      if (Ze.length !== 256)
        throw new Error("assertion failure");
      var ue = null;
      function St(e) {
        if (/^[\x20-\x7e]*$/.test(e))
          return N(e, "utf-8");
        if (ue == null) {
          ue = {};
          for (var r = 0; r < Ze.length; r++)
            ue[Ze[r]] = r;
        }
        for (var t = F(e.length), r = 0; r < e.length; r++) {
          var n = ue[e[r]];
          if (n == null)
            throw new Error("character not encodable in CP437: " + JSON.stringify(e[r]));
          t[r] = n;
        }
        return t;
      }
      function F(e) {
        F = r;
        try {
          return F(e);
        } catch (e2) {
          return F = t, F(e);
        }
        function r(n) {
          return Buffer.allocUnsafe(n);
        }
        function t(n) {
          return new Buffer(n);
        }
      }
      function N(e, r) {
        N = t;
        try {
          return N(e, r);
        } catch (e2) {
          return N = n, N(e, r);
        }
        function t(i, o) {
          return Buffer.from(i, o);
        }
        function n(i, o) {
          return new Buffer(i, o);
        }
      }
      function te(e, r) {
        te = t;
        try {
          return te(e, r);
        } catch (e2) {
          return te = n, te(e, r);
        }
        function t(i, o) {
          return i.includes(o);
        }
        function n(i, o) {
          for (var s = 0; s <= i.length - o.length; s++)
            for (var f = 0; ; f++) {
              if (f === o.length)
                return true;
              if (i[s + f] !== o[f])
                break;
            }
          return false;
        }
      }
    });
    var Lr = E((Dn, Ir) => {
      Ir.exports = xe;
      function xe() {
        this.pending = 0, this.max = 1 / 0, this.listeners = [], this.waiting = [], this.error = null;
      }
      xe.prototype.go = function(e) {
        this.pending < this.max ? Sr(this, e) : this.waiting.push(e);
      };
      xe.prototype.wait = function(e) {
        this.pending === 0 ? e(this.error) : this.listeners.push(e);
      };
      xe.prototype.hold = function() {
        return Fr(this);
      };
      function Fr(e) {
        e.pending += 1;
        var r = false;
        return t;
        function t(i) {
          if (r)
            throw new Error("callback called twice");
          if (r = true, e.error = e.error || i, e.pending -= 1, e.waiting.length > 0 && e.pending < e.max)
            Sr(e, e.waiting.shift());
          else if (e.pending === 0) {
            var o = e.listeners;
            e.listeners = [], o.forEach(n);
          }
        }
        function n(i) {
          i(e.error);
        }
      }
      function Sr(e, r) {
        r(Fr(e));
      }
    });
    var zr = E((ie) => {
      var ne = require("fs"), ve = require("util"), Ye = require("stream"), Or = Ye.Readable, $e = Ye.Writable, It = Ye.PassThrough, Lt = Lr(), Ee = require("events").EventEmitter;
      ie.createFromBuffer = Ot;
      ie.createFromFd = zt;
      ie.BufferSlicer = D;
      ie.FdSlicer = R;
      ve.inherits(R, Ee);
      function R(e, r) {
        r = r || {}, Ee.call(this), this.fd = e, this.pend = new Lt(), this.pend.max = 1, this.refCount = 0, this.autoClose = !!r.autoClose;
      }
      R.prototype.read = function(e, r, t, n, i) {
        var o = this;
        o.pend.go(function(s) {
          ne.read(o.fd, e, r, t, n, function(f, u, d) {
            s(), i(f, u, d);
          });
        });
      };
      R.prototype.write = function(e, r, t, n, i) {
        var o = this;
        o.pend.go(function(s) {
          ne.write(o.fd, e, r, t, n, function(f, u, d) {
            s(), i(f, u, d);
          });
        });
      };
      R.prototype.createReadStream = function(e) {
        return new we(this, e);
      };
      R.prototype.createWriteStream = function(e) {
        return new ge(this, e);
      };
      R.prototype.ref = function() {
        this.refCount += 1;
      };
      R.prototype.unref = function() {
        var e = this;
        if (e.refCount -= 1, e.refCount > 0)
          return;
        if (e.refCount < 0)
          throw new Error("invalid unref");
        e.autoClose && ne.close(e.fd, r);
        function r(t) {
          t ? e.emit("error", t) : e.emit("close");
        }
      };
      ve.inherits(we, Or);
      function we(e, r) {
        r = r || {}, Or.call(this, r), this.context = e, this.context.ref(), this.start = r.start || 0, this.endOffset = r.end, this.pos = this.start, this.destroyed = false;
      }
      we.prototype._read = function(e) {
        var r = this;
        if (!r.destroyed) {
          var t = Math.min(r._readableState.highWaterMark, e);
          if (r.endOffset != null && (t = Math.min(t, r.endOffset - r.pos)), t <= 0) {
            r.destroyed = true, r.push(null), r.context.unref();
            return;
          }
          r.context.pend.go(function(n) {
            if (r.destroyed)
              return n();
            var i = Buffer.alloc(t);
            ne.read(r.context.fd, i, 0, t, r.pos, function(o, s) {
              o ? r.destroy(o) : s === 0 ? (r.destroyed = true, r.push(null), r.context.unref()) : (r.pos += s, r.push(i.slice(0, s))), n();
            });
          });
        }
      };
      we.prototype.destroy = function(e) {
        this.destroyed || (e = e || new Error("stream destroyed"), this.destroyed = true, this.emit("error", e), this.context.unref());
      };
      ve.inherits(ge, $e);
      function ge(e, r) {
        r = r || {}, $e.call(this, r), this.context = e, this.context.ref(), this.start = r.start || 0, this.endOffset = r.end == null ? 1 / 0 : +r.end, this.bytesWritten = 0, this.pos = this.start, this.destroyed = false, this.on("finish", this.destroy.bind(this));
      }
      ge.prototype._write = function(e, r, t) {
        var n = this;
        if (!n.destroyed) {
          if (n.pos + e.length > n.endOffset) {
            var i = new Error("maximum file length exceeded");
            i.code = "ETOOBIG", n.destroy(), t(i);
            return;
          }
          n.context.pend.go(function(o) {
            if (n.destroyed)
              return o();
            ne.write(n.context.fd, e, 0, e.length, n.pos, function(s, f) {
              s ? (n.destroy(), o(), t(s)) : (n.bytesWritten += f, n.pos += f, n.emit("progress"), o(), t());
            });
          });
        }
      };
      ge.prototype.destroy = function() {
        this.destroyed || (this.destroyed = true, this.context.unref());
      };
      ve.inherits(D, Ee);
      function D(e, r) {
        Ee.call(this), r = r || {}, this.refCount = 0, this.buffer = e, this.maxChunkSize = r.maxChunkSize || Number.MAX_SAFE_INTEGER;
      }
      D.prototype.read = function(e, r, t, n, i) {
        var o = n + t, s = o - this.buffer.length, f = s > 0 ? s : t;
        this.buffer.copy(e, r, n, o), setImmediate(function() {
          i(null, f);
        });
      };
      D.prototype.write = function(e, r, t, n, i) {
        e.copy(this.buffer, n, r, r + t), setImmediate(function() {
          i(null, t, e);
        });
      };
      D.prototype.createReadStream = function(e) {
        e = e || {};
        var r = new It(e);
        r.destroyed = false, r.start = e.start || 0, r.endOffset = e.end, r.pos = r.endOffset || this.buffer.length;
        for (var t = this.buffer.slice(r.start, r.pos), n = 0; ; ) {
          var i = n + this.maxChunkSize;
          if (i >= t.length) {
            n < t.length && r.write(t.slice(n, t.length));
            break;
          }
          r.write(t.slice(n, i)), n = i;
        }
        return r.end(), r.destroy = function() {
          r.destroyed = true;
        }, r;
      };
      D.prototype.createWriteStream = function(e) {
        var r = this;
        e = e || {};
        var t = new $e(e);
        return t.start = e.start || 0, t.endOffset = e.end == null ? this.buffer.length : +e.end, t.bytesWritten = 0, t.pos = t.start, t.destroyed = false, t._write = function(n, i, o) {
          if (!t.destroyed) {
            var s = t.pos + n.length;
            if (s > t.endOffset) {
              var f = new Error("maximum file length exceeded");
              f.code = "ETOOBIG", t.destroyed = true, o(f);
              return;
            }
            n.copy(r.buffer, t.pos, 0, n.length), t.bytesWritten += n.length, t.pos = s, t.emit("progress"), o();
          }
        }, t.destroy = function() {
          t.destroyed = true;
        }, t;
      };
      D.prototype.ref = function() {
        this.refCount += 1;
      };
      D.prototype.unref = function() {
        if (this.refCount -= 1, this.refCount < 0)
          throw new Error("invalid unref");
      };
      function Ot(e, r) {
        return new D(e, r);
      }
      function zt(e, r) {
        return new R(e, r);
      }
    });
    var Xe = E((A) => {
      var je = require("fs"), _t = require("zlib"), _r = zr(), At = Be(), be = require("util"), Fe = require("events").EventEmitter, Ar = require("stream").Transform, Ve = require("stream").PassThrough, Rt = require("stream").Writable;
      A.open = Dt;
      A.fromFd = Rr;
      A.fromBuffer = Ut;
      A.fromRandomAccessReader = Ke;
      A.dosDateTimeToDate = Ur;
      A.validateFileName = Tr;
      A.ZipFile = B;
      A.Entry = oe;
      A.RandomAccessReader = q;
      function Dt(e, r, t) {
        typeof r == "function" && (t = r, r = null), r == null && (r = {}), r.autoClose == null && (r.autoClose = true), r.lazyEntries == null && (r.lazyEntries = false), r.decodeStrings == null && (r.decodeStrings = true), r.validateEntrySizes == null && (r.validateEntrySizes = true), r.strictFileNames == null && (r.strictFileNames = false), t == null && (t = Ce), je.open(e, "r", function(n, i) {
          if (n)
            return t(n);
          Rr(i, r, function(o, s) {
            o && je.close(i, Ce), t(o, s);
          });
        });
      }
      function Rr(e, r, t) {
        typeof r == "function" && (t = r, r = null), r == null && (r = {}), r.autoClose == null && (r.autoClose = false), r.lazyEntries == null && (r.lazyEntries = false), r.decodeStrings == null && (r.decodeStrings = true), r.validateEntrySizes == null && (r.validateEntrySizes = true), r.strictFileNames == null && (r.strictFileNames = false), t == null && (t = Ce), je.fstat(e, function(n, i) {
          if (n)
            return t(n);
          var o = _r.createFromFd(e, { autoClose: true });
          Ke(o, i.size, r, t);
        });
      }
      function Ut(e, r, t) {
        typeof r == "function" && (t = r, r = null), r == null && (r = {}), r.autoClose = false, r.lazyEntries == null && (r.lazyEntries = false), r.decodeStrings == null && (r.decodeStrings = true), r.validateEntrySizes == null && (r.validateEntrySizes = true), r.strictFileNames == null && (r.strictFileNames = false);
        var n = _r.createFromBuffer(e, { maxChunkSize: 65536 });
        Ke(n, e.length, r, t);
      }
      function Ke(e, r, t, n) {
        typeof t == "function" && (n = t, t = null), t == null && (t = {}), t.autoClose == null && (t.autoClose = true), t.lazyEntries == null && (t.lazyEntries = false), t.decodeStrings == null && (t.decodeStrings = true);
        var i = !!t.decodeStrings;
        if (t.validateEntrySizes == null && (t.validateEntrySizes = true), t.strictFileNames == null && (t.strictFileNames = false), n == null && (n = Ce), typeof r != "number")
          throw new Error("expected totalSize parameter to be a number");
        if (r > Number.MAX_SAFE_INTEGER)
          throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
        e.ref();
        var o = 22, s = 65535, f = Math.min(o + s, r), u = _(f), d = r - u.length;
        $(e, u, 0, f, d, function(a) {
          if (a)
            return n(a);
          for (var c = f - o; c >= 0; c -= 1)
            if (u.readUInt32LE(c) === 101010256) {
              var l = u.slice(c), x = l.readUInt16LE(4);
              if (x !== 0)
                return n(new Error("multi-disk zip files are not supported: found disk number: " + x));
              var g = l.readUInt16LE(10), p = l.readUInt32LE(16), h = l.readUInt16LE(20), v = l.length - o;
              if (h !== v)
                return n(new Error("invalid comment length. expected: " + v + ". found: " + h));
              var w = i ? ye(l, 22, l.length, false) : l.slice(22);
              if (!(g === 65535 || p === 4294967295))
                return n(null, new B(e, p, r, g, w, t.autoClose, t.lazyEntries, i, t.validateEntrySizes, t.strictFileNames));
              var b = _(20), U = d + c - b.length;
              $(e, b, 0, b.length, U, function(Y) {
                if (Y)
                  return n(Y);
                if (b.readUInt32LE(0) !== 117853008)
                  return n(new Error("invalid zip64 end of central directory locator signature"));
                var ee = j(b, 8), P = _(56);
                $(e, P, 0, P.length, ee, function(re) {
                  return re ? n(re) : P.readUInt32LE(0) !== 101075792 ? n(new Error("invalid zip64 end of central directory record signature")) : (g = j(P, 32), p = j(P, 48), n(null, new B(e, p, r, g, w, t.autoClose, t.lazyEntries, i, t.validateEntrySizes, t.strictFileNames)));
                });
              });
              return;
            }
          n(new Error("end of central directory record signature not found"));
        });
      }
      be.inherits(B, Fe);
      function B(e, r, t, n, i, o, s, f, u, d) {
        var a = this;
        Fe.call(a), a.reader = e, a.reader.on("error", function(c) {
          Dr(a, c);
        }), a.reader.once("close", function() {
          a.emit("close");
        }), a.readEntryCursor = r, a.fileSize = t, a.entryCount = n, a.comment = i, a.entriesRead = 0, a.autoClose = !!o, a.lazyEntries = !!s, a.decodeStrings = !!f, a.validateEntrySizes = !!u, a.strictFileNames = !!d, a.isOpen = true, a.emittedError = false, a.lazyEntries || a._readEntry();
      }
      B.prototype.close = function() {
        !this.isOpen || (this.isOpen = false, this.reader.unref());
      };
      function L(e, r) {
        e.autoClose && e.close(), Dr(e, r);
      }
      function Dr(e, r) {
        e.emittedError || (e.emittedError = true, e.emit("error", r));
      }
      B.prototype.readEntry = function() {
        if (!this.lazyEntries)
          throw new Error("readEntry() called without lazyEntries:true");
        this._readEntry();
      };
      B.prototype._readEntry = function() {
        var e = this;
        if (e.entryCount === e.entriesRead) {
          setImmediate(function() {
            e.autoClose && e.close(), !e.emittedError && e.emit("end");
          });
          return;
        }
        if (!e.emittedError) {
          var r = _(46);
          $(e.reader, r, 0, r.length, e.readEntryCursor, function(t) {
            if (t)
              return L(e, t);
            if (!e.emittedError) {
              var n = new oe(), i = r.readUInt32LE(0);
              if (i !== 33639248)
                return L(e, new Error("invalid central directory file header signature: 0x" + i.toString(16)));
              if (n.versionMadeBy = r.readUInt16LE(4), n.versionNeededToExtract = r.readUInt16LE(6), n.generalPurposeBitFlag = r.readUInt16LE(8), n.compressionMethod = r.readUInt16LE(10), n.lastModFileTime = r.readUInt16LE(12), n.lastModFileDate = r.readUInt16LE(14), n.crc32 = r.readUInt32LE(16), n.compressedSize = r.readUInt32LE(20), n.uncompressedSize = r.readUInt32LE(24), n.fileNameLength = r.readUInt16LE(28), n.extraFieldLength = r.readUInt16LE(30), n.fileCommentLength = r.readUInt16LE(32), n.internalFileAttributes = r.readUInt16LE(36), n.externalFileAttributes = r.readUInt32LE(38), n.relativeOffsetOfLocalHeader = r.readUInt32LE(42), n.generalPurposeBitFlag & 64)
                return L(e, new Error("strong encryption is not supported"));
              e.readEntryCursor += 46, r = _(n.fileNameLength + n.extraFieldLength + n.fileCommentLength), $(e.reader, r, 0, r.length, e.readEntryCursor, function(o) {
                if (o)
                  return L(e, o);
                if (!e.emittedError) {
                  var s = (n.generalPurposeBitFlag & 2048) !== 0;
                  n.fileName = e.decodeStrings ? ye(r, 0, n.fileNameLength, s) : r.slice(0, n.fileNameLength);
                  var f = n.fileNameLength + n.extraFieldLength, u = r.slice(n.fileNameLength, f);
                  n.extraFields = [];
                  for (var d = 0; d < u.length - 3; ) {
                    var a = u.readUInt16LE(d + 0), c = u.readUInt16LE(d + 2), l = d + 4, x = l + c;
                    if (x > u.length)
                      return L(e, new Error("extra field length exceeds extra field buffer size"));
                    var g = _(c);
                    u.copy(g, 0, l, x), n.extraFields.push({ id: a, data: g }), d = x;
                  }
                  if (n.fileComment = e.decodeStrings ? ye(r, f, f + n.fileCommentLength, s) : r.slice(f, f + n.fileCommentLength), n.comment = n.fileComment, e.readEntryCursor += r.length, e.entriesRead += 1, n.uncompressedSize === 4294967295 || n.compressedSize === 4294967295 || n.relativeOffsetOfLocalHeader === 4294967295) {
                    for (var p = null, d = 0; d < n.extraFields.length; d++) {
                      var h = n.extraFields[d];
                      if (h.id === 1) {
                        p = h.data;
                        break;
                      }
                    }
                    if (p == null)
                      return L(e, new Error("expected zip64 extended information extra field"));
                    var v = 0;
                    if (n.uncompressedSize === 4294967295) {
                      if (v + 8 > p.length)
                        return L(e, new Error("zip64 extended information extra field does not include uncompressed size"));
                      n.uncompressedSize = j(p, v), v += 8;
                    }
                    if (n.compressedSize === 4294967295) {
                      if (v + 8 > p.length)
                        return L(e, new Error("zip64 extended information extra field does not include compressed size"));
                      n.compressedSize = j(p, v), v += 8;
                    }
                    if (n.relativeOffsetOfLocalHeader === 4294967295) {
                      if (v + 8 > p.length)
                        return L(e, new Error("zip64 extended information extra field does not include relative header offset"));
                      n.relativeOffsetOfLocalHeader = j(p, v), v += 8;
                    }
                  }
                  if (e.decodeStrings)
                    for (var d = 0; d < n.extraFields.length; d++) {
                      var h = n.extraFields[d];
                      if (h.id === 28789) {
                        if (h.data.length < 6 || h.data.readUInt8(0) !== 1)
                          continue;
                        var w = h.data.readUInt32LE(1);
                        if (At.unsigned(r.slice(0, n.fileNameLength)) !== w)
                          continue;
                        n.fileName = ye(h.data, 5, h.data.length, true);
                        break;
                      }
                    }
                  if (e.validateEntrySizes && n.compressionMethod === 0) {
                    var b = n.uncompressedSize;
                    if (n.isEncrypted() && (b += 12), n.compressedSize !== b) {
                      var U = "compressed/uncompressed size mismatch for stored file: " + n.compressedSize + " != " + n.uncompressedSize;
                      return L(e, new Error(U));
                    }
                  }
                  if (e.decodeStrings) {
                    e.strictFileNames || (n.fileName = n.fileName.replace(/\\/g, "/"));
                    var Y = Tr(n.fileName, e.validateFileNameOptions);
                    if (Y != null)
                      return L(e, new Error(Y));
                  }
                  e.emit("entry", n), e.lazyEntries || e._readEntry();
                }
              });
            }
          });
        }
      };
      B.prototype.openReadStream = function(e, r, t) {
        var n = this, i = 0, o = e.compressedSize;
        if (t == null)
          t = r, r = {};
        else {
          if (r.decrypt != null) {
            if (!e.isEncrypted())
              throw new Error("options.decrypt can only be specified for encrypted entries");
            if (r.decrypt !== false)
              throw new Error("invalid options.decrypt value: " + r.decrypt);
            if (e.isCompressed() && r.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
          if (r.decompress != null) {
            if (!e.isCompressed())
              throw new Error("options.decompress can only be specified for compressed entries");
            if (!(r.decompress === false || r.decompress === true))
              throw new Error("invalid options.decompress value: " + r.decompress);
          }
          if (r.start != null || r.end != null) {
            if (e.isCompressed() && r.decompress !== false)
              throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
            if (e.isEncrypted() && r.decrypt !== false)
              throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
          if (r.start != null) {
            if (i = r.start, i < 0)
              throw new Error("options.start < 0");
            if (i > e.compressedSize)
              throw new Error("options.start > entry.compressedSize");
          }
          if (r.end != null) {
            if (o = r.end, o < 0)
              throw new Error("options.end < 0");
            if (o > e.compressedSize)
              throw new Error("options.end > entry.compressedSize");
            if (o < i)
              throw new Error("options.end < options.start");
          }
        }
        if (!n.isOpen)
          return t(new Error("closed"));
        if (e.isEncrypted() && r.decrypt !== false)
          return t(new Error("entry is encrypted, and options.decrypt !== false"));
        n.reader.ref();
        var s = _(30);
        $(n.reader, s, 0, s.length, e.relativeOffsetOfLocalHeader, function(f) {
          try {
            if (f)
              return t(f);
            var u = s.readUInt32LE(0);
            if (u !== 67324752)
              return t(new Error("invalid local file header signature: 0x" + u.toString(16)));
            var d = s.readUInt16LE(26), a = s.readUInt16LE(28), c = e.relativeOffsetOfLocalHeader + s.length + d + a, l;
            if (e.compressionMethod === 0)
              l = false;
            else if (e.compressionMethod === 8)
              l = r.decompress != null ? r.decompress : true;
            else
              return t(new Error("unsupported compression method: " + e.compressionMethod));
            var x = c, g = x + e.compressedSize;
            if (e.compressedSize !== 0 && g > n.fileSize)
              return t(new Error("file data overflows file bounds: " + x + " + " + e.compressedSize + " > " + n.fileSize));
            var p = n.reader.createReadStream({ start: x + i, end: x + o }), h = p;
            if (l) {
              var v = false, w = _t.createInflateRaw();
              p.on("error", function(b) {
                setImmediate(function() {
                  v || w.emit("error", b);
                });
              }), p.pipe(w), n.validateEntrySizes ? (h = new se(e.uncompressedSize), w.on("error", function(b) {
                setImmediate(function() {
                  v || h.emit("error", b);
                });
              }), w.pipe(h)) : h = w, h.destroy = function() {
                v = true, w !== h && w.unpipe(h), p.unpipe(w), p.destroy();
              };
            }
            t(null, h);
          } finally {
            n.reader.unref();
          }
        });
      };
      function oe() {
      }
      oe.prototype.getLastModDate = function() {
        return Ur(this.lastModFileDate, this.lastModFileTime);
      };
      oe.prototype.isEncrypted = function() {
        return (this.generalPurposeBitFlag & 1) !== 0;
      };
      oe.prototype.isCompressed = function() {
        return this.compressionMethod === 8;
      };
      function Ur(e, r) {
        var t = e & 31, n = (e >> 5 & 15) - 1, i = (e >> 9 & 127) + 1980, o = 0, s = (r & 31) * 2, f = r >> 5 & 63, u = r >> 11 & 31;
        return new Date(i, n, t, u, f, s, o);
      }
      function Tr(e) {
        return e.indexOf("\\") !== -1 ? "invalid characters in fileName: " + e : /^[a-zA-Z]:/.test(e) || /^\//.test(e) ? "absolute path: " + e : e.split("/").indexOf("..") !== -1 ? "invalid relative path: " + e : null;
      }
      function $(e, r, t, n, i, o) {
        if (n === 0)
          return setImmediate(function() {
            o(null, _(0));
          });
        e.read(r, t, n, i, function(s, f) {
          if (s)
            return o(s);
          if (f < n)
            return o(new Error("unexpected EOF"));
          o();
        });
      }
      be.inherits(se, Ar);
      function se(e) {
        Ar.call(this), this.actualByteCount = 0, this.expectedByteCount = e;
      }
      se.prototype._transform = function(e, r, t) {
        if (this.actualByteCount += e.length, this.actualByteCount > this.expectedByteCount) {
          var n = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
          return t(new Error(n));
        }
        t(null, e);
      };
      se.prototype._flush = function(e) {
        if (this.actualByteCount < this.expectedByteCount) {
          var r = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
          return e(new Error(r));
        }
        e();
      };
      be.inherits(q, Fe);
      function q() {
        Fe.call(this), this.refCount = 0;
      }
      q.prototype.ref = function() {
        this.refCount += 1;
      };
      q.prototype.unref = function() {
        var e = this;
        if (e.refCount -= 1, e.refCount > 0)
          return;
        if (e.refCount < 0)
          throw new Error("invalid unref");
        e.close(r);
        function r(t) {
          if (t)
            return e.emit("error", t);
          e.emit("close");
        }
      };
      q.prototype.createReadStream = function(e) {
        var r = e.start, t = e.end;
        if (r === t) {
          var n = new Ve();
          return setImmediate(function() {
            n.end();
          }), n;
        }
        var i = this._readStreamForRange(r, t), o = false, s = new Se(this);
        i.on("error", function(u) {
          setImmediate(function() {
            o || s.emit("error", u);
          });
        }), s.destroy = function() {
          i.unpipe(s), s.unref(), i.destroy();
        };
        var f = new se(t - r);
        return s.on("error", function(u) {
          setImmediate(function() {
            o || f.emit("error", u);
          });
        }), f.destroy = function() {
          o = true, s.unpipe(f), s.destroy();
        }, i.pipe(s).pipe(f);
      };
      q.prototype._readStreamForRange = function(e, r) {
        throw new Error("not implemented");
      };
      q.prototype.read = function(e, r, t, n, i) {
        var o = this.createReadStream({ start: n, end: n + t }), s = new Rt(), f = 0;
        s._write = function(u, d, a) {
          u.copy(e, r + f, 0, u.length), f += u.length, a();
        }, s.on("finish", i), o.on("error", function(u) {
          i(u);
        }), o.pipe(s);
      };
      q.prototype.close = function(e) {
        setImmediate(e);
      };
      be.inherits(Se, Ve);
      function Se(e) {
        Ve.call(this), this.context = e, this.context.ref(), this.unreffedYet = false;
      }
      Se.prototype._flush = function(e) {
        this.unref(), e();
      };
      Se.prototype.unref = function(e) {
        this.unreffedYet || (this.unreffedYet = true, this.context.unref());
      };
      var Tt = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
      function ye(e, r, t, n) {
        if (n)
          return e.toString("utf8", r, t);
        for (var i = "", o = r; o < t; o++)
          i += Tt[e[o]];
        return i;
      }
      function j(e, r) {
        var t = e.readUInt32LE(r), n = e.readUInt32LE(r + 4);
        return n * 4294967296 + t;
      }
      var _;
      typeof Buffer.allocUnsafe == "function" ? _ = function(e) {
        return Buffer.allocUnsafe(e);
      } : _ = function(e) {
        return new Buffer(e);
      };
      function Ce(e) {
        if (e)
          throw e;
      }
    });
    var Mr = E((Nn, Nr) => {
      var V = 1e3, K = V * 60, X = K * 60, H = X * 24, Nt = H * 7, Mt = H * 365.25;
      Nr.exports = function(e, r) {
        r = r || {};
        var t = typeof e;
        if (t === "string" && e.length > 0)
          return Bt(e);
        if (t === "number" && isFinite(e))
          return r.long ? Pt(e) : qt(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
      };
      function Bt(e) {
        if (e = String(e), !(e.length > 100)) {
          var r = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
          if (!!r) {
            var t = parseFloat(r[1]), n = (r[2] || "ms").toLowerCase();
            switch (n) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return t * Mt;
              case "weeks":
              case "week":
              case "w":
                return t * Nt;
              case "days":
              case "day":
              case "d":
                return t * H;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return t * X;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return t * K;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return t * V;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return t;
              default:
                return;
            }
          }
        }
      }
      function qt(e) {
        var r = Math.abs(e);
        return r >= H ? Math.round(e / H) + "d" : r >= X ? Math.round(e / X) + "h" : r >= K ? Math.round(e / K) + "m" : r >= V ? Math.round(e / V) + "s" : e + "ms";
      }
      function Pt(e) {
        var r = Math.abs(e);
        return r >= H ? Ie(e, r, H, "day") : r >= X ? Ie(e, r, X, "hour") : r >= K ? Ie(e, r, K, "minute") : r >= V ? Ie(e, r, V, "second") : e + " ms";
      }
      function Ie(e, r, t, n) {
        var i = r >= t * 1.5;
        return Math.round(e / t) + " " + n + (i ? "s" : "");
      }
    });
    var Je = E((Mn, Br) => {
      function Zt(e) {
        t.debug = t, t.default = t, t.coerce = u, t.disable = o, t.enable = i, t.enabled = s, t.humanize = Mr(), t.destroy = d, Object.keys(e).forEach((a) => {
          t[a] = e[a];
        }), t.names = [], t.skips = [], t.formatters = {};
        function r(a) {
          let c = 0;
          for (let l = 0; l < a.length; l++)
            c = (c << 5) - c + a.charCodeAt(l), c |= 0;
          return t.colors[Math.abs(c) % t.colors.length];
        }
        t.selectColor = r;
        function t(a) {
          let c, l = null, x, g;
          function p(...h) {
            if (!p.enabled)
              return;
            let v = p, w = Number(new Date()), b = w - (c || w);
            v.diff = b, v.prev = c, v.curr = w, c = w, h[0] = t.coerce(h[0]), typeof h[0] != "string" && h.unshift("%O");
            let U = 0;
            h[0] = h[0].replace(/%([a-zA-Z%])/g, (ee, P) => {
              if (ee === "%%")
                return "%";
              U++;
              let re = t.formatters[P];
              if (typeof re == "function") {
                let lt = h[U];
                ee = re.call(v, lt), h.splice(U, 1), U--;
              }
              return ee;
            }), t.formatArgs.call(v, h), (v.log || t.log).apply(v, h);
          }
          return p.namespace = a, p.useColors = t.useColors(), p.color = t.selectColor(a), p.extend = n, p.destroy = t.destroy, Object.defineProperty(p, "enabled", { enumerable: true, configurable: false, get: () => l !== null ? l : (x !== t.namespaces && (x = t.namespaces, g = t.enabled(a)), g), set: (h) => {
            l = h;
          } }), typeof t.init == "function" && t.init(p), p;
        }
        function n(a, c) {
          let l = t(this.namespace + (typeof c == "undefined" ? ":" : c) + a);
          return l.log = this.log, l;
        }
        function i(a) {
          t.save(a), t.namespaces = a, t.names = [], t.skips = [];
          let c, l = (typeof a == "string" ? a : "").split(/[\s,]+/), x = l.length;
          for (c = 0; c < x; c++)
            !l[c] || (a = l[c].replace(/\*/g, ".*?"), a[0] === "-" ? t.skips.push(new RegExp("^" + a.slice(1) + "$")) : t.names.push(new RegExp("^" + a + "$")));
        }
        function o() {
          let a = [...t.names.map(f), ...t.skips.map(f).map((c) => "-" + c)].join(",");
          return t.enable(""), a;
        }
        function s(a) {
          if (a[a.length - 1] === "*")
            return true;
          let c, l;
          for (c = 0, l = t.skips.length; c < l; c++)
            if (t.skips[c].test(a))
              return false;
          for (c = 0, l = t.names.length; c < l; c++)
            if (t.names[c].test(a))
              return true;
          return false;
        }
        function f(a) {
          return a.toString().substring(2, a.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function u(a) {
          return a instanceof Error ? a.stack || a.message : a;
        }
        function d() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return t.enable(t.load()), t;
      }
      Br.exports = Zt;
    });
    var qr = E((S, Le) => {
      S.formatArgs = Ht;
      S.save = Gt;
      S.load = Yt;
      S.useColors = Wt;
      S.storage = $t();
      S.destroy = (() => {
        let e = false;
        return () => {
          e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
        };
      })();
      S.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function Wt() {
        return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function Ht(e) {
        if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + Le.exports.humanize(this.diff), !this.useColors)
          return;
        let r = "color: " + this.color;
        e.splice(1, 0, r, "color: inherit");
        let t = 0, n = 0;
        e[0].replace(/%[a-zA-Z%]/g, (i) => {
          i !== "%%" && (t++, i === "%c" && (n = t));
        }), e.splice(n, 0, r);
      }
      S.log = console.debug || console.log || (() => {
      });
      function Gt(e) {
        try {
          e ? S.storage.setItem("debug", e) : S.storage.removeItem("debug");
        } catch (e2) {
        }
      }
      function Yt() {
        let e;
        try {
          e = S.storage.getItem("debug");
        } catch (e2) {
        }
        return !e && typeof process != "undefined" && "env" in process && (e = process.env.DEBUG), e;
      }
      function $t() {
        try {
          return localStorage;
        } catch (e) {
        }
      }
      Le.exports = Je()(S);
      var { formatters: jt } = Le.exports;
      jt.j = function(e) {
        try {
          return JSON.stringify(e);
        } catch (r) {
          return "[UnexpectedJSONParseError]: " + r.message;
        }
      };
    });
    var Zr = E((Bn, Pr) => {
      "use strict";
      Pr.exports = (e, r) => {
        r = r || process.argv;
        let t = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = r.indexOf(t + e), i = r.indexOf("--");
        return n !== -1 && (i === -1 ? true : n < i);
      };
    });
    var Hr = E((qn, Wr) => {
      "use strict";
      var Vt = require("os"), O = Zr(), C = process.env, J;
      O("no-color") || O("no-colors") || O("color=false") ? J = false : (O("color") || O("colors") || O("color=true") || O("color=always")) && (J = true);
      "FORCE_COLOR" in C && (J = C.FORCE_COLOR.length === 0 || parseInt(C.FORCE_COLOR, 10) !== 0);
      function Kt(e) {
        return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
      }
      function Xt(e) {
        if (J === false)
          return 0;
        if (O("color=16m") || O("color=full") || O("color=truecolor"))
          return 3;
        if (O("color=256"))
          return 2;
        if (e && !e.isTTY && J !== true)
          return 0;
        let r = J ? 1 : 0;
        if (process.platform === "win32") {
          let t = Vt.release().split(".");
          return Number(process.versions.node.split(".")[0]) >= 8 && Number(t[0]) >= 10 && Number(t[2]) >= 10586 ? Number(t[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in C)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((t) => t in C) || C.CI_NAME === "codeship" ? 1 : r;
        if ("TEAMCITY_VERSION" in C)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(C.TEAMCITY_VERSION) ? 1 : 0;
        if (C.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in C) {
          let t = parseInt((C.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (C.TERM_PROGRAM) {
            case "iTerm.app":
              return t >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(C.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(C.TERM) || "COLORTERM" in C ? 1 : (C.TERM === "dumb", r);
      }
      function Qe(e) {
        let r = Xt(e);
        return Kt(r);
      }
      Wr.exports = { supportsColor: Qe, stdout: Qe(process.stdout), stderr: Qe(process.stderr) };
    });
    var Yr = E((y, ze) => {
      var Jt = require("tty"), Oe = require("util");
      y.init = on;
      y.log = rn;
      y.formatArgs = kt;
      y.save = tn;
      y.load = nn;
      y.useColors = Qt;
      y.destroy = Oe.deprecate(() => {
      }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      y.colors = [6, 2, 3, 4, 5, 1];
      try {
        let e = Hr();
        e && (e.stderr || e).level >= 2 && (y.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
      } catch (e) {
      }
      y.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, r) => {
        let t = r.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o) => o.toUpperCase()), n = process.env[r];
        return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), e[t] = n, e;
      }, {});
      function Qt() {
        return "colors" in y.inspectOpts ? Boolean(y.inspectOpts.colors) : Jt.isatty(process.stderr.fd);
      }
      function kt(e) {
        let { namespace: r, useColors: t } = this;
        if (t) {
          let n = this.color, i = "[3" + (n < 8 ? n : "8;5;" + n), o = `  ${i};1m${r} [0m`;
          e[0] = o + e[0].split(`
`).join(`
` + o), e.push(i + "m+" + ze.exports.humanize(this.diff) + "[0m");
        } else
          e[0] = en() + r + " " + e[0];
      }
      function en() {
        return y.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
      }
      function rn(...e) {
        return process.stderr.write(Oe.format(...e) + `
`);
      }
      function tn(e) {
        e ? process.env.DEBUG = e : delete process.env.DEBUG;
      }
      function nn() {
        return process.env.DEBUG;
      }
      function on(e) {
        e.inspectOpts = {};
        let r = Object.keys(y.inspectOpts);
        for (let t = 0; t < r.length; t++)
          e.inspectOpts[r[t]] = y.inspectOpts[r[t]];
      }
      ze.exports = Je()(y);
      var { formatters: Gr } = ze.exports;
      Gr.o = function(e) {
        return this.inspectOpts.colors = this.useColors, Oe.inspect(e, this.inspectOpts).split(`
`).map((r) => r.trim()).join(" ");
      };
      Gr.O = function(e) {
        return this.inspectOpts.colors = this.useColors, Oe.inspect(e, this.inspectOpts);
      };
    });
    var $r = E((Pn, ke) => {
      typeof process == "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs ? ke.exports = qr() : ke.exports = Yr();
    });
    var Kr = E((Zn, Vr) => {
      Vr.exports = jr;
      function jr(e, r) {
        if (e && r)
          return jr(e)(r);
        if (typeof e != "function")
          throw new TypeError("need wrapper function");
        return Object.keys(e).forEach(function(n) {
          t[n] = e[n];
        }), t;
        function t() {
          for (var n = new Array(arguments.length), i = 0; i < n.length; i++)
            n[i] = arguments[i];
          var o = e.apply(this, n), s = n[n.length - 1];
          return typeof o == "function" && o !== s && Object.keys(s).forEach(function(f) {
            o[f] = s[f];
          }), o;
        }
      }
    });
    var rr = E((Wn, er) => {
      var Xr = Kr();
      er.exports = Xr(_e);
      er.exports.strict = Xr(Jr);
      _e.proto = _e(function() {
        Object.defineProperty(Function.prototype, "once", { value: function() {
          return _e(this);
        }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
          return Jr(this);
        }, configurable: true });
      });
      function _e(e) {
        var r = function() {
          return r.called ? r.value : (r.called = true, r.value = e.apply(this, arguments));
        };
        return r.called = false, r;
      }
      function Jr(e) {
        var r = function() {
          if (r.called)
            throw new Error(r.onceError);
          return r.called = true, r.value = e.apply(this, arguments);
        }, t = e.name || "Function wrapped with `once`";
        return r.onceError = t + " shouldn't be called more than once", r.called = false, r;
      }
    });
    var et = E((Hn, kr) => {
      var sn = rr(), fn = function() {
      }, an = function(e) {
        return e.setHeader && typeof e.abort == "function";
      }, un = function(e) {
        return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
      }, Qr = function(e, r, t) {
        if (typeof r == "function")
          return Qr(e, null, r);
        r || (r = {}), t = sn(t || fn);
        var n = e._writableState, i = e._readableState, o = r.readable || r.readable !== false && e.readable, s = r.writable || r.writable !== false && e.writable, f = false, u = function() {
          e.writable || d();
        }, d = function() {
          s = false, o || t.call(e);
        }, a = function() {
          o = false, s || t.call(e);
        }, c = function(h) {
          t.call(e, h ? new Error("exited with error code: " + h) : null);
        }, l = function(h) {
          t.call(e, h);
        }, x = function() {
          process.nextTick(g);
        }, g = function() {
          if (!f) {
            if (o && !(i && i.ended && !i.destroyed))
              return t.call(e, new Error("premature close"));
            if (s && !(n && n.ended && !n.destroyed))
              return t.call(e, new Error("premature close"));
          }
        }, p = function() {
          e.req.on("finish", d);
        };
        return an(e) ? (e.on("complete", d), e.on("abort", x), e.req ? p() : e.on("request", p)) : s && !n && (e.on("end", u), e.on("close", u)), un(e) && e.on("exit", c), e.on("end", a), e.on("finish", d), r.error !== false && e.on("error", l), e.on("close", x), function() {
          f = true, e.removeListener("complete", d), e.removeListener("abort", x), e.removeListener("request", p), e.req && e.req.removeListener("finish", d), e.removeListener("end", u), e.removeListener("close", u), e.removeListener("finish", d), e.removeListener("exit", c), e.removeListener("end", a), e.removeListener("error", l), e.removeListener("close", x);
        };
      };
      kr.exports = Qr;
    });
    var nt = E((Gn, tt) => {
      var cn = rr(), dn = et(), tr = require("fs"), fe = function() {
      }, ln = /^v?\.0/.test(process.version), Ae = function(e) {
        return typeof e == "function";
      }, hn = function(e) {
        return !ln || !tr ? false : (e instanceof (tr.ReadStream || fe) || e instanceof (tr.WriteStream || fe)) && Ae(e.close);
      }, pn = function(e) {
        return e.setHeader && Ae(e.abort);
      }, mn = function(e, r, t, n) {
        n = cn(n);
        var i = false;
        e.on("close", function() {
          i = true;
        }), dn(e, { readable: r, writable: t }, function(s) {
          if (s)
            return n(s);
          i = true, n();
        });
        var o = false;
        return function(s) {
          if (!i && !o) {
            if (o = true, hn(e))
              return e.close(fe);
            if (pn(e))
              return e.abort();
            if (Ae(e.destroy))
              return e.destroy();
            n(s || new Error("stream was destroyed"));
          }
        };
      }, rt = function(e) {
        e();
      }, xn = function(e, r) {
        return e.pipe(r);
      }, vn = function() {
        var e = Array.prototype.slice.call(arguments), r = Ae(e[e.length - 1] || fe) && e.pop() || fe;
        if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
          throw new Error("pump requires two streams per minimum");
        var t, n = e.map(function(i, o) {
          var s = o < e.length - 1, f = o > 0;
          return mn(i, s, f, function(u) {
            t || (t = u), u && n.forEach(rt), !s && (n.forEach(rt), r(t));
          });
        });
        return e.reduce(xn);
      };
      tt.exports = vn;
    });
    var ot = E((Yn, it) => {
      "use strict";
      var { PassThrough: En } = require("stream");
      it.exports = (e) => {
        e = __spreadValues({}, e);
        let { array: r } = e, { encoding: t } = e, n = t === "buffer", i = false;
        r ? i = !(t || n) : t = t || "utf8", n && (t = null);
        let o = new En({ objectMode: i });
        t && o.setEncoding(t);
        let s = 0, f = [];
        return o.on("data", (u) => {
          f.push(u), i ? s = f.length : s += u.length;
        }), o.getBufferedValue = () => r ? f : n ? Buffer.concat(f, s) : f.join(""), o.getBufferedLength = () => s, o;
      };
    });
    var st = E(($n, Q) => {
      "use strict";
      var { constants: wn } = require("buffer"), gn = nt(), yn = ot(), Re = class extends Error {
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      };
      function De(e, r) {
        return __async(this, null, function* () {
          if (!e)
            return Promise.reject(new Error("Expected a stream"));
          r = __spreadValues({ maxBuffer: 1 / 0 }, r);
          let { maxBuffer: t } = r, n;
          return yield new Promise((i, o) => {
            let s = (f) => {
              f && n.getBufferedLength() <= wn.MAX_LENGTH && (f.bufferedData = n.getBufferedValue()), o(f);
            };
            n = gn(e, yn(r), (f) => {
              if (f) {
                s(f);
                return;
              }
              i();
            }), n.on("data", () => {
              n.getBufferedLength() > t && s(new Re());
            });
          }), n.getBufferedValue();
        });
      }
      Q.exports = De;
      Q.exports.default = De;
      Q.exports.buffer = (e, r) => De(e, __spreadProps(__spreadValues({}, r), { encoding: "buffer" }));
      Q.exports.array = (e, r) => De(e, __spreadProps(__spreadValues({}, r), { array: true }));
      Q.exports.MaxBufferError = Re;
    });
    var at = E((jn, ft) => {
      var z = $r()("extract-zip"), { createWriteStream: Cn, promises: k } = require("fs"), bn = st(), G = require("path"), { promisify: ir } = require("util"), Fn = require("stream"), Sn = Xe(), In = ir(Sn.open), Ln = ir(Fn.pipeline), nr = class {
        constructor(r, t) {
          this.zipPath = r, this.opts = t;
        }
        extract() {
          return __async(this, null, function* () {
            return z("opening", this.zipPath, "with opts", this.opts), this.zipfile = yield In(this.zipPath, { lazyEntries: true }), this.canceled = false, new Promise((r, t) => {
              this.zipfile.on("error", (n) => {
                this.canceled = true, t(n);
              }), this.zipfile.readEntry(), this.zipfile.on("close", () => {
                this.canceled || (z("zip extraction complete"), r());
              }), this.zipfile.on("entry", (n) => __async(this, null, function* () {
                if (this.canceled) {
                  z("skipping entry", n.fileName, { cancelled: this.canceled });
                  return;
                }
                if (z("zipfile entry", n.fileName), n.fileName.startsWith("__MACOSX/")) {
                  this.zipfile.readEntry();
                  return;
                }
                let i = G.dirname(G.join(this.opts.dir, n.fileName));
                try {
                  yield k.mkdir(i, { recursive: true });
                  let o = yield k.realpath(i);
                  if (G.relative(this.opts.dir, o).split(G.sep).includes(".."))
                    throw new Error(`Out of bound path "${o}" found while processing file ${n.fileName}`);
                  yield this.extractEntry(n), z("finished processing", n.fileName), this.zipfile.readEntry();
                } catch (o) {
                  this.canceled = true, this.zipfile.close(), t(o);
                }
              }));
            });
          });
        }
        extractEntry(r) {
          return __async(this, null, function* () {
            if (this.canceled) {
              z("skipping entry extraction", r.fileName, { cancelled: this.canceled });
              return;
            }
            this.opts.onEntry && this.opts.onEntry(r, this.zipfile);
            let t = G.join(this.opts.dir, r.fileName), n = r.externalFileAttributes >> 16 & 65535, i = 61440, o = 16384, s = 40960, f = (n & i) === s, u = (n & i) === o;
            !u && r.fileName.endsWith("/") && (u = true);
            let d = r.versionMadeBy >> 8;
            u || (u = d === 0 && r.externalFileAttributes === 16), z("extracting entry", { filename: r.fileName, isDir: u, isSymlink: f });
            let a = this.getExtractedMode(n, u) & 511, c = u ? t : G.dirname(t), l = { recursive: true };
            if (u && (l.mode = a), z("mkdir", __spreadValues({ dir: c }, l)), yield k.mkdir(c, l), u)
              return;
            z("opening read stream", t);
            let x = yield ir(this.zipfile.openReadStream.bind(this.zipfile))(r);
            if (f) {
              let g = yield bn(x);
              z("creating symlink", g, t), yield k.symlink(g, t);
            } else
              yield Ln(x, Cn(t, { mode: a }));
          });
        }
        getExtractedMode(r, t) {
          let n = r;
          return n === 0 && (t ? (this.opts.defaultDirMode && (n = parseInt(this.opts.defaultDirMode, 10)), n || (n = 493)) : (this.opts.defaultFileMode && (n = parseInt(this.opts.defaultFileMode, 10)), n || (n = 420))), n;
        }
      };
      ft.exports = function(e, r) {
        return __async(this, null, function* () {
          if (z("creating target directory", r.dir), !G.isAbsolute(r.dir))
            throw new Error("Target directory is expected to be absolute");
          return yield k.mkdir(r.dir, { recursive: true }), r.dir = yield k.realpath(r.dir), new nr(e, r).extract();
        });
      };
    });
    var zn = {};
    Et(zn, { extract: () => On, yauzl: () => dt, yazl: () => ct });
    module2.exports = wt(zn);
    var ct = Ue(br());
    var dt = Ue(Xe());
    var ut = Ue(at());
    var On = ut.default;
  }
});

// node_modules/playwright-core/lib/zipBundle.js
var require_zipBundle = __commonJS({
  "node_modules/playwright-core/lib/zipBundle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.yazl = exports2.yauzl = exports2.extract = void 0;
    var yazl2 = require_zipBundleImpl().yazl;
    exports2.yazl = yazl2;
    var yauzl2 = require_zipBundleImpl().yauzl;
    exports2.yauzl = yauzl2;
    var extract2 = require_zipBundleImpl().extract;
    exports2.extract = extract2;
  }
});

// node_modules/playwright-core/lib/utils/traceUtils.js
var require_traceUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/traceUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createAfterActionTraceEventForStep = createAfterActionTraceEventForStep;
    exports2.createBeforeActionTraceEventForStep = createBeforeActionTraceEventForStep;
    exports2.mergeTraceFiles = mergeTraceFiles;
    exports2.saveTraceFile = saveTraceFile;
    exports2.serializeClientSideCallMetadata = serializeClientSideCallMetadata;
    var _fs = _interopRequireDefault(require("fs"));
    var _zipBundle = require_zipBundle();
    var _manualPromise = require_manualPromise();
    var _crypto = require_crypto();
    var _time = require_time();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function serializeClientSideCallMetadata(metadatas) {
      const fileNames = /* @__PURE__ */ new Map();
      const stacks = [];
      for (const m of metadatas) {
        if (!m.stack || !m.stack.length)
          continue;
        const stack = [];
        for (const frame of m.stack) {
          let ordinal = fileNames.get(frame.file);
          if (typeof ordinal !== "number") {
            ordinal = fileNames.size;
            fileNames.set(frame.file, ordinal);
          }
          const stackFrame = [ordinal, frame.line || 0, frame.column || 0, frame.function || ""];
          stack.push(stackFrame);
        }
        stacks.push([m.id, stack]);
      }
      return {
        files: [...fileNames.keys()],
        stacks
      };
    }
    function mergeTraceFiles(fileName, temporaryTraceFiles) {
      return __async(this, null, function* () {
        if (temporaryTraceFiles.length === 1) {
          yield _fs.default.promises.rename(temporaryTraceFiles[0], fileName);
          return;
        }
        const mergePromise = new _manualPromise.ManualPromise();
        const zipFile = new _zipBundle.yazl.ZipFile();
        const entryNames = /* @__PURE__ */ new Set();
        zipFile.on("error", (error) => mergePromise.reject(error));
        for (let i = 0; i < temporaryTraceFiles.length; ++i) {
          const tempFile = temporaryTraceFiles[i];
          const promise = new _manualPromise.ManualPromise();
          _zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
            if (err) {
              promise.reject(err);
              return;
            }
            let pendingEntries = inZipFile.entryCount;
            inZipFile.on("entry", (entry) => {
              let entryName = entry.fileName;
              if (entry.fileName.match(/[\d-]*trace./))
                entryName = i + "-" + entry.fileName;
              inZipFile.openReadStream(entry, (err2, readStream) => {
                if (err2) {
                  promise.reject(err2);
                  return;
                }
                if (!entryNames.has(entryName)) {
                  entryNames.add(entryName);
                  zipFile.addReadStream(readStream, entryName);
                }
                if (--pendingEntries === 0)
                  promise.resolve();
              });
            });
          });
          yield promise;
        }
        zipFile.end(void 0, () => {
          zipFile.outputStream.pipe(_fs.default.createWriteStream(fileName)).on("close", () => {
            Promise.all(temporaryTraceFiles.map((tempFile) => _fs.default.promises.unlink(tempFile))).then(() => {
              mergePromise.resolve();
            });
          }).on("error", (error) => mergePromise.reject(error));
        });
        yield mergePromise;
      });
    }
    function saveTraceFile(fileName, traceEvents, saveSources) {
      return __async(this, null, function* () {
        const zipFile = new _zipBundle.yazl.ZipFile();
        if (saveSources) {
          const sourceFiles = /* @__PURE__ */ new Set();
          for (const event of traceEvents) {
            if (event.type === "before") {
              for (const frame of event.stack || [])
                sourceFiles.add(frame.file);
            }
          }
          for (const sourceFile of sourceFiles) {
            yield _fs.default.promises.readFile(sourceFile, "utf8").then((source) => {
              zipFile.addBuffer(Buffer.from(source), "resources/src@" + (0, _crypto.calculateSha1)(sourceFile) + ".txt");
            }).catch(() => {
            });
          }
        }
        const sha1s = /* @__PURE__ */ new Set();
        for (const event of traceEvents.filter((e) => e.type === "after")) {
          for (const attachment of event.attachments || []) {
            let contentPromise;
            if (attachment.path)
              contentPromise = _fs.default.promises.readFile(attachment.path);
            else if (attachment.base64)
              contentPromise = Promise.resolve(Buffer.from(attachment.base64, "base64"));
            if (!contentPromise)
              continue;
            const content = yield contentPromise;
            const sha1 = (0, _crypto.calculateSha1)(content);
            attachment.sha1 = sha1;
            delete attachment.path;
            delete attachment.base64;
            if (sha1s.has(sha1))
              continue;
            sha1s.add(sha1);
            zipFile.addBuffer(content, "resources/" + sha1);
          }
        }
        const traceContent = Buffer.from(traceEvents.map((e) => JSON.stringify(e)).join("\n"));
        zipFile.addBuffer(traceContent, "trace.trace");
        yield new Promise((f) => {
          zipFile.end(void 0, () => {
            zipFile.outputStream.pipe(_fs.default.createWriteStream(fileName)).on("close", f);
          });
        });
      });
    }
    function createBeforeActionTraceEventForStep(callId, parentId, apiName, params, wallTime, stack) {
      return {
        type: "before",
        callId,
        parentId,
        wallTime,
        startTime: (0, _time.monotonicTime)(),
        class: "Test",
        method: "step",
        apiName,
        params: Object.fromEntries(Object.entries(params || {}).map(([name, value]) => [name, generatePreview(value)])),
        stack
      };
    }
    function createAfterActionTraceEventForStep(callId, attachments, error) {
      return {
        type: "after",
        callId,
        endTime: (0, _time.monotonicTime)(),
        log: [],
        attachments,
        error
      };
    }
    function generatePreview(value, visited = /* @__PURE__ */ new Set()) {
      if (visited.has(value))
        return "";
      visited.add(value);
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value.toString();
      if (typeof value === "boolean")
        return value.toString();
      if (value === null)
        return "null";
      if (value === void 0)
        return "undefined";
      if (Array.isArray(value))
        return "[" + value.map((v) => generatePreview(v, visited)).join(", ") + "]";
      if (typeof value === "object")
        return "Object";
      return String(value);
    }
  }
});

// node_modules/playwright-core/lib/utils/linuxUtils.js
var require_linuxUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/linuxUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLinuxDistributionInfo = getLinuxDistributionInfo;
    exports2.getLinuxDistributionInfoSync = getLinuxDistributionInfoSync;
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var didFailToReadOSRelease = false;
    var osRelease;
    function getLinuxDistributionInfo() {
      return __async(this, null, function* () {
        if (process.platform !== "linux")
          return void 0;
        if (!osRelease && !didFailToReadOSRelease) {
          try {
            var _fields$get, _fields$get2;
            const osReleaseText = yield _fs.default.promises.readFile("/etc/os-release", "utf8");
            const fields = parseOSReleaseText(osReleaseText);
            osRelease = {
              id: (_fields$get = fields.get("id")) !== null && _fields$get !== void 0 ? _fields$get : "",
              version: (_fields$get2 = fields.get("version_id")) !== null && _fields$get2 !== void 0 ? _fields$get2 : ""
            };
          } catch (e) {
            didFailToReadOSRelease = true;
          }
        }
        return osRelease;
      });
    }
    function getLinuxDistributionInfoSync() {
      if (process.platform !== "linux")
        return void 0;
      if (!osRelease && !didFailToReadOSRelease) {
        try {
          var _fields$get3, _fields$get4;
          const osReleaseText = _fs.default.readFileSync("/etc/os-release", "utf8");
          const fields = parseOSReleaseText(osReleaseText);
          osRelease = {
            id: (_fields$get3 = fields.get("id")) !== null && _fields$get3 !== void 0 ? _fields$get3 : "",
            version: (_fields$get4 = fields.get("version_id")) !== null && _fields$get4 !== void 0 ? _fields$get4 : ""
          };
        } catch (e) {
          didFailToReadOSRelease = true;
        }
      }
      return osRelease;
    }
    function parseOSReleaseText(osReleaseText) {
      const fields = /* @__PURE__ */ new Map();
      for (const line of osReleaseText.split("\n")) {
        const tokens = line.split("=");
        const name = tokens.shift();
        let value = tokens.join("=").trim();
        if (value.startsWith('"') && value.endsWith('"'))
          value = value.substring(1, value.length - 1);
        if (!name)
          continue;
        fields.set(name.toLowerCase(), value);
      }
      return fields;
    }
  }
});

// node_modules/playwright-core/package.json
var require_package = __commonJS({
  "node_modules/playwright-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "playwright-core",
      version: "1.36.0",
      description: "A high-level API to automate web browsers",
      repository: "github:Microsoft/playwright",
      homepage: "https://playwright.dev",
      engines: {
        node: ">=16"
      },
      author: {
        name: "Microsoft Corporation"
      },
      license: "Apache-2.0",
      exports: {
        ".": {
          types: "./index.d.ts",
          import: "./index.mjs",
          require: "./index.js",
          default: "./index.js"
        },
        "./package.json": "./package.json",
        "./lib/outofprocess": "./lib/outofprocess.js",
        "./lib/image_tools/stats": "./lib/image_tools/stats.js",
        "./lib/image_tools/compare": "./lib/image_tools/compare.js",
        "./lib/image_tools/imageChannel": "./lib/image_tools/imageChannel.js",
        "./lib/image_tools/colorUtils": "./lib/image_tools/colorUtils.js",
        "./lib/cli/cli": "./lib/cli/cli.js",
        "./lib/cli/program": "./lib/cli/program.js",
        "./lib/containers/docker": "./lib/containers/docker.js",
        "./lib/remote/playwrightServer": "./lib/remote/playwrightServer.js",
        "./lib/server": "./lib/server/index.js",
        "./lib/utils": "./lib/utils/index.js",
        "./lib/utilsBundle": "./lib/utilsBundle.js",
        "./lib/zipBundle": "./lib/zipBundle.js",
        "./types/protocol": "./types/protocol.d.ts",
        "./types/structs": "./types/structs.d.ts"
      },
      bin: {
        "playwright-core": "./cli.js"
      },
      types: "types/types.d.ts"
    };
  }
});

// node_modules/playwright-core/lib/utils/userAgent.js
var require_userAgent = __commonJS({
  "node_modules/playwright-core/lib/utils/userAgent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getEmbedderName = getEmbedderName;
    exports2.getPlaywrightVersion = getPlaywrightVersion;
    exports2.getUserAgent = getUserAgent;
    var _child_process = require("child_process");
    var _os = _interopRequireDefault(require("os"));
    var _linuxUtils = require_linuxUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cachedUserAgent;
    function getUserAgent() {
      if (cachedUserAgent)
        return cachedUserAgent;
      try {
        cachedUserAgent = determineUserAgent();
      } catch (e) {
        cachedUserAgent = "Playwright/unknown";
      }
      return cachedUserAgent;
    }
    function determineUserAgent() {
      let osIdentifier = "unknown";
      let osVersion = "unknown";
      if (process.platform === "win32") {
        const version = _os.default.release().split(".");
        osIdentifier = "windows";
        osVersion = `${version[0]}.${version[1]}`;
      } else if (process.platform === "darwin") {
        const version = (0, _child_process.execSync)("sw_vers -productVersion", {
          stdio: ["ignore", "pipe", "ignore"]
        }).toString().trim().split(".");
        osIdentifier = "macOS";
        osVersion = `${version[0]}.${version[1]}`;
      } else if (process.platform === "linux") {
        const distroInfo = (0, _linuxUtils.getLinuxDistributionInfoSync)();
        if (distroInfo) {
          osIdentifier = distroInfo.id || "linux";
          osVersion = distroInfo.version || "unknown";
        } else {
          osIdentifier = "linux";
        }
      }
      const additionalTokens = [];
      if (process.env.CI)
        additionalTokens.push("CI/1");
      const serializedTokens = additionalTokens.length ? " " + additionalTokens.join(" ") : "";
      const {
        embedderName,
        embedderVersion
      } = getEmbedderName();
      return `Playwright/${getPlaywrightVersion()} (${_os.default.arch()}; ${osIdentifier} ${osVersion}) ${embedderName}/${embedderVersion}${serializedTokens}`;
    }
    function getEmbedderName() {
      let embedderName = "unknown";
      let embedderVersion = "unknown";
      if (!process.env.PW_LANG_NAME) {
        embedderName = "node";
        embedderVersion = process.version.substring(1).split(".").slice(0, 2).join(".");
      } else if (["node", "python", "java", "csharp"].includes(process.env.PW_LANG_NAME)) {
        var _process$env$PW_LANG_;
        embedderName = process.env.PW_LANG_NAME;
        embedderVersion = (_process$env$PW_LANG_ = process.env.PW_LANG_NAME_VERSION) !== null && _process$env$PW_LANG_ !== void 0 ? _process$env$PW_LANG_ : "unknown";
      }
      return {
        embedderName,
        embedderVersion
      };
    }
    function getPlaywrightVersion(majorMinorOnly = false) {
      const packageJson = require_package();
      return majorMinorOnly ? packageJson.version.split(".").slice(0, 2).join(".") : packageJson.version;
    }
  }
});

// node_modules/playwright-core/lib/utils/zipFile.js
var require_zipFile = __commonJS({
  "node_modules/playwright-core/lib/utils/zipFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ZipFile = void 0;
    var _zipBundle = require_zipBundle();
    var ZipFile = class {
      constructor(fileName) {
        this._fileName = void 0;
        this._zipFile = void 0;
        this._entries = /* @__PURE__ */ new Map();
        this._openedPromise = void 0;
        this._fileName = fileName;
        this._openedPromise = this._open();
      }
      _open() {
        return __async(this, null, function* () {
          yield new Promise((fulfill, reject) => {
            _zipBundle.yauzl.open(this._fileName, {
              autoClose: false
            }, (e, z) => {
              if (e) {
                reject(e);
                return;
              }
              this._zipFile = z;
              this._zipFile.on("entry", (entry) => {
                this._entries.set(entry.fileName, entry);
              });
              this._zipFile.on("end", fulfill);
            });
          });
        });
      }
      entries() {
        return __async(this, null, function* () {
          yield this._openedPromise;
          return [...this._entries.keys()];
        });
      }
      read(entryPath) {
        return __async(this, null, function* () {
          yield this._openedPromise;
          const entry = this._entries.get(entryPath);
          if (!entry)
            throw new Error(`${entryPath} not found in file ${this._fileName}`);
          return new Promise((resolve, reject) => {
            this._zipFile.openReadStream(entry, (error, readStream) => {
              if (error || !readStream) {
                reject(error || "Entry not found");
                return;
              }
              const buffers = [];
              readStream.on("data", (data) => buffers.push(data));
              readStream.on("end", () => resolve(Buffer.concat(buffers)));
            });
          });
        });
      }
      close() {
        var _this$_zipFile;
        (_this$_zipFile = this._zipFile) === null || _this$_zipFile === void 0 ? void 0 : _this$_zipFile.close();
      }
    };
    exports2.ZipFile = ZipFile;
  }
});

// node_modules/playwright-core/lib/utils/zones.js
var require_zones = __commonJS({
  "node_modules/playwright-core/lib/utils/zones.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.runWithFinally = runWithFinally;
    exports2.zones = void 0;
    var _stackTrace = require_stackTrace();
    var ZoneManager = class {
      constructor() {
        this.lastZoneId = 0;
        this._zones = /* @__PURE__ */ new Map();
      }
      run(type, data, func) {
        return new Zone(this, ++this.lastZoneId, type, data).run(func);
      }
      zoneData(type, rawStack) {
        for (const line of rawStack) {
          for (const zoneId of zoneIds(line)) {
            const zone = this._zones.get(zoneId);
            if (zone && zone.type === type)
              return zone.data;
          }
        }
        return null;
      }
      preserve(callback) {
        const rawStack = (0, _stackTrace.captureRawStack)();
        const refs = [];
        for (const line of rawStack)
          refs.push(...zoneIds(line));
        Object.defineProperty(callback, "name", {
          value: `__PWZONE__[${refs.join(",")}]-refs`
        });
        return callback();
      }
    };
    function zoneIds(line) {
      const index = line.indexOf("__PWZONE__[");
      if (index === -1)
        return [];
      return line.substring(index + "__PWZONE__[".length, line.indexOf("]", index)).split(",").map((s) => +s);
    }
    var Zone = class {
      constructor(manager, id, type, data) {
        this._manager = void 0;
        this.id = void 0;
        this.type = void 0;
        this.data = void 0;
        this.wallTime = void 0;
        this._manager = manager;
        this.id = id;
        this.type = type;
        this.data = data;
        this.wallTime = Date.now();
      }
      run(func) {
        this._manager._zones.set(this.id, this);
        Object.defineProperty(func, "name", {
          value: `__PWZONE__[${this.id}]-${this.type}`
        });
        return runWithFinally(() => func(this.data), () => {
          this._manager._zones.delete(this.id);
        });
      }
    };
    function runWithFinally(func, finallyFunc) {
      try {
        const result = func();
        if (result instanceof Promise) {
          return result.then((r) => {
            finallyFunc();
            return r;
          }).catch((e) => {
            finallyFunc();
            throw e;
          });
        }
        finallyFunc();
        return result;
      } catch (e) {
        finallyFunc();
        throw e;
      }
    }
    var zones = new ZoneManager();
    exports2.zones = zones;
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/stringUtils.js
var require_stringUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/stringUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.cssEscape = cssEscape;
    exports2.escapeForAttributeSelector = escapeForAttributeSelector;
    exports2.escapeForTextSelector = escapeForTextSelector;
    exports2.escapeWithQuotes = escapeWithQuotes;
    exports2.isString = isString;
    exports2.normalizeWhiteSpace = normalizeWhiteSpace;
    exports2.toSnakeCase = toSnakeCase;
    exports2.toTitleCase = toTitleCase;
    function escapeWithQuotes(text, char = "'") {
      const stringified = JSON.stringify(text);
      const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
      if (char === "'")
        return char + escapedText.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + escapedText.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + escapedText.replace(/[`]/g, "`") + char;
      throw new Error("Invalid escape char");
    }
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function toTitleCase(name) {
      return name.charAt(0).toUpperCase() + name.substring(1);
    }
    function toSnakeCase(name) {
      return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();
    }
    function cssEscape(s) {
      let result = "";
      for (let i = 0; i < s.length; i++)
        result += cssEscapeOne(s, i);
      return result;
    }
    function cssEscapeOne(s, i) {
      const c = s.charCodeAt(i);
      if (c === 0)
        return "\uFFFD";
      if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))
        return "\\" + c.toString(16) + " ";
      if (i === 0 && c === 45 && s.length === 1)
        return "\\" + s.charAt(i);
      if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)
        return s.charAt(i);
      return "\\" + s.charAt(i);
    }
    function normalizeWhiteSpace(text) {
      return text.replace(/\u200b/g, "").trim().replace(/\s+/g, " ");
    }
    function escapeForTextSelector(text, exact) {
      if (typeof text !== "string")
        return String(text).replace(/>>/g, "\\>\\>");
      return `${JSON.stringify(text)}${exact ? "s" : "i"}`;
    }
    function escapeForAttributeSelector(value, exact) {
      if (typeof value !== "string")
        return String(value).replace(/>>/g, "\\>\\>");
      return `"${value.replace(/\\/g, "\\\\").replace(/["]/g, '\\"')}"${exact ? "s" : "i"}`;
    }
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/cssTokenizer.js
var require_cssTokenizer = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/cssTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WhitespaceToken = exports2.URLToken = exports2.SuffixMatchToken = exports2.SubstringMatchToken = exports2.StringValuedToken = exports2.StringToken = exports2.SemicolonToken = exports2.PrefixMatchToken = exports2.PercentageToken = exports2.OpenSquareToken = exports2.OpenParenToken = exports2.OpenCurlyToken = exports2.NumberToken = exports2.InvalidCharacterError = exports2.IncludeMatchToken = exports2.IdentToken = exports2.HashToken = exports2.GroupingToken = exports2.FunctionToken = exports2.EOFToken = exports2.DimensionToken = exports2.DelimToken = exports2.DashMatchToken = exports2.CommaToken = exports2.ColumnToken = exports2.ColonToken = exports2.CloseSquareToken = exports2.CloseParenToken = exports2.CloseCurlyToken = exports2.CSSParserToken = exports2.CDOToken = exports2.CDCToken = exports2.BadURLToken = exports2.BadStringToken = exports2.AtKeywordToken = void 0;
    exports2.tokenize = tokenize;
    var between = function(num, first, last) {
      return num >= first && num <= last;
    };
    function digit(code) {
      return between(code, 48, 57);
    }
    function hexdigit(code) {
      return digit(code) || between(code, 65, 70) || between(code, 97, 102);
    }
    function uppercaseletter(code) {
      return between(code, 65, 90);
    }
    function lowercaseletter(code) {
      return between(code, 97, 122);
    }
    function letter(code) {
      return uppercaseletter(code) || lowercaseletter(code);
    }
    function nonascii(code) {
      return code >= 128;
    }
    function namestartchar(code) {
      return letter(code) || nonascii(code) || code === 95;
    }
    function namechar(code) {
      return namestartchar(code) || digit(code) || code === 45;
    }
    function nonprintable(code) {
      return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;
    }
    function newline(code) {
      return code === 10;
    }
    function whitespace(code) {
      return newline(code) || code === 9 || code === 32;
    }
    var maximumallowedcodepoint = 1114111;
    var InvalidCharacterError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidCharacterError";
      }
    };
    exports2.InvalidCharacterError = InvalidCharacterError;
    function preprocess(str) {
      const codepoints = [];
      for (let i = 0; i < str.length; i++) {
        let code = str.charCodeAt(i);
        if (code === 13 && str.charCodeAt(i + 1) === 10) {
          code = 10;
          i++;
        }
        if (code === 13 || code === 12)
          code = 10;
        if (code === 0)
          code = 65533;
        if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
          const lead = code - 55296;
          const trail = str.charCodeAt(i + 1) - 56320;
          code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
          i++;
        }
        codepoints.push(code);
      }
      return codepoints;
    }
    function stringFromCode(code) {
      if (code <= 65535)
        return String.fromCharCode(code);
      code -= Math.pow(2, 16);
      const lead = Math.floor(code / Math.pow(2, 10)) + 55296;
      const trail = code % Math.pow(2, 10) + 56320;
      return String.fromCharCode(lead) + String.fromCharCode(trail);
    }
    function tokenize(str1) {
      const str = preprocess(str1);
      let i = -1;
      const tokens = [];
      let code;
      let line = 0;
      let column = 0;
      let lastLineLength = 0;
      const incrLineno = function() {
        line += 1;
        lastLineLength = column;
        column = 0;
      };
      const locStart = {
        line,
        column
      };
      const codepoint = function(i2) {
        if (i2 >= str.length)
          return -1;
        return str[i2];
      };
      const next = function(num) {
        if (num === void 0)
          num = 1;
        if (num > 3)
          throw "Spec Error: no more than three codepoints of lookahead.";
        return codepoint(i + num);
      };
      const consume = function(num) {
        if (num === void 0)
          num = 1;
        i += num;
        code = codepoint(i);
        if (newline(code))
          incrLineno();
        else
          column += num;
        return true;
      };
      const reconsume = function() {
        i -= 1;
        if (newline(code)) {
          line -= 1;
          column = lastLineLength;
        } else {
          column -= 1;
        }
        locStart.line = line;
        locStart.column = column;
        return true;
      };
      const eof = function(codepoint2) {
        if (codepoint2 === void 0)
          codepoint2 = code;
        return codepoint2 === -1;
      };
      const donothing = function() {
      };
      const parseerror = function() {
      };
      const consumeAToken = function() {
        consumeComments();
        consume();
        if (whitespace(code)) {
          while (whitespace(next()))
            consume();
          return new WhitespaceToken();
        } else if (code === 34) {
          return consumeAStringToken();
        } else if (code === 35) {
          if (namechar(next()) || areAValidEscape(next(1), next(2))) {
            const token = new HashToken("");
            if (wouldStartAnIdentifier(next(1), next(2), next(3)))
              token.type = "id";
            token.value = consumeAName();
            return token;
          } else {
            return new DelimToken(code);
          }
        } else if (code === 36) {
          if (next() === 61) {
            consume();
            return new SuffixMatchToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 39) {
          return consumeAStringToken();
        } else if (code === 40) {
          return new OpenParenToken();
        } else if (code === 41) {
          return new CloseParenToken();
        } else if (code === 42) {
          if (next() === 61) {
            consume();
            return new SubstringMatchToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 43) {
          if (startsWithANumber()) {
            reconsume();
            return consumeANumericToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 44) {
          return new CommaToken();
        } else if (code === 45) {
          if (startsWithANumber()) {
            reconsume();
            return consumeANumericToken();
          } else if (next(1) === 45 && next(2) === 62) {
            consume(2);
            return new CDCToken();
          } else if (startsWithAnIdentifier()) {
            reconsume();
            return consumeAnIdentlikeToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 46) {
          if (startsWithANumber()) {
            reconsume();
            return consumeANumericToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 58) {
          return new ColonToken();
        } else if (code === 59) {
          return new SemicolonToken();
        } else if (code === 60) {
          if (next(1) === 33 && next(2) === 45 && next(3) === 45) {
            consume(3);
            return new CDOToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 64) {
          if (wouldStartAnIdentifier(next(1), next(2), next(3)))
            return new AtKeywordToken(consumeAName());
          else
            return new DelimToken(code);
        } else if (code === 91) {
          return new OpenSquareToken();
        } else if (code === 92) {
          if (startsWithAValidEscape()) {
            reconsume();
            return consumeAnIdentlikeToken();
          } else {
            parseerror();
            return new DelimToken(code);
          }
        } else if (code === 93) {
          return new CloseSquareToken();
        } else if (code === 94) {
          if (next() === 61) {
            consume();
            return new PrefixMatchToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 123) {
          return new OpenCurlyToken();
        } else if (code === 124) {
          if (next() === 61) {
            consume();
            return new DashMatchToken();
          } else if (next() === 124) {
            consume();
            return new ColumnToken();
          } else {
            return new DelimToken(code);
          }
        } else if (code === 125) {
          return new CloseCurlyToken();
        } else if (code === 126) {
          if (next() === 61) {
            consume();
            return new IncludeMatchToken();
          } else {
            return new DelimToken(code);
          }
        } else if (digit(code)) {
          reconsume();
          return consumeANumericToken();
        } else if (namestartchar(code)) {
          reconsume();
          return consumeAnIdentlikeToken();
        } else if (eof()) {
          return new EOFToken();
        } else {
          return new DelimToken(code);
        }
      };
      const consumeComments = function() {
        while (next(1) === 47 && next(2) === 42) {
          consume(2);
          while (true) {
            consume();
            if (code === 42 && next() === 47) {
              consume();
              break;
            } else if (eof()) {
              parseerror();
              return;
            }
          }
        }
      };
      const consumeANumericToken = function() {
        const num = consumeANumber();
        if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
          const token = new DimensionToken();
          token.value = num.value;
          token.repr = num.repr;
          token.type = num.type;
          token.unit = consumeAName();
          return token;
        } else if (next() === 37) {
          consume();
          const token = new PercentageToken();
          token.value = num.value;
          token.repr = num.repr;
          return token;
        } else {
          const token = new NumberToken();
          token.value = num.value;
          token.repr = num.repr;
          token.type = num.type;
          return token;
        }
      };
      const consumeAnIdentlikeToken = function() {
        const str2 = consumeAName();
        if (str2.toLowerCase() === "url" && next() === 40) {
          consume();
          while (whitespace(next(1)) && whitespace(next(2)))
            consume();
          if (next() === 34 || next() === 39)
            return new FunctionToken(str2);
          else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))
            return new FunctionToken(str2);
          else
            return consumeAURLToken();
        } else if (next() === 40) {
          consume();
          return new FunctionToken(str2);
        } else {
          return new IdentToken(str2);
        }
      };
      const consumeAStringToken = function(endingCodePoint) {
        if (endingCodePoint === void 0)
          endingCodePoint = code;
        let string = "";
        while (consume()) {
          if (code === endingCodePoint || eof()) {
            return new StringToken(string);
          } else if (newline(code)) {
            parseerror();
            reconsume();
            return new BadStringToken();
          } else if (code === 92) {
            if (eof(next()))
              donothing();
            else if (newline(next()))
              consume();
            else
              string += stringFromCode(consumeEscape());
          } else {
            string += stringFromCode(code);
          }
        }
        throw new Error("Internal error");
      };
      const consumeAURLToken = function() {
        const token = new URLToken("");
        while (whitespace(next()))
          consume();
        if (eof(next()))
          return token;
        while (consume()) {
          if (code === 41 || eof()) {
            return token;
          } else if (whitespace(code)) {
            while (whitespace(next()))
              consume();
            if (next() === 41 || eof(next())) {
              consume();
              return token;
            } else {
              consumeTheRemnantsOfABadURL();
              return new BadURLToken();
            }
          } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {
            parseerror();
            consumeTheRemnantsOfABadURL();
            return new BadURLToken();
          } else if (code === 92) {
            if (startsWithAValidEscape()) {
              token.value += stringFromCode(consumeEscape());
            } else {
              parseerror();
              consumeTheRemnantsOfABadURL();
              return new BadURLToken();
            }
          } else {
            token.value += stringFromCode(code);
          }
        }
        throw new Error("Internal error");
      };
      const consumeEscape = function() {
        consume();
        if (hexdigit(code)) {
          const digits = [code];
          for (let total = 0; total < 5; total++) {
            if (hexdigit(next())) {
              consume();
              digits.push(code);
            } else {
              break;
            }
          }
          if (whitespace(next()))
            consume();
          let value = parseInt(digits.map(function(x) {
            return String.fromCharCode(x);
          }).join(""), 16);
          if (value > maximumallowedcodepoint)
            value = 65533;
          return value;
        } else if (eof()) {
          return 65533;
        } else {
          return code;
        }
      };
      const areAValidEscape = function(c1, c2) {
        if (c1 !== 92)
          return false;
        if (newline(c2))
          return false;
        return true;
      };
      const startsWithAValidEscape = function() {
        return areAValidEscape(code, next());
      };
      const wouldStartAnIdentifier = function(c1, c2, c3) {
        if (c1 === 45)
          return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);
        else if (namestartchar(c1))
          return true;
        else if (c1 === 92)
          return areAValidEscape(c1, c2);
        else
          return false;
      };
      const startsWithAnIdentifier = function() {
        return wouldStartAnIdentifier(code, next(1), next(2));
      };
      const wouldStartANumber = function(c1, c2, c3) {
        if (c1 === 43 || c1 === 45) {
          if (digit(c2))
            return true;
          if (c2 === 46 && digit(c3))
            return true;
          return false;
        } else if (c1 === 46) {
          if (digit(c2))
            return true;
          return false;
        } else if (digit(c1)) {
          return true;
        } else {
          return false;
        }
      };
      const startsWithANumber = function() {
        return wouldStartANumber(code, next(1), next(2));
      };
      const consumeAName = function() {
        let result = "";
        while (consume()) {
          if (namechar(code)) {
            result += stringFromCode(code);
          } else if (startsWithAValidEscape()) {
            result += stringFromCode(consumeEscape());
          } else {
            reconsume();
            return result;
          }
        }
        throw new Error("Internal parse error");
      };
      const consumeANumber = function() {
        let repr = "";
        let type = "integer";
        if (next() === 43 || next() === 45) {
          consume();
          repr += stringFromCode(code);
        }
        while (digit(next())) {
          consume();
          repr += stringFromCode(code);
        }
        if (next(1) === 46 && digit(next(2))) {
          consume();
          repr += stringFromCode(code);
          consume();
          repr += stringFromCode(code);
          type = "number";
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
        }
        const c1 = next(1), c2 = next(2), c3 = next(3);
        if ((c1 === 69 || c1 === 101) && digit(c2)) {
          consume();
          repr += stringFromCode(code);
          consume();
          repr += stringFromCode(code);
          type = "number";
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
        } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {
          consume();
          repr += stringFromCode(code);
          consume();
          repr += stringFromCode(code);
          consume();
          repr += stringFromCode(code);
          type = "number";
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
        }
        const value = convertAStringToANumber(repr);
        return {
          type,
          value,
          repr
        };
      };
      const convertAStringToANumber = function(string) {
        return +string;
      };
      const consumeTheRemnantsOfABadURL = function() {
        while (consume()) {
          if (code === 41 || eof()) {
            return;
          } else if (startsWithAValidEscape()) {
            consumeEscape();
            donothing();
          } else {
            donothing();
          }
        }
      };
      let iterationCount = 0;
      while (!eof(next())) {
        tokens.push(consumeAToken());
        iterationCount++;
        if (iterationCount > str.length * 2)
          throw new Error("I'm infinite-looping!");
      }
      return tokens;
    }
    var CSSParserToken = class {
      constructor() {
        this.tokenType = "";
        this.value = void 0;
      }
      toJSON() {
        return {
          token: this.tokenType
        };
      }
      toString() {
        return this.tokenType;
      }
      toSource() {
        return "" + this;
      }
    };
    exports2.CSSParserToken = CSSParserToken;
    var BadStringToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "BADSTRING";
      }
    };
    exports2.BadStringToken = BadStringToken;
    var BadURLToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "BADURL";
      }
    };
    exports2.BadURLToken = BadURLToken;
    var WhitespaceToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "WHITESPACE";
      }
      toString() {
        return "WS";
      }
      toSource() {
        return " ";
      }
    };
    exports2.WhitespaceToken = WhitespaceToken;
    var CDOToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "CDO";
      }
      toSource() {
        return "<!--";
      }
    };
    exports2.CDOToken = CDOToken;
    var CDCToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "CDC";
      }
      toSource() {
        return "-->";
      }
    };
    exports2.CDCToken = CDCToken;
    var ColonToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = ":";
      }
    };
    exports2.ColonToken = ColonToken;
    var SemicolonToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = ";";
      }
    };
    exports2.SemicolonToken = SemicolonToken;
    var CommaToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = ",";
      }
    };
    exports2.CommaToken = CommaToken;
    var GroupingToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.value = "";
        this.mirror = "";
      }
    };
    exports2.GroupingToken = GroupingToken;
    var OpenCurlyToken = class extends GroupingToken {
      constructor() {
        super();
        this.tokenType = "{";
        this.value = "{";
        this.mirror = "}";
      }
    };
    exports2.OpenCurlyToken = OpenCurlyToken;
    var CloseCurlyToken = class extends GroupingToken {
      constructor() {
        super();
        this.tokenType = "}";
        this.value = "}";
        this.mirror = "{";
      }
    };
    exports2.CloseCurlyToken = CloseCurlyToken;
    var OpenSquareToken = class extends GroupingToken {
      constructor() {
        super();
        this.tokenType = "[";
        this.value = "[";
        this.mirror = "]";
      }
    };
    exports2.OpenSquareToken = OpenSquareToken;
    var CloseSquareToken = class extends GroupingToken {
      constructor() {
        super();
        this.tokenType = "]";
        this.value = "]";
        this.mirror = "[";
      }
    };
    exports2.CloseSquareToken = CloseSquareToken;
    var OpenParenToken = class extends GroupingToken {
      constructor() {
        super();
        this.tokenType = "(";
        this.value = "(";
        this.mirror = ")";
      }
    };
    exports2.OpenParenToken = OpenParenToken;
    var CloseParenToken = class extends GroupingToken {
      constructor() {
        super();
        this.tokenType = ")";
        this.value = ")";
        this.mirror = "(";
      }
    };
    exports2.CloseParenToken = CloseParenToken;
    var IncludeMatchToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "~=";
      }
    };
    exports2.IncludeMatchToken = IncludeMatchToken;
    var DashMatchToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "|=";
      }
    };
    exports2.DashMatchToken = DashMatchToken;
    var PrefixMatchToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "^=";
      }
    };
    exports2.PrefixMatchToken = PrefixMatchToken;
    var SuffixMatchToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "$=";
      }
    };
    exports2.SuffixMatchToken = SuffixMatchToken;
    var SubstringMatchToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "*=";
      }
    };
    exports2.SubstringMatchToken = SubstringMatchToken;
    var ColumnToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "||";
      }
    };
    exports2.ColumnToken = ColumnToken;
    var EOFToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.tokenType = "EOF";
      }
      toSource() {
        return "";
      }
    };
    exports2.EOFToken = EOFToken;
    var DelimToken = class extends CSSParserToken {
      constructor(code) {
        super();
        this.tokenType = "DELIM";
        this.value = "";
        this.value = stringFromCode(code);
      }
      toString() {
        return "DELIM(" + this.value + ")";
      }
      toJSON() {
        const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      }
      toSource() {
        if (this.value === "\\")
          return "\\\n";
        else
          return this.value;
      }
    };
    exports2.DelimToken = DelimToken;
    var StringValuedToken = class extends CSSParserToken {
      constructor(...args) {
        super(...args);
        this.value = "";
      }
      ASCIIMatch(str) {
        return this.value.toLowerCase() === str.toLowerCase();
      }
      toJSON() {
        const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      }
    };
    exports2.StringValuedToken = StringValuedToken;
    var IdentToken = class extends StringValuedToken {
      constructor(val) {
        super();
        this.tokenType = "IDENT";
        this.value = val;
      }
      toString() {
        return "IDENT(" + this.value + ")";
      }
      toSource() {
        return escapeIdent(this.value);
      }
    };
    exports2.IdentToken = IdentToken;
    var FunctionToken = class extends StringValuedToken {
      constructor(val) {
        super();
        this.tokenType = "FUNCTION";
        this.mirror = void 0;
        this.value = val;
        this.mirror = ")";
      }
      toString() {
        return "FUNCTION(" + this.value + ")";
      }
      toSource() {
        return escapeIdent(this.value) + "(";
      }
    };
    exports2.FunctionToken = FunctionToken;
    var AtKeywordToken = class extends StringValuedToken {
      constructor(val) {
        super();
        this.tokenType = "AT-KEYWORD";
        this.value = val;
      }
      toString() {
        return "AT(" + this.value + ")";
      }
      toSource() {
        return "@" + escapeIdent(this.value);
      }
    };
    exports2.AtKeywordToken = AtKeywordToken;
    var HashToken = class extends StringValuedToken {
      constructor(val) {
        super();
        this.tokenType = "HASH";
        this.type = void 0;
        this.value = val;
        this.type = "unrestricted";
      }
      toString() {
        return "HASH(" + this.value + ")";
      }
      toJSON() {
        const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
      }
      toSource() {
        if (this.type === "id")
          return "#" + escapeIdent(this.value);
        else
          return "#" + escapeHash(this.value);
      }
    };
    exports2.HashToken = HashToken;
    var StringToken = class extends StringValuedToken {
      constructor(val) {
        super();
        this.tokenType = "STRING";
        this.value = val;
      }
      toString() {
        return '"' + escapeString(this.value) + '"';
      }
    };
    exports2.StringToken = StringToken;
    var URLToken = class extends StringValuedToken {
      constructor(val) {
        super();
        this.tokenType = "URL";
        this.value = val;
      }
      toString() {
        return "URL(" + this.value + ")";
      }
      toSource() {
        return 'url("' + escapeString(this.value) + '")';
      }
    };
    exports2.URLToken = URLToken;
    var NumberToken = class extends CSSParserToken {
      constructor() {
        super();
        this.tokenType = "NUMBER";
        this.type = void 0;
        this.repr = void 0;
        this.type = "integer";
        this.repr = "";
      }
      toString() {
        if (this.type === "integer")
          return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
      }
      toJSON() {
        const json = super.toJSON();
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
      }
      toSource() {
        return this.repr;
      }
    };
    exports2.NumberToken = NumberToken;
    var PercentageToken = class extends CSSParserToken {
      constructor() {
        super();
        this.tokenType = "PERCENTAGE";
        this.repr = void 0;
        this.repr = "";
      }
      toString() {
        return "PERCENTAGE(" + this.value + ")";
      }
      toJSON() {
        const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
      }
      toSource() {
        return this.repr + "%";
      }
    };
    exports2.PercentageToken = PercentageToken;
    var DimensionToken = class extends CSSParserToken {
      constructor() {
        super();
        this.tokenType = "DIMENSION";
        this.type = void 0;
        this.repr = void 0;
        this.unit = void 0;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
      }
      toString() {
        return "DIM(" + this.value + "," + this.unit + ")";
      }
      toJSON() {
        const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
      }
      toSource() {
        const source = this.repr;
        let unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {
          unit = "\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
      }
    };
    exports2.DimensionToken = DimensionToken;
    function escapeIdent(string) {
      string = "" + string;
      let result = "";
      const firstcode = string.charCodeAt(0);
      for (let i = 0; i < string.length; i++) {
        const code = string.charCodeAt(i);
        if (code === 0)
          throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
        if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)
          result += "\\" + code.toString(16) + " ";
        else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
          result += string[i];
        else
          result += "\\" + string[i];
      }
      return result;
    }
    function escapeHash(string) {
      string = "" + string;
      let result = "";
      for (let i = 0; i < string.length; i++) {
        const code = string.charCodeAt(i);
        if (code === 0)
          throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
        if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))
          result += string[i];
        else
          result += "\\" + code.toString(16) + " ";
      }
      return result;
    }
    function escapeString(string) {
      string = "" + string;
      let result = "";
      for (let i = 0; i < string.length; i++) {
        const code = string.charCodeAt(i);
        if (code === 0)
          throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
        if (between(code, 1, 31) || code === 127)
          result += "\\" + code.toString(16) + " ";
        else if (code === 34 || code === 92)
          result += "\\" + string[i];
        else
          result += string[i];
      }
      return result;
    }
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/cssParser.js
var require_cssParser = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/cssParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.InvalidSelectorError = void 0;
    exports2.isInvalidSelectorError = isInvalidSelectorError;
    exports2.parseCSS = parseCSS;
    exports2.serializeSelector = serializeSelector;
    var css = _interopRequireWildcard(require_cssTokenizer());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var InvalidSelectorError = class extends Error {
    };
    exports2.InvalidSelectorError = InvalidSelectorError;
    function isInvalidSelectorError(error) {
      return error instanceof InvalidSelectorError;
    }
    function parseCSS(selector, customNames) {
      let tokens;
      try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
          tokens.push(new css.EOFToken());
      } catch (e) {
        const newMessage = e.message + ` while parsing selector "${selector}"`;
        const index = (e.stack || "").indexOf(e.message);
        if (index !== -1)
          e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
      }
      const unsupportedToken = tokens.find((token) => {
        return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || token instanceof css.URLToken || token instanceof css.PercentageToken;
      });
      if (unsupportedToken)
        throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
      let pos = 0;
      const names = /* @__PURE__ */ new Set();
      function unexpected() {
        return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
      }
      function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
          pos++;
      }
      function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
      }
      function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
      }
      function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
      }
      function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
      }
      function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
      }
      function isStar(p = pos) {
        return tokens[p] instanceof css.DelimToken && tokens[p].value === "*";
      }
      function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
      }
      function isClauseCombinator(p = pos) {
        return tokens[p] instanceof css.DelimToken && [">", "+", "~"].includes(tokens[p].value);
      }
      function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;
      }
      function consumeFunctionArguments() {
        const result2 = [consumeArgument()];
        while (true) {
          skipWhitespace();
          if (!isComma())
            break;
          pos++;
          result2.push(consumeArgument());
        }
        return result2;
      }
      function consumeArgument() {
        skipWhitespace();
        if (isNumber())
          return tokens[pos++].value;
        if (isString())
          return tokens[pos++].value;
        return consumeComplexSelector();
      }
      function consumeComplexSelector() {
        const result2 = {
          simples: []
        };
        skipWhitespace();
        if (isClauseCombinator()) {
          result2.simples.push({
            selector: {
              functions: [{
                name: "scope",
                args: []
              }]
            },
            combinator: ""
          });
        } else {
          result2.simples.push({
            selector: consumeSimpleSelector(),
            combinator: ""
          });
        }
        while (true) {
          skipWhitespace();
          if (isClauseCombinator()) {
            result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
            skipWhitespace();
          } else if (isSelectorClauseEnd()) {
            break;
          }
          result2.simples.push({
            combinator: "",
            selector: consumeSimpleSelector()
          });
        }
        return result2;
      }
      function consumeSimpleSelector() {
        let rawCSSString = "";
        const functions = [];
        while (!isSelectorClauseEnd()) {
          if (isIdent() || isStar()) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css.HashToken) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === ".") {
            pos++;
            if (isIdent())
              rawCSSString += "." + tokens[pos++].toSource();
            else
              throw unexpected();
          } else if (tokens[pos] instanceof css.ColonToken) {
            pos++;
            if (isIdent()) {
              if (!customNames.has(tokens[pos].value.toLowerCase())) {
                rawCSSString += ":" + tokens[pos++].toSource();
              } else {
                const name = tokens[pos++].value.toLowerCase();
                functions.push({
                  name,
                  args: []
                });
                names.add(name);
              }
            } else if (tokens[pos] instanceof css.FunctionToken) {
              const name = tokens[pos++].value.toLowerCase();
              if (!customNames.has(name)) {
                rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
              } else {
                functions.push({
                  name,
                  args: consumeFunctionArguments()
                });
                names.add(name);
              }
              skipWhitespace();
              if (!isCloseParen())
                throw unexpected();
              pos++;
            } else {
              throw unexpected();
            }
          } else if (tokens[pos] instanceof css.OpenSquareToken) {
            rawCSSString += "[";
            pos++;
            while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
              rawCSSString += tokens[pos++].toSource();
            if (!(tokens[pos] instanceof css.CloseSquareToken))
              throw unexpected();
            rawCSSString += "]";
            pos++;
          } else {
            throw unexpected();
          }
        }
        if (!rawCSSString && !functions.length)
          throw unexpected();
        return {
          css: rawCSSString || void 0,
          functions
        };
      }
      function consumeBuiltinFunctionArguments() {
        let s = "";
        while (!isCloseParen() && !isEOF())
          s += tokens[pos++].toSource();
        return s;
      }
      const result = consumeFunctionArguments();
      if (!isEOF())
        throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);
      if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
        throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);
      return {
        selector: result,
        names: Array.from(names)
      };
    }
    function serializeSelector(args) {
      return args.map((arg) => {
        if (typeof arg === "string")
          return `"${arg}"`;
        if (typeof arg === "number")
          return String(arg);
        return arg.simples.map(({
          selector,
          combinator
        }) => {
          let s = selector.css || "";
          s = s + selector.functions.map((func) => `:${func.name}(${serializeSelector(func.args)})`).join("");
          if (combinator)
            s += " " + combinator;
          return s;
        }).join(" ");
      }).join(", ");
    }
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/selectorParser.js
var require_selectorParser = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/selectorParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "InvalidSelectorError", {
      enumerable: true,
      get: function() {
        return _cssParser.InvalidSelectorError;
      }
    });
    exports2.customCSSNames = void 0;
    Object.defineProperty(exports2, "isInvalidSelectorError", {
      enumerable: true,
      get: function() {
        return _cssParser.isInvalidSelectorError;
      }
    });
    exports2.parseAttributeSelector = parseAttributeSelector;
    exports2.parseSelector = parseSelector;
    exports2.splitSelectorByFrame = splitSelectorByFrame;
    exports2.stringifySelector = stringifySelector;
    exports2.visitAllSelectorParts = visitAllSelectorParts;
    var _cssParser = require_cssParser();
    var kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "left-of", "right-of", "above", "below", "near"]);
    var kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);
    var customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
    exports2.customCSSNames = customCSSNames;
    function parseSelector(selector) {
      const parsedStrings = parseSelectorString(selector);
      const parts = [];
      for (const part of parsedStrings.parts) {
        if (part.name === "css" || part.name === "css:light") {
          if (part.name === "css:light")
            part.body = ":light(" + part.body + ")";
          const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);
          parts.push({
            name: "css",
            body: parsedCSS.selector,
            source: part.body
          });
          continue;
        }
        if (kNestedSelectorNames.has(part.name)) {
          let innerSelector;
          let distance;
          try {
            const unescaped = JSON.parse("[" + part.body + "]");
            if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")
              throw new _cssParser.InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
            innerSelector = unescaped[0];
            if (unescaped.length === 2) {
              if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))
                throw new _cssParser.InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
              distance = unescaped[1];
            }
          } catch (e) {
            throw new _cssParser.InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);
          }
          const nested = {
            name: part.name,
            source: part.body,
            body: {
              parsed: parseSelector(innerSelector),
              distance
            }
          };
          const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");
          const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;
          if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))
            nested.body.parsed.parts.splice(0, lastFrameIndex + 1);
          parts.push(nested);
          continue;
        }
        parts.push(__spreadProps(__spreadValues({}, part), {
          source: part.body
        }));
      }
      if (kNestedSelectorNames.has(parts[0].name))
        throw new _cssParser.InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);
      return {
        capture: parsedStrings.capture,
        parts
      };
    }
    function splitSelectorByFrame(selectorText) {
      const selector = parseSelector(selectorText);
      const result = [];
      let chunk = {
        parts: []
      };
      let chunkStartIndex = 0;
      for (let i = 0; i < selector.parts.length; ++i) {
        const part = selector.parts[i];
        if (part.name === "internal:control" && part.body === "enter-frame") {
          if (!chunk.parts.length)
            throw new _cssParser.InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");
          result.push(chunk);
          chunk = {
            parts: []
          };
          chunkStartIndex = i + 1;
          continue;
        }
        if (selector.capture === i)
          chunk.capture = i - chunkStartIndex;
        chunk.parts.push(part);
      }
      if (!chunk.parts.length)
        throw new _cssParser.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
      result.push(chunk);
      if (typeof selector.capture === "number" && typeof result[result.length - 1].capture !== "number")
        throw new _cssParser.InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
      return result;
    }
    function selectorPartsEqual(list1, list2) {
      return stringifySelector({
        parts: list1
      }) === stringifySelector({
        parts: list2
      });
    }
    function stringifySelector(selector) {
      if (typeof selector === "string")
        return selector;
      return selector.parts.map((p, i) => {
        const prefix = p.name === "css" ? "" : p.name + "=";
        return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;
      }).join(" >> ");
    }
    function visitAllSelectorParts(selector, visitor) {
      const visit = (selector2, nested) => {
        for (const part of selector2.parts) {
          visitor(part, nested);
          if (kNestedSelectorNames.has(part.name))
            visit(part.body.parsed, true);
        }
      };
      visit(selector, false);
    }
    function parseSelectorString(selector) {
      let index = 0;
      let quote;
      let start = 0;
      const result = {
        parts: []
      };
      const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf("=");
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
          name = part.substring(0, eqIndex).trim();
          body = part.substring(eqIndex + 1);
        } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
          name = "text";
          body = part;
        } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
          name = "text";
          body = part;
        } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
          name = "xpath";
          body = part;
        } else {
          name = "css";
          body = part;
        }
        let capture = false;
        if (name[0] === "*") {
          capture = true;
          name = name.substring(1);
        }
        result.parts.push({
          name,
          body
        });
        if (capture) {
          if (result.capture !== void 0)
            throw new _cssParser.InvalidSelectorError(`Only one of the selectors can capture using * modifier`);
          result.capture = result.parts.length - 1;
        }
      };
      if (!selector.includes(">>")) {
        index = selector.length;
        append();
        return result;
      }
      const shouldIgnoreTextSelectorQuote = () => {
        const prefix = selector.substring(start, index);
        const match = prefix.match(/^\s*text\s*=(.*)$/);
        return !!match && !!match[1];
      };
      while (index < selector.length) {
        const c = selector[index];
        if (c === "\\" && index + 1 < selector.length) {
          index += 2;
        } else if (c === quote) {
          quote = void 0;
          index++;
        } else if (!quote && (c === '"' || c === "'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {
          quote = c;
          index++;
        } else if (!quote && c === ">" && selector[index + 1] === ">") {
          append();
          index += 2;
          start = index;
        } else {
          index++;
        }
      }
      append();
      return result;
    }
    function parseAttributeSelector(selector, allowUnquotedStrings) {
      let wp = 0;
      let EOL = selector.length === 0;
      const next = () => selector[wp] || "";
      const eat1 = () => {
        const result2 = next();
        ++wp;
        EOL = wp >= selector.length;
        return result2;
      };
      const syntaxError = (stage) => {
        if (EOL)
          throw new _cssParser.InvalidSelectorError(`Unexpected end of selector while parsing selector \`${selector}\``);
        throw new _cssParser.InvalidSelectorError(`Error while parsing selector \`${selector}\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));
      };
      function skipSpaces() {
        while (!EOL && /\s/.test(next()))
          eat1();
      }
      function isCSSNameChar(char) {
        return char >= "\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";
      }
      function readIdentifier() {
        let result2 = "";
        skipSpaces();
        while (!EOL && isCSSNameChar(next()))
          result2 += eat1();
        return result2;
      }
      function readQuotedString(quote) {
        let result2 = eat1();
        if (result2 !== quote)
          syntaxError("parsing quoted string");
        while (!EOL && next() !== quote) {
          if (next() === "\\")
            eat1();
          result2 += eat1();
        }
        if (next() !== quote)
          syntaxError("parsing quoted string");
        result2 += eat1();
        return result2;
      }
      function readRegularExpression() {
        if (eat1() !== "/")
          syntaxError("parsing regular expression");
        let source = "";
        let inClass = false;
        while (!EOL) {
          if (next() === "\\") {
            source += eat1();
            if (EOL)
              syntaxError("parsing regular expressiion");
          } else if (inClass && next() === "]") {
            inClass = false;
          } else if (!inClass && next() === "[") {
            inClass = true;
          } else if (!inClass && next() === "/") {
            break;
          }
          source += eat1();
        }
        if (eat1() !== "/")
          syntaxError("parsing regular expression");
        let flags = "";
        while (!EOL && next().match(/[dgimsuy]/))
          flags += eat1();
        try {
          return new RegExp(source, flags);
        } catch (e) {
          throw new _cssParser.InvalidSelectorError(`Error while parsing selector \`${selector}\`: ${e.message}`);
        }
      }
      function readAttributeToken() {
        let token = "";
        skipSpaces();
        if (next() === `'` || next() === `"`)
          token = readQuotedString(next()).slice(1, -1);
        else
          token = readIdentifier();
        if (!token)
          syntaxError("parsing property path");
        return token;
      }
      function readOperator() {
        skipSpaces();
        let op = "";
        if (!EOL)
          op += eat1();
        if (!EOL && op !== "=")
          op += eat1();
        if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))
          syntaxError("parsing operator");
        return op;
      }
      function readAttribute() {
        eat1();
        const jsonPath = [];
        jsonPath.push(readAttributeToken());
        skipSpaces();
        while (next() === ".") {
          eat1();
          jsonPath.push(readAttributeToken());
          skipSpaces();
        }
        if (next() === "]") {
          eat1();
          return {
            name: jsonPath.join("."),
            jsonPath,
            op: "<truthy>",
            value: null,
            caseSensitive: false
          };
        }
        const operator = readOperator();
        let value = void 0;
        let caseSensitive = true;
        skipSpaces();
        if (next() === "/") {
          if (operator !== "=")
            throw new _cssParser.InvalidSelectorError(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with regular expression`);
          value = readRegularExpression();
        } else if (next() === `'` || next() === `"`) {
          value = readQuotedString(next()).slice(1, -1);
          skipSpaces();
          if (next() === "i" || next() === "I") {
            caseSensitive = false;
            eat1();
          } else if (next() === "s" || next() === "S") {
            caseSensitive = true;
            eat1();
          }
        } else {
          value = "";
          while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))
            value += eat1();
          if (value === "true") {
            value = true;
          } else if (value === "false") {
            value = false;
          } else {
            if (!allowUnquotedStrings) {
              value = +value;
              if (Number.isNaN(value))
                syntaxError("parsing attribute value");
            }
          }
        }
        skipSpaces();
        if (next() !== "]")
          syntaxError("parsing attribute value");
        eat1();
        if (operator !== "=" && typeof value !== "string")
          throw new _cssParser.InvalidSelectorError(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);
        return {
          name: jsonPath.join("."),
          jsonPath,
          op: operator,
          value,
          caseSensitive
        };
      }
      const result = {
        name: "",
        attributes: []
      };
      result.name = readIdentifier();
      skipSpaces();
      while (next() === "[") {
        result.attributes.push(readAttribute());
        skipSpaces();
      }
      if (!EOL)
        syntaxError(void 0);
      if (!result.name && !result.attributes.length)
        throw new _cssParser.InvalidSelectorError(`Error while parsing selector \`${selector}\` - selector cannot be empty`);
      return result;
    }
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/locatorGenerators.js
var require_locatorGenerators = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/locatorGenerators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PythonLocatorFactory = exports2.JsonlLocatorFactory = exports2.JavaScriptLocatorFactory = exports2.JavaLocatorFactory = exports2.CSharpLocatorFactory = void 0;
    exports2.asLocator = asLocator;
    exports2.asLocators = asLocators;
    var _stringUtils = require_stringUtils();
    var _selectorParser = require_selectorParser();
    function asLocator(lang, selector, isFrameLocator = false, playSafe = false) {
      return asLocators(lang, selector, isFrameLocator, playSafe)[0];
    }
    function asLocators(lang, selector, isFrameLocator = false, playSafe = false, maxOutputSize = 20) {
      if (playSafe) {
        try {
          return innerAsLocators(generators[lang], (0, _selectorParser.parseSelector)(selector), isFrameLocator, maxOutputSize);
        } catch (e) {
          return [selector];
        }
      } else {
        return innerAsLocators(generators[lang], (0, _selectorParser.parseSelector)(selector), isFrameLocator, maxOutputSize);
      }
    }
    function innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {
      const parts = [...parsed.parts];
      for (let index = 0; index < parts.length - 1; index++) {
        if (parts[index].name === "nth" && parts[index + 1].name === "internal:control" && parts[index + 1].body === "enter-frame") {
          const [nth] = parts.splice(index, 1);
          parts.splice(index + 1, 0, nth);
        }
      }
      const tokens = [];
      let nextBase = isFrameLocator ? "frame-locator" : "page";
      for (let index = 0; index < parts.length; index++) {
        const part = parts[index];
        const base = nextBase;
        nextBase = "locator";
        if (part.name === "nth") {
          if (part.body === "0")
            tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);
          else if (part.body === "-1")
            tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);
          else
            tokens.push([factory.generateLocator(base, "nth", part.body)]);
          continue;
        }
        if (part.name === "internal:text") {
          const {
            exact,
            text
          } = detectExact(part.body);
          tokens.push([factory.generateLocator(base, "text", text, {
            exact
          })]);
          continue;
        }
        if (part.name === "internal:has-text") {
          const {
            exact,
            text
          } = detectExact(part.body);
          if (!exact) {
            tokens.push([factory.generateLocator(base, "has-text", text, {
              exact
            })]);
            continue;
          }
        }
        if (part.name === "internal:has-not-text") {
          const {
            exact,
            text
          } = detectExact(part.body);
          if (!exact) {
            tokens.push([factory.generateLocator(base, "has-not-text", text, {
              exact
            })]);
            continue;
          }
        }
        if (part.name === "internal:has") {
          const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
          tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));
          continue;
        }
        if (part.name === "internal:has-not") {
          const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
          tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));
          continue;
        }
        if (part.name === "internal:and") {
          const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
          tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));
          continue;
        }
        if (part.name === "internal:or") {
          const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);
          tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));
          continue;
        }
        if (part.name === "internal:label") {
          const {
            exact,
            text
          } = detectExact(part.body);
          tokens.push([factory.generateLocator(base, "label", text, {
            exact
          })]);
          continue;
        }
        if (part.name === "internal:role") {
          const attrSelector = (0, _selectorParser.parseAttributeSelector)(part.body, true);
          const options = {
            attrs: []
          };
          for (const attr of attrSelector.attributes) {
            if (attr.name === "name") {
              options.exact = attr.caseSensitive;
              options.name = attr.value;
            } else {
              if (attr.name === "level" && typeof attr.value === "string")
                attr.value = +attr.value;
              options.attrs.push({
                name: attr.name === "include-hidden" ? "includeHidden" : attr.name,
                value: attr.value
              });
            }
          }
          tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);
          continue;
        }
        if (part.name === "internal:testid") {
          const attrSelector = (0, _selectorParser.parseAttributeSelector)(part.body, true);
          const {
            value
          } = attrSelector.attributes[0];
          tokens.push([factory.generateLocator(base, "test-id", value)]);
          continue;
        }
        if (part.name === "internal:attr") {
          const attrSelector = (0, _selectorParser.parseAttributeSelector)(part.body, true);
          const {
            name,
            value,
            caseSensitive
          } = attrSelector.attributes[0];
          const text = value;
          const exact = !!caseSensitive;
          if (name === "placeholder") {
            tokens.push([factory.generateLocator(base, "placeholder", text, {
              exact
            })]);
            continue;
          }
          if (name === "alt") {
            tokens.push([factory.generateLocator(base, "alt", text, {
              exact
            })]);
            continue;
          }
          if (name === "title") {
            tokens.push([factory.generateLocator(base, "title", text, {
              exact
            })]);
            continue;
          }
        }
        let locatorType = "default";
        const nextPart = parts[index + 1];
        if (nextPart && nextPart.name === "internal:control" && nextPart.body === "enter-frame") {
          locatorType = "frame";
          nextBase = "frame-locator";
          index++;
        }
        const selectorPart = (0, _selectorParser.stringifySelector)({
          parts: [part]
        });
        const locatorPart = factory.generateLocator(base, locatorType, selectorPart);
        if (locatorType === "default" && nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {
          const {
            exact,
            text
          } = detectExact(nextPart.body);
          if (!exact) {
            const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, {
              exact
            });
            const options = {};
            if (nextPart.name === "internal:has-text")
              options.hasText = text;
            else
              options.hasNotText = text;
            const combinedPart = factory.generateLocator(base, "default", selectorPart, options);
            tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);
            index++;
            continue;
          }
        }
        tokens.push([locatorPart]);
      }
      return combineTokens(factory, tokens, maxOutputSize);
    }
    function combineTokens(factory, tokens, maxOutputSize) {
      const currentTokens = tokens.map(() => "");
      const result = [];
      const visit = (index) => {
        if (index === tokens.length) {
          result.push(factory.chainLocators(currentTokens));
          return currentTokens.length < maxOutputSize;
        }
        for (const taken of tokens[index]) {
          currentTokens[index] = taken;
          if (!visit(index + 1))
            return false;
        }
        return true;
      };
      visit(0);
      return result;
    }
    function detectExact(text) {
      let exact = false;
      const match = text.match(/^\/(.*)\/([igm]*)$/);
      if (match)
        return {
          text: new RegExp(match[1], match[2])
        };
      if (text.endsWith('"')) {
        text = JSON.parse(text);
        exact = true;
      } else if (text.endsWith('"s')) {
        text = JSON.parse(text.substring(0, text.length - 1));
        exact = true;
      } else if (text.endsWith('"i')) {
        text = JSON.parse(text.substring(0, text.length - 1));
        exact = false;
      }
      return {
        exact,
        text
      };
    }
    var JavaScriptLocatorFactory = class {
      generateLocator(base, kind, body, options = {}) {
        switch (kind) {
          case "default":
            if (options.hasText !== void 0)
              return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;
            if (options.hasNotText !== void 0)
              return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;
            return `locator(${this.quote(body)})`;
          case "frame":
            return `frameLocator(${this.quote(body)})`;
          case "nth":
            return `nth(${body})`;
          case "first":
            return `first()`;
          case "last":
            return `last()`;
          case "role":
            const attrs = [];
            if (isRegExp(options.name)) {
              attrs.push(`name: ${options.name}`);
            } else if (typeof options.name === "string") {
              attrs.push(`name: ${this.quote(options.name)}`);
              if (options.exact)
                attrs.push(`exact: true`);
            }
            for (const {
              name,
              value
            } of options.attrs)
              attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);
            const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";
            return `getByRole(${this.quote(body)}${attrString})`;
          case "has-text":
            return `filter({ hasText: ${this.toHasText(body)} })`;
          case "has-not-text":
            return `filter({ hasNotText: ${this.toHasText(body)} })`;
          case "has":
            return `filter({ has: ${body} })`;
          case "hasNot":
            return `filter({ hasNot: ${body} })`;
          case "and":
            return `and(${body})`;
          case "or":
            return `or(${body})`;
          case "test-id":
            return `getByTestId(${this.toTestIdValue(body)})`;
          case "text":
            return this.toCallWithExact("getByText", body, !!options.exact);
          case "alt":
            return this.toCallWithExact("getByAltText", body, !!options.exact);
          case "placeholder":
            return this.toCallWithExact("getByPlaceholder", body, !!options.exact);
          case "label":
            return this.toCallWithExact("getByLabel", body, !!options.exact);
          case "title":
            return this.toCallWithExact("getByTitle", body, !!options.exact);
          default:
            throw new Error("Unknown selector kind " + kind);
        }
      }
      chainLocators(locators) {
        return locators.join(".");
      }
      toCallWithExact(method, body, exact) {
        if (isRegExp(body))
          return `${method}(${body})`;
        return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;
      }
      toHasText(body) {
        if (isRegExp(body))
          return String(body);
        return this.quote(body);
      }
      toTestIdValue(value) {
        if (isRegExp(value))
          return String(value);
        return this.quote(value);
      }
      quote(text) {
        return (0, _stringUtils.escapeWithQuotes)(text, "'");
      }
    };
    exports2.JavaScriptLocatorFactory = JavaScriptLocatorFactory;
    var PythonLocatorFactory = class {
      generateLocator(base, kind, body, options = {}) {
        switch (kind) {
          case "default":
            if (options.hasText !== void 0)
              return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;
            if (options.hasNotText !== void 0)
              return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;
            return `locator(${this.quote(body)})`;
          case "frame":
            return `frame_locator(${this.quote(body)})`;
          case "nth":
            return `nth(${body})`;
          case "first":
            return `first`;
          case "last":
            return `last`;
          case "role":
            const attrs = [];
            if (isRegExp(options.name)) {
              attrs.push(`name=${this.regexToString(options.name)}`);
            } else if (typeof options.name === "string") {
              attrs.push(`name=${this.quote(options.name)}`);
              if (options.exact)
                attrs.push(`exact=True`);
            }
            for (const {
              name,
              value
            } of options.attrs) {
              let valueString = typeof value === "string" ? this.quote(value) : value;
              if (typeof value === "boolean")
                valueString = value ? "True" : "False";
              attrs.push(`${(0, _stringUtils.toSnakeCase)(name)}=${valueString}`);
            }
            const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";
            return `get_by_role(${this.quote(body)}${attrString})`;
          case "has-text":
            return `filter(has_text=${this.toHasText(body)})`;
          case "has-not-text":
            return `filter(has_not_text=${this.toHasText(body)})`;
          case "has":
            return `filter(has=${body})`;
          case "hasNot":
            return `filter(has_not=${body})`;
          case "and":
            return `and_(${body})`;
          case "or":
            return `or_(${body})`;
          case "test-id":
            return `get_by_test_id(${this.toTestIdValue(body)})`;
          case "text":
            return this.toCallWithExact("get_by_text", body, !!options.exact);
          case "alt":
            return this.toCallWithExact("get_by_alt_text", body, !!options.exact);
          case "placeholder":
            return this.toCallWithExact("get_by_placeholder", body, !!options.exact);
          case "label":
            return this.toCallWithExact("get_by_label", body, !!options.exact);
          case "title":
            return this.toCallWithExact("get_by_title", body, !!options.exact);
          default:
            throw new Error("Unknown selector kind " + kind);
        }
      }
      chainLocators(locators) {
        return locators.join(".");
      }
      regexToString(body) {
        const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";
        return `re.compile(r"${body.source.replace(/\\\//, "/").replace(/"/g, '\\"')}"${suffix})`;
      }
      toCallWithExact(method, body, exact) {
        if (isRegExp(body))
          return `${method}(${this.regexToString(body)})`;
        if (exact)
          return `${method}(${this.quote(body)}, exact=True)`;
        return `${method}(${this.quote(body)})`;
      }
      toHasText(body) {
        if (isRegExp(body))
          return this.regexToString(body);
        return `${this.quote(body)}`;
      }
      toTestIdValue(value) {
        if (isRegExp(value))
          return this.regexToString(value);
        return this.quote(value);
      }
      quote(text) {
        return (0, _stringUtils.escapeWithQuotes)(text, '"');
      }
    };
    exports2.PythonLocatorFactory = PythonLocatorFactory;
    var JavaLocatorFactory = class {
      generateLocator(base, kind, body, options = {}) {
        let clazz;
        switch (base) {
          case "page":
            clazz = "Page";
            break;
          case "frame-locator":
            clazz = "FrameLocator";
            break;
          case "locator":
            clazz = "Locator";
            break;
        }
        switch (kind) {
          case "default":
            if (options.hasText !== void 0)
              return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;
            if (options.hasNotText !== void 0)
              return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;
            return `locator(${this.quote(body)})`;
          case "frame":
            return `frameLocator(${this.quote(body)})`;
          case "nth":
            return `nth(${body})`;
          case "first":
            return `first()`;
          case "last":
            return `last()`;
          case "role":
            const attrs = [];
            if (isRegExp(options.name)) {
              attrs.push(`.setName(${this.regexToString(options.name)})`);
            } else if (typeof options.name === "string") {
              attrs.push(`.setName(${this.quote(options.name)})`);
              if (options.exact)
                attrs.push(`.setExact(true)`);
            }
            for (const {
              name,
              value
            } of options.attrs)
              attrs.push(`.set${(0, _stringUtils.toTitleCase)(name)}(${typeof value === "string" ? this.quote(value) : value})`);
            const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";
            return `getByRole(AriaRole.${(0, _stringUtils.toSnakeCase)(body).toUpperCase()}${attrString})`;
          case "has-text":
            return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;
          case "has-not-text":
            return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;
          case "has":
            return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;
          case "hasNot":
            return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;
          case "and":
            return `and(${body})`;
          case "or":
            return `or(${body})`;
          case "test-id":
            return `getByTestId(${this.toTestIdValue(body)})`;
          case "text":
            return this.toCallWithExact(clazz, "getByText", body, !!options.exact);
          case "alt":
            return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);
          case "placeholder":
            return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);
          case "label":
            return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);
          case "title":
            return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);
          default:
            throw new Error("Unknown selector kind " + kind);
        }
      }
      chainLocators(locators) {
        return locators.join(".");
      }
      regexToString(body) {
        const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";
        return `Pattern.compile(${this.quote(body.source)}${suffix})`;
      }
      toCallWithExact(clazz, method, body, exact) {
        if (isRegExp(body))
          return `${method}(${this.regexToString(body)})`;
        if (exact)
          return `${method}(${this.quote(body)}, new ${clazz}.${(0, _stringUtils.toTitleCase)(method)}Options().setExact(true))`;
        return `${method}(${this.quote(body)})`;
      }
      toHasText(body) {
        if (isRegExp(body))
          return this.regexToString(body);
        return this.quote(body);
      }
      toTestIdValue(value) {
        if (isRegExp(value))
          return this.regexToString(value);
        return this.quote(value);
      }
      quote(text) {
        return (0, _stringUtils.escapeWithQuotes)(text, '"');
      }
    };
    exports2.JavaLocatorFactory = JavaLocatorFactory;
    var CSharpLocatorFactory = class {
      generateLocator(base, kind, body, options = {}) {
        switch (kind) {
          case "default":
            if (options.hasText !== void 0)
              return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;
            if (options.hasNotText !== void 0)
              return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;
            return `Locator(${this.quote(body)})`;
          case "frame":
            return `FrameLocator(${this.quote(body)})`;
          case "nth":
            return `Nth(${body})`;
          case "first":
            return `First`;
          case "last":
            return `Last`;
          case "role":
            const attrs = [];
            if (isRegExp(options.name)) {
              attrs.push(`NameRegex = ${this.regexToString(options.name)}`);
            } else if (typeof options.name === "string") {
              attrs.push(`Name = ${this.quote(options.name)}`);
              if (options.exact)
                attrs.push(`Exact = true`);
            }
            for (const {
              name,
              value
            } of options.attrs)
              attrs.push(`${(0, _stringUtils.toTitleCase)(name)} = ${typeof value === "string" ? this.quote(value) : value}`);
            const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";
            return `GetByRole(AriaRole.${(0, _stringUtils.toTitleCase)(body)}${attrString})`;
          case "has-text":
            return `Filter(new() { ${this.toHasText(body)} })`;
          case "has-not-text":
            return `Filter(new() { ${this.toHasNotText(body)} })`;
          case "has":
            return `Filter(new() { Has = ${body} })`;
          case "hasNot":
            return `Filter(new() { HasNot = ${body} })`;
          case "and":
            return `And(${body})`;
          case "or":
            return `Or(${body})`;
          case "test-id":
            return `GetByTestId(${this.toTestIdValue(body)})`;
          case "text":
            return this.toCallWithExact("GetByText", body, !!options.exact);
          case "alt":
            return this.toCallWithExact("GetByAltText", body, !!options.exact);
          case "placeholder":
            return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);
          case "label":
            return this.toCallWithExact("GetByLabel", body, !!options.exact);
          case "title":
            return this.toCallWithExact("GetByTitle", body, !!options.exact);
          default:
            throw new Error("Unknown selector kind " + kind);
        }
      }
      chainLocators(locators) {
        return locators.join(".");
      }
      regexToString(body) {
        const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";
        return `new Regex(${this.quote(body.source)}${suffix})`;
      }
      toCallWithExact(method, body, exact) {
        if (isRegExp(body))
          return `${method}(${this.regexToString(body)})`;
        if (exact)
          return `${method}(${this.quote(body)}, new() { Exact = true })`;
        return `${method}(${this.quote(body)})`;
      }
      toHasText(body) {
        if (isRegExp(body))
          return `HasTextRegex = ${this.regexToString(body)}`;
        return `HasText = ${this.quote(body)}`;
      }
      toTestIdValue(value) {
        if (isRegExp(value))
          return this.regexToString(value);
        return this.quote(value);
      }
      toHasNotText(body) {
        if (isRegExp(body))
          return `HasNotTextRegex = ${this.regexToString(body)}`;
        return `HasNotText = ${this.quote(body)}`;
      }
      quote(text) {
        return (0, _stringUtils.escapeWithQuotes)(text, '"');
      }
    };
    exports2.CSharpLocatorFactory = CSharpLocatorFactory;
    var JsonlLocatorFactory = class {
      generateLocator(base, kind, body, options = {}) {
        return JSON.stringify({
          kind,
          body,
          options
        });
      }
      chainLocators(locators) {
        const objects = locators.map((l) => JSON.parse(l));
        for (let i = 0; i < objects.length - 1; ++i)
          objects[i].next = objects[i + 1];
        return JSON.stringify(objects[0]);
      }
    };
    exports2.JsonlLocatorFactory = JsonlLocatorFactory;
    var generators = {
      javascript: new JavaScriptLocatorFactory(),
      python: new PythonLocatorFactory(),
      java: new JavaLocatorFactory(),
      csharp: new CSharpLocatorFactory(),
      jsonl: new JsonlLocatorFactory()
    };
    function isRegExp(obj) {
      return obj instanceof RegExp;
    }
  }
});

// node_modules/playwright-core/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/playwright-core/lib/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _ascii = require_ascii();
    Object.keys(_ascii).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _ascii[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _ascii[key];
        }
      });
    });
    var _comparators = require_comparators();
    Object.keys(_comparators).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _comparators[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _comparators[key];
        }
      });
    });
    var _crypto = require_crypto();
    Object.keys(_crypto).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _crypto[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _crypto[key];
        }
      });
    });
    var _debug = require_debug();
    Object.keys(_debug).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _debug[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _debug[key];
        }
      });
    });
    var _env = require_env();
    Object.keys(_env).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _env[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _env[key];
        }
      });
    });
    var _eventsHelper = require_eventsHelper();
    Object.keys(_eventsHelper).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _eventsHelper[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _eventsHelper[key];
        }
      });
    });
    var _fileUtils = require_fileUtils();
    Object.keys(_fileUtils).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _fileUtils[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _fileUtils[key];
        }
      });
    });
    var _glob = require_glob();
    Object.keys(_glob).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _glob[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _glob[key];
        }
      });
    });
    var _headers = require_headers();
    Object.keys(_headers).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _headers[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _headers[key];
        }
      });
    });
    var _httpServer = require_httpServer();
    Object.keys(_httpServer).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _httpServer[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _httpServer[key];
        }
      });
    });
    var _manualPromise = require_manualPromise();
    Object.keys(_manualPromise).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _manualPromise[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _manualPromise[key];
        }
      });
    });
    var _mimeType = require_mimeType();
    Object.keys(_mimeType).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _mimeType[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _mimeType[key];
        }
      });
    });
    var _multimap = require_multimap();
    Object.keys(_multimap).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _multimap[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _multimap[key];
        }
      });
    });
    var _network = require_network();
    Object.keys(_network).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _network[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _network[key];
        }
      });
    });
    var _processLauncher = require_processLauncher();
    Object.keys(_processLauncher).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _processLauncher[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _processLauncher[key];
        }
      });
    });
    var _profiler = require_profiler();
    Object.keys(_profiler).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _profiler[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _profiler[key];
        }
      });
    });
    var _rtti = require_rtti();
    Object.keys(_rtti).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _rtti[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _rtti[key];
        }
      });
    });
    var _spawnAsync = require_spawnAsync();
    Object.keys(_spawnAsync).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _spawnAsync[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _spawnAsync[key];
        }
      });
    });
    var _stackTrace = require_stackTrace();
    Object.keys(_stackTrace).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _stackTrace[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _stackTrace[key];
        }
      });
    });
    var _task = require_task();
    Object.keys(_task).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _task[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _task[key];
        }
      });
    });
    var _time = require_time();
    Object.keys(_time).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _time[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _time[key];
        }
      });
    });
    var _timeoutRunner = require_timeoutRunner();
    Object.keys(_timeoutRunner).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _timeoutRunner[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _timeoutRunner[key];
        }
      });
    });
    var _traceUtils = require_traceUtils();
    Object.keys(_traceUtils).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _traceUtils[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _traceUtils[key];
        }
      });
    });
    var _userAgent = require_userAgent();
    Object.keys(_userAgent).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _userAgent[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _userAgent[key];
        }
      });
    });
    var _zipFile = require_zipFile();
    Object.keys(_zipFile).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _zipFile[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _zipFile[key];
        }
      });
    });
    var _zones = require_zones();
    Object.keys(_zones).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _zones[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _zones[key];
        }
      });
    });
    var _locatorGenerators = require_locatorGenerators();
    Object.keys(_locatorGenerators).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (key in exports2 && exports2[key] === _locatorGenerators[key])
        return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _locatorGenerators[key];
        }
      });
    });
  }
});

// node_modules/playwright-core/lib/utils/hostPlatform.js
var require_hostPlatform = __commonJS({
  "node_modules/playwright-core/lib/utils/hostPlatform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hostPlatform = void 0;
    var _os = _interopRequireDefault(require("os"));
    var _linuxUtils = require_linuxUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hostPlatform = (() => {
      const platform = _os.default.platform();
      if (platform === "darwin") {
        const ver = _os.default.release().split(".").map((a) => parseInt(a, 10));
        let macVersion = "";
        if (ver[0] < 18) {
          macVersion = "mac10.13";
        } else if (ver[0] === 18) {
          macVersion = "mac10.14";
        } else if (ver[0] === 19) {
          macVersion = "mac10.15";
        } else {
          const LAST_STABLE_MAC_MAJOR_VERSION = 13;
          macVersion = "mac" + Math.min(ver[0] - 9, LAST_STABLE_MAC_MAJOR_VERSION);
          if (_os.default.cpus().some((cpu) => cpu.model.includes("Apple")))
            macVersion += "-arm64";
        }
        return macVersion;
      }
      if (platform === "linux") {
        const archSuffix = _os.default.arch() === "arm64" ? "-arm64" : "";
        const distroInfo = (0, _linuxUtils.getLinuxDistributionInfoSync)();
        if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === "ubuntu" || (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === "pop" || (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === "neon" || (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === "tuxedo") {
          if (parseInt(distroInfo.version, 10) <= 19)
            return "ubuntu18.04" + archSuffix;
          if (parseInt(distroInfo.version, 10) <= 21)
            return "ubuntu20.04" + archSuffix;
          return "ubuntu22.04" + archSuffix;
        }
        if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === "debian" && (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.version) === "11")
          return "debian11" + archSuffix;
        if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === "debian" && (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.version) === "12")
          return "debian12" + archSuffix;
        return "generic-linux" + archSuffix;
      }
      if (platform === "win32")
        return "win64";
      return "<unknown>";
    })();
    exports2.hostPlatform = hostPlatform;
  }
});

// node_modules/playwright-core/lib/server/registry/nativeDeps.js
var require_nativeDeps = __commonJS({
  "node_modules/playwright-core/lib/server/registry/nativeDeps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.deps = void 0;
    var deps = {
      "ubuntu18.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6", "libxtst6"],
        webkit: [],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libbrotlidec.so.1": "libbrotli1",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libepoxy.so.0": "libepoxy0",
          "libevent-2.1.so.6": "libevent-2.1-6",
          "libevdev.so.2": "libevdev2",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicudata.so.60": "libicu60",
          "libicui18n.so.60": "libicu60",
          "libicuuc.so.60": "libicu60",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libvpx.so.5": "libvpx5",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6",
          "libevent-2.1-6": "libevent-2.1-6"
        }
      },
      "ubuntu20.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6", "libxtst6"],
        webkit: ["libenchant-2-2", "libflite1", "libx264-155", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgtk-3-0", "libgudev-1.0-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu66", "libjpeg-turbo8", "libnotify4", "libopengl0", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1", "libatomic1", "libevent-2.1-7"],
        lib2package: {
          "libflite.so.1": "libflite1",
          "libflite_usenglish.so.1": "libflite1",
          "libflite_cmu_grapheme_lang.so.1": "libflite1",
          "libflite_cmu_grapheme_lex.so.1": "libflite1",
          "libflite_cmu_indic_lang.so.1": "libflite1",
          "libflite_cmu_indic_lex.so.1": "libflite1",
          "libflite_cmulex.so.1": "libflite1",
          "libflite_cmu_time_awb.so.1": "libflite1",
          "libflite_cmu_us_awb.so.1": "libflite1",
          "libflite_cmu_us_kal16.so.1": "libflite1",
          "libflite_cmu_us_kal.so.1": "libflite1",
          "libflite_cmu_us_rms.so.1": "libflite1",
          "libflite_cmu_us_slt.so.1": "libflite1",
          "libx264.so": "libx264-155",
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libevdev.so.2": "libevdev2",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libgudev-1.0.so.0": "libgudev-1.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicui18n.so.66": "libicu66",
          "libicuuc.so.66": "libicu66",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libOpenGL.so.0": "libopengl0",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6",
          "libxshmfence.so.1": "libxshmfence1",
          "libatomic.so.1": "libatomic1",
          "libenchant-2.so.2": "libenchant-2-2",
          "libevent-2.1.so.7": "libevent-2.1-7"
        }
      },
      "ubuntu22.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "fonts-unifont", "libfontconfig1", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "fonts-freefont-ttf"],
        chromium: ["libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libgbm1", "libglib2.0-0", "libnspr4", "libnss3", "libpango-1.0-0", "libwayland-client0", "libx11-6", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxkbcommon0", "libxrandr2"],
        firefox: ["ffmpeg", "libasound2", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrandr2", "libxrender1", "libxtst6"],
        webkit: ["libenchant-2-2", "gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libicu70", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libdbus-1-3", "libdrm2", "libegl1", "libepoxy0", "libevdev2", "libffi7", "libfontconfig1", "libfreetype6", "libgbm1", "libgdk-pixbuf-2.0-0", "libgles2", "libglib2.0-0", "libglx0", "libgstreamer-gl1.0-0", "libgstreamer-plugins-base1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libgudev-1.0-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libjpeg-turbo8", "liblcms2-2", "libmanette-0.2-0", "libnotify4", "libopengl0", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libproxy1v5", "libsecret-1-0", "libsoup2.4-1", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1", "libx264-163", "libatomic1", "libevent-2.1-7"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libepoxy.so.0": "libepoxy0",
          "libevdev.so.2": "libevdev2",
          "libffi.so.7": "libffi7",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libGLX.so.0": "libglx0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgudev-1.0.so.0": "libgudev-1.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libjpeg.so.8": "libjpeg-turbo8",
          "liblcms2.so.2": "liblcms2-2",
          "libmanette-0.2.so.0": "libmanette-0.2-0",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libOpenGL.so.0": "libopengl0",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libproxy.so.1": "libproxy1v5",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXtst.so.6": "libxtst6",
          "libicui18n.so.60": "libicu70",
          "libicuuc.so.66": "libicu70",
          "libicui18n.so.66": "libicu70",
          "libwebp.so.6": "libwebp6",
          "libenchant-2.so.2": "libenchant-2-2",
          "libx264.so": "libx264-163",
          "libvpx.so.7": "libvpx7",
          "libatomic.so.1": "libatomic1",
          "libevent-2.1.so.7": "libevent-2.1-7"
        }
      },
      "debian11": {
        tools: ["xvfb", "fonts-noto-color-emoji", "fonts-unifont", "libfontconfig1", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "fonts-freefont-ttf"],
        chromium: ["libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libgbm1", "libglib2.0-0", "libnspr4", "libnss3", "libpango-1.0-0", "libwayland-client0", "libx11-6", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxkbcommon0", "libxrandr2"],
        firefox: ["libasound2", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libglib2.0-0", "libgtk-3-0", "libharfbuzz0b", "libpango-1.0-0", "libpangocairo-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrandr2", "libxrender1", "libxtst6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libdbus-1-3", "libdrm2", "libegl1", "libenchant-2-2", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgbm1", "libgdk-pixbuf-2.0-0", "libgles2", "libglib2.0-0", "libglx0", "libgstreamer-gl1.0-0", "libgstreamer-plugins-base1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libgudev-1.0-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu67", "libjpeg62-turbo", "liblcms2-2", "libmanette-0.2-0", "libnotify4", "libopengl0", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libproxy1v5", "libsecret-1-0", "libsoup2.4-1", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1", "libatomic1", "libevent-2.1-7"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant-2.so.2": "libenchant-2-2",
          "libepoxy.so.0": "libepoxy0",
          "libevdev.so.2": "libevdev2",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libGLX.so.0": "libglx0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstallocators-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgudev-1.0.so.0": "libgudev-1.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicui18n.so.67": "libicu67",
          "libicuuc.so.67": "libicu67",
          "libjpeg.so.62": "libjpeg62-turbo",
          "liblcms2.so.2": "liblcms2-2",
          "libmanette-0.2.so.0": "libmanette-0.2-0",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libOpenGL.so.0": "libopengl0",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libproxy.so.1": "libproxy1v5",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXtst.so.6": "libxtst6",
          "libatomic.so.1": "libatomic1",
          "libevent-2.1.so.7": "libevent-2.1-7"
        }
      },
      "debian12": {
        tools: ["xvfb", "fonts-noto-color-emoji", "fonts-unifont", "libfontconfig1", "libfreetype6", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "fonts-freefont-ttf"],
        chromium: ["libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libgbm1", "libglib2.0-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxkbcommon0", "libxrandr2"],
        firefox: [],
        webkit: [],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdrm.so.2": "libdrm2",
          "libgbm.so.1": "libgbm1",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libsmime3.so": "libnss3",
          "libX11.so.6": "libx11-6",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libXrandr.so.2": "libxrandr2"
        }
      }
    };
    exports2.deps = deps;
    deps["ubuntu20.04-arm64"] = {
      tools: [...deps["ubuntu20.04"].tools],
      chromium: [...deps["ubuntu20.04"].chromium],
      firefox: [...deps["ubuntu20.04"].firefox],
      webkit: [...deps["ubuntu20.04"].webkit],
      lib2package: __spreadValues({}, deps["ubuntu20.04"].lib2package)
    };
    deps["ubuntu22.04-arm64"] = {
      tools: [...deps["ubuntu22.04"].tools],
      chromium: [...deps["ubuntu22.04"].chromium],
      firefox: [...deps["ubuntu22.04"].firefox],
      webkit: [...deps["ubuntu22.04"].webkit],
      lib2package: __spreadValues({}, deps["ubuntu22.04"].lib2package)
    };
    deps["debian11-arm64"] = {
      tools: [...deps["debian11"].tools],
      chromium: [...deps["debian11"].chromium],
      firefox: [...deps["debian11"].firefox],
      webkit: [...deps["debian11"].webkit],
      lib2package: __spreadValues({}, deps["debian11"].lib2package)
    };
    deps["debian12-arm64"] = {
      tools: [...deps["debian12"].tools],
      chromium: [...deps["debian12"].chromium],
      firefox: [...deps["debian12"].firefox],
      webkit: [...deps["debian12"].webkit],
      lib2package: __spreadValues({}, deps["debian12"].lib2package)
    };
  }
});

// node_modules/playwright-core/lib/server/registry/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/playwright-core/lib/server/registry/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dockerVersion = dockerVersion;
    exports2.installDependenciesLinux = installDependenciesLinux;
    exports2.installDependenciesWindows = installDependenciesWindows;
    exports2.readDockerVersionSync = readDockerVersionSync;
    exports2.transformCommandsForRoot = transformCommandsForRoot;
    exports2.validateDependenciesLinux = validateDependenciesLinux;
    exports2.validateDependenciesWindows = validateDependenciesWindows;
    exports2.writeDockerVersion = writeDockerVersion;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var os = _interopRequireWildcard(require("os"));
    var _child_process = _interopRequireDefault(require("child_process"));
    var utils = _interopRequireWildcard(require_utils());
    var _spawnAsync = require_spawnAsync();
    var _hostPlatform = require_hostPlatform();
    var _ = require_registry();
    var _nativeDeps = require_nativeDeps();
    var _userAgent = require_userAgent();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BIN_DIRECTORY = _path.default.join(__dirname, "..", "..", "..", "bin");
    var languageBindingVersion = process.env.PW_CLI_DISPLAY_VERSION || require_package().version;
    var dockerVersionFilePath = "/ms-playwright/.docker-info";
    function writeDockerVersion(dockerImageNameTemplate) {
      return __async(this, null, function* () {
        yield _fs.default.promises.mkdir(_path.default.dirname(dockerVersionFilePath), {
          recursive: true
        });
        yield _fs.default.promises.writeFile(dockerVersionFilePath, JSON.stringify(dockerVersion(dockerImageNameTemplate), null, 2), "utf8");
        yield _fs.default.promises.chmod(dockerVersionFilePath, 511);
      });
    }
    function dockerVersion(dockerImageNameTemplate) {
      return {
        driverVersion: languageBindingVersion,
        dockerImageName: dockerImageNameTemplate.replace("%version%", languageBindingVersion)
      };
    }
    function readDockerVersionSync() {
      try {
        const data = JSON.parse(_fs.default.readFileSync(dockerVersionFilePath, "utf8"));
        return __spreadProps(__spreadValues({}, data), {
          dockerImageNameTemplate: data.dockerImageName.replace(data.driverVersion, "%version%")
        });
      } catch (e) {
        return null;
      }
    }
    var checkExecutable = (filePath) => _fs.default.promises.access(filePath, _fs.default.constants.X_OK).then(() => true).catch((e) => false);
    function isSupportedWindowsVersion() {
      if (os.platform() !== "win32" || os.arch() !== "x64")
        return false;
      const [major, minor] = os.release().split(".").map((token) => parseInt(token, 10));
      return major > 6 || major === 6 && minor > 1;
    }
    function installDependenciesWindows(targets, dryRun) {
      return __async(this, null, function* () {
        if (targets.has("chromium")) {
          const command = "powershell.exe";
          const args = ["-ExecutionPolicy", "Bypass", "-File", _path.default.join(BIN_DIRECTORY, "install_media_pack.ps1")];
          if (dryRun) {
            console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
            return;
          }
          const {
            code
          } = yield (0, _spawnAsync.spawnAsync)(command, args, {
            cwd: BIN_DIRECTORY,
            stdio: "inherit"
          });
          if (code !== 0)
            throw new Error("Failed to install windows dependencies!");
        }
      });
    }
    function installDependenciesLinux(targets, dryRun) {
      return __async(this, null, function* () {
        const libraries = [];
        let platform = _hostPlatform.hostPlatform;
        if (platform === "generic-linux" || platform === "generic-linux-arm64") {
          console.warn("BEWARE: your OS is not officially supported by Playwright; installing dependencies for Ubuntu as a fallback.");
          platform = _hostPlatform.hostPlatform === "generic-linux" ? "ubuntu20.04" : "ubuntu20.04-arm64";
        }
        for (const target of targets) {
          const info = _nativeDeps.deps[platform];
          if (!info) {
            console.warn("Cannot install dependencies for this linux distribution!");
            return;
          }
          libraries.push(...info[target]);
        }
        const uniqueLibraries = Array.from(new Set(libraries));
        if (!dryRun)
          console.log(`Installing dependencies...`);
        const commands = [];
        commands.push("apt-get update");
        commands.push(["apt-get", "install", "-y", "--no-install-recommends", ...uniqueLibraries].join(" "));
        const {
          command,
          args,
          elevatedPermissions
        } = yield transformCommandsForRoot(commands);
        if (dryRun) {
          console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
          return;
        }
        if (elevatedPermissions)
          console.log("Switching to root user to install dependencies...");
        const child = _child_process.default.spawn(command, args, {
          stdio: "inherit"
        });
        yield new Promise((resolve, reject) => {
          child.on("exit", (code) => code === 0 ? resolve() : reject(new Error(`Installation process exited with code: ${code}`)));
          child.on("error", reject);
        });
      });
    }
    function validateDependenciesWindows(windowsExeAndDllDirectories) {
      return __async(this, null, function* () {
        const directoryPaths = windowsExeAndDllDirectories;
        const lddPaths = [];
        for (const directoryPath of directoryPaths)
          lddPaths.push(...yield executablesOrSharedLibraries(directoryPath));
        const allMissingDeps = yield Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(lddPath)));
        const missingDeps = /* @__PURE__ */ new Set();
        for (const deps of allMissingDeps) {
          for (const dep of deps)
            missingDeps.add(dep);
        }
        if (!missingDeps.size)
          return;
        let isCrtMissing = false;
        let isMediaFoundationMissing = false;
        for (const dep of missingDeps) {
          if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
            isCrtMissing = true;
          else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
            isMediaFoundationMissing = true;
        }
        const details = [];
        if (isCrtMissing) {
          details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
        }
        if (isMediaFoundationMissing) {
          details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
        }
        details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join("\n    ")}`, ``);
        const message = `Host system is missing dependencies!

${details.join("\n")}`;
        if (isSupportedWindowsVersion()) {
          throw new Error(message);
        } else {
          console.warn(`WARNING: running on unsupported windows version!`);
          console.warn(message);
        }
      });
    }
    function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
      return __async(this, null, function* () {
        var _deps$hostPlatform;
        const directoryPaths = linuxLddDirectories;
        const lddPaths = [];
        for (const directoryPath of directoryPaths)
          lddPaths.push(...yield executablesOrSharedLibraries(directoryPath));
        const missingDepsPerFile = yield Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
        const missingDeps = /* @__PURE__ */ new Set();
        for (const deps of missingDepsPerFile) {
          for (const dep of deps)
            missingDeps.add(dep);
        }
        for (const dep of yield missingDLOPENLibraries(dlOpenLibraries))
          missingDeps.add(dep);
        if (!missingDeps.size)
          return;
        const allMissingDeps = new Set(missingDeps);
        const missingPackages = /* @__PURE__ */ new Set();
        const libraryToPackageNameMapping = _nativeDeps.deps[_hostPlatform.hostPlatform] ? __spreadValues(__spreadValues({}, ((_deps$hostPlatform = _nativeDeps.deps[_hostPlatform.hostPlatform]) === null || _deps$hostPlatform === void 0 ? void 0 : _deps$hostPlatform.lib2package) || {}), MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU) : {};
        for (const missingDep of missingDeps) {
          const packageName = libraryToPackageNameMapping[missingDep];
          if (packageName) {
            missingPackages.add(packageName);
            missingDeps.delete(missingDep);
          }
        }
        const maybeSudo = process.getuid() !== 0 && os.platform() !== "win32" ? "sudo " : "";
        const dockerInfo = readDockerVersionSync();
        const errorLines = [`Host system is missing dependencies to run browsers.`];
        if (dockerInfo && !dockerInfo.driverVersion.startsWith((0, _userAgent.getPlaywrightVersion)(true) + ".")) {
          const pwVersion = (0, _userAgent.getPlaywrightVersion)();
          const requiredDockerImage = dockerInfo.dockerImageName.replace(dockerInfo.driverVersion, pwVersion);
          errorLines.push(...[`This is most likely due to docker image version not matching Playwright version:`, `- Playwright: ${pwVersion}`, `-     Docker: ${dockerInfo.driverVersion}`, ``, `Either:`, `- (recommended) use docker image "${requiredDockerImage}"`, `- (alternative 1) run the following command inside docker to install missing dependencies:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, "install-deps")}`, ``, `- (alternative 2) use apt inside docker:`, ``, `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`, ``, `<3 Playwright Team`]);
        } else if (missingPackages.size && !missingDeps.size) {
          errorLines.push(...[`Please install them with the following command:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, "install-deps")}`, ``, `Alternatively, use apt:`, `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`, ``, `<3 Playwright Team`]);
        } else {
          errorLines.push(...[`Missing libraries:`, ...[...allMissingDeps].map((dep) => "    " + dep)]);
        }
        throw new Error("\n" + utils.wrapInASCIIBox(errorLines.join("\n"), 1));
      });
    }
    function isSharedLib(basename) {
      switch (os.platform()) {
        case "linux":
          return basename.endsWith(".so") || basename.includes(".so.");
        case "win32":
          return basename.endsWith(".dll");
        default:
          return false;
      }
    }
    function executablesOrSharedLibraries(directoryPath) {
      return __async(this, null, function* () {
        if (!_fs.default.existsSync(directoryPath))
          return [];
        const allPaths = (yield _fs.default.promises.readdir(directoryPath)).map((file) => _path.default.resolve(directoryPath, file));
        const allStats = yield Promise.all(allPaths.map((aPath) => _fs.default.promises.stat(aPath)));
        const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());
        const executablersOrLibraries = (yield Promise.all(filePaths.map((filePath) => __async(this, null, function* () {
          const basename = _path.default.basename(filePath).toLowerCase();
          if (isSharedLib(basename))
            return filePath;
          if (yield checkExecutable(filePath))
            return filePath;
          return false;
        })))).filter(Boolean);
        return executablersOrLibraries;
      });
    }
    function missingFileDependenciesWindows(filePath) {
      return __async(this, null, function* () {
        const executable = _path.default.join(__dirname, "..", "..", "..", "bin", "PrintDeps.exe");
        const dirname = _path.default.dirname(filePath);
        const {
          stdout,
          code
        } = yield (0, _spawnAsync.spawnAsync)(executable, [filePath], {
          cwd: dirname,
          env: __spreadProps(__spreadValues({}, process.env), {
            LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
          })
        });
        if (code !== 0)
          return [];
        const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
        return missingDeps;
      });
    }
    function missingFileDependencies(filePath, extraLDPaths) {
      return __async(this, null, function* () {
        const dirname = _path.default.dirname(filePath);
        let LD_LIBRARY_PATH = extraLDPaths.join(":");
        if (process.env.LD_LIBRARY_PATH)
          LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
        const {
          stdout,
          code
        } = yield (0, _spawnAsync.spawnAsync)("ldd", [filePath], {
          cwd: dirname,
          env: __spreadProps(__spreadValues({}, process.env), {
            LD_LIBRARY_PATH
          })
        });
        if (code !== 0)
          return [];
        const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
        return missingDeps;
      });
    }
    function missingDLOPENLibraries(libraries) {
      return __async(this, null, function* () {
        if (!libraries.length)
          return [];
        const {
          stdout,
          code,
          error
        } = yield (0, _spawnAsync.spawnAsync)("/sbin/ldconfig", ["-p"], {});
        if (code !== 0 || error)
          return [];
        const isLibraryAvailable = (library) => stdout.toLowerCase().includes(library.toLowerCase());
        return libraries.filter((library) => !isLibraryAvailable(library));
      });
    }
    var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
      "libx264.so": "gstreamer1.0-libav"
    };
    function quoteProcessArgs(args) {
      return args.map((arg) => {
        if (arg.includes(" "))
          return `"${arg}"`;
        return arg;
      });
    }
    function transformCommandsForRoot(commands) {
      return __async(this, null, function* () {
        const isRoot = process.getuid() === 0;
        if (isRoot)
          return {
            command: "sh",
            args: ["-c", `${commands.join("&& ")}`],
            elevatedPermissions: false
          };
        const sudoExists = yield (0, _spawnAsync.spawnAsync)("which", ["sudo"]);
        if (sudoExists.code === 0)
          return {
            command: "sudo",
            args: ["--", "sh", "-c", `${commands.join("&& ")}`],
            elevatedPermissions: true
          };
        return {
          command: "su",
          args: ["root", "-c", `${commands.join("&& ")}`],
          elevatedPermissions: true
        };
      });
    }
  }
});

// node_modules/playwright-core/lib/common/debugLogger.js
var require_debugLogger = __commonJS({
  "node_modules/playwright-core/lib/common/debugLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.debugLogger = exports2.RecentLogsCollector = void 0;
    var _utilsBundle = require_utilsBundle();
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLoggerColorMap = {
      "api": 45,
      "protocol": 34,
      "install": 34,
      "download": 34,
      "browser": 0,
      "socks": 92,
      "error": 160,
      "channel:command": 33,
      "channel:response": 202,
      "channel:event": 207,
      "server": 45,
      "server:channel": 34
    };
    var DebugLogger = class {
      constructor() {
        this._debuggers = /* @__PURE__ */ new Map();
        if (process.env.DEBUG_FILE) {
          const ansiRegex = new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"), "g");
          const stream = _fs.default.createWriteStream(process.env.DEBUG_FILE);
          _utilsBundle.debug.log = (data) => {
            stream.write(data.replace(ansiRegex, ""));
            stream.write("\n");
          };
        }
      }
      log(name, message) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
          cachedDebugger = (0, _utilsBundle.debug)(`pw:${name}`);
          this._debuggers.set(name, cachedDebugger);
          cachedDebugger.color = debugLoggerColorMap[name];
        }
        cachedDebugger(message);
      }
      isEnabled(name) {
        return _utilsBundle.debug.enabled(`pw:${name}`);
      }
    };
    var debugLogger = new DebugLogger();
    exports2.debugLogger = debugLogger;
    var kLogCount = 150;
    var RecentLogsCollector = class {
      constructor() {
        this._logs = [];
      }
      log(message) {
        this._logs.push(message);
        if (this._logs.length === kLogCount * 2)
          this._logs.splice(0, kLogCount);
      }
      recentLogs() {
        if (this._logs.length > kLogCount)
          return this._logs.slice(-kLogCount);
        return this._logs;
      }
    };
    exports2.RecentLogsCollector = RecentLogsCollector;
  }
});

// node_modules/playwright-core/lib/server/registry/browserFetcher.js
var require_browserFetcher = __commonJS({
  "node_modules/playwright-core/lib/server/registry/browserFetcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.downloadBrowserWithProgressBar = downloadBrowserWithProgressBar;
    exports2.logPolitely = logPolitely;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _child_process = _interopRequireDefault(require("child_process"));
    var _fileUtils = require_fileUtils();
    var _debugLogger = require_debugLogger();
    var _manualPromise = require_manualPromise();
    var _utilsBundle = require_utilsBundle();
    var _ = require_registry();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function downloadBrowserWithProgressBar(title, browserDirectory, executablePath, downloadURLs, downloadFileName, downloadConnectionTimeout) {
      return __async(this, null, function* () {
        if (yield (0, _fileUtils.existsAsync)((0, _.browserDirectoryToMarkerFilePath)(browserDirectory))) {
          _debugLogger.debugLogger.log("install", `${title} is already downloaded.`);
          return false;
        }
        const zipPath = _path.default.join(_os.default.tmpdir(), downloadFileName);
        try {
          const retryCount = 3;
          for (let attempt = 1; attempt <= retryCount; ++attempt) {
            _debugLogger.debugLogger.log("install", `downloading ${title} - attempt #${attempt}`);
            const url = downloadURLs[(attempt - 1) % downloadURLs.length];
            logPolitely(`Downloading ${title}` + _utilsBundle.colors.dim(` from ${url}`));
            const {
              error
            } = yield downloadBrowserWithProgressBarOutOfProcess(title, browserDirectory, url, zipPath, executablePath, downloadConnectionTimeout);
            if (!error) {
              _debugLogger.debugLogger.log("install", `SUCCESS installing ${title}`);
              break;
            }
            if (yield (0, _fileUtils.existsAsync)(zipPath))
              yield _fs.default.promises.unlink(zipPath);
            if (yield (0, _fileUtils.existsAsync)(browserDirectory))
              yield _fs.default.promises.rmdir(browserDirectory, {
                recursive: true
              });
            const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
            _debugLogger.debugLogger.log("install", `attempt #${attempt} - ERROR: ${errorMessage}`);
            if (attempt >= retryCount)
              throw error;
          }
        } catch (e) {
          _debugLogger.debugLogger.log("install", `FAILED installation ${title} with error: ${e}`);
          process.exitCode = 1;
          throw e;
        } finally {
          if (yield (0, _fileUtils.existsAsync)(zipPath))
            yield _fs.default.promises.unlink(zipPath);
        }
        logPolitely(`${title} downloaded to ${browserDirectory}`);
        return true;
      });
    }
    function downloadBrowserWithProgressBarOutOfProcess(title, browserDirectory, url, zipPath, executablePath, downloadConnectionTimeout) {
      const cp = _child_process.default.fork(_path.default.join(__dirname, "oopDownloadBrowserMain.js"), [title, browserDirectory, url, zipPath, executablePath || "", String(downloadConnectionTimeout)]);
      const promise = new _manualPromise.ManualPromise();
      cp.on("message", (message) => {
        if ((message === null || message === void 0 ? void 0 : message.method) === "log")
          _debugLogger.debugLogger.log("install", message.params.message);
      });
      cp.on("exit", (code) => {
        if (code !== 0) {
          promise.resolve({
            error: new Error(`Download failure, code=${code}`)
          });
          return;
        }
        if (!_fs.default.existsSync((0, _.browserDirectoryToMarkerFilePath)(browserDirectory)))
          promise.resolve({
            error: new Error(`Download failure, ${(0, _.browserDirectoryToMarkerFilePath)(browserDirectory)} does not exist`)
          });
        else
          promise.resolve({
            error: null
          });
      });
      cp.on("error", (error) => {
        promise.resolve({
          error
        });
      });
      return promise;
    }
    function logPolitely(toBeLogged) {
      const logLevel = process.env.npm_config_loglevel;
      const logLevelDisplay = ["silent", "error", "warn"].indexOf(logLevel || "") > -1;
      if (!logLevelDisplay)
        console.log(toBeLogged);
    }
  }
});

// node_modules/playwright-core/browsers.json
var require_browsers = __commonJS({
  "node_modules/playwright-core/browsers.json"(exports2, module2) {
    module2.exports = {
      comment: "Do not edit this file, use utils/roll_browser.js",
      browsers: [
        {
          name: "chromium",
          revision: "1071",
          installByDefault: true,
          browserVersion: "115.0.5790.75"
        },
        {
          name: "chromium-with-symbols",
          revision: "1071",
          installByDefault: false,
          browserVersion: "115.0.5790.75"
        },
        {
          name: "chromium-tip-of-tree",
          revision: "1128",
          installByDefault: false,
          browserVersion: "117.0.5860.0"
        },
        {
          name: "firefox",
          revision: "1419",
          installByDefault: true,
          browserVersion: "115.0"
        },
        {
          name: "firefox-beta",
          revision: "1418",
          installByDefault: false,
          browserVersion: "115.0b8"
        },
        {
          name: "webkit",
          revision: "1869",
          installByDefault: true,
          revisionOverrides: {
            "mac10.14": "1446",
            "mac10.15": "1616",
            mac11: "1816",
            "mac11-arm64": "1816",
            "ubuntu18.04": "1728"
          },
          browserVersion: "17.0"
        },
        {
          name: "ffmpeg",
          revision: "1009",
          installByDefault: true
        },
        {
          name: "android",
          revision: "1000",
          installByDefault: false
        }
      ]
    };
  }
});

// node_modules/playwright-core/lib/server/registry/index.js
var require_registry = __commonJS({
  "node_modules/playwright-core/lib/server/registry/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Registry = void 0;
    exports2.browserDirectoryToMarkerFilePath = browserDirectoryToMarkerFilePath;
    exports2.buildPlaywrightCLICommand = buildPlaywrightCLICommand;
    exports2.findChromiumChannel = findChromiumChannel;
    exports2.installBrowsersForNpmInstall = installBrowsersForNpmInstall;
    exports2.installDefaultBrowsersForNpmInstall = installDefaultBrowsersForNpmInstall;
    exports2.registryDirectory = exports2.registry = void 0;
    Object.defineProperty(exports2, "writeDockerVersion", {
      enumerable: true,
      get: function() {
        return _dependencies.writeDockerVersion;
      }
    });
    var os = _interopRequireWildcard(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var util = _interopRequireWildcard(require("util"));
    var fs = _interopRequireWildcard(require("fs"));
    var _utilsBundle = require_utilsBundle();
    var _linuxUtils = require_linuxUtils();
    var _network = require_network();
    var _userAgent = require_userAgent();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _hostPlatform = require_hostPlatform();
    var _spawnAsync = require_spawnAsync();
    var _dependencies = require_dependencies();
    var _browserFetcher = require_browserFetcher();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var PACKAGE_PATH = _path.default.join(__dirname, "..", "..", "..");
    var BIN_PATH = _path.default.join(__dirname, "..", "..", "..", "bin");
    var PLAYWRIGHT_CDN_MIRRORS = ["https://playwright.azureedge.net", "https://playwright-akamai.azureedge.net", "https://playwright-verizon.azureedge.net"];
    if (process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {
      for (let i = 0; i < PLAYWRIGHT_CDN_MIRRORS.length; i++) {
        const cdn = PLAYWRIGHT_CDN_MIRRORS[i];
        if (cdn !== process.env.PW_TEST_CDN_THAT_SHOULD_WORK)
          PLAYWRIGHT_CDN_MIRRORS[i] = cdn + ".does-not-resolve.playwright.dev";
      }
    }
    var EXECUTABLE_PATHS = {
      "chromium": {
        "linux": ["chrome-linux", "chrome"],
        "mac": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "win": ["chrome-win", "chrome.exe"]
      },
      "firefox": {
        "linux": ["firefox", "firefox"],
        "mac": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "win": ["firefox", "firefox.exe"]
      },
      "webkit": {
        "linux": ["pw_run.sh"],
        "mac": ["pw_run.sh"],
        "win": ["Playwright.exe"]
      },
      "ffmpeg": {
        "linux": ["ffmpeg-linux"],
        "mac": ["ffmpeg-mac"],
        "win": ["ffmpeg-win64.exe"]
      }
    };
    var DOWNLOAD_PATHS = {
      "chromium": {
        "<unknown>": void 0,
        "generic-linux": "builds/chromium/%s/chromium-linux.zip",
        "generic-linux-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu18.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu20.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu22.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu22.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "debian11": "builds/chromium/%s/chromium-linux.zip",
        "debian11-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "debian12": "builds/chromium/%s/chromium-linux.zip",
        "debian12-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "mac10.13": "builds/chromium/%s/chromium-mac.zip",
        "mac10.14": "builds/chromium/%s/chromium-mac.zip",
        "mac10.15": "builds/chromium/%s/chromium-mac.zip",
        "mac11": "builds/chromium/%s/chromium-mac.zip",
        "mac11-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "mac12": "builds/chromium/%s/chromium-mac.zip",
        "mac12-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "mac13": "builds/chromium/%s/chromium-mac.zip",
        "mac13-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "win64": "builds/chromium/%s/chromium-win64.zip"
      },
      "chromium-tip-of-tree": {
        "<unknown>": void 0,
        "generic-linux": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
        "generic-linux-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
        "ubuntu18.04": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
        "ubuntu20.04": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
        "ubuntu22.04": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
        "ubuntu22.04-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
        "debian11": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
        "debian11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
        "debian12": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip",
        "debian12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip",
        "mac10.13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
        "mac10.14": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
        "mac10.15": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
        "mac11": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
        "mac11-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
        "mac12": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
        "mac12-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
        "mac13": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip",
        "mac13-arm64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip",
        "win64": "builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-win64.zip"
      },
      "chromium-with-symbols": {
        "<unknown>": void 0,
        "generic-linux": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "generic-linux-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu18.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu20.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu22.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu22.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "debian11": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "debian11-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "debian12": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "debian12-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "mac10.13": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.14": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.15": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "mac12": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac12-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "mac13": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac13-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "win64": "builds/chromium/%s/chromium-with-symbols-win64.zip"
      },
      "firefox": {
        "<unknown>": void 0,
        "generic-linux": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "generic-linux-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
        "ubuntu18.04": "builds/firefox/%s/firefox-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "ubuntu22.04": "builds/firefox/%s/firefox-ubuntu-22.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
        "ubuntu22.04-arm64": "builds/firefox/%s/firefox-ubuntu-22.04-arm64.zip",
        "debian11": "builds/firefox/%s/firefox-debian-11.zip",
        "debian11-arm64": "builds/firefox/%s/firefox-debian-11-arm64.zip",
        "debian12": void 0,
        "debian12-arm64": void 0,
        "mac10.13": "builds/firefox/%s/firefox-mac-13.zip",
        "mac10.14": "builds/firefox/%s/firefox-mac-13.zip",
        "mac10.15": "builds/firefox/%s/firefox-mac-13.zip",
        "mac11": "builds/firefox/%s/firefox-mac-13.zip",
        "mac11-arm64": "builds/firefox/%s/firefox-mac-13-arm64.zip",
        "mac12": "builds/firefox/%s/firefox-mac-13.zip",
        "mac12-arm64": "builds/firefox/%s/firefox-mac-13-arm64.zip",
        "mac13": "builds/firefox/%s/firefox-mac-13.zip",
        "mac13-arm64": "builds/firefox/%s/firefox-mac-13-arm64.zip",
        "win64": "builds/firefox/%s/firefox-win64.zip"
      },
      "firefox-beta": {
        "<unknown>": void 0,
        "generic-linux": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
        "generic-linux-arm64": void 0,
        "ubuntu18.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
        "ubuntu22.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-22.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": void 0,
        "ubuntu22.04-arm64": "builds/firefox-beta/%s/firefox-beta-ubuntu-22.04-arm64.zip",
        "debian11": "builds/firefox-beta/%s/firefox-beta-debian-11.zip",
        "debian11-arm64": "builds/firefox-beta/%s/firefox-beta-debian-11-arm64.zip",
        "debian12": void 0,
        "debian12-arm64": void 0,
        "mac10.13": "builds/firefox-beta/%s/firefox-beta-mac-13.zip",
        "mac10.14": "builds/firefox-beta/%s/firefox-beta-mac-13.zip",
        "mac10.15": "builds/firefox-beta/%s/firefox-beta-mac-13.zip",
        "mac11": "builds/firefox-beta/%s/firefox-beta-mac-13.zip",
        "mac11-arm64": "builds/firefox-beta/%s/firefox-beta-mac-13-arm64.zip",
        "mac12": "builds/firefox-beta/%s/firefox-beta-mac-13.zip",
        "mac12-arm64": "builds/firefox-beta/%s/firefox-beta-mac-13-arm64.zip",
        "mac13": "builds/firefox-beta/%s/firefox-beta-mac-13.zip",
        "mac13-arm64": "builds/firefox-beta/%s/firefox-beta-mac-13-arm64.zip",
        "win64": "builds/firefox-beta/%s/firefox-beta-win64.zip"
      },
      "webkit": {
        "<unknown>": void 0,
        "generic-linux": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "generic-linux-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
        "ubuntu18.04": "builds/deprecated-webkit-ubuntu-18.04/%s/deprecated-webkit-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "ubuntu22.04": "builds/webkit/%s/webkit-ubuntu-22.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
        "ubuntu22.04-arm64": "builds/webkit/%s/webkit-ubuntu-22.04-arm64.zip",
        "debian11": "builds/webkit/%s/webkit-debian-11.zip",
        "debian11-arm64": "builds/webkit/%s/webkit-debian-11-arm64.zip",
        "debian12": void 0,
        "debian12-arm64": void 0,
        "mac10.13": void 0,
        "mac10.14": "builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
        "mac10.15": "builds/deprecated-webkit-mac-10.15/%s/deprecated-webkit-mac-10.15.zip",
        "mac11": "builds/webkit/%s/webkit-mac-11.zip",
        "mac11-arm64": "builds/webkit/%s/webkit-mac-11-arm64.zip",
        "mac12": "builds/webkit/%s/webkit-mac-12.zip",
        "mac12-arm64": "builds/webkit/%s/webkit-mac-12-arm64.zip",
        "mac13": "builds/webkit/%s/webkit-mac-13.zip",
        "mac13-arm64": "builds/webkit/%s/webkit-mac-13-arm64.zip",
        "win64": "builds/webkit/%s/webkit-win64.zip"
      },
      "ffmpeg": {
        "<unknown>": void 0,
        "generic-linux": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "generic-linux-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu18.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu20.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu22.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu18.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu22.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "debian11": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "debian11-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "debian12": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "debian12-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "mac10.13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "mac12": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac12-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "mac13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac13-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "win64": "builds/ffmpeg/%s/ffmpeg-win64.zip"
      },
      "android": {
        "<unknown>": "builds/android/%s/android.zip"
      }
    };
    var registryDirectory = (() => {
      let result;
      const envDefined = (0, _utils.getFromENV)("PLAYWRIGHT_BROWSERS_PATH");
      if (envDefined === "0") {
        result = _path.default.join(__dirname, "..", "..", "..", ".local-browsers");
      } else if (envDefined) {
        result = envDefined;
      } else {
        let cacheDirectory;
        if (process.platform === "linux")
          cacheDirectory = process.env.XDG_CACHE_HOME || _path.default.join(os.homedir(), ".cache");
        else if (process.platform === "darwin")
          cacheDirectory = _path.default.join(os.homedir(), "Library", "Caches");
        else if (process.platform === "win32")
          cacheDirectory = process.env.LOCALAPPDATA || _path.default.join(os.homedir(), "AppData", "Local");
        else
          throw new Error("Unsupported platform: " + process.platform);
        result = _path.default.join(cacheDirectory, "ms-playwright");
      }
      if (!_path.default.isAbsolute(result)) {
        result = _path.default.resolve((0, _utils.getFromENV)("INIT_CWD") || process.cwd(), result);
      }
      return result;
    })();
    exports2.registryDirectory = registryDirectory;
    function isBrowserDirectory(browserDirectory) {
      const baseName = _path.default.basename(browserDirectory);
      for (const browserName of allDownloadable) {
        if (baseName.startsWith(browserName + "-"))
          return true;
      }
      return false;
    }
    function readDescriptors(browsersJSON) {
      return browsersJSON["browsers"].map((obj) => {
        const name = obj.name;
        const revisionOverride = (obj.revisionOverrides || {})[_hostPlatform.hostPlatform];
        const revision = revisionOverride || obj.revision;
        const browserDirectoryPrefix = revisionOverride ? `${name}_${_hostPlatform.hostPlatform}_special` : `${name}`;
        const descriptor = {
          name,
          revision,
          browserVersion: revisionOverride ? void 0 : obj.browserVersion,
          installByDefault: !!obj.installByDefault,
          dir: _path.default.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision)
        };
        return descriptor;
      });
    }
    var allDownloadable = ["chromium", "firefox", "webkit", "ffmpeg", "firefox-beta", "chromium-with-symbols", "chromium-tip-of-tree"];
    var Registry = class {
      constructor(browsersJSON) {
        this._executables = void 0;
        const descriptors = readDescriptors(browsersJSON);
        const findExecutablePath = (dir, name) => {
          let tokens = void 0;
          if (process.platform === "linux")
            tokens = EXECUTABLE_PATHS[name]["linux"];
          else if (process.platform === "darwin")
            tokens = EXECUTABLE_PATHS[name]["mac"];
          else if (process.platform === "win32")
            tokens = EXECUTABLE_PATHS[name]["win"];
          return tokens ? _path.default.join(dir, ...tokens) : void 0;
        };
        const executablePathOrDie = (name, e, installByDefault, sdkLanguage) => {
          if (!e)
            throw new Error(`${name} is not supported on ${_hostPlatform.hostPlatform}`);
          const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? "" : " " + name}`);
          if (!(0, _fileUtils.canAccessFile)(e)) {
            const currentDockerVersion = (0, _dependencies.readDockerVersionSync)();
            const preferredDockerVersion = currentDockerVersion ? (0, _dependencies.dockerVersion)(currentDockerVersion.dockerImageNameTemplate) : null;
            const isOutdatedDockerImage = currentDockerVersion && preferredDockerVersion && currentDockerVersion.dockerImageName !== preferredDockerVersion.dockerImageName;
            const prettyMessage = isOutdatedDockerImage ? [`Looks like ${sdkLanguage === "javascript" ? "Playwright Test or " : ""}Playwright was just updated to ${preferredDockerVersion.driverVersion}.`, `Please update docker image as well.`, `-  current: ${currentDockerVersion.dockerImageName}`, `- required: ${preferredDockerVersion.dockerImageName}`, ``, `<3 Playwright Team`].join("\n") : [`Looks like ${sdkLanguage === "javascript" ? "Playwright Test or " : ""}Playwright was just installed or updated.`, `Please run the following command to download new browser${installByDefault ? "s" : ""}:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
            throw new Error(`Executable doesn't exist at ${e}
${(0, _utils.wrapInASCIIBox)(prettyMessage, 1)}`);
          }
          return e;
        };
        this._executables = [];
        const chromium = descriptors.find((d) => d.name === "chromium");
        const chromiumExecutable = findExecutablePath(chromium.dir, "chromium");
        this._executables.push({
          type: "browser",
          name: "chromium",
          browserName: "chromium",
          directory: chromium.dir,
          executablePath: () => chromiumExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium.installByDefault, sdkLanguage),
          installType: chromium.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromium.dir, ["chrome-linux"], [], ["chrome-win"]),
          downloadURLs: this._downloadURLs(chromium),
          browserVersion: chromium.browserVersion,
          _install: () => this._downloadExecutable(chromium, chromiumExecutable),
          _dependencyGroup: "chromium",
          _isHermeticInstallation: true
        });
        const chromiumWithSymbols = descriptors.find((d) => d.name === "chromium-with-symbols");
        const chromiumWithSymbolsExecutable = findExecutablePath(chromiumWithSymbols.dir, "chromium");
        this._executables.push({
          type: "tool",
          name: "chromium-with-symbols",
          browserName: "chromium",
          directory: chromiumWithSymbols.dir,
          executablePath: () => chromiumWithSymbolsExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium-with-symbols", chromiumWithSymbolsExecutable, chromiumWithSymbols.installByDefault, sdkLanguage),
          installType: chromiumWithSymbols.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromiumWithSymbols.dir, ["chrome-linux"], [], ["chrome-win"]),
          downloadURLs: this._downloadURLs(chromiumWithSymbols),
          browserVersion: chromiumWithSymbols.browserVersion,
          _install: () => this._downloadExecutable(chromiumWithSymbols, chromiumWithSymbolsExecutable),
          _dependencyGroup: "chromium",
          _isHermeticInstallation: true
        });
        const chromiumTipOfTree = descriptors.find((d) => d.name === "chromium-tip-of-tree");
        const chromiumTipOfTreeExecutable = findExecutablePath(chromiumTipOfTree.dir, "chromium");
        this._executables.push({
          type: "tool",
          name: "chromium-tip-of-tree",
          browserName: "chromium",
          directory: chromiumTipOfTree.dir,
          executablePath: () => chromiumTipOfTreeExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium-tip-of-tree", chromiumTipOfTreeExecutable, chromiumTipOfTree.installByDefault, sdkLanguage),
          installType: chromiumTipOfTree.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromiumTipOfTree.dir, ["chrome-linux"], [], ["chrome-win"]),
          downloadURLs: this._downloadURLs(chromiumTipOfTree),
          browserVersion: chromiumTipOfTree.browserVersion,
          _install: () => this._downloadExecutable(chromiumTipOfTree, chromiumTipOfTreeExecutable),
          _dependencyGroup: "chromium",
          _isHermeticInstallation: true
        });
        this._executables.push(this._createChromiumChannel("chrome", {
          "linux": "/opt/google/chrome/chrome",
          "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
          "win32": `\\Google\\Chrome\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome", {
          "linux": "reinstall_chrome_stable_linux.sh",
          "darwin": "reinstall_chrome_stable_mac.sh",
          "win32": "reinstall_chrome_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-beta", {
          "linux": "/opt/google/chrome-beta/chrome",
          "darwin": "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
          "win32": `\\Google\\Chrome Beta\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome-beta", {
          "linux": "reinstall_chrome_beta_linux.sh",
          "darwin": "reinstall_chrome_beta_mac.sh",
          "win32": "reinstall_chrome_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-dev", {
          "linux": "/opt/google/chrome-unstable/chrome",
          "darwin": "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
          "win32": `\\Google\\Chrome Dev\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("chrome-canary", {
          "linux": "",
          "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
          "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("msedge", {
          "linux": "/opt/microsoft/msedge/msedge",
          "darwin": "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
          "win32": `\\Microsoft\\Edge\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge", {
          "linux": "reinstall_msedge_stable_linux.sh",
          "darwin": "reinstall_msedge_stable_mac.sh",
          "win32": "reinstall_msedge_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-beta", {
          "linux": "/opt/microsoft/msedge-beta/msedge",
          "darwin": "/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta",
          "win32": `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-beta", {
          "darwin": "reinstall_msedge_beta_mac.sh",
          "linux": "reinstall_msedge_beta_linux.sh",
          "win32": "reinstall_msedge_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-dev", {
          "linux": "/opt/microsoft/msedge-dev/msedge",
          "darwin": "/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev",
          "win32": `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-dev", {
          "darwin": "reinstall_msedge_dev_mac.sh",
          "linux": "reinstall_msedge_dev_linux.sh",
          "win32": "reinstall_msedge_dev_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-canary", {
          "linux": "",
          "darwin": "/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary",
          "win32": `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
        }));
        const firefox = descriptors.find((d) => d.name === "firefox");
        const firefoxExecutable = findExecutablePath(firefox.dir, "firefox");
        this._executables.push({
          type: "browser",
          name: "firefox",
          browserName: "firefox",
          directory: firefox.dir,
          executablePath: () => firefoxExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox", firefoxExecutable, firefox.installByDefault, sdkLanguage),
          installType: firefox.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefox.dir, ["firefox"], [], ["firefox"]),
          downloadURLs: this._downloadURLs(firefox),
          browserVersion: firefox.browserVersion,
          _install: () => this._downloadExecutable(firefox, firefoxExecutable),
          _dependencyGroup: "firefox",
          _isHermeticInstallation: true
        });
        const firefoxBeta = descriptors.find((d) => d.name === "firefox-beta");
        const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, "firefox");
        this._executables.push({
          type: "tool",
          name: "firefox-beta",
          browserName: "firefox",
          directory: firefoxBeta.dir,
          executablePath: () => firefoxBetaExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox-beta", firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage),
          installType: firefoxBeta.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefoxBeta.dir, ["firefox"], [], ["firefox"]),
          downloadURLs: this._downloadURLs(firefoxBeta),
          browserVersion: firefoxBeta.browserVersion,
          _install: () => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable),
          _dependencyGroup: "firefox",
          _isHermeticInstallation: true
        });
        const webkit = descriptors.find((d) => d.name === "webkit");
        const webkitExecutable = findExecutablePath(webkit.dir, "webkit");
        const webkitLinuxLddDirectories = [_path.default.join("minibrowser-gtk"), _path.default.join("minibrowser-gtk", "bin"), _path.default.join("minibrowser-gtk", "lib"), _path.default.join("minibrowser-gtk", "sys", "lib"), _path.default.join("minibrowser-wpe"), _path.default.join("minibrowser-wpe", "bin"), _path.default.join("minibrowser-wpe", "lib"), _path.default.join("minibrowser-wpe", "sys", "lib")];
        this._executables.push({
          type: "browser",
          name: "webkit",
          browserName: "webkit",
          directory: webkit.dir,
          executablePath: () => webkitExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("webkit", webkitExecutable, webkit.installByDefault, sdkLanguage),
          installType: webkit.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "webkit", webkit.dir, webkitLinuxLddDirectories, ["libGLESv2.so.2", "libx264.so"], [""]),
          downloadURLs: this._downloadURLs(webkit),
          browserVersion: webkit.browserVersion,
          _install: () => this._downloadExecutable(webkit, webkitExecutable),
          _dependencyGroup: "webkit",
          _isHermeticInstallation: true
        });
        const ffmpeg = descriptors.find((d) => d.name === "ffmpeg");
        const ffmpegExecutable = findExecutablePath(ffmpeg.dir, "ffmpeg");
        this._executables.push({
          type: "tool",
          name: "ffmpeg",
          browserName: void 0,
          directory: ffmpeg.dir,
          executablePath: () => ffmpegExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("ffmpeg", ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage),
          installType: ffmpeg.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: () => Promise.resolve(),
          downloadURLs: this._downloadURLs(ffmpeg),
          _install: () => this._downloadExecutable(ffmpeg, ffmpegExecutable),
          _dependencyGroup: "tools",
          _isHermeticInstallation: true
        });
        const android = descriptors.find((d) => d.name === "android");
        this._executables.push({
          type: "tool",
          name: "android",
          browserName: void 0,
          directory: android.dir,
          executablePath: () => void 0,
          executablePathOrDie: () => "",
          installType: "download-on-demand",
          validateHostRequirements: () => Promise.resolve(),
          downloadURLs: this._downloadURLs(android),
          _install: () => this._downloadExecutable(android),
          _dependencyGroup: "tools",
          _isHermeticInstallation: true
        });
      }
      _createChromiumChannel(name, lookAt, install) {
        const executablePath = (sdkLanguage, shouldThrow) => {
          const suffix = lookAt[process.platform];
          if (!suffix) {
            if (shouldThrow)
              throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
            return void 0;
          }
          const prefixes = process.platform === "win32" ? [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env["PROGRAMFILES(X86)"]].filter(Boolean) : [""];
          for (const prefix of prefixes) {
            const executablePath2 = _path.default.join(prefix, suffix);
            if ((0, _fileUtils.canAccessFile)(executablePath2))
              return executablePath2;
          }
          if (!shouldThrow)
            return void 0;
          const location2 = prefixes.length ? ` at ${_path.default.join(prefixes[0], suffix)}` : ``;
          const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
          throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
        };
        return {
          type: "channel",
          name,
          browserName: "chromium",
          directory: void 0,
          executablePath: (sdkLanguage) => executablePath(sdkLanguage, false),
          executablePathOrDie: (sdkLanguage) => executablePath(sdkLanguage, true),
          installType: install ? "install-script" : "none",
          validateHostRequirements: () => Promise.resolve(),
          _isHermeticInstallation: false,
          _install: install
        };
      }
      executables() {
        return this._executables;
      }
      findExecutable(name) {
        return this._executables.find((b) => b.name === name);
      }
      defaultExecutables() {
        return this._executables.filter((e) => e.installType === "download-by-default");
      }
      _addRequirementsAndDedupe(executables) {
        const set = /* @__PURE__ */ new Set();
        for (const executable of executables) {
          set.add(executable);
          if (executable.browserName === "chromium")
            set.add(this.findExecutable("ffmpeg"));
        }
        return Array.from(set);
      }
      _validateHostRequirements(sdkLanguage, browserName, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
        return __async(this, null, function* () {
          if ((0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
            process.stderr.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
            return;
          }
          const distributionInfo = yield (0, _linuxUtils.getLinuxDistributionInfo)();
          if (browserName === "firefox" && (distributionInfo === null || distributionInfo === void 0 ? void 0 : distributionInfo.id) === "ubuntu" && (distributionInfo === null || distributionInfo === void 0 ? void 0 : distributionInfo.version) === "16.04")
            throw new Error(`Cannot launch Firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 20.04`);
          if (os.platform() === "linux")
            return yield (0, _dependencies.validateDependenciesLinux)(sdkLanguage, linuxLddDirectories.map((d) => _path.default.join(browserDirectory, d)), dlOpenLibraries);
          if (os.platform() === "win32" && os.arch() === "x64")
            return yield (0, _dependencies.validateDependenciesWindows)(windowsExeAndDllDirectories.map((d) => _path.default.join(browserDirectory, d)));
        });
      }
      installDeps(executablesToInstallDeps, dryRun) {
        return __async(this, null, function* () {
          const executables = this._addRequirementsAndDedupe(executablesToInstallDeps);
          const targets = /* @__PURE__ */ new Set();
          for (const executable of executables) {
            if (executable._dependencyGroup)
              targets.add(executable._dependencyGroup);
          }
          targets.add("tools");
          if (os.platform() === "win32")
            return yield (0, _dependencies.installDependenciesWindows)(targets, dryRun);
          if (os.platform() === "linux")
            return yield (0, _dependencies.installDependenciesLinux)(targets, dryRun);
        });
      }
      install(executablesToInstall, forceReinstall) {
        return __async(this, null, function* () {
          const executables = this._addRequirementsAndDedupe(executablesToInstall);
          yield fs.promises.mkdir(registryDirectory, {
            recursive: true
          });
          const lockfilePath = _path.default.join(registryDirectory, "__dirlock");
          const linksDir = _path.default.join(registryDirectory, ".links");
          let releaseLock;
          try {
            releaseLock = yield _utilsBundle.lockfile.lock(registryDirectory, {
              retries: {
                retries: 20,
                factor: 1.27579
              },
              onCompromised: (err) => {
                throw new Error(`${err.message} Path: ${lockfilePath}`);
              },
              lockfilePath
            });
            yield fs.promises.mkdir(linksDir, {
              recursive: true
            });
            yield fs.promises.writeFile(_path.default.join(linksDir, (0, _utils.calculateSha1)(PACKAGE_PATH)), PACKAGE_PATH);
            yield this._validateInstallationCache(linksDir);
            for (const executable of executables) {
              if (!executable._install)
                throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
              const {
                embedderName
              } = (0, _userAgent.getEmbedderName)();
              if (!(0, _utils.getAsBooleanFromENV)("CI") && !executable._isHermeticInstallation && !forceReinstall && executable.executablePath(embedderName)) {
                const command = buildPlaywrightCLICommand(embedderName, "install --force " + executable.name);
                throw new Error("\n" + (0, _utils.wrapInASCIIBox)([`ATTENTION: "${executable.name}" is already installed on the system!`, ``, `"${executable.name}" installation is not hermetic; installing newer version`, `requires *removal* of a current installation first.`, ``, `To *uninstall* current version and re-install latest "${executable.name}":`, ``, `- Close all running instances of "${executable.name}", if any`, `- Use "--force" to install browser:`, ``, `    ${command}`, ``, `<3 Playwright Team`].join("\n"), 1));
              }
              yield executable._install();
            }
          } catch (e) {
            if (e.code === "ELOCKED") {
              const rmCommand = process.platform === "win32" ? "rm -R" : "rm -rf";
              throw new Error("\n" + (0, _utils.wrapInASCIIBox)([`An active lockfile is found at:`, ``, `  ${lockfilePath}`, ``, `Either:`, `- wait a few minutes if other Playwright is installing browsers in parallel`, `- remove lock manually with:`, ``, `    ${rmCommand} ${lockfilePath}`, ``, `<3 Playwright Team`].join("\n"), 1));
            } else {
              throw e;
            }
          } finally {
            if (releaseLock)
              yield releaseLock();
          }
        });
      }
      uninstall(all) {
        return __async(this, null, function* () {
          const linksDir = _path.default.join(registryDirectory, ".links");
          if (all) {
            const links = yield fs.promises.readdir(linksDir).catch(() => []);
            for (const link of links)
              yield fs.promises.unlink(_path.default.join(linksDir, link));
          } else {
            yield fs.promises.unlink(_path.default.join(linksDir, (0, _utils.calculateSha1)(PACKAGE_PATH))).catch(() => {
            });
          }
          yield this._validateInstallationCache(linksDir);
          return {
            numberOfBrowsersLeft: (yield fs.promises.readdir(registryDirectory).catch(() => [])).filter((browserDirectory) => isBrowserDirectory(browserDirectory)).length
          };
        });
      }
      _downloadURLs(descriptor) {
        const paths = DOWNLOAD_PATHS[descriptor.name];
        const downloadPathTemplate = paths[_hostPlatform.hostPlatform] || paths["<unknown>"];
        if (!downloadPathTemplate)
          return [];
        const downloadPath = util.format(downloadPathTemplate, descriptor.revision);
        let downloadURLs = PLAYWRIGHT_CDN_MIRRORS.map((mirror) => `${mirror}/${downloadPath}`);
        let downloadHostEnv;
        if (descriptor.name.startsWith("chromium"))
          downloadHostEnv = "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST";
        else if (descriptor.name.startsWith("firefox"))
          downloadHostEnv = "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST";
        else if (descriptor.name.startsWith("webkit"))
          downloadHostEnv = "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST";
        const customHostOverride = downloadHostEnv && (0, _utils.getFromENV)(downloadHostEnv) || (0, _utils.getFromENV)("PLAYWRIGHT_DOWNLOAD_HOST");
        if (customHostOverride)
          downloadURLs = [`${customHostOverride}/${downloadPath}`];
        return downloadURLs;
      }
      _downloadExecutable(descriptor, executablePath) {
        return __async(this, null, function* () {
          const downloadURLs = this._downloadURLs(descriptor);
          if (!downloadURLs.length)
            throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${_hostPlatform.hostPlatform}`);
          if (_hostPlatform.hostPlatform === "generic-linux" || _hostPlatform.hostPlatform === "generic-linux-arm64")
            (0, _browserFetcher.logPolitely)("BEWARE: your OS is not officially supported by Playwright; downloading fallback build.");
          const displayName = descriptor.name.split("-").map((word) => {
            return word === "ffmpeg" ? "FFMPEG" : word.charAt(0).toUpperCase() + word.slice(1);
          }).join(" ");
          const title = descriptor.browserVersion ? `${displayName} ${descriptor.browserVersion} (playwright build v${descriptor.revision})` : `${displayName} playwright build v${descriptor.revision}`;
          const downloadFileName = `playwright-download-${descriptor.name}-${_hostPlatform.hostPlatform}-${descriptor.revision}.zip`;
          const downloadConnectionTimeoutEnv = (0, _utils.getFromENV)("PLAYWRIGHT_DOWNLOAD_CONNECTION_TIMEOUT");
          const downloadConnectionTimeout = +(downloadConnectionTimeoutEnv || "0") || 3e4;
          yield (0, _browserFetcher.downloadBrowserWithProgressBar)(title, descriptor.dir, executablePath, downloadURLs, downloadFileName, downloadConnectionTimeout).catch((e) => {
            throw new Error(`Failed to download ${title}, caused by
${e.stack}`);
          });
        });
      }
      _installMSEdgeChannel(channel, scripts) {
        return __async(this, null, function* () {
          const scriptArgs = [];
          if (process.platform !== "linux") {
            const products = lowercaseAllKeys(JSON.parse(yield (0, _network.fetchData)({
              url: "https://edgeupdates.microsoft.com/api/products"
            })));
            const productName = {
              "msedge": "Stable",
              "msedge-beta": "Beta",
              "msedge-dev": "Dev"
            }[channel];
            const product = products.find((product2) => product2.product === productName);
            const searchConfig = {
              darwin: {
                platform: "MacOS",
                arch: "universal",
                artifact: "pkg"
              },
              win32: {
                platform: "Windows",
                arch: "x64",
                artifact: "msi"
              }
            }[process.platform];
            const release = searchConfig ? product.releases.find((release2) => release2.platform === searchConfig.platform && release2.architecture === searchConfig.arch) : null;
            const artifact = release ? release.artifacts.find((artifact2) => artifact2.artifactname === searchConfig.artifact) : null;
            if (artifact)
              scriptArgs.push(artifact.location);
            else
              throw new Error(`Cannot install ${channel} on ${process.platform}`);
          }
          yield this._installChromiumChannel(channel, scripts, scriptArgs);
        });
      }
      _installChromiumChannel(_0, _1) {
        return __async(this, arguments, function* (channel, scripts, scriptArgs = []) {
          const scriptName = scripts[process.platform];
          if (!scriptName)
            throw new Error(`Cannot install ${channel} on ${process.platform}`);
          const cwd = BIN_PATH;
          const isPowerShell = scriptName.endsWith(".ps1");
          if (isPowerShell) {
            const args = ["-ExecutionPolicy", "Bypass", "-File", _path.default.join(BIN_PATH, scriptName), ...scriptArgs];
            const {
              code
            } = yield (0, _spawnAsync.spawnAsync)("powershell.exe", args, {
              cwd,
              stdio: "inherit"
            });
            if (code !== 0)
              throw new Error(`Failed to install ${channel}`);
          } else {
            const {
              command,
              args,
              elevatedPermissions
            } = yield (0, _dependencies.transformCommandsForRoot)([`bash "${_path.default.join(BIN_PATH, scriptName)}" ${scriptArgs.join("")}`]);
            if (elevatedPermissions)
              console.log("Switching to root user to install dependencies...");
            const {
              code
            } = yield (0, _spawnAsync.spawnAsync)(command, args, {
              cwd,
              stdio: "inherit"
            });
            if (code !== 0)
              throw new Error(`Failed to install ${channel}`);
          }
        });
      }
      _validateInstallationCache(linksDir) {
        return __async(this, null, function* () {
          const usedBrowserPaths = /* @__PURE__ */ new Set();
          for (const fileName of yield fs.promises.readdir(linksDir)) {
            const linkPath = _path.default.join(linksDir, fileName);
            let linkTarget = "";
            try {
              linkTarget = (yield fs.promises.readFile(linkPath)).toString();
              const browsersJSON = require(_path.default.join(linkTarget, "browsers.json"));
              const descriptors = readDescriptors(browsersJSON);
              for (const browserName of allDownloadable) {
                const descriptor = descriptors.find((d) => d.name === browserName);
                if (!descriptor)
                  continue;
                const usedBrowserPath = descriptor.dir;
                const browserRevision = parseInt(descriptor.revision, 10);
                const shouldHaveMarkerFile = browserName === "chromium" && (browserRevision >= 786218 || browserRevision < 3e5) || browserName === "firefox" && browserRevision >= 1128 || browserName === "webkit" && browserRevision >= 1307 || browserName !== "firefox" && browserName !== "chromium" && browserName !== "webkit";
                if (!shouldHaveMarkerFile || (yield (0, _fileUtils.existsAsync)(browserDirectoryToMarkerFilePath(usedBrowserPath))))
                  usedBrowserPaths.add(usedBrowserPath);
              }
            } catch (e) {
              yield fs.promises.unlink(linkPath).catch((e2) => {
              });
            }
          }
          if (!(0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_GC")) {
            let downloadedBrowsers = (yield fs.promises.readdir(registryDirectory)).map((file) => _path.default.join(registryDirectory, file));
            downloadedBrowsers = downloadedBrowsers.filter((file) => isBrowserDirectory(file));
            const directories = new Set(downloadedBrowsers);
            for (const browserDirectory of usedBrowserPaths)
              directories.delete(browserDirectory);
            for (const directory of directories)
              (0, _browserFetcher.logPolitely)("Removing unused browser at " + directory);
            yield (0, _fileUtils.removeFolders)([...directories]);
          }
        });
      }
    };
    exports2.Registry = Registry;
    function browserDirectoryToMarkerFilePath(browserDirectory) {
      return _path.default.join(browserDirectory, "INSTALLATION_COMPLETE");
    }
    function buildPlaywrightCLICommand(sdkLanguage, parameters) {
      switch (sdkLanguage) {
        case "python":
          return `playwright ${parameters}`;
        case "java":
          return `mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="${parameters}"`;
        case "csharp":
          return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;
        default:
          return `npx playwright ${parameters}`;
      }
    }
    function installDefaultBrowsersForNpmInstall() {
      return __async(this, null, function* () {
        const defaultBrowserNames = registry.defaultExecutables().map((e) => e.name);
        return installBrowsersForNpmInstall(defaultBrowserNames);
      });
    }
    function installBrowsersForNpmInstall(browsers) {
      return __async(this, null, function* () {
        if ((0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD")) {
          (0, _browserFetcher.logPolitely)("Skipping browsers download because `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` env variable is set");
          return false;
        }
        const executables = [];
        for (const browserName of browsers) {
          const executable = registry.findExecutable(browserName);
          if (!executable || executable.installType === "none")
            throw new Error(`Cannot install ${browserName}`);
          executables.push(executable);
        }
        yield registry.install(executables, false);
      });
    }
    function findChromiumChannel(sdkLanguage) {
      let channel = null;
      for (const name of ["chromium", "chrome", "msedge"]) {
        try {
          registry.findExecutable(name).executablePathOrDie(sdkLanguage);
          channel = name === "chromium" ? void 0 : name;
          break;
        } catch (e) {
        }
      }
      if (channel === null) {
        const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
        const prettyMessage = [`No chromium-based browser found on the system.`, `Please run the following command to download one:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
        throw new Error("\n" + (0, _utils.wrapInASCIIBox)(prettyMessage, 1));
      }
      return channel;
    }
    function lowercaseAllKeys(json) {
      if (typeof json !== "object" || !json)
        return json;
      if (Array.isArray(json))
        return json.map(lowercaseAllKeys);
      const result = {};
      for (const [key, value] of Object.entries(json))
        result[key.toLowerCase()] = lowercaseAllKeys(value);
      return result;
    }
    var registry = new Registry(require_browsers());
    exports2.registry = registry;
  }
});

// node_modules/playwright-core/lib/common/errors.js
var require_errors = __commonJS({
  "node_modules/playwright-core/lib/common/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutError = void 0;
    exports2.isSafeCloseError = isSafeCloseError;
    exports2.kBrowserOrContextClosedError = exports2.kBrowserClosedError = void 0;
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    exports2.TimeoutError = TimeoutError;
    var kBrowserClosedError = "Browser has been closed";
    exports2.kBrowserClosedError = kBrowserClosedError;
    var kBrowserOrContextClosedError = "Target page, context or browser has been closed";
    exports2.kBrowserOrContextClosedError = kBrowserOrContextClosedError;
    function isSafeCloseError(error) {
      return error.message.endsWith(kBrowserClosedError) || error.message.endsWith(kBrowserOrContextClosedError);
    }
  }
});

// node_modules/playwright-core/lib/protocol/serializers.js
var require_serializers = __commonJS({
  "node_modules/playwright-core/lib/protocol/serializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseError = parseError;
    exports2.parseSerializedValue = parseSerializedValue;
    exports2.serializeError = serializeError;
    exports2.serializeValue = serializeValue;
    var _errors = require_errors();
    function serializeError(e) {
      if (isError(e))
        return {
          error: {
            message: e.message,
            stack: e.stack,
            name: e.name
          }
        };
      return {
        value: serializeValue(e, (value) => ({
          fallThrough: value
        }))
      };
    }
    function parseError(error) {
      if (!error.error) {
        if (error.value === void 0)
          throw new Error("Serialized error must have either an error or a value");
        return parseSerializedValue(error.value, void 0);
      }
      if (error.error.name === "TimeoutError") {
        const e2 = new _errors.TimeoutError(error.error.message);
        e2.stack = error.error.stack || "";
        return e2;
      }
      const e = new Error(error.error.message);
      e.stack = error.error.stack || "";
      e.name = error.error.name;
      return e;
    }
    function parseSerializedValue(value, handles) {
      return innerParseSerializedValue(value, handles, /* @__PURE__ */ new Map());
    }
    function innerParseSerializedValue(value, handles, refs) {
      if (value.ref !== void 0)
        return refs.get(value.ref);
      if (value.n !== void 0)
        return value.n;
      if (value.s !== void 0)
        return value.s;
      if (value.b !== void 0)
        return value.b;
      if (value.v !== void 0) {
        if (value.v === "undefined")
          return void 0;
        if (value.v === "null")
          return null;
        if (value.v === "NaN")
          return NaN;
        if (value.v === "Infinity")
          return Infinity;
        if (value.v === "-Infinity")
          return -Infinity;
        if (value.v === "-0")
          return -0;
      }
      if (value.d !== void 0)
        return new Date(value.d);
      if (value.u !== void 0)
        return new URL(value.u);
      if (value.bi !== void 0)
        return BigInt(value.bi);
      if (value.r !== void 0)
        return new RegExp(value.r.p, value.r.f);
      if (value.a !== void 0) {
        const result = [];
        refs.set(value.id, result);
        for (const v of value.a)
          result.push(innerParseSerializedValue(v, handles, refs));
        return result;
      }
      if (value.o !== void 0) {
        const result = {};
        refs.set(value.id, result);
        for (const {
          k,
          v
        } of value.o)
          result[k] = innerParseSerializedValue(v, handles, refs);
        return result;
      }
      if (value.h !== void 0) {
        if (handles === void 0)
          throw new Error("Unexpected handle");
        return handles[value.h];
      }
      throw new Error("Unexpected value");
    }
    function serializeValue(value, handleSerializer) {
      return innerSerializeValue(value, handleSerializer, {
        lastId: 0,
        visited: /* @__PURE__ */ new Map()
      });
    }
    function innerSerializeValue(value, handleSerializer, visitorInfo) {
      const handle = handleSerializer(value);
      if ("fallThrough" in handle)
        value = handle.fallThrough;
      else
        return handle;
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return {
          b: value
        };
      if (typeof value === "number")
        return {
          n: value
        };
      if (typeof value === "string")
        return {
          s: value
        };
      if (typeof value === "bigint")
        return {
          bi: value.toString()
        };
      if (isError(value)) {
        const error = value;
        if ("captureStackTrace" in globalThis.Error) {
          return {
            s: error.stack || ""
          };
        }
        return {
          s: `${error.name}: ${error.message}
${error.stack}`
        };
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isURL(value))
        return {
          u: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      const id = visitorInfo.visited.get(value);
      if (id)
        return {
          ref: id
        };
      if (Array.isArray(value)) {
        const a = [];
        const id2 = ++visitorInfo.lastId;
        visitorInfo.visited.set(value, id2);
        for (let i = 0; i < value.length; ++i)
          a.push(innerSerializeValue(value[i], handleSerializer, visitorInfo));
        return {
          a,
          id: id2
        };
      }
      if (typeof value === "object") {
        const o = [];
        const id2 = ++visitorInfo.lastId;
        visitorInfo.visited.set(value, id2);
        for (const name of Object.keys(value))
          o.push({
            k: name,
            v: innerSerializeValue(value[name], handleSerializer, visitorInfo)
          });
        return {
          o,
          id: id2
        };
      }
      throw new Error("Unexpected value");
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isURL(obj) {
      return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";
    }
    function isError(obj) {
      const proto = obj ? Object.getPrototypeOf(obj) : null;
      return obj instanceof Error || (proto === null || proto === void 0 ? void 0 : proto.name) === "Error" || proto && isError(proto);
    }
  }
});

// node_modules/playwright-core/lib/protocol/validatorPrimitives.js
var require_validatorPrimitives = __commonJS({
  "node_modules/playwright-core/lib/protocol/validatorPrimitives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValidationError = void 0;
    exports2.createMetadataValidator = createMetadataValidator;
    exports2.findValidator = findValidator;
    exports2.maybeFindValidator = maybeFindValidator;
    exports2.tUndefined = exports2.tType = exports2.tString = exports2.tOptional = exports2.tObject = exports2.tNumber = exports2.tEnum = exports2.tChannel = exports2.tBoolean = exports2.tBinary = exports2.tArray = exports2.tAny = exports2.scheme = void 0;
    var _utils = require_utils();
    var ValidationError = class extends Error {
    };
    exports2.ValidationError = ValidationError;
    var scheme = {};
    exports2.scheme = scheme;
    function findValidator(type, method, kind) {
      const validator = maybeFindValidator(type, method, kind);
      if (!validator)
        throw new ValidationError(`Unknown scheme for ${kind}: ${type}.${method}`);
      return validator;
    }
    function maybeFindValidator(type, method, kind) {
      const schemeName = type + (kind === "Initializer" ? "" : method[0].toUpperCase() + method.substring(1)) + kind;
      return scheme[schemeName];
    }
    function createMetadataValidator() {
      return tOptional(scheme["Metadata"]);
    }
    var tNumber = (arg, path, context) => {
      if (arg instanceof Number)
        return arg.valueOf();
      if (typeof arg === "number")
        return arg;
      throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
    };
    exports2.tNumber = tNumber;
    var tBoolean = (arg, path, context) => {
      if (arg instanceof Boolean)
        return arg.valueOf();
      if (typeof arg === "boolean")
        return arg;
      throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
    };
    exports2.tBoolean = tBoolean;
    var tString = (arg, path, context) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
    };
    exports2.tString = tString;
    var tBinary = (arg, path, context) => {
      if (context.binary === "fromBase64") {
        if (arg instanceof String)
          return Buffer.from(arg.valueOf(), "base64");
        if (typeof arg === "string")
          return Buffer.from(arg, "base64");
        throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
      }
      if (context.binary === "toBase64") {
        if (!(arg instanceof Buffer))
          throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);
        return arg.toString("base64");
      }
      if (context.binary === "buffer") {
        if (!(arg instanceof Buffer))
          throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);
        return arg;
      }
      throw new ValidationError(`Unsupported binary behavior "${context.binary}"`);
    };
    exports2.tBinary = tBinary;
    var tUndefined = (arg, path, context) => {
      if (Object.is(arg, void 0))
        return arg;
      throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
    };
    exports2.tUndefined = tUndefined;
    var tAny = (arg, path, context) => {
      return arg;
    };
    exports2.tAny = tAny;
    var tOptional = (v) => {
      return (arg, path, context) => {
        if (Object.is(arg, void 0))
          return arg;
        return v(arg, path, context);
      };
    };
    exports2.tOptional = tOptional;
    var tArray = (v) => {
      return (arg, path, context) => {
        if (!Array.isArray(arg))
          throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
        return arg.map((x, index) => v(x, path + "[" + index + "]", context));
      };
    };
    exports2.tArray = tArray;
    var tObject = (s) => {
      return (arg, path, context) => {
        if (Object.is(arg, null))
          throw new ValidationError(`${path}: expected object, got null`);
        if (typeof arg !== "object")
          throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
        const result = {};
        for (const [key, v] of Object.entries(s)) {
          const value = v(arg[key], path ? path + "." + key : key, context);
          if (!Object.is(value, void 0))
            result[key] = value;
        }
        if ((0, _utils.isUnderTest)()) {
          for (const [key, value] of Object.entries(arg)) {
            if (key.startsWith("__testHook"))
              result[key] = value;
          }
        }
        return result;
      };
    };
    exports2.tObject = tObject;
    var tEnum = (e) => {
      return (arg, path, context) => {
        if (!e.includes(arg))
          throw new ValidationError(`${path}: expected one of (${e.join("|")})`);
        return arg;
      };
    };
    exports2.tEnum = tEnum;
    var tChannel = (names) => {
      return (arg, path, context) => {
        return context.tChannelImpl(names, arg, path, context);
      };
    };
    exports2.tChannel = tChannel;
    var tType = (name) => {
      return (arg, path, context) => {
        const v = scheme[name];
        if (!v)
          throw new ValidationError(path + ': unknown type "' + name + '"');
        return v(arg, path, context);
      };
    };
    exports2.tType = tType;
  }
});

// node_modules/playwright-core/lib/protocol/validator.js
var require_validator = __commonJS({
  "node_modules/playwright-core/lib/protocol/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ValidationError", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.ValidationError;
      }
    });
    Object.defineProperty(exports2, "createMetadataValidator", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.createMetadataValidator;
      }
    });
    Object.defineProperty(exports2, "findValidator", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.findValidator;
      }
    });
    Object.defineProperty(exports2, "maybeFindValidator", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.maybeFindValidator;
      }
    });
    var _validatorPrimitives = require_validatorPrimitives();
    _validatorPrimitives.scheme.StackFrame = (0, _validatorPrimitives.tObject)({
      file: _validatorPrimitives.tString,
      line: _validatorPrimitives.tNumber,
      column: _validatorPrimitives.tNumber,
      function: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.Metadata = (0, _validatorPrimitives.tObject)({
      location: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tString,
        line: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        column: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      apiName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      internal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      wallTime: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.ClientSideCallMetadata = (0, _validatorPrimitives.tObject)({
      id: _validatorPrimitives.tNumber,
      stack: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("StackFrame")))
    });
    _validatorPrimitives.scheme.Point = (0, _validatorPrimitives.tObject)({
      x: _validatorPrimitives.tNumber,
      y: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.Rect = (0, _validatorPrimitives.tObject)({
      x: _validatorPrimitives.tNumber,
      y: _validatorPrimitives.tNumber,
      width: _validatorPrimitives.tNumber,
      height: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.SerializedValue = (0, _validatorPrimitives.tObject)({
      n: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      b: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      s: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      v: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
      d: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      u: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      bi: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      r: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        p: _validatorPrimitives.tString,
        f: _validatorPrimitives.tString
      })),
      a: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("SerializedValue"))),
      o: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        k: _validatorPrimitives.tString,
        v: (0, _validatorPrimitives.tType)("SerializedValue")
      }))),
      h: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      id: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      ref: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.SerializedArgument = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue"),
      handles: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)("*"))
    });
    _validatorPrimitives.scheme.ExpectedTextValue = (0, _validatorPrimitives.tObject)({
      string: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      matchSubstring: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      ignoreCase: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      normalizeWhiteSpace: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.AXNode = (0, _validatorPrimitives.tObject)({
      role: _validatorPrimitives.tString,
      name: _validatorPrimitives.tString,
      valueString: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      valueNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      description: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      keyshortcuts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      roledescription: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      valuetext: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      disabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      expanded: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      multiline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      multiselectable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      readonly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      required: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      checked: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["checked", "unchecked", "mixed"])),
      pressed: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["pressed", "released", "mixed"])),
      level: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      valuemin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      valuemax: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      autocomplete: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      haspopup: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      invalid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      orientation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("AXNode")))
    });
    _validatorPrimitives.scheme.SetNetworkCookie = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      value: _validatorPrimitives.tString,
      url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      domain: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      expires: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      httpOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      secure: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      sameSite: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"]))
    });
    _validatorPrimitives.scheme.NetworkCookie = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      value: _validatorPrimitives.tString,
      domain: _validatorPrimitives.tString,
      path: _validatorPrimitives.tString,
      expires: _validatorPrimitives.tNumber,
      httpOnly: _validatorPrimitives.tBoolean,
      secure: _validatorPrimitives.tBoolean,
      sameSite: (0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"])
    });
    _validatorPrimitives.scheme.NameValue = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.OriginStorage = (0, _validatorPrimitives.tObject)({
      origin: _validatorPrimitives.tString,
      localStorage: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.SerializedError = (0, _validatorPrimitives.tObject)({
      error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        message: _validatorPrimitives.tString,
        name: _validatorPrimitives.tString,
        stack: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("SerializedValue"))
    });
    _validatorPrimitives.scheme.RecordHarOptions = (0, _validatorPrimitives.tObject)({
      path: _validatorPrimitives.tString,
      content: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["embed", "attach", "omit"])),
      mode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["full", "minimal"])),
      urlGlob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      urlRegexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      urlRegexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FormField = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      file: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        buffer: _validatorPrimitives.tBinary
      }))
    });
    _validatorPrimitives.scheme.APIRequestContextInitializer = (0, _validatorPrimitives.tObject)({
      tracing: (0, _validatorPrimitives.tChannel)(["Tracing"])
    });
    _validatorPrimitives.scheme.APIRequestContextFetchParams = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString,
      params: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      jsonData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
      formData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      multipartData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("FormField"))),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      failOnStatusCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      maxRedirects: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.APIRequestContextFetchResult = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tType)("APIResponse")
    });
    _validatorPrimitives.scheme.APIRequestContextFetchResponseBodyParams = (0, _validatorPrimitives.tObject)({
      fetchUid: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.APIRequestContextFetchResponseBodyResult = (0, _validatorPrimitives.tObject)({
      binary: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
    });
    _validatorPrimitives.scheme.APIRequestContextFetchLogParams = (0, _validatorPrimitives.tObject)({
      fetchUid: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.APIRequestContextFetchLogResult = (0, _validatorPrimitives.tObject)({
      log: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.APIRequestContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.APIRequestContextStorageStateResult = (0, _validatorPrimitives.tObject)({
      cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NetworkCookie")),
      origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("OriginStorage"))
    });
    _validatorPrimitives.scheme.APIRequestContextDisposeAPIResponseParams = (0, _validatorPrimitives.tObject)({
      fetchUid: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.APIRequestContextDisposeAPIResponseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.APIRequestContextDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.APIRequestContextDisposeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.APIResponse = (0, _validatorPrimitives.tObject)({
      fetchUid: _validatorPrimitives.tString,
      url: _validatorPrimitives.tString,
      status: _validatorPrimitives.tNumber,
      statusText: _validatorPrimitives.tString,
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.LifecycleEvent = (0, _validatorPrimitives.tEnum)(["load", "domcontentloaded", "networkidle", "commit"]);
    _validatorPrimitives.scheme.LocalUtilsInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.LocalUtilsZipParams = (0, _validatorPrimitives.tObject)({
      zipFile: _validatorPrimitives.tString,
      entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue")),
      stacksId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      mode: (0, _validatorPrimitives.tEnum)(["write", "append"]),
      includeSources: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.LocalUtilsZipResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.LocalUtilsHarOpenParams = (0, _validatorPrimitives.tObject)({
      file: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.LocalUtilsHarOpenResult = (0, _validatorPrimitives.tObject)({
      harId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.LocalUtilsHarLookupParams = (0, _validatorPrimitives.tObject)({
      harId: _validatorPrimitives.tString,
      url: _validatorPrimitives.tString,
      method: _validatorPrimitives.tString,
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue")),
      postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      isNavigationRequest: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.LocalUtilsHarLookupResult = (0, _validatorPrimitives.tObject)({
      action: (0, _validatorPrimitives.tEnum)(["error", "redirect", "fulfill", "noentry"]),
      message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      redirectURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
    });
    _validatorPrimitives.scheme.LocalUtilsHarCloseParams = (0, _validatorPrimitives.tObject)({
      harId: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.LocalUtilsHarCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.LocalUtilsHarUnzipParams = (0, _validatorPrimitives.tObject)({
      zipFile: _validatorPrimitives.tString,
      harFile: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.LocalUtilsHarUnzipResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.LocalUtilsConnectParams = (0, _validatorPrimitives.tObject)({
      wsEndpoint: _validatorPrimitives.tString,
      headers: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
      exposeNetwork: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      socksProxyRedirectPortForTest: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.LocalUtilsConnectResult = (0, _validatorPrimitives.tObject)({
      pipe: (0, _validatorPrimitives.tChannel)(["JsonPipe"]),
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.LocalUtilsTracingStartedParams = (0, _validatorPrimitives.tObject)({
      tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      traceName: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.LocalUtilsTracingStartedResult = (0, _validatorPrimitives.tObject)({
      stacksId: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.LocalUtilsAddStackToTracingNoReplyParams = (0, _validatorPrimitives.tObject)({
      callData: (0, _validatorPrimitives.tType)("ClientSideCallMetadata")
    });
    _validatorPrimitives.scheme.LocalUtilsAddStackToTracingNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.LocalUtilsTraceDiscardedParams = (0, _validatorPrimitives.tObject)({
      stacksId: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.LocalUtilsTraceDiscardedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RootInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RootInitializeParams = (0, _validatorPrimitives.tObject)({
      sdkLanguage: (0, _validatorPrimitives.tEnum)(["javascript", "python", "java", "csharp"])
    });
    _validatorPrimitives.scheme.RootInitializeResult = (0, _validatorPrimitives.tObject)({
      playwright: (0, _validatorPrimitives.tChannel)(["Playwright"])
    });
    _validatorPrimitives.scheme.PlaywrightInitializer = (0, _validatorPrimitives.tObject)({
      chromium: (0, _validatorPrimitives.tChannel)(["BrowserType"]),
      firefox: (0, _validatorPrimitives.tChannel)(["BrowserType"]),
      webkit: (0, _validatorPrimitives.tChannel)(["BrowserType"]),
      android: (0, _validatorPrimitives.tChannel)(["Android"]),
      electron: (0, _validatorPrimitives.tChannel)(["Electron"]),
      utils: (0, _validatorPrimitives.tChannel)(["LocalUtils"]),
      deviceDescriptors: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        descriptor: (0, _validatorPrimitives.tObject)({
          userAgent: _validatorPrimitives.tString,
          viewport: (0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }),
          screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          })),
          deviceScaleFactor: _validatorPrimitives.tNumber,
          isMobile: _validatorPrimitives.tBoolean,
          hasTouch: _validatorPrimitives.tBoolean,
          defaultBrowserType: (0, _validatorPrimitives.tEnum)(["chromium", "firefox", "webkit"])
        })
      })),
      selectors: (0, _validatorPrimitives.tChannel)(["Selectors"]),
      preLaunchedBrowser: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Browser"])),
      preConnectedAndroidDevice: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["AndroidDevice"])),
      socksSupport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["SocksSupport"]))
    });
    _validatorPrimitives.scheme.PlaywrightNewRequestParams = (0, _validatorPrimitives.tObject)({
      baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        server: _validatorPrimitives.tString,
        bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NetworkCookie")),
        origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("OriginStorage"))
      })),
      tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.PlaywrightNewRequestResult = (0, _validatorPrimitives.tObject)({
      request: (0, _validatorPrimitives.tChannel)(["APIRequestContext"])
    });
    _validatorPrimitives.scheme.RecorderSource = (0, _validatorPrimitives.tObject)({
      isRecorded: _validatorPrimitives.tBoolean,
      id: _validatorPrimitives.tString,
      label: _validatorPrimitives.tString,
      text: _validatorPrimitives.tString,
      language: _validatorPrimitives.tString,
      highlight: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        line: _validatorPrimitives.tNumber,
        type: _validatorPrimitives.tString
      })),
      revealLine: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      group: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.DebugControllerInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerInspectRequestedEvent = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      locator: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.DebugControllerStateChangedEvent = (0, _validatorPrimitives.tObject)({
      pageCount: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.DebugControllerSourceChangedEvent = (0, _validatorPrimitives.tObject)({
      text: _validatorPrimitives.tString,
      header: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      footer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      actions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
    });
    _validatorPrimitives.scheme.DebugControllerPausedEvent = (0, _validatorPrimitives.tObject)({
      paused: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.DebugControllerBrowsersChangedEvent = (0, _validatorPrimitives.tObject)({
      browsers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        contexts: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          pages: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
        }))
      }))
    });
    _validatorPrimitives.scheme.DebugControllerInitializeParams = (0, _validatorPrimitives.tObject)({
      codegenId: _validatorPrimitives.tString,
      sdkLanguage: (0, _validatorPrimitives.tEnum)(["javascript", "python", "java", "csharp"])
    });
    _validatorPrimitives.scheme.DebugControllerInitializeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerSetReportStateChangedParams = (0, _validatorPrimitives.tObject)({
      enabled: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.DebugControllerSetReportStateChangedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerResetForReuseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerResetForReuseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerNavigateParams = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.DebugControllerNavigateResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerSetRecorderModeParams = (0, _validatorPrimitives.tObject)({
      mode: (0, _validatorPrimitives.tEnum)(["inspecting", "recording", "none"]),
      testIdAttributeName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.DebugControllerSetRecorderModeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerHighlightParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.DebugControllerHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerHideHighlightParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerHideHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerResumeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerResumeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerKillParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerKillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerCloseAllBrowsersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DebugControllerCloseAllBrowsersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SocksSupportInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SocksSupportSocksRequestedEvent = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString,
      host: _validatorPrimitives.tString,
      port: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.SocksSupportSocksDataEvent = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString,
      data: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.SocksSupportSocksClosedEvent = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.SocksSupportSocksConnectedParams = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString,
      host: _validatorPrimitives.tString,
      port: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.SocksSupportSocksConnectedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SocksSupportSocksFailedParams = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString,
      errorCode: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.SocksSupportSocksFailedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SocksSupportSocksDataParams = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString,
      data: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.SocksSupportSocksDataResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SocksSupportSocksErrorParams = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString,
      error: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.SocksSupportSocksErrorResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SocksSupportSocksEndParams = (0, _validatorPrimitives.tObject)({
      uid: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.SocksSupportSocksEndResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SelectorsInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SelectorsRegisterParams = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      source: _validatorPrimitives.tString,
      contentScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.SelectorsRegisterResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.SelectorsSetTestIdAttributeNameParams = (0, _validatorPrimitives.tObject)({
      testIdAttributeName: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.SelectorsSetTestIdAttributeNameResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserTypeInitializer = (0, _validatorPrimitives.tObject)({
      executablePath: _validatorPrimitives.tString,
      name: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.BrowserTypeLaunchParams = (0, _validatorPrimitives.tObject)({
      channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        server: _validatorPrimitives.tString,
        bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      firefoxUserPrefs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
      slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.BrowserTypeLaunchResult = (0, _validatorPrimitives.tObject)({
      browser: (0, _validatorPrimitives.tChannel)(["Browser"])
    });
    _validatorPrimitives.scheme.BrowserTypeLaunchPersistentContextParams = (0, _validatorPrimitives.tObject)({
      channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        server: _validatorPrimitives.tString,
        bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        longitude: _validatorPrimitives.tNumber,
        latitude: _validatorPrimitives.tNumber,
        accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "no-override"])),
      reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "no-override"])),
      forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "no-override"])),
      acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        dir: _validatorPrimitives.tString,
        size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        }))
      })),
      recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("RecordHarOptions")),
      strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["allow", "block"])),
      userDataDir: _validatorPrimitives.tString,
      slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.BrowserTypeLaunchPersistentContextResult = (0, _validatorPrimitives.tObject)({
      context: (0, _validatorPrimitives.tChannel)(["BrowserContext"])
    });
    _validatorPrimitives.scheme.BrowserTypeConnectOverCDPParams = (0, _validatorPrimitives.tObject)({
      endpointURL: _validatorPrimitives.tString,
      headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.BrowserTypeConnectOverCDPResult = (0, _validatorPrimitives.tObject)({
      browser: (0, _validatorPrimitives.tChannel)(["Browser"]),
      defaultContext: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["BrowserContext"]))
    });
    _validatorPrimitives.scheme.BrowserInitializer = (0, _validatorPrimitives.tObject)({
      version: _validatorPrimitives.tString,
      name: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.BrowserCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserKillForTestsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserKillForTestsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserDefaultUserAgentForTestParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserDefaultUserAgentForTestResult = (0, _validatorPrimitives.tObject)({
      userAgent: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.BrowserNewContextParams = (0, _validatorPrimitives.tObject)({
      noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        longitude: _validatorPrimitives.tNumber,
        latitude: _validatorPrimitives.tNumber,
        accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "no-override"])),
      reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "no-override"])),
      forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "no-override"])),
      acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        dir: _validatorPrimitives.tString,
        size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        }))
      })),
      recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("RecordHarOptions")),
      strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["allow", "block"])),
      proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        server: _validatorPrimitives.tString,
        bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("SetNetworkCookie"))),
        origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("OriginStorage")))
      }))
    });
    _validatorPrimitives.scheme.BrowserNewContextResult = (0, _validatorPrimitives.tObject)({
      context: (0, _validatorPrimitives.tChannel)(["BrowserContext"])
    });
    _validatorPrimitives.scheme.BrowserNewContextForReuseParams = (0, _validatorPrimitives.tObject)({
      noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        longitude: _validatorPrimitives.tNumber,
        latitude: _validatorPrimitives.tNumber,
        accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "no-override"])),
      reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "no-override"])),
      forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "no-override"])),
      acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        dir: _validatorPrimitives.tString,
        size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        }))
      })),
      recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("RecordHarOptions")),
      strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["allow", "block"])),
      proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        server: _validatorPrimitives.tString,
        bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("SetNetworkCookie"))),
        origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("OriginStorage")))
      }))
    });
    _validatorPrimitives.scheme.BrowserNewContextForReuseResult = (0, _validatorPrimitives.tObject)({
      context: (0, _validatorPrimitives.tChannel)(["BrowserContext"])
    });
    _validatorPrimitives.scheme.BrowserNewBrowserCDPSessionParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserNewBrowserCDPSessionResult = (0, _validatorPrimitives.tObject)({
      session: (0, _validatorPrimitives.tChannel)(["CDPSession"])
    });
    _validatorPrimitives.scheme.BrowserStartTracingParams = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"])),
      path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      categories: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
    });
    _validatorPrimitives.scheme.BrowserStartTracingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserStopTracingParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserStopTracingResult = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.EventTargetInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.EventTargetWaitForEventInfoParams = (0, _validatorPrimitives.tObject)({
      info: (0, _validatorPrimitives.tObject)({
        waitId: _validatorPrimitives.tString,
        phase: (0, _validatorPrimitives.tEnum)(["before", "after", "log"]),
        event: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })
    });
    _validatorPrimitives.scheme.BrowserContextWaitForEventInfoParams = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoParams");
    _validatorPrimitives.scheme.PageWaitForEventInfoParams = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoParams");
    _validatorPrimitives.scheme.WebSocketWaitForEventInfoParams = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoParams");
    _validatorPrimitives.scheme.ElectronApplicationWaitForEventInfoParams = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoParams");
    _validatorPrimitives.scheme.AndroidDeviceWaitForEventInfoParams = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoParams");
    _validatorPrimitives.scheme.EventTargetWaitForEventInfoResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextWaitForEventInfoResult = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoResult");
    _validatorPrimitives.scheme.PageWaitForEventInfoResult = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoResult");
    _validatorPrimitives.scheme.WebSocketWaitForEventInfoResult = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoResult");
    _validatorPrimitives.scheme.ElectronApplicationWaitForEventInfoResult = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoResult");
    _validatorPrimitives.scheme.AndroidDeviceWaitForEventInfoResult = (0, _validatorPrimitives.tType)("EventTargetWaitForEventInfoResult");
    _validatorPrimitives.scheme.BrowserContextInitializer = (0, _validatorPrimitives.tObject)({
      isChromium: _validatorPrimitives.tBoolean,
      requestContext: (0, _validatorPrimitives.tChannel)(["APIRequestContext"]),
      tracing: (0, _validatorPrimitives.tChannel)(["Tracing"])
    });
    _validatorPrimitives.scheme.BrowserContextBindingCallEvent = (0, _validatorPrimitives.tObject)({
      binding: (0, _validatorPrimitives.tChannel)(["BindingCall"])
    });
    _validatorPrimitives.scheme.BrowserContextConsoleEvent = (0, _validatorPrimitives.tObject)({
      message: (0, _validatorPrimitives.tChannel)(["ConsoleMessage"])
    });
    _validatorPrimitives.scheme.BrowserContextCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextDialogEvent = (0, _validatorPrimitives.tObject)({
      dialog: (0, _validatorPrimitives.tChannel)(["Dialog"])
    });
    _validatorPrimitives.scheme.BrowserContextPageEvent = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tChannel)(["Page"])
    });
    _validatorPrimitives.scheme.BrowserContextRouteEvent = (0, _validatorPrimitives.tObject)({
      route: (0, _validatorPrimitives.tChannel)(["Route"])
    });
    _validatorPrimitives.scheme.BrowserContextVideoEvent = (0, _validatorPrimitives.tObject)({
      artifact: (0, _validatorPrimitives.tChannel)(["Artifact"])
    });
    _validatorPrimitives.scheme.BrowserContextBackgroundPageEvent = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tChannel)(["Page"])
    });
    _validatorPrimitives.scheme.BrowserContextServiceWorkerEvent = (0, _validatorPrimitives.tObject)({
      worker: (0, _validatorPrimitives.tChannel)(["Worker"])
    });
    _validatorPrimitives.scheme.BrowserContextRequestEvent = (0, _validatorPrimitives.tObject)({
      request: (0, _validatorPrimitives.tChannel)(["Request"]),
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"]))
    });
    _validatorPrimitives.scheme.BrowserContextRequestFailedEvent = (0, _validatorPrimitives.tObject)({
      request: (0, _validatorPrimitives.tChannel)(["Request"]),
      failureText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      responseEndTiming: _validatorPrimitives.tNumber,
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"]))
    });
    _validatorPrimitives.scheme.BrowserContextRequestFinishedEvent = (0, _validatorPrimitives.tObject)({
      request: (0, _validatorPrimitives.tChannel)(["Request"]),
      response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Response"])),
      responseEndTiming: _validatorPrimitives.tNumber,
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"]))
    });
    _validatorPrimitives.scheme.BrowserContextResponseEvent = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tChannel)(["Response"]),
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"]))
    });
    _validatorPrimitives.scheme.BrowserContextAddCookiesParams = (0, _validatorPrimitives.tObject)({
      cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("SetNetworkCookie"))
    });
    _validatorPrimitives.scheme.BrowserContextAddCookiesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextAddInitScriptParams = (0, _validatorPrimitives.tObject)({
      source: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.BrowserContextAddInitScriptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextClearCookiesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextClearCookiesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextClearPermissionsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextClearPermissionsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextCookiesParams = (0, _validatorPrimitives.tObject)({
      urls: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.BrowserContextCookiesResult = (0, _validatorPrimitives.tObject)({
      cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NetworkCookie"))
    });
    _validatorPrimitives.scheme.BrowserContextExposeBindingParams = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.BrowserContextExposeBindingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextGrantPermissionsParams = (0, _validatorPrimitives.tObject)({
      permissions: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString),
      origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.BrowserContextGrantPermissionsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextNewPageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextNewPageResult = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tChannel)(["Page"])
    });
    _validatorPrimitives.scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.BrowserContextSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.BrowserContextSetExtraHTTPHeadersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextSetGeolocationParams = (0, _validatorPrimitives.tObject)({
      geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        longitude: _validatorPrimitives.tNumber,
        latitude: _validatorPrimitives.tNumber,
        accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      }))
    });
    _validatorPrimitives.scheme.BrowserContextSetGeolocationResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextSetHTTPCredentialsParams = (0, _validatorPrimitives.tObject)({
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      }))
    });
    _validatorPrimitives.scheme.BrowserContextSetHTTPCredentialsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextSetNetworkInterceptionPatternsParams = (0, _validatorPrimitives.tObject)({
      patterns: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        glob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      }))
    });
    _validatorPrimitives.scheme.BrowserContextSetNetworkInterceptionPatternsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextSetOfflineParams = (0, _validatorPrimitives.tObject)({
      offline: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.BrowserContextSetOfflineResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextStorageStateResult = (0, _validatorPrimitives.tObject)({
      cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NetworkCookie")),
      origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("OriginStorage"))
    });
    _validatorPrimitives.scheme.BrowserContextPauseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextPauseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextRecorderSupplementEnableParams = (0, _validatorPrimitives.tObject)({
      language: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      mode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["inspecting", "recording"])),
      pauseOnNextStatement: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      testIdAttributeName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      launchOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
      contextOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
      device: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      saveStorage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      outputFile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      omitCallTracking: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.BrowserContextRecorderSupplementEnableResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BrowserContextNewCDPSessionParams = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"])),
      frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Frame"]))
    });
    _validatorPrimitives.scheme.BrowserContextNewCDPSessionResult = (0, _validatorPrimitives.tObject)({
      session: (0, _validatorPrimitives.tChannel)(["CDPSession"])
    });
    _validatorPrimitives.scheme.BrowserContextHarStartParams = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"])),
      options: (0, _validatorPrimitives.tType)("RecordHarOptions")
    });
    _validatorPrimitives.scheme.BrowserContextHarStartResult = (0, _validatorPrimitives.tObject)({
      harId: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.BrowserContextHarExportParams = (0, _validatorPrimitives.tObject)({
      harId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.BrowserContextHarExportResult = (0, _validatorPrimitives.tObject)({
      artifact: (0, _validatorPrimitives.tChannel)(["Artifact"])
    });
    _validatorPrimitives.scheme.BrowserContextCreateTempFileParams = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.BrowserContextCreateTempFileResult = (0, _validatorPrimitives.tObject)({
      writableStream: (0, _validatorPrimitives.tChannel)(["WritableStream"])
    });
    _validatorPrimitives.scheme.BrowserContextUpdateSubscriptionParams = (0, _validatorPrimitives.tObject)({
      event: (0, _validatorPrimitives.tEnum)(["console", "dialog", "request", "response", "requestFinished", "requestFailed"]),
      enabled: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.BrowserContextUpdateSubscriptionResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageInitializer = (0, _validatorPrimitives.tObject)({
      mainFrame: (0, _validatorPrimitives.tChannel)(["Frame"]),
      viewportSize: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      isClosed: _validatorPrimitives.tBoolean,
      opener: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"]))
    });
    _validatorPrimitives.scheme.PageBindingCallEvent = (0, _validatorPrimitives.tObject)({
      binding: (0, _validatorPrimitives.tChannel)(["BindingCall"])
    });
    _validatorPrimitives.scheme.PageCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageCrashEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageDownloadEvent = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString,
      suggestedFilename: _validatorPrimitives.tString,
      artifact: (0, _validatorPrimitives.tChannel)(["Artifact"])
    });
    _validatorPrimitives.scheme.PageFileChooserEvent = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tChannel)(["ElementHandle"]),
      isMultiple: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.PageFrameAttachedEvent = (0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tChannel)(["Frame"])
    });
    _validatorPrimitives.scheme.PageFrameDetachedEvent = (0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tChannel)(["Frame"])
    });
    _validatorPrimitives.scheme.PagePageErrorEvent = (0, _validatorPrimitives.tObject)({
      error: (0, _validatorPrimitives.tType)("SerializedError")
    });
    _validatorPrimitives.scheme.PageRouteEvent = (0, _validatorPrimitives.tObject)({
      route: (0, _validatorPrimitives.tChannel)(["Route"])
    });
    _validatorPrimitives.scheme.PageVideoEvent = (0, _validatorPrimitives.tObject)({
      artifact: (0, _validatorPrimitives.tChannel)(["Artifact"])
    });
    _validatorPrimitives.scheme.PageWebSocketEvent = (0, _validatorPrimitives.tObject)({
      webSocket: (0, _validatorPrimitives.tChannel)(["WebSocket"])
    });
    _validatorPrimitives.scheme.PageWorkerEvent = (0, _validatorPrimitives.tObject)({
      worker: (0, _validatorPrimitives.tChannel)(["Worker"])
    });
    _validatorPrimitives.scheme.PageSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageSetDefaultNavigationTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageAddInitScriptParams = (0, _validatorPrimitives.tObject)({
      source: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.PageAddInitScriptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageCloseParams = (0, _validatorPrimitives.tObject)({
      runBeforeUnload: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.PageCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageEmulateMediaParams = (0, _validatorPrimitives.tObject)({
      media: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["screen", "print", "no-override"])),
      colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "no-override"])),
      reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "no-override"])),
      forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "no-override"]))
    });
    _validatorPrimitives.scheme.PageEmulateMediaResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageExposeBindingParams = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString,
      needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.PageExposeBindingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageGoBackParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent"))
    });
    _validatorPrimitives.scheme.PageGoBackResult = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Response"]))
    });
    _validatorPrimitives.scheme.PageGoForwardParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent"))
    });
    _validatorPrimitives.scheme.PageGoForwardResult = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Response"]))
    });
    _validatorPrimitives.scheme.PageReloadParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent"))
    });
    _validatorPrimitives.scheme.PageReloadResult = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Response"]))
    });
    _validatorPrimitives.scheme.PageExpectScreenshotParams = (0, _validatorPrimitives.tObject)({
      expected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      isNot: _validatorPrimitives.tBoolean,
      locator: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        frame: (0, _validatorPrimitives.tChannel)(["Frame"]),
        selector: _validatorPrimitives.tString
      })),
      comparatorOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        comparator: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        maxDiffPixels: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        maxDiffPixelRatio: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        threshold: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      screenshotOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clip: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Rect")),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["hide", "initial"])),
        animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["disabled", "allow"])),
        scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["css", "device"])),
        mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          frame: (0, _validatorPrimitives.tChannel)(["Frame"]),
          selector: _validatorPrimitives.tString
        }))),
        maskColor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      }))
    });
    _validatorPrimitives.scheme.PageExpectScreenshotResult = (0, _validatorPrimitives.tObject)({
      diff: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      errorMessage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      actual: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      previous: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      log: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
    });
    _validatorPrimitives.scheme.PageScreenshotParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
      quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      clip: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Rect")),
      omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["hide", "initial"])),
      animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["disabled", "allow"])),
      scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["css", "device"])),
      mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        frame: (0, _validatorPrimitives.tChannel)(["Frame"]),
        selector: _validatorPrimitives.tString
      }))),
      maskColor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.PageScreenshotResult = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.PageSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.PageSetExtraHTTPHeadersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageSetNetworkInterceptionPatternsParams = (0, _validatorPrimitives.tObject)({
      patterns: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        glob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      }))
    });
    _validatorPrimitives.scheme.PageSetNetworkInterceptionPatternsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageSetViewportSizeParams = (0, _validatorPrimitives.tObject)({
      viewportSize: (0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })
    });
    _validatorPrimitives.scheme.PageSetViewportSizeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageKeyboardDownParams = (0, _validatorPrimitives.tObject)({
      key: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.PageKeyboardDownResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageKeyboardUpParams = (0, _validatorPrimitives.tObject)({
      key: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.PageKeyboardUpResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageKeyboardInsertTextParams = (0, _validatorPrimitives.tObject)({
      text: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.PageKeyboardInsertTextResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageKeyboardTypeParams = (0, _validatorPrimitives.tObject)({
      text: _validatorPrimitives.tString,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageKeyboardTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageKeyboardPressParams = (0, _validatorPrimitives.tObject)({
      key: _validatorPrimitives.tString,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageKeyboardPressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageMouseMoveParams = (0, _validatorPrimitives.tObject)({
      x: _validatorPrimitives.tNumber,
      y: _validatorPrimitives.tNumber,
      steps: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageMouseMoveResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageMouseDownParams = (0, _validatorPrimitives.tObject)({
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageMouseDownResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageMouseUpParams = (0, _validatorPrimitives.tObject)({
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageMouseUpResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageMouseClickParams = (0, _validatorPrimitives.tObject)({
      x: _validatorPrimitives.tNumber,
      y: _validatorPrimitives.tNumber,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.PageMouseClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageMouseWheelParams = (0, _validatorPrimitives.tObject)({
      deltaX: _validatorPrimitives.tNumber,
      deltaY: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.PageMouseWheelResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageTouchscreenTapParams = (0, _validatorPrimitives.tObject)({
      x: _validatorPrimitives.tNumber,
      y: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.PageTouchscreenTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageAccessibilitySnapshotParams = (0, _validatorPrimitives.tObject)({
      interestingOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      root: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.PageAccessibilitySnapshotResult = (0, _validatorPrimitives.tObject)({
      rootAXNode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("AXNode"))
    });
    _validatorPrimitives.scheme.PagePdfParams = (0, _validatorPrimitives.tObject)({
      scale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      displayHeaderFooter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      headerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      footerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      printBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      landscape: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      pageRanges: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      format: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      width: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      height: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      preferCSSPageSize: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      margin: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        top: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        bottom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        left: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        right: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      }))
    });
    _validatorPrimitives.scheme.PagePdfResult = (0, _validatorPrimitives.tObject)({
      pdf: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.PageStartJSCoverageParams = (0, _validatorPrimitives.tObject)({
      resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      reportAnonymousScripts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.PageStartJSCoverageResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageStopJSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageStopJSCoverageResult = (0, _validatorPrimitives.tObject)({
      entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        scriptId: _validatorPrimitives.tString,
        source: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        functions: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          functionName: _validatorPrimitives.tString,
          isBlockCoverage: _validatorPrimitives.tBoolean,
          ranges: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
            startOffset: _validatorPrimitives.tNumber,
            endOffset: _validatorPrimitives.tNumber,
            count: _validatorPrimitives.tNumber
          }))
        }))
      }))
    });
    _validatorPrimitives.scheme.PageStartCSSCoverageParams = (0, _validatorPrimitives.tObject)({
      resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.PageStartCSSCoverageResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageStopCSSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageStopCSSCoverageResult = (0, _validatorPrimitives.tObject)({
      entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        ranges: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          start: _validatorPrimitives.tNumber,
          end: _validatorPrimitives.tNumber
        }))
      }))
    });
    _validatorPrimitives.scheme.PageBringToFrontParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageBringToFrontResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.PageUpdateSubscriptionParams = (0, _validatorPrimitives.tObject)({
      event: (0, _validatorPrimitives.tEnum)(["console", "dialog", "fileChooser", "request", "response", "requestFinished", "requestFailed"]),
      enabled: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.PageUpdateSubscriptionResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameInitializer = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString,
      name: _validatorPrimitives.tString,
      parentFrame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Frame"])),
      loadStates: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("LifecycleEvent"))
    });
    _validatorPrimitives.scheme.FrameLoadstateEvent = (0, _validatorPrimitives.tObject)({
      add: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent")),
      remove: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent"))
    });
    _validatorPrimitives.scheme.FrameNavigatedEvent = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString,
      name: _validatorPrimitives.tString,
      newDocument: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        request: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Request"]))
      })),
      error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.FrameEvalOnSelectorResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.FrameEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.FrameEvalOnSelectorAllResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.FrameAddScriptTagParams = (0, _validatorPrimitives.tObject)({
      url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      type: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameAddScriptTagResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tChannel)(["ElementHandle"])
    });
    _validatorPrimitives.scheme.FrameAddStyleTagParams = (0, _validatorPrimitives.tObject)({
      url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameAddStyleTagResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tChannel)(["ElementHandle"])
    });
    _validatorPrimitives.scheme.FrameBlurParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameBlurResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameCheckParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameCheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameClickParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameContentResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameDragAndDropParams = (0, _validatorPrimitives.tObject)({
      source: _validatorPrimitives.tString,
      target: _validatorPrimitives.tString,
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      sourcePosition: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      targetPosition: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameDragAndDropResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameDblclickParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameDblclickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameDispatchEventParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      type: _validatorPrimitives.tString,
      eventInit: (0, _validatorPrimitives.tType)("SerializedArgument"),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameDispatchEventResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      exposeUtilityScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.FrameEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.FrameEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.FrameEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.FrameFillParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      value: _validatorPrimitives.tString,
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameFocusParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameFocusResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameFrameElementParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameFrameElementResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tChannel)(["ElementHandle"])
    });
    _validatorPrimitives.scheme.FrameHighlightParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameGetAttributeParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      name: _validatorPrimitives.tString,
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameGetAttributeResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameGotoParams = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString,
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent")),
      referer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameGotoResult = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Response"]))
    });
    _validatorPrimitives.scheme.FrameHoverParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameHoverResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameInnerHTMLParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameInnerHTMLResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameInnerTextParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameInnerTextResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameInputValueParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameInputValueResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameIsCheckedParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameIsCheckedResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.FrameIsDisabledParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameIsDisabledResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.FrameIsEnabledParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameIsEnabledResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.FrameIsHiddenParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameIsHiddenResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.FrameIsVisibleParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameIsVisibleResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.FrameIsEditableParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameIsEditableResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.FramePressParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      key: _validatorPrimitives.tString,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FramePressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameQuerySelectorParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameQuerySelectorResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.FrameQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameQuerySelectorAllResult = (0, _validatorPrimitives.tObject)({
      elements: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.FrameQueryCountParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameQueryCountResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.FrameSelectOptionParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))),
      options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        valueOrLabel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      }))),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameSelectOptionResult = (0, _validatorPrimitives.tObject)({
      values: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameSetContentParams = (0, _validatorPrimitives.tObject)({
      html: _validatorPrimitives.tString,
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("LifecycleEvent"))
    });
    _validatorPrimitives.scheme.FrameSetContentResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameSetInputFilesParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        buffer: _validatorPrimitives.tBinary
      })),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameSetInputFilesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["WritableStream"]))),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameSetInputFilePathsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameTapParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameTextContentParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameTextContentResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.FrameTitleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameTitleResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.FrameTypeParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      text: _validatorPrimitives.tString,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameUncheckParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameUncheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameWaitForTimeoutParams = (0, _validatorPrimitives.tObject)({
      timeout: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.FrameWaitForTimeoutResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.FrameWaitForFunctionParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument"),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      pollingInterval: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameWaitForFunctionResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.FrameWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"])),
      omitReturnValue: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.FrameWaitForSelectorResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.FrameExpectParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      expression: _validatorPrimitives.tString,
      expressionArg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
      expectedText: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("ExpectedTextValue"))),
      expectedNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      expectedValue: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("SerializedArgument")),
      useInnerText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      isNot: _validatorPrimitives.tBoolean,
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.FrameExpectResult = (0, _validatorPrimitives.tObject)({
      matches: _validatorPrimitives.tBoolean,
      received: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("SerializedValue")),
      timedOut: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      log: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
    });
    _validatorPrimitives.scheme.WorkerInitializer = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.WorkerCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.WorkerEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.WorkerEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.WorkerEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.WorkerEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.JSHandleInitializer = (0, _validatorPrimitives.tObject)({
      preview: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.JSHandlePreviewUpdatedEvent = (0, _validatorPrimitives.tObject)({
      preview: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandlePreviewUpdatedEvent = (0, _validatorPrimitives.tType)("JSHandlePreviewUpdatedEvent");
    _validatorPrimitives.scheme.JSHandleDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleDisposeParams = (0, _validatorPrimitives.tType)("JSHandleDisposeParams");
    _validatorPrimitives.scheme.JSHandleDisposeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleDisposeResult = (0, _validatorPrimitives.tType)("JSHandleDisposeResult");
    _validatorPrimitives.scheme.JSHandleEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElementHandleEvaluateExpressionParams = (0, _validatorPrimitives.tType)("JSHandleEvaluateExpressionParams");
    _validatorPrimitives.scheme.JSHandleEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.ElementHandleEvaluateExpressionResult = (0, _validatorPrimitives.tType)("JSHandleEvaluateExpressionResult");
    _validatorPrimitives.scheme.JSHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElementHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tType)("JSHandleEvaluateExpressionHandleParams");
    _validatorPrimitives.scheme.JSHandleEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.ElementHandleEvaluateExpressionHandleResult = (0, _validatorPrimitives.tType)("JSHandleEvaluateExpressionHandleResult");
    _validatorPrimitives.scheme.JSHandleGetPropertyListParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleGetPropertyListParams = (0, _validatorPrimitives.tType)("JSHandleGetPropertyListParams");
    _validatorPrimitives.scheme.JSHandleGetPropertyListResult = (0, _validatorPrimitives.tObject)({
      properties: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
      }))
    });
    _validatorPrimitives.scheme.ElementHandleGetPropertyListResult = (0, _validatorPrimitives.tType)("JSHandleGetPropertyListResult");
    _validatorPrimitives.scheme.JSHandleGetPropertyParams = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleGetPropertyParams = (0, _validatorPrimitives.tType)("JSHandleGetPropertyParams");
    _validatorPrimitives.scheme.JSHandleGetPropertyResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.ElementHandleGetPropertyResult = (0, _validatorPrimitives.tType)("JSHandleGetPropertyResult");
    _validatorPrimitives.scheme.JSHandleJsonValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleJsonValueParams = (0, _validatorPrimitives.tType)("JSHandleJsonValueParams");
    _validatorPrimitives.scheme.JSHandleJsonValueResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.ElementHandleJsonValueResult = (0, _validatorPrimitives.tType)("JSHandleJsonValueResult");
    _validatorPrimitives.scheme.JSHandleObjectCountParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleObjectCountParams = (0, _validatorPrimitives.tType)("JSHandleObjectCountParams");
    _validatorPrimitives.scheme.JSHandleObjectCountResult = (0, _validatorPrimitives.tObject)({
      count: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.ElementHandleObjectCountResult = (0, _validatorPrimitives.tType)("JSHandleObjectCountResult");
    _validatorPrimitives.scheme.ElementHandleInitializer = (0, _validatorPrimitives.tObject)({
      preview: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElementHandleEvalOnSelectorResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.ElementHandleEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElementHandleEvalOnSelectorAllResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.ElementHandleBoundingBoxParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleBoundingBoxResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Rect"))
    });
    _validatorPrimitives.scheme.ElementHandleCheckParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleCheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleClickParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleContentFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleContentFrameResult = (0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Frame"]))
    });
    _validatorPrimitives.scheme.ElementHandleDblclickParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleDblclickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleDispatchEventParams = (0, _validatorPrimitives.tObject)({
      type: _validatorPrimitives.tString,
      eventInit: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElementHandleDispatchEventResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleFillParams = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString,
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleFocusParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleFocusResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleGetAttributeParams = (0, _validatorPrimitives.tObject)({
      name: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleGetAttributeResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ElementHandleHoverParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleHoverResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleInnerHTMLParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleInnerHTMLResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleInnerTextParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleInnerTextResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleInputValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleInputValueResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleIsCheckedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleIsCheckedResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ElementHandleIsDisabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleIsDisabledResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ElementHandleIsEditableParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleIsEditableResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ElementHandleIsEnabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleIsEnabledResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ElementHandleIsHiddenParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleIsHiddenResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ElementHandleIsVisibleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleIsVisibleResult = (0, _validatorPrimitives.tObject)({
      value: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ElementHandleOwnerFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleOwnerFrameResult = (0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Frame"]))
    });
    _validatorPrimitives.scheme.ElementHandlePressParams = (0, _validatorPrimitives.tObject)({
      key: _validatorPrimitives.tString,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandlePressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleQuerySelectorParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleQuerySelectorResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.ElementHandleQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ElementHandleQuerySelectorAllResult = (0, _validatorPrimitives.tObject)({
      elements: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.ElementHandleScreenshotParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
      quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["hide", "initial"])),
      animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["disabled", "allow"])),
      scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["css", "device"])),
      mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        frame: (0, _validatorPrimitives.tChannel)(["Frame"]),
        selector: _validatorPrimitives.tString
      }))),
      maskColor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ElementHandleScreenshotResult = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.ElementHandleScrollIntoViewIfNeededParams = (0, _validatorPrimitives.tObject)({
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.ElementHandleScrollIntoViewIfNeededResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleSelectOptionParams = (0, _validatorPrimitives.tObject)({
      elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))),
      options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        valueOrLabel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      }))),
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleSelectOptionResult = (0, _validatorPrimitives.tObject)({
      values: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ElementHandleSelectTextParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.ElementHandleSelectTextResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleSetInputFilesParams = (0, _validatorPrimitives.tObject)({
      files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        buffer: _validatorPrimitives.tBinary
      })),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleSetInputFilesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({
      localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["WritableStream"]))),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleSetInputFilePathsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleTapParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleTextContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleTextContentResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ElementHandleTypeParams = (0, _validatorPrimitives.tObject)({
      text: _validatorPrimitives.tString,
      delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.ElementHandleTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleUncheckParams = (0, _validatorPrimitives.tObject)({
      force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("Point")),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.ElementHandleUncheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleWaitForElementStateParams = (0, _validatorPrimitives.tObject)({
      state: (0, _validatorPrimitives.tEnum)(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.ElementHandleWaitForElementStateResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElementHandleWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
      selector: _validatorPrimitives.tString,
      strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"]))
    });
    _validatorPrimitives.scheme.ElementHandleWaitForSelectorResult = (0, _validatorPrimitives.tObject)({
      element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["ElementHandle"]))
    });
    _validatorPrimitives.scheme.RequestInitializer = (0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Frame"])),
      serviceWorker: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Worker"])),
      url: _validatorPrimitives.tString,
      resourceType: _validatorPrimitives.tString,
      method: _validatorPrimitives.tString,
      postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue")),
      isNavigationRequest: _validatorPrimitives.tBoolean,
      redirectedFrom: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Request"]))
    });
    _validatorPrimitives.scheme.RequestResponseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RequestResponseResult = (0, _validatorPrimitives.tObject)({
      response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Response"]))
    });
    _validatorPrimitives.scheme.RequestRawRequestHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RequestRawRequestHeadersResult = (0, _validatorPrimitives.tObject)({
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.RouteInitializer = (0, _validatorPrimitives.tObject)({
      request: (0, _validatorPrimitives.tChannel)(["Request"])
    });
    _validatorPrimitives.scheme.RouteRedirectNavigationRequestParams = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.RouteRedirectNavigationRequestResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RouteAbortParams = (0, _validatorPrimitives.tObject)({
      errorCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      requestUrl: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.RouteAbortResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RouteContinueParams = (0, _validatorPrimitives.tObject)({
      url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
      requestUrl: _validatorPrimitives.tString,
      isFallback: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.RouteContinueResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.RouteFulfillParams = (0, _validatorPrimitives.tObject)({
      status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      isBase64: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      fetchResponseUid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      requestUrl: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.RouteFulfillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ResourceTiming = (0, _validatorPrimitives.tObject)({
      startTime: _validatorPrimitives.tNumber,
      domainLookupStart: _validatorPrimitives.tNumber,
      domainLookupEnd: _validatorPrimitives.tNumber,
      connectStart: _validatorPrimitives.tNumber,
      secureConnectionStart: _validatorPrimitives.tNumber,
      connectEnd: _validatorPrimitives.tNumber,
      requestStart: _validatorPrimitives.tNumber,
      responseStart: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.ResponseInitializer = (0, _validatorPrimitives.tObject)({
      request: (0, _validatorPrimitives.tChannel)(["Request"]),
      url: _validatorPrimitives.tString,
      status: _validatorPrimitives.tNumber,
      statusText: _validatorPrimitives.tString,
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue")),
      timing: (0, _validatorPrimitives.tType)("ResourceTiming"),
      fromServiceWorker: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.ResponseBodyParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ResponseBodyResult = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.ResponseSecurityDetailsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ResponseSecurityDetailsResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("SecurityDetails"))
    });
    _validatorPrimitives.scheme.ResponseServerAddrParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ResponseServerAddrResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("RemoteAddr"))
    });
    _validatorPrimitives.scheme.ResponseRawResponseHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ResponseRawResponseHeadersResult = (0, _validatorPrimitives.tObject)({
      headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))
    });
    _validatorPrimitives.scheme.ResponseSizesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ResponseSizesResult = (0, _validatorPrimitives.tObject)({
      sizes: (0, _validatorPrimitives.tType)("RequestSizes")
    });
    _validatorPrimitives.scheme.SecurityDetails = (0, _validatorPrimitives.tObject)({
      issuer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      protocol: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      subjectName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      validFrom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      validTo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.RequestSizes = (0, _validatorPrimitives.tObject)({
      requestBodySize: _validatorPrimitives.tNumber,
      requestHeadersSize: _validatorPrimitives.tNumber,
      responseBodySize: _validatorPrimitives.tNumber,
      responseHeadersSize: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.RemoteAddr = (0, _validatorPrimitives.tObject)({
      ipAddress: _validatorPrimitives.tString,
      port: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.WebSocketInitializer = (0, _validatorPrimitives.tObject)({
      url: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.WebSocketOpenEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.WebSocketFrameSentEvent = (0, _validatorPrimitives.tObject)({
      opcode: _validatorPrimitives.tNumber,
      data: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.WebSocketFrameReceivedEvent = (0, _validatorPrimitives.tObject)({
      opcode: _validatorPrimitives.tNumber,
      data: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.WebSocketSocketErrorEvent = (0, _validatorPrimitives.tObject)({
      error: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.WebSocketCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ConsoleMessageInitializer = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tChannel)(["Page"]),
      type: _validatorPrimitives.tString,
      text: _validatorPrimitives.tString,
      args: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])),
      location: (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        lineNumber: _validatorPrimitives.tNumber,
        columnNumber: _validatorPrimitives.tNumber
      })
    });
    _validatorPrimitives.scheme.BindingCallInitializer = (0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tChannel)(["Frame"]),
      name: _validatorPrimitives.tString,
      args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("SerializedValue"))),
      handle: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"]))
    });
    _validatorPrimitives.scheme.BindingCallRejectParams = (0, _validatorPrimitives.tObject)({
      error: (0, _validatorPrimitives.tType)("SerializedError")
    });
    _validatorPrimitives.scheme.BindingCallRejectResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.BindingCallResolveParams = (0, _validatorPrimitives.tObject)({
      result: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.BindingCallResolveResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DialogInitializer = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Page"])),
      type: _validatorPrimitives.tString,
      message: _validatorPrimitives.tString,
      defaultValue: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.DialogAcceptParams = (0, _validatorPrimitives.tObject)({
      promptText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.DialogAcceptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DialogDismissParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.DialogDismissResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.TracingInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.TracingTracingStartParams = (0, _validatorPrimitives.tObject)({
      name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      snapshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      sources: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.TracingTracingStartResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.TracingTracingStartChunkParams = (0, _validatorPrimitives.tObject)({
      name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      title: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.TracingTracingStartChunkResult = (0, _validatorPrimitives.tObject)({
      traceName: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.TracingTracingStopChunkParams = (0, _validatorPrimitives.tObject)({
      mode: (0, _validatorPrimitives.tEnum)(["archive", "discard", "entries"])
    });
    _validatorPrimitives.scheme.TracingTracingStopChunkResult = (0, _validatorPrimitives.tObject)({
      artifact: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Artifact"])),
      entries: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue")))
    });
    _validatorPrimitives.scheme.TracingTracingStopParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.TracingTracingStopResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactInitializer = (0, _validatorPrimitives.tObject)({
      absolutePath: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ArtifactPathAfterFinishedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactPathAfterFinishedResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ArtifactSaveAsParams = (0, _validatorPrimitives.tObject)({
      path: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.ArtifactSaveAsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactSaveAsStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactSaveAsStreamResult = (0, _validatorPrimitives.tObject)({
      stream: (0, _validatorPrimitives.tChannel)(["Stream"])
    });
    _validatorPrimitives.scheme.ArtifactFailureParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactFailureResult = (0, _validatorPrimitives.tObject)({
      error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ArtifactStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactStreamResult = (0, _validatorPrimitives.tObject)({
      stream: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(["Stream"]))
    });
    _validatorPrimitives.scheme.ArtifactCancelParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactCancelResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactDeleteParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ArtifactDeleteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.StreamInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.StreamReadParams = (0, _validatorPrimitives.tObject)({
      size: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.StreamReadResult = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.StreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.StreamCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.WritableStreamInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.WritableStreamWriteParams = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.WritableStreamWriteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.WritableStreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.WritableStreamCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.CDPSessionInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.CDPSessionEventEvent = (0, _validatorPrimitives.tObject)({
      method: _validatorPrimitives.tString,
      params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
    });
    _validatorPrimitives.scheme.CDPSessionSendParams = (0, _validatorPrimitives.tObject)({
      method: _validatorPrimitives.tString,
      params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
    });
    _validatorPrimitives.scheme.CDPSessionSendResult = (0, _validatorPrimitives.tObject)({
      result: _validatorPrimitives.tAny
    });
    _validatorPrimitives.scheme.CDPSessionDetachParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.CDPSessionDetachResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElectronInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElectronLaunchParams = (0, _validatorPrimitives.tObject)({
      executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      cwd: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "no-override"])),
      extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        longitude: _validatorPrimitives.tNumber,
        latitude: _validatorPrimitives.tNumber,
        accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("RecordHarOptions")),
      recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        dir: _validatorPrimitives.tString,
        size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        }))
      })),
      strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.ElectronLaunchResult = (0, _validatorPrimitives.tObject)({
      electronApplication: (0, _validatorPrimitives.tChannel)(["ElectronApplication"])
    });
    _validatorPrimitives.scheme.ElectronApplicationInitializer = (0, _validatorPrimitives.tObject)({
      context: (0, _validatorPrimitives.tChannel)(["BrowserContext"])
    });
    _validatorPrimitives.scheme.ElectronApplicationCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElectronApplicationBrowserWindowParams = (0, _validatorPrimitives.tObject)({
      page: (0, _validatorPrimitives.tChannel)(["Page"])
    });
    _validatorPrimitives.scheme.ElectronApplicationBrowserWindowResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
      value: (0, _validatorPrimitives.tType)("SerializedValue")
    });
    _validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
      expression: _validatorPrimitives.tString,
      isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      arg: (0, _validatorPrimitives.tType)("SerializedArgument")
    });
    _validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
      handle: (0, _validatorPrimitives.tChannel)(["ElementHandle", "JSHandle"])
    });
    _validatorPrimitives.scheme.ElectronApplicationCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.ElectronApplicationCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDevicesParams = (0, _validatorPrimitives.tObject)({
      host: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      port: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      omitDriverInstall: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
    });
    _validatorPrimitives.scheme.AndroidDevicesResult = (0, _validatorPrimitives.tObject)({
      devices: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(["AndroidDevice"]))
    });
    _validatorPrimitives.scheme.AndroidSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
      timeout: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.AndroidSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidSocketInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidSocketDataEvent = (0, _validatorPrimitives.tObject)({
      data: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.AndroidSocketCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidSocketWriteParams = (0, _validatorPrimitives.tObject)({
      data: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.AndroidSocketWriteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidSocketCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidSocketCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceInitializer = (0, _validatorPrimitives.tObject)({
      model: _validatorPrimitives.tString,
      serial: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceWebViewAddedEvent = (0, _validatorPrimitives.tObject)({
      webView: (0, _validatorPrimitives.tType)("AndroidWebView")
    });
    _validatorPrimitives.scheme.AndroidDeviceWebViewRemovedEvent = (0, _validatorPrimitives.tObject)({
      socketName: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceWaitParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["gone"])),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceWaitResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceFillParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      text: _validatorPrimitives.tString,
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceTapParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      duration: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceDragParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      dest: (0, _validatorPrimitives.tType)("Point"),
      speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceDragResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceFlingParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
      speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceFlingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceLongTapParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceLongTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDevicePinchCloseParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      percent: _validatorPrimitives.tNumber,
      speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDevicePinchCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDevicePinchOpenParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      percent: _validatorPrimitives.tNumber,
      speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDevicePinchOpenResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceScrollParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
      percent: _validatorPrimitives.tNumber,
      speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceScrollResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceSwipeParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
      direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
      percent: _validatorPrimitives.tNumber,
      speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDeviceSwipeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceInfoParams = (0, _validatorPrimitives.tObject)({
      selector: (0, _validatorPrimitives.tType)("AndroidSelector")
    });
    _validatorPrimitives.scheme.AndroidDeviceInfoResult = (0, _validatorPrimitives.tObject)({
      info: (0, _validatorPrimitives.tType)("AndroidElementInfo")
    });
    _validatorPrimitives.scheme.AndroidDeviceScreenshotParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceScreenshotResult = (0, _validatorPrimitives.tObject)({
      binary: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.AndroidDeviceInputTypeParams = (0, _validatorPrimitives.tObject)({
      text: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceInputTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceInputPressParams = (0, _validatorPrimitives.tObject)({
      key: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceInputPressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceInputTapParams = (0, _validatorPrimitives.tObject)({
      point: (0, _validatorPrimitives.tType)("Point")
    });
    _validatorPrimitives.scheme.AndroidDeviceInputTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceInputSwipeParams = (0, _validatorPrimitives.tObject)({
      segments: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("Point")),
      steps: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.AndroidDeviceInputSwipeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceInputDragParams = (0, _validatorPrimitives.tObject)({
      from: (0, _validatorPrimitives.tType)("Point"),
      to: (0, _validatorPrimitives.tType)("Point"),
      steps: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.AndroidDeviceInputDragResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceLaunchBrowserParams = (0, _validatorPrimitives.tObject)({
      noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        longitude: _validatorPrimitives.tNumber,
        latitude: _validatorPrimitives.tNumber,
        accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("NameValue"))),
      offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        username: _validatorPrimitives.tString,
        password: _validatorPrimitives.tString,
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      })),
      deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "no-override"])),
      reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "no-override"])),
      forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "no-override"])),
      acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        dir: _validatorPrimitives.tString,
        size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        }))
      })),
      recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("RecordHarOptions")),
      strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["allow", "block"])),
      pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
      proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        server: _validatorPrimitives.tString,
        bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      }))
    });
    _validatorPrimitives.scheme.AndroidDeviceLaunchBrowserResult = (0, _validatorPrimitives.tObject)({
      context: (0, _validatorPrimitives.tChannel)(["BrowserContext"])
    });
    _validatorPrimitives.scheme.AndroidDeviceOpenParams = (0, _validatorPrimitives.tObject)({
      command: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceOpenResult = (0, _validatorPrimitives.tObject)({
      socket: (0, _validatorPrimitives.tChannel)(["AndroidSocket"])
    });
    _validatorPrimitives.scheme.AndroidDeviceShellParams = (0, _validatorPrimitives.tObject)({
      command: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceShellResult = (0, _validatorPrimitives.tObject)({
      result: _validatorPrimitives.tBinary
    });
    _validatorPrimitives.scheme.AndroidDeviceInstallApkParams = (0, _validatorPrimitives.tObject)({
      file: _validatorPrimitives.tBinary,
      args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
    });
    _validatorPrimitives.scheme.AndroidDeviceInstallApkResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDevicePushParams = (0, _validatorPrimitives.tObject)({
      file: _validatorPrimitives.tBinary,
      path: _validatorPrimitives.tString,
      mode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
    });
    _validatorPrimitives.scheme.AndroidDevicePushResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
      timeout: _validatorPrimitives.tNumber
    });
    _validatorPrimitives.scheme.AndroidDeviceSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceConnectToWebViewParams = (0, _validatorPrimitives.tObject)({
      socketName: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidDeviceConnectToWebViewResult = (0, _validatorPrimitives.tObject)({
      context: (0, _validatorPrimitives.tChannel)(["BrowserContext"])
    });
    _validatorPrimitives.scheme.AndroidDeviceCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidDeviceCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.AndroidWebView = (0, _validatorPrimitives.tObject)({
      pid: _validatorPrimitives.tNumber,
      pkg: _validatorPrimitives.tString,
      socketName: _validatorPrimitives.tString
    });
    _validatorPrimitives.scheme.AndroidSelector = (0, _validatorPrimitives.tObject)({
      checkable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      checked: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      clazz: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      clickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      depth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
      desc: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      enabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      focusable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      hasChild: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        selector: (0, _validatorPrimitives.tType)("AndroidSelector")
      })),
      hasDescendant: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        selector: (0, _validatorPrimitives.tType)("AndroidSelector"),
        maxDepth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      })),
      longClickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      res: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
      scrollable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
      text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
    });
    _validatorPrimitives.scheme.AndroidElementInfo = (0, _validatorPrimitives.tObject)({
      children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)("AndroidElementInfo"))),
      clazz: _validatorPrimitives.tString,
      desc: _validatorPrimitives.tString,
      res: _validatorPrimitives.tString,
      pkg: _validatorPrimitives.tString,
      text: _validatorPrimitives.tString,
      bounds: (0, _validatorPrimitives.tType)("Rect"),
      checkable: _validatorPrimitives.tBoolean,
      checked: _validatorPrimitives.tBoolean,
      clickable: _validatorPrimitives.tBoolean,
      enabled: _validatorPrimitives.tBoolean,
      focusable: _validatorPrimitives.tBoolean,
      focused: _validatorPrimitives.tBoolean,
      longClickable: _validatorPrimitives.tBoolean,
      scrollable: _validatorPrimitives.tBoolean,
      selected: _validatorPrimitives.tBoolean
    });
    _validatorPrimitives.scheme.JsonPipeInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.JsonPipeMessageEvent = (0, _validatorPrimitives.tObject)({
      message: _validatorPrimitives.tAny
    });
    _validatorPrimitives.scheme.JsonPipeClosedEvent = (0, _validatorPrimitives.tObject)({
      error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)("SerializedError"))
    });
    _validatorPrimitives.scheme.JsonPipeSendParams = (0, _validatorPrimitives.tObject)({
      message: _validatorPrimitives.tAny
    });
    _validatorPrimitives.scheme.JsonPipeSendResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.JsonPipeCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
    _validatorPrimitives.scheme.JsonPipeCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
  }
});

// node_modules/playwright-core/lib/server/instrumentation.js
var require_instrumentation = __commonJS({
  "node_modules/playwright-core/lib/server/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SdkObject = void 0;
    exports2.createInstrumentation = createInstrumentation;
    exports2.kTestSdkObjects = void 0;
    exports2.serverSideCallMetadata = serverSideCallMetadata;
    var _events = require("events");
    var _utils = require_utils();
    var kTestSdkObjects = new WeakSet();
    exports2.kTestSdkObjects = kTestSdkObjects;
    var SdkObject = class extends _events.EventEmitter {
      constructor(parent, guidPrefix, guid) {
        super();
        this.guid = void 0;
        this.attribution = void 0;
        this.instrumentation = void 0;
        this.guid = guid || `${guidPrefix || ""}@${(0, _utils.createGuid)()}`;
        this.setMaxListeners(0);
        this.attribution = __spreadValues({}, parent.attribution);
        this.instrumentation = parent.instrumentation;
        if (process.env._PW_INTERNAL_COUNT_SDK_OBJECTS)
          kTestSdkObjects.add(this);
      }
    };
    exports2.SdkObject = SdkObject;
    function createInstrumentation() {
      const listeners = /* @__PURE__ */ new Map();
      return new Proxy({}, {
        get: (obj, prop) => {
          if (typeof prop !== "string")
            return obj[prop];
          if (prop === "addListener")
            return (listener, context) => listeners.set(listener, context);
          if (prop === "removeListener")
            return (listener) => listeners.delete(listener);
          if (!prop.startsWith("on"))
            return obj[prop];
          return (sdkObject, ...params) => __async(this, null, function* () {
            for (const [listener, context] of listeners) {
              var _prop, _ref;
              if (!context || sdkObject.attribution.context === context)
                yield (_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, sdkObject, ...params);
            }
          });
        }
      });
    }
    function serverSideCallMetadata() {
      return {
        id: "",
        startTime: 0,
        endTime: 0,
        wallTime: Date.now(),
        type: "Internal",
        method: "",
        params: {},
        log: [],
        isServerSide: true
      };
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/dispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dispatcherSymbol = exports2.RootDispatcher = exports2.DispatcherConnection = exports2.Dispatcher = void 0;
    exports2.existingDispatcher = existingDispatcher;
    var _events = require("events");
    var _serializers = require_serializers();
    var _validator = require_validator();
    var _utils = require_utils();
    var _errors = require_errors();
    var _instrumentation = require_instrumentation();
    var _stackTrace = require_stackTrace();
    var _eventsHelper = require_eventsHelper();
    var dispatcherSymbol = Symbol("dispatcher");
    exports2.dispatcherSymbol = dispatcherSymbol;
    var metadataValidator = (0, _validator.createMetadataValidator)();
    function existingDispatcher(object) {
      return object[dispatcherSymbol];
    }
    var Dispatcher = class extends _events.EventEmitter {
      constructor(parent, object, type, initializer) {
        super();
        this._connection = void 0;
        this._parent = void 0;
        this._dispatchers = /* @__PURE__ */ new Map();
        this._disposed = false;
        this._eventListeners = [];
        this._guid = void 0;
        this._type = void 0;
        this._object = void 0;
        this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
        this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
        const guid = object.guid;
        (0, _utils.assert)(!this._connection._dispatchers.has(guid));
        this._connection._dispatchers.set(guid, this);
        if (this._parent) {
          (0, _utils.assert)(!this._parent._dispatchers.has(guid));
          this._parent._dispatchers.set(guid, this);
        }
        this._type = type;
        this._guid = guid;
        this._object = object;
        object[dispatcherSymbol] = this;
        if (this._parent)
          this._connection.sendCreate(this._parent, type, guid, initializer, this._parent._object);
      }
      parentScope() {
        return this._parent;
      }
      addObjectListener(eventName, handler) {
        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._object, eventName, handler));
      }
      adopt(child) {
        const oldParent = child._parent;
        oldParent._dispatchers.delete(child._guid);
        this._dispatchers.set(child._guid, child);
        child._parent = this;
        this._connection.sendAdopt(this, child);
      }
      _dispatchEvent(method, params) {
        if (this._disposed) {
          if ((0, _utils.isUnderTest)())
            throw new Error(`${this._guid} is sending "${String(method)}" event after being disposed`);
          return;
        }
        const sdkObject = this._object instanceof _instrumentation.SdkObject ? this._object : void 0;
        this._connection.sendEvent(this, method, params, sdkObject);
      }
      _dispose() {
        this._disposeRecursively();
        this._connection.sendDispose(this);
      }
      _onDispose() {
      }
      _disposeRecursively() {
        (0, _utils.assert)(!this._disposed, `${this._guid} is disposed more than once`);
        this._onDispose();
        this._disposed = true;
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        if (this._parent)
          this._parent._dispatchers.delete(this._guid);
        this._connection._dispatchers.delete(this._guid);
        for (const dispatcher of [...this._dispatchers.values()])
          dispatcher._disposeRecursively();
        this._dispatchers.clear();
        delete this._object[dispatcherSymbol];
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
        };
      }
      waitForEventInfo() {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.Dispatcher = Dispatcher;
    var RootDispatcher = class extends Dispatcher {
      constructor(connection, createPlaywright) {
        super(connection, {
          guid: ""
        }, "Root", {});
        this._initialized = false;
        this.createPlaywright = createPlaywright;
      }
      initialize(params) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this.createPlaywright);
          (0, _utils.assert)(!this._initialized);
          this._initialized = true;
          return {
            playwright: yield this.createPlaywright(this, params)
          };
        });
      }
    };
    exports2.RootDispatcher = RootDispatcher;
    var DispatcherConnection = class {
      constructor(isLocal) {
        this._dispatchers = /* @__PURE__ */ new Map();
        this.onmessage = (message) => {
        };
        this._waitOperations = /* @__PURE__ */ new Map();
        this._isLocal = void 0;
        this._isLocal = !!isLocal;
      }
      sendEvent(dispatcher, event, params, sdkObject) {
        const validator = (0, _validator.findValidator)(dispatcher._type, event, "Event");
        params = validator(params, "", {
          tChannelImpl: this._tChannelImplToWire.bind(this),
          binary: this._isLocal ? "buffer" : "toBase64"
        });
        this._sendMessageToClient(dispatcher._guid, dispatcher._type, event, params, sdkObject);
      }
      sendCreate(parent, type, guid, initializer, sdkObject) {
        const validator = (0, _validator.findValidator)(type, "", "Initializer");
        initializer = validator(initializer, "", {
          tChannelImpl: this._tChannelImplToWire.bind(this),
          binary: this._isLocal ? "buffer" : "toBase64"
        });
        this._sendMessageToClient(parent._guid, type, "__create__", {
          type,
          initializer,
          guid
        }, sdkObject);
      }
      sendAdopt(parent, dispatcher) {
        this._sendMessageToClient(parent._guid, dispatcher._type, "__adopt__", {
          guid: dispatcher._guid
        });
      }
      sendDispose(dispatcher) {
        this._sendMessageToClient(dispatcher._guid, dispatcher._type, "__dispose__", {});
      }
      _sendMessageToClient(guid, type, method, params, sdkObject) {
        if (sdkObject) {
          var _sdkObject$attributio, _sdkObject$attributio2, _sdkObject$instrument;
          const event = {
            type: "event",
            class: type,
            method,
            params: params || {},
            time: (0, _utils.monotonicTime)(),
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio = sdkObject.attribution) === null || _sdkObject$attributio === void 0 ? void 0 : (_sdkObject$attributio2 = _sdkObject$attributio.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.guid
          };
          (_sdkObject$instrument = sdkObject.instrumentation) === null || _sdkObject$instrument === void 0 ? void 0 : _sdkObject$instrument.onEvent(sdkObject, event);
        }
        this.onmessage({
          guid,
          method,
          params
        });
      }
      _tChannelImplFromWire(names, arg, path, context) {
        if (arg && typeof arg === "object" && typeof arg.guid === "string") {
          const guid = arg.guid;
          const dispatcher = this._dispatchers.get(guid);
          if (!dispatcher)
            throw new _validator.ValidationError(`${path}: no object with guid ${guid}`);
          if (names !== "*" && !names.includes(dispatcher._type))
            throw new _validator.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${names.toString()}`);
          return dispatcher;
        }
        throw new _validator.ValidationError(`${path}: expected guid for ${names.toString()}`);
      }
      _tChannelImplToWire(names, arg, path, context) {
        if (arg instanceof Dispatcher) {
          if (names !== "*" && !names.includes(arg._type))
            throw new _validator.ValidationError(`${path}: dispatcher with guid ${arg._guid} has type ${arg._type}, expected ${names.toString()}`);
          return {
            guid: arg._guid
          };
        }
        throw new _validator.ValidationError(`${path}: expected dispatcher ${names.toString()}`);
      }
      dispatch(message) {
        return __async(this, null, function* () {
          var _sdkObject$attributio3, _sdkObject$attributio4, _sdkObject$attributio5, _sdkObject$attributio6, _params$info;
          const {
            id,
            guid,
            method,
            params,
            metadata
          } = message;
          const dispatcher = this._dispatchers.get(guid);
          if (!dispatcher) {
            this.onmessage({
              id,
              error: (0, _serializers.serializeError)(new Error(_errors.kBrowserOrContextClosedError))
            });
            return;
          }
          let validParams;
          let validMetadata;
          try {
            const validator = (0, _validator.findValidator)(dispatcher._type, method, "Params");
            validParams = validator(params, "", {
              tChannelImpl: this._tChannelImplFromWire.bind(this),
              binary: this._isLocal ? "buffer" : "fromBase64"
            });
            validMetadata = metadataValidator(metadata, "", {
              tChannelImpl: this._tChannelImplFromWire.bind(this),
              binary: this._isLocal ? "buffer" : "fromBase64"
            });
            if (typeof dispatcher[method] !== "function")
              throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
          } catch (e) {
            this.onmessage({
              id,
              error: (0, _serializers.serializeError)(e)
            });
            return;
          }
          const sdkObject = dispatcher._object instanceof _instrumentation.SdkObject ? dispatcher._object : void 0;
          const callMetadata = {
            id: `call@${id}`,
            wallTime: validMetadata.wallTime || Date.now(),
            location: validMetadata.location,
            apiName: validMetadata.apiName,
            internal: validMetadata.internal,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio3 = sdkObject.attribution) === null || _sdkObject$attributio3 === void 0 ? void 0 : (_sdkObject$attributio4 = _sdkObject$attributio3.page) === null || _sdkObject$attributio4 === void 0 ? void 0 : _sdkObject$attributio4.guid,
            frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio5 = sdkObject.attribution) === null || _sdkObject$attributio5 === void 0 ? void 0 : (_sdkObject$attributio6 = _sdkObject$attributio5.frame) === null || _sdkObject$attributio6 === void 0 ? void 0 : _sdkObject$attributio6.guid,
            startTime: (0, _utils.monotonicTime)(),
            endTime: 0,
            type: dispatcher._type,
            method,
            params: params || {},
            log: []
          };
          if (sdkObject && params !== null && params !== void 0 && (_params$info = params.info) !== null && _params$info !== void 0 && _params$info.waitId) {
            const info = params.info;
            switch (info.phase) {
              case "before": {
                this._waitOperations.set(info.waitId, callMetadata);
                yield sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
                this.onmessage({
                  id
                });
                return;
              }
              case "log": {
                const originalMetadata = this._waitOperations.get(info.waitId);
                originalMetadata.log.push(info.message);
                sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, "api", info.message);
                this.onmessage({
                  id
                });
                return;
              }
              case "after": {
                const originalMetadata = this._waitOperations.get(info.waitId);
                originalMetadata.endTime = (0, _utils.monotonicTime)();
                originalMetadata.error = info.error ? {
                  error: {
                    name: "Error",
                    message: info.error
                  }
                } : void 0;
                this._waitOperations.delete(info.waitId);
                yield sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
                this.onmessage({
                  id
                });
                return;
              }
            }
          }
          let error;
          yield sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
          try {
            const result = yield dispatcher[method](validParams, callMetadata);
            const validator = (0, _validator.findValidator)(dispatcher._type, method, "Result");
            callMetadata.result = validator(result, "", {
              tChannelImpl: this._tChannelImplToWire.bind(this),
              binary: this._isLocal ? "buffer" : "toBase64"
            });
          } catch (e) {
            callMetadata.error = (0, _serializers.serializeError)(e);
            if (callMetadata.log.length)
              (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(callMetadata.log));
            error = (0, _serializers.serializeError)(e);
          } finally {
            callMetadata.endTime = (0, _utils.monotonicTime)();
            yield sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata);
          }
          const response = {
            id
          };
          if (callMetadata.result)
            response.result = callMetadata.result;
          if (error)
            response.error = error;
          this.onmessage(response);
        });
      }
    };
    exports2.DispatcherConnection = DispatcherConnection;
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
  }
});

// node_modules/playwright-core/lib/common/timeoutSettings.js
var require_timeoutSettings = __commonJS({
  "node_modules/playwright-core/lib/common/timeoutSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutSettings = exports2.DEFAULT_TIMEOUT = exports2.DEFAULT_LAUNCH_TIMEOUT = void 0;
    var _utils = require_utils();
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var DEFAULT_LAUNCH_TIMEOUT = 3 * 60 * 1e3;
    exports2.DEFAULT_LAUNCH_TIMEOUT = DEFAULT_LAUNCH_TIMEOUT;
    var TimeoutSettings = class {
      constructor(parent) {
        this._parent = void 0;
        this._defaultTimeout = void 0;
        this._defaultNavigationTimeout = void 0;
        this._parent = parent;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      defaultNavigationTimeout() {
        return this._defaultNavigationTimeout;
      }
      defaultTimeout() {
        return this._defaultTimeout;
      }
      navigationTimeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if (this._defaultNavigationTimeout !== void 0)
          return this._defaultNavigationTimeout;
        if ((0, _utils.debugMode)())
          return 0;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.navigationTimeout(options);
        return DEFAULT_TIMEOUT;
      }
      timeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if ((0, _utils.debugMode)())
          return 0;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.timeout(options);
        return DEFAULT_TIMEOUT;
      }
      static timeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if ((0, _utils.debugMode)())
          return 0;
        return DEFAULT_TIMEOUT;
      }
      static launchTimeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if ((0, _utils.debugMode)())
          return 0;
        return DEFAULT_LAUNCH_TIMEOUT;
      }
    };
    exports2.TimeoutSettings = TimeoutSettings;
  }
});

// node_modules/playwright-core/lib/server/helper.js
var require_helper = __commonJS({
  "node_modules/playwright-core/lib/server/helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.helper = void 0;
    var _debugLogger = require_debugLogger();
    var _eventsHelper = require_eventsHelper();
    var MAX_LOG_LENGTH = process.env.MAX_LOG_LENGTH ? +process.env.MAX_LOG_LENGTH : Infinity;
    var Helper = class {
      static completeUserURL(urlString) {
        if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
          urlString = "http://" + urlString;
        return urlString;
      }
      static enclosingIntRect(rect) {
        const x = Math.floor(rect.x + 1e-3);
        const y = Math.floor(rect.y + 1e-3);
        const x2 = Math.ceil(rect.x + rect.width - 1e-3);
        const y2 = Math.ceil(rect.y + rect.height - 1e-3);
        return {
          x,
          y,
          width: x2 - x,
          height: y2 - y
        };
      }
      static enclosingIntSize(size) {
        return {
          width: Math.floor(size.width + 1e-3),
          height: Math.floor(size.height + 1e-3)
        };
      }
      static getViewportSizeFromWindowFeatures(features) {
        const widthString = features.find((f) => f.startsWith("width="));
        const heightString = features.find((f) => f.startsWith("height="));
        const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
        const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
        if (!Number.isNaN(width) && !Number.isNaN(height))
          return {
            width,
            height
          };
        return null;
      }
      static waitForEvent(progress2, emitter, event, predicate) {
        const listeners = [];
        const promise = new Promise((resolve, reject) => {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(emitter, event, (eventArg) => {
            try {
              if (predicate && !predicate(eventArg))
                return;
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              resolve(eventArg);
            } catch (e) {
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              reject(e);
            }
          }));
        });
        const dispose = () => _eventsHelper.eventsHelper.removeEventListeners(listeners);
        if (progress2)
          progress2.cleanupWhenAborted(dispose);
        return {
          promise,
          dispose
        };
      }
      static secondsToRoundishMillis(value) {
        return (value * 1e6 | 0) / 1e3;
      }
      static millisToRoundishMillis(value) {
        return (value * 1e3 | 0) / 1e3;
      }
      static debugProtocolLogger(protocolLogger) {
        return (direction, message) => {
          if (protocolLogger)
            protocolLogger(direction, message);
          if (_debugLogger.debugLogger.isEnabled("protocol")) {
            let text = JSON.stringify(message);
            if (text.length > MAX_LOG_LENGTH)
              text = text.substring(0, MAX_LOG_LENGTH / 2) + " <<<<<( LOG TRUNCATED )>>>>> " + text.substring(text.length - MAX_LOG_LENGTH / 2);
            _debugLogger.debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + text);
          }
        };
      }
      static formatBrowserLogs(logs) {
        if (!logs.length)
          return "";
        return "\n" + "=".repeat(20) + " Browser output: " + "=".repeat(20) + "\n" + logs.join("\n");
      }
    };
    var helper = Helper;
    exports2.helper = helper;
  }
});

// node_modules/playwright-core/lib/server/network.js
var require_network2 = __commonJS({
  "node_modules/playwright-core/lib/server/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocket = exports2.STATUS_TEXTS = exports2.Route = exports2.Response = exports2.Request = void 0;
    exports2.filterCookies = filterCookies;
    exports2.mergeHeaders = mergeHeaders;
    exports2.parsedURL = parsedURL;
    exports2.rewriteCookies = rewriteCookies;
    exports2.singleHeader = singleHeader;
    exports2.stripFragmentFromUrl = stripFragmentFromUrl;
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _instrumentation = require_instrumentation();
    var _fetch = require_fetch();
    var _browserContext = require_browserContext();
    function filterCookies(cookies, urls) {
      const parsedURLs = urls.map((s) => new URL(s));
      return cookies.filter((c) => {
        if (!parsedURLs.length)
          return true;
        for (const parsedURL2 of parsedURLs) {
          let domain = c.domain;
          if (!domain.startsWith("."))
            domain = "." + domain;
          if (!("." + parsedURL2.hostname).endsWith(domain))
            continue;
          if (!parsedURL2.pathname.startsWith(c.path))
            continue;
          if (parsedURL2.protocol !== "https:" && parsedURL2.hostname !== "localhost" && c.secure)
            continue;
          return true;
        }
        return false;
      });
    }
    var kMaxCookieExpiresDateInSeconds = 253402300799;
    function rewriteCookies(cookies) {
      return cookies.map((c) => {
        (0, _utils.assert)(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
        (0, _utils.assert)(!(c.url && c.domain), "Cookie should have either url or domain");
        (0, _utils.assert)(!(c.url && c.path), "Cookie should have either url or path");
        (0, _utils.assert)(!(c.expires && c.expires < 0 && c.expires !== -1), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
        (0, _utils.assert)(!(c.expires && c.expires > 0 && c.expires > kMaxCookieExpiresDateInSeconds), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
        const copy = __spreadValues({}, c);
        if (copy.url) {
          (0, _utils.assert)(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
          (0, _utils.assert)(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
          const url = new URL(copy.url);
          copy.domain = url.hostname;
          copy.path = url.pathname.substring(0, url.pathname.lastIndexOf("/") + 1);
          copy.secure = url.protocol === "https:";
        }
        return copy;
      });
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function stripFragmentFromUrl(url) {
      if (!url.includes("#"))
        return url;
      return url.substring(0, url.indexOf("#"));
    }
    var Request = class extends _instrumentation.SdkObject {
      constructor(context, frame, serviceWorker, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        super(frame || context, "request");
        this._response = null;
        this._redirectedFrom = void 0;
        this._redirectedTo = null;
        this._documentId = void 0;
        this._isFavicon = void 0;
        this._failureText = null;
        this._url = void 0;
        this._resourceType = void 0;
        this._method = void 0;
        this._postData = void 0;
        this._headers = void 0;
        this._headersMap = /* @__PURE__ */ new Map();
        this._frame = null;
        this._serviceWorker = null;
        this._context = void 0;
        this._rawRequestHeadersPromise = new _manualPromise.ManualPromise();
        this._waitForResponsePromise = new _manualPromise.ManualPromise();
        this._responseEndTiming = -1;
        this._overrides = void 0;
        (0, _utils.assert)(!url.startsWith("data:"), "Data urls should not fire requests");
        this._context = context;
        this._frame = frame;
        this._serviceWorker = serviceWorker;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        this._updateHeadersMap();
        this._isFavicon = url.endsWith("/favicon.ico") || !!(redirectedFrom !== null && redirectedFrom !== void 0 && redirectedFrom._isFavicon);
      }
      _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromise.resolve(null);
      }
      _setOverrides(overrides) {
        this._overrides = overrides;
        this._updateHeadersMap();
      }
      _updateHeadersMap() {
        for (const {
          name,
          value
        } of this.headers())
          this._headersMap.set(name.toLowerCase(), value);
      }
      _hasOverrides() {
        return !!this._overrides;
      }
      url() {
        var _this$_overrides;
        return ((_this$_overrides = this._overrides) === null || _this$_overrides === void 0 ? void 0 : _this$_overrides.url) || this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        var _this$_overrides2;
        return ((_this$_overrides2 = this._overrides) === null || _this$_overrides2 === void 0 ? void 0 : _this$_overrides2.method) || this._method;
      }
      postDataBuffer() {
        var _this$_overrides3;
        return ((_this$_overrides3 = this._overrides) === null || _this$_overrides3 === void 0 ? void 0 : _this$_overrides3.postData) || this._postData;
      }
      headers() {
        var _this$_overrides4;
        return ((_this$_overrides4 = this._overrides) === null || _this$_overrides4 === void 0 ? void 0 : _this$_overrides4.headers) || this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      setRawRequestHeaders(headers) {
        if (!this._rawRequestHeadersPromise.isDone())
          this._rawRequestHeadersPromise.resolve(headers || this._headers);
      }
      rawRequestHeaders() {
        return __async(this, null, function* () {
          var _this$_overrides5;
          return ((_this$_overrides5 = this._overrides) === null || _this$_overrides5 === void 0 ? void 0 : _this$_overrides5.headers) || this._rawRequestHeadersPromise;
        });
      }
      response() {
        return this._waitForResponsePromise;
      }
      _existingResponse() {
        return this._response;
      }
      _setResponse(response) {
        this._response = response;
        this._waitForResponsePromise.resolve(response);
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
      frame() {
        return this._frame;
      }
      serviceWorker() {
        return this._serviceWorker;
      }
      isNavigationRequest() {
        return !!this._documentId;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      bodySize() {
        var _this$postDataBuffer;
        return ((_this$postDataBuffer = this.postDataBuffer()) === null || _this$postDataBuffer === void 0 ? void 0 : _this$postDataBuffer.length) || 0;
      }
      requestHeadersSize() {
        return __async(this, null, function* () {
          let headersSize = 4;
          headersSize += this.method().length;
          headersSize += new URL(this.url()).pathname.length;
          headersSize += 8;
          const headers = yield this.rawRequestHeaders();
          for (const header of headers)
            headersSize += header.name.length + header.value.length + 4;
          return headersSize;
        });
      }
    };
    exports2.Request = Request;
    var Route = class extends _instrumentation.SdkObject {
      constructor(request, delegate) {
        super(request._frame || request._context, "route");
        this._request = void 0;
        this._delegate = void 0;
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
        this._request._context.addRouteInFlight(this);
      }
      request() {
        return this._request;
      }
      abort(errorCode = "failed") {
        return __async(this, null, function* () {
          this._startHandling();
          this._request._context.emit(_browserContext.BrowserContext.Events.RequestAborted, this._request);
          yield this._delegate.abort(errorCode);
          this._endHandling();
        });
      }
      redirectNavigationRequest(url) {
        return __async(this, null, function* () {
          this._startHandling();
          (0, _utils.assert)(this._request.isNavigationRequest());
          this._request.frame().redirectNavigation(url, this._request._documentId, this._request.headerValue("referer"));
        });
      }
      fulfill(overrides) {
        return __async(this, null, function* () {
          this._startHandling();
          let body = overrides.body;
          let isBase64 = overrides.isBase64 || false;
          if (body === void 0) {
            if (overrides.fetchResponseUid) {
              const buffer = this._request._context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || _fetch.APIRequestContext.findResponseBody(overrides.fetchResponseUid);
              (0, _utils.assert)(buffer, "Fetch response has been disposed");
              body = buffer.toString("base64");
              isBase64 = true;
            } else {
              body = "";
              isBase64 = false;
            }
          }
          const headers = [...overrides.headers || []];
          this._maybeAddCorsHeaders(headers);
          this._request._context.emit(_browserContext.BrowserContext.Events.RequestFulfilled, this._request);
          yield this._delegate.fulfill({
            status: overrides.status || 200,
            headers,
            body,
            isBase64
          });
          this._endHandling();
        });
      }
      _maybeAddCorsHeaders(headers) {
        const origin = this._request.headerValue("origin");
        if (!origin)
          return;
        const requestUrl = new URL(this._request.url());
        if (!requestUrl.protocol.startsWith("http"))
          return;
        if (requestUrl.origin === origin.trim())
          return;
        const corsHeader = headers.find(({
          name
        }) => name === "access-control-allow-origin");
        if (corsHeader)
          return;
        headers.push({
          name: "access-control-allow-origin",
          value: origin
        });
        headers.push({
          name: "access-control-allow-credentials",
          value: "true"
        });
        headers.push({
          name: "vary",
          value: "Origin"
        });
      }
      continue(overrides) {
        return __async(this, null, function* () {
          this._startHandling();
          if (overrides.url) {
            const newUrl = new URL(overrides.url);
            const oldUrl = new URL(this._request.url());
            if (oldUrl.protocol !== newUrl.protocol)
              throw new Error("New URL must have same protocol as overridden URL");
          }
          this._request._setOverrides(overrides);
          if (!overrides.isFallback)
            this._request._context.emit(_browserContext.BrowserContext.Events.RequestContinued, this._request);
          yield this._delegate.continue(this._request, overrides);
          this._endHandling();
        });
      }
      _startHandling() {
        (0, _utils.assert)(!this._handled, "Route is already handled!");
        this._handled = true;
      }
      _endHandling() {
        this._request._context.removeRouteInFlight(this);
      }
    };
    exports2.Route = Route;
    var Response = class extends _instrumentation.SdkObject {
      constructor(request, status, statusText, headers, timing, getResponseBodyCallback, fromServiceWorker, httpVersion) {
        super(request.frame() || request._context, "response");
        this._request = void 0;
        this._contentPromise = null;
        this._finishedPromise = new _manualPromise.ManualPromise();
        this._status = void 0;
        this._statusText = void 0;
        this._url = void 0;
        this._headers = void 0;
        this._headersMap = /* @__PURE__ */ new Map();
        this._getResponseBodyCallback = void 0;
        this._timing = void 0;
        this._serverAddrPromise = new _manualPromise.ManualPromise();
        this._securityDetailsPromise = new _manualPromise.ManualPromise();
        this._rawResponseHeadersPromise = new _manualPromise.ManualPromise();
        this._httpVersion = void 0;
        this._fromServiceWorker = void 0;
        this._encodedBodySizePromise = new _manualPromise.ManualPromise();
        this._transferSizePromise = new _manualPromise.ManualPromise();
        this._responseHeadersSizePromise = new _manualPromise.ManualPromise();
        this._request = request;
        this._timing = timing;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._request._setResponse(this);
        this._httpVersion = httpVersion;
        this._fromServiceWorker = fromServiceWorker;
      }
      _serverAddrFinished(addr) {
        this._serverAddrPromise.resolve(addr);
      }
      _securityDetailsFinished(securityDetails) {
        this._securityDetailsPromise.resolve(securityDetails);
      }
      _requestFinished(responseEndTiming) {
        this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
        if (this._timing.requestStart === -1)
          this._timing.requestStart = this._request._responseEndTiming;
        this._finishedPromise.resolve();
      }
      _setHttpVersion(httpVersion) {
        this._httpVersion = httpVersion;
      }
      url() {
        return this._url;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      rawResponseHeaders() {
        return __async(this, null, function* () {
          return this._rawResponseHeadersPromise;
        });
      }
      setRawResponseHeaders(headers) {
        if (!this._rawResponseHeadersPromise.isDone())
          this._rawResponseHeadersPromise.resolve(headers || this._headers);
      }
      setTransferSize(size) {
        this._transferSizePromise.resolve(size);
      }
      setEncodedBodySize(size) {
        this._encodedBodySizePromise.resolve(size);
      }
      setResponseHeadersSize(size) {
        this._responseHeadersSizePromise.resolve(size);
      }
      timing() {
        return this._timing;
      }
      serverAddr() {
        return __async(this, null, function* () {
          return (yield this._serverAddrPromise) || null;
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return (yield this._securityDetailsPromise) || null;
        });
      }
      body() {
        if (!this._contentPromise) {
          this._contentPromise = this._finishedPromise.then(() => __async(this, null, function* () {
            if (this._status >= 300 && this._status <= 399)
              throw new Error("Response body is unavailable for redirect responses");
            return this._getResponseBodyCallback();
          }));
        }
        return this._contentPromise;
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      httpVersion() {
        if (!this._httpVersion)
          return "HTTP/1.1";
        if (this._httpVersion === "http/1.1")
          return "HTTP/1.1";
        if (this._httpVersion === "h2")
          return "HTTP/2.0";
        return this._httpVersion;
      }
      fromServiceWorker() {
        return this._fromServiceWorker;
      }
      responseHeadersSize() {
        return __async(this, null, function* () {
          const availableSize = yield this._responseHeadersSizePromise;
          if (availableSize !== null)
            return availableSize;
          let headersSize = 4;
          headersSize += 8;
          headersSize += 3;
          headersSize += this.statusText().length;
          const headers = yield this._rawResponseHeadersPromise;
          for (const header of headers)
            headersSize += header.name.length + header.value.length + 4;
          headersSize += 2;
          return headersSize;
        });
      }
      sizes() {
        return __async(this, null, function* () {
          const requestHeadersSize = yield this._request.requestHeadersSize();
          const responseHeadersSize = yield this.responseHeadersSize();
          let encodedBodySize = yield this._encodedBodySizePromise;
          if (encodedBodySize === null) {
            var _headers$find;
            const headers = yield this._rawResponseHeadersPromise;
            const contentLength = (_headers$find = headers.find((h) => h.name.toLowerCase() === "content-length")) === null || _headers$find === void 0 ? void 0 : _headers$find.value;
            encodedBodySize = contentLength ? +contentLength : 0;
          }
          let transferSize = yield this._transferSizePromise;
          if (transferSize === null) {
            transferSize = responseHeadersSize + encodedBodySize;
          }
          return {
            requestBodySize: this._request.bodySize(),
            requestHeadersSize,
            responseBodySize: encodedBodySize,
            responseHeadersSize,
            transferSize
          };
        });
      }
    };
    exports2.Response = Response;
    var WebSocket = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "ws");
        this._url = void 0;
        this._notified = false;
        this._url = url;
      }
      markAsNotified() {
        if (this._notified)
          return false;
        this._notified = true;
        return true;
      }
      url() {
        return this._url;
      }
      frameSent(opcode, data) {
        this.emit(WebSocket.Events.FrameSent, {
          opcode,
          data
        });
      }
      frameReceived(opcode, data) {
        this.emit(WebSocket.Events.FrameReceived, {
          opcode,
          data
        });
      }
      error(errorMessage) {
        this.emit(WebSocket.Events.SocketError, errorMessage);
      }
      closed() {
        this.emit(WebSocket.Events.Close);
      }
    };
    exports2.WebSocket = WebSocket;
    WebSocket.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
    var STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    exports2.STATUS_TEXTS = STATUS_TEXTS;
    function singleHeader(name, value) {
      return [{
        name,
        value
      }];
    }
    function mergeHeaders(headers) {
      const lowerCaseToValue = /* @__PURE__ */ new Map();
      const lowerCaseToOriginalCase = /* @__PURE__ */ new Map();
      for (const h of headers) {
        if (!h)
          continue;
        for (const {
          name,
          value
        } of h) {
          const lower = name.toLowerCase();
          lowerCaseToOriginalCase.set(lower, name);
          lowerCaseToValue.set(lower, value);
        }
      }
      const result = [];
      for (const [lower, value] of lowerCaseToValue)
        result.push({
          name: lowerCaseToOriginalCase.get(lower),
          value
        });
      return result;
    }
  }
});

// node_modules/playwright-core/lib/generated/injectedScriptSource.js
var require_injectedScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/injectedScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = '\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n// packages/playwright-core/src/server/injected/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/server/injected/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith("/"))\n      selector = "." + selector;\n    const result = [];\n    const document = root.ownerDocument || root;\n    if (!document)\n      return result;\n    const it = document.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/playwright-core/src/server/injected/domUtils.ts\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css, scope) {\n  while (element) {\n    const closest = element.closest(css);\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n      return;\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction getElementComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementStyleVisibilityVisible(element, style) {\n  style = style != null ? style : getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (Element.prototype.checkVisibility) {\n    if (!element.checkVisibility({ checkOpacity: false, checkVisibilityCSS: false }))\n      return false;\n  } else {\n    const detailsOrSummary = element.closest("details,summary");\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)\n      return false;\n  }\n  if (style.visibility !== "visible")\n    return false;\n  return true;\n}\nfunction isElementVisible(element) {\n  const style = getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (style.display === "contents") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isElementVisible(child))\n        return true;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return true;\n    }\n    return false;\n  }\n  if (!isElementStyleVisibilityVisible(element, style))\n    return false;\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction isVisibleTextNode(node) {\n  const range = node.ownerDocument.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\n\n// packages/playwright-core/src/server/injected/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n}\nvar kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\nvar kGlobalAriaAttributes = [\n  "aria-atomic",\n  "aria-busy",\n  "aria-controls",\n  "aria-current",\n  "aria-describedby",\n  "aria-details",\n  "aria-disabled",\n  "aria-dropeffect",\n  "aria-errormessage",\n  "aria-flowto",\n  "aria-grabbed",\n  "aria-haspopup",\n  "aria-hidden",\n  "aria-invalid",\n  "aria-keyshortcuts",\n  "aria-label",\n  "aria-labelledby",\n  "aria-live",\n  "aria-owns",\n  "aria-relevant",\n  "aria-roledescription"\n];\nfunction hasGlobalAriaAttribute(e) {\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\n}\nvar kImplicitRoleByTagName = {\n  "A": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "AREA": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "ARTICLE": () => "article",\n  "ASIDE": () => "complementary",\n  "BLOCKQUOTE": () => "blockquote",\n  "BUTTON": () => "button",\n  "CAPTION": () => "caption",\n  "CODE": () => "code",\n  "DATALIST": () => "listbox",\n  "DD": () => "definition",\n  "DEL": () => "deletion",\n  "DETAILS": () => "group",\n  "DFN": () => "term",\n  "DIALOG": () => "dialog",\n  "DT": () => "term",\n  "EM": () => "emphasis",\n  "FIELDSET": () => "group",\n  "FIGURE": () => "figure",\n  "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n  "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n  "H1": () => "heading",\n  "H2": () => "heading",\n  "H3": () => "heading",\n  "H4": () => "heading",\n  "H5": () => "heading",\n  "H6": () => "heading",\n  "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n  "HR": () => "separator",\n  "HTML": () => "document",\n  "IMG": (e) => e.getAttribute("alt") === "" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute("tabindex")))) ? "presentation" : "img",\n  "INPUT": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === "search")\n      return e.hasAttribute("list") ? "combobox" : "searchbox";\n    if (["email", "tel", "text", "url", ""].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute("list"))[0];\n      return list && list.tagName === "DATALIST" ? "combobox" : "textbox";\n    }\n    if (type === "hidden")\n      return "";\n    return {\n      "button": "button",\n      "checkbox": "checkbox",\n      "image": "button",\n      "number": "spinbutton",\n      "radio": "radio",\n      "range": "slider",\n      "reset": "button",\n      "submit": "button"\n    }[type] || "textbox";\n  },\n  "INS": () => "insertion",\n  "LI": () => "listitem",\n  "MAIN": () => "main",\n  "MARK": () => "mark",\n  "MATH": () => "math",\n  "MENU": () => "list",\n  "METER": () => "meter",\n  "NAV": () => "navigation",\n  "OL": () => "list",\n  "OPTGROUP": () => "group",\n  "OPTION": () => "option",\n  "OUTPUT": () => "status",\n  "P": () => "paragraph",\n  "PROGRESS": () => "progressbar",\n  "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n  "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n  "STRONG": () => "strong",\n  "SUB": () => "subscript",\n  "SUP": () => "superscript",\n  "SVG": () => "img",\n  "TABLE": () => "table",\n  "TBODY": () => "rowgroup",\n  "TD": (e) => {\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "TEXTAREA": () => "textbox",\n  "TFOOT": () => "rowgroup",\n  "TH": (e) => {\n    if (e.getAttribute("scope") === "col")\n      return "columnheader";\n    if (e.getAttribute("scope") === "row")\n      return "rowheader";\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "THEAD": () => "rowgroup",\n  "TIME": () => "time",\n  "TR": () => "row",\n  "UL": () => "list"\n};\nvar kPresentationInheritanceParents = {\n  "DD": ["DL", "DIV"],\n  "DIV": ["DL"],\n  "DT": ["DL", "DIV"],\n  "LI": ["OL", "UL"],\n  "TBODY": ["TABLE"],\n  "TD": ["TR"],\n  "TFOOT": ["TABLE"],\n  "TH": ["TR"],\n  "THEAD": ["TABLE"],\n  "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName.toUpperCase()]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\n    if (!parents || !parent || !parents.includes(parent.tagName))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar allRoles = [\n  "alert",\n  "alertdialog",\n  "application",\n  "article",\n  "banner",\n  "blockquote",\n  "button",\n  "caption",\n  "cell",\n  "checkbox",\n  "code",\n  "columnheader",\n  "combobox",\n  "command",\n  "complementary",\n  "composite",\n  "contentinfo",\n  "definition",\n  "deletion",\n  "dialog",\n  "directory",\n  "document",\n  "emphasis",\n  "feed",\n  "figure",\n  "form",\n  "generic",\n  "grid",\n  "gridcell",\n  "group",\n  "heading",\n  "img",\n  "input",\n  "insertion",\n  "landmark",\n  "link",\n  "list",\n  "listbox",\n  "listitem",\n  "log",\n  "main",\n  "marquee",\n  "math",\n  "meter",\n  "menu",\n  "menubar",\n  "menuitem",\n  "menuitemcheckbox",\n  "menuitemradio",\n  "navigation",\n  "none",\n  "note",\n  "option",\n  "paragraph",\n  "presentation",\n  "progressbar",\n  "radio",\n  "radiogroup",\n  "range",\n  "region",\n  "roletype",\n  "row",\n  "rowgroup",\n  "rowheader",\n  "scrollbar",\n  "search",\n  "searchbox",\n  "section",\n  "sectionhead",\n  "select",\n  "separator",\n  "slider",\n  "spinbutton",\n  "status",\n  "strong",\n  "structure",\n  "subscript",\n  "superscript",\n  "switch",\n  "tab",\n  "table",\n  "tablist",\n  "tabpanel",\n  "term",\n  "textbox",\n  "time",\n  "timer",\n  "toolbar",\n  "tooltip",\n  "tree",\n  "treegrid",\n  "treeitem",\n  "widget",\n  "window"\n];\nvar abstractRoles = ["command", "composite", "input", "landmark", "range", "roletype", "section", "sectionhead", "select", "structure", "widget", "window"];\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element) {\n  return !hasGlobalAriaAttribute(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if ((explicitRole === "none" || explicitRole === "presentation") && hasPresentationConflictResolution(element))\n    return getImplicitAriaRole(element);\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === "true";\n}\nfunction isElementHiddenForAria(element) {\n  if (["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(element.tagName))\n    return true;\n  const style = getElementComputedStyle(element);\n  const isSlot = element.nodeName === "SLOT";\n  if ((style == null ? void 0 : style.display) === "contents" && !isSlot) {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\n        return false;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return false;\n    }\n    return true;\n  }\n  const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n    return true;\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n}\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n  if (hidden === void 0) {\n    hidden = false;\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n      hidden = true;\n    if (!hidden) {\n      const style = getElementComputedStyle(element);\n      hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n    }\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n    }\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n  }\n  return hidden;\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(" ").filter((id) => !!id);\n    const set = /* @__PURE__ */ new Set();\n    for (const id of ids) {\n      const firstElement = root.querySelector("#" + CSS.escape(id));\n      if (firstElement)\n        set.add(firstElement);\n    }\n    return [...set];\n  } catch (e) {\n    return [];\n  }\n}\nfunction normalizeAccessbileName(s) {\n  return s.replace(/\\r\\n/g, "\\n").replace(/\\u00A0/g, " ").replace(/\\s\\s+/g, " ").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getPseudoContent(pseudoStyle) {\n  if (!pseudoStyle)\n    return "";\n  const content = pseudoStyle.content;\n  if (content[0] === "\'" && content[content.length - 1] === "\'" || content[0] === \'"\' && content[content.length - 1] === \'"\') {\n    const unquoted = content.substring(1, content.length - 1);\n    const display = pseudoStyle.display || "inline";\n    if (display !== "inline")\n      return " " + unquoted + " ";\n    return unquoted;\n  }\n  return "";\n}\nfunction getAriaLabelledByElements(element) {\n  const ref = element.getAttribute("aria-labelledby");\n  if (ref === null)\n    return null;\n  return getIdRefs(element, ref);\n}\nfunction allowsNameFromContent(role, targetDescendant) {\n  const alwaysAllowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n  const descendantAllowsNameFromContent = targetDescendant && ["", "caption", "code", "contentinfo", "definition", "deletion", "emphasis", "insertion", "list", "listitem", "mark", "none", "paragraph", "presentation", "region", "row", "rowgroup", "section", "strong", "subscript", "superscript", "table", "term", "time"].includes(role);\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n}\nfunction getElementAccessibleName(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n  let accessibleName = cache == null ? void 0 : cache.get(element);\n  if (accessibleName === void 0) {\n    accessibleName = "";\n    const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n    if (!elementProhibitsNaming) {\n      accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\n        includeHidden,\n        visitedElements: /* @__PURE__ */ new Set(),\n        embeddedInLabelledBy: "none",\n        embeddedInLabel: "none",\n        embeddedInTextAlternativeElement: false,\n        embeddedInTargetElement: "self"\n      }));\n    }\n    cache == null ? void 0 : cache.set(element, accessibleName);\n  }\n  return accessibleName;\n}\nfunction getElementAccessibleNameInternal(element, options) {\n  if (options.visitedElements.has(element))\n    return "";\n  const childOptions = {\n    ...options,\n    embeddedInLabel: options.embeddedInLabel === "self" ? "descendant" : options.embeddedInLabel,\n    embeddedInLabelledBy: options.embeddedInLabelledBy === "self" ? "descendant" : options.embeddedInLabelledBy,\n    embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden && options.embeddedInLabelledBy !== "self" && isElementHiddenForAria(element)) {\n    options.visitedElements.add(element);\n    return "";\n  }\n  const labelledBy = getAriaLabelledByElements(element);\n  if (options.embeddedInLabelledBy === "none") {\n    const accessibleName = (labelledBy || []).map((ref) => getElementAccessibleNameInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: "self",\n      embeddedInTargetElement: "none",\n      embeddedInLabel: "none",\n      embeddedInTextAlternativeElement: false\n    })).join(" ");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || "";\n  if (options.embeddedInLabel !== "none" || options.embeddedInLabelledBy !== "none") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === "textbox") {\n        options.visitedElements.add(element);\n        if (element.tagName === "INPUT" || element.tagName === "TEXTAREA")\n          return element.value;\n        return element.textContent || "";\n      }\n      if (["combobox", "listbox"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (element.tagName === "SELECT") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter((e) => getAriaRole(e) === "option") : [];\n        }\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(" ");\n      }\n      if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute("aria-valuetext"))\n          return element.getAttribute("aria-valuetext") || "";\n        if (element.hasAttribute("aria-valuenow"))\n          return element.getAttribute("aria-valuenow") || "";\n        return element.getAttribute("value") || "";\n      }\n      if (["menu"].includes(role)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute("aria-label") || "";\n  if (ariaLabel.trim()) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (!["presentation", "none"].includes(role)) {\n    if (element.tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || "";\n      if (value.trim())\n        return value;\n      if (element.type === "submit")\n        return "Submit";\n      if (element.type === "reset")\n        return "Reset";\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "INPUT" && element.type === "image") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && options.embeddedInLabelledBy === "none") {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      if (title.trim())\n        return title;\n      return "Submit";\n    }\n    if (!labelledBy && element.tagName === "BUTTON") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n    }\n    if (!labelledBy && (element.tagName === "TEXTAREA" || element.tagName === "SELECT" || element.tagName === "INPUT")) {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n      const usePlaceholder = element.tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || element.tagName === "TEXTAREA";\n      const placeholder = element.getAttribute("placeholder") || "";\n      const title = element.getAttribute("title") || "";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (!labelledBy && element.tagName === "FIELDSET") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "LEGEND") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (!labelledBy && element.tagName === "FIGURE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "FIGCAPTION") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "IMG") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "TABLE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "CAPTION") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const summary = element.getAttribute("summary") || "";\n      if (summary)\n        return summary;\n    }\n    if (element.tagName === "AREA") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName.toUpperCase() === "SVG" || element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName.toUpperCase() === "TITLE" && child.ownerSVGElement) {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInLabelledBy: "self"\n          });\n        }\n      }\n    }\n    if (element.ownerSVGElement && element.tagName.toUpperCase() === "A") {\n      const title = element.getAttribute("xlink:title") || "";\n      if (title.trim()) {\n        options.visitedElements.add(element);\n        return title;\n      }\n    }\n  }\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || options.embeddedInLabelledBy !== "none" || options.embeddedInLabel !== "none" || options.embeddedInTextAlternativeElement) {\n    options.visitedElements.add(element);\n    const tokens = [];\n    const visit = (node, skipSlotted) => {\n      var _a;\n      if (skipSlotted && node.assignedSlot)\n        return;\n      if (node.nodeType === 1) {\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || "inline";\n        let token = getElementAccessibleNameInternal(node, childOptions);\n        if (display !== "inline" || node.nodeName === "BR")\n          token = " " + token + " ";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || "");\n      }\n    };\n    tokens.push(getPseudoContent(getElementComputedStyle(element, "::before")));\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(child, false);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(child, true);\n      }\n      for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n        visit(owned, true);\n    }\n    tokens.push(getPseudoContent(getElementComputedStyle(element, "::after")));\n    const accessibleName = tokens.join("");\n    if (accessibleName.trim())\n      return accessibleName;\n  }\n  if (!["presentation", "none"].includes(role) || element.tagName === "IFRAME") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute("title") || "";\n    if (title.trim())\n      return title;\n  }\n  options.visitedElements.add(element);\n  return "";\n}\nvar kAriaSelectedRoles = ["gridcell", "option", "row", "tab", "rowheader", "columnheader", "treeitem"];\nfunction getAriaSelected(element) {\n  if (element.tagName === "OPTION")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n    return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = ["checkbox", "menuitemcheckbox", "option", "radio", "switch", "menuitemradio", "treeitem"];\nfunction getAriaChecked(element) {\n  const result = getChecked(element, true);\n  return result === "error" ? false : result;\n}\nfunction getChecked(element, allowMixed) {\n  if (allowMixed && element.tagName === "INPUT" && element.indeterminate)\n    return "mixed";\n  if (element.tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n    const checked = element.getAttribute("aria-checked");\n    if (checked === "true")\n      return true;\n    if (allowMixed && checked === "mixed")\n      return "mixed";\n    return false;\n  }\n  return "error";\n}\nvar kAriaPressedRoles = ["button"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n    const pressed = element.getAttribute("aria-pressed");\n    if (pressed === "true")\n      return true;\n    if (pressed === "mixed")\n      return "mixed";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = ["application", "button", "checkbox", "combobox", "gridcell", "link", "listbox", "menuitem", "row", "rowheader", "tab", "treeitem", "columnheader", "menuitemcheckbox", "menuitemradio", "rowheader", "switch"];\nfunction getAriaExpanded(element) {\n  if (element.tagName === "DETAILS")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || "")) {\n    const expanded = element.getAttribute("aria-expanded");\n    if (expanded === null)\n      return "none";\n    if (expanded === "true")\n      return true;\n    return false;\n  }\n  return "none";\n}\nvar kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\nfunction getAriaLevel(element) {\n  const native = { "H1": 1, "H2": 2, "H3": 3, "H4": 4, "H5": 5, "H6": 6 }[element.tagName];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n    const attr = element.getAttribute("aria-level");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = ["application", "button", "composite", "gridcell", "group", "input", "link", "menuitem", "scrollbar", "separator", "tab", "checkbox", "columnheader", "combobox", "grid", "listbox", "menu", "menubar", "menuitemcheckbox", "menuitemradio", "option", "radio", "radiogroup", "row", "rowheader", "searchbox", "select", "slider", "spinbutton", "switch", "tablist", "textbox", "toolbar", "tree", "treegrid", "treeitem"];\nfunction getAriaDisabled(element) {\n  const isNativeFormControl = ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(element.tagName);\n  if (isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledFieldSet(element)))\n    return true;\n  return hasExplicitAriaDisabled(element);\n}\nfunction belongsToDisabledFieldSet(element) {\n  if (!element)\n    return false;\n  if (element.tagName === "FIELDSET" && element.hasAttribute("disabled"))\n    return true;\n  return belongsToDisabledFieldSet(element.parentElement);\n}\nfunction hasExplicitAriaDisabled(element) {\n  if (!element)\n    return false;\n  if (kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n    const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n    if (attribute === "true")\n      return true;\n    if (attribute === "false")\n      return false;\n  }\n  return hasExplicitAriaDisabled(parentElementOrShadowHost(element));\n}\nvar cacheAccessibleName;\nvar cacheAccessibleNameHidden;\nvar cacheIsHidden;\nvar cachesCounter = 0;\nfunction beginAriaCaches() {\n  ++cachesCounter;\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = /* @__PURE__ */ new Map();\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = /* @__PURE__ */ new Map();\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = /* @__PURE__ */ new Map();\n}\nfunction endAriaCaches() {\n  if (!--cachesCounter) {\n    cacheAccessibleName = void 0;\n    cacheAccessibleNameHidden = void 0;\n    cacheIsHidden = void 0;\n  }\n}\n\n// packages/playwright-core/src/server/injected/selectorUtils.ts\nfunction matchesComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttributePart(obj, attr);\n}\nfunction matchesAttributePart(value, attr) {\n  const objValue = typeof value === "string" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === "string" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === "<truthy>")\n    return !!objValue;\n  if (attr.op === "=") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === "string" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== "string" || typeof attrValue !== "string")\n    return false;\n  if (attr.op === "*=")\n    return objValue.includes(attrValue);\n  if (attr.op === "^=")\n    return objValue.startsWith(attrValue);\n  if (attr.op === "$=")\n    return objValue.endsWith(attrValue);\n  if (attr.op === "|=")\n    return objValue === attrValue || objValue.startsWith(attrValue + "-");\n  if (attr.op === "~=")\n    return objValue.split(" ").includes(attrValue);\n  return false;\n}\nfunction shouldSkipForTextMatching(element) {\n  const document = element.ownerDocument;\n  return element.nodeName === "SCRIPT" || element.nodeName === "NOSCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(cache, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return "none";\n  if (!matcher(elementText(cache, element)))\n    return "none";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\n      return "selfAndChildren";\n  }\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\n    return "selfAndChildren";\n  return "self";\n}\nfunction getElementLabels(textCache, element) {\n  const labels = getAriaLabelledByElements(element);\n  if (labels)\n    return labels.map((label) => elementText(textCache, label));\n  const ariaLabel = element.getAttribute("aria-label");\n  if (ariaLabel !== null && !!ariaLabel.trim())\n    return [{ full: ariaLabel, immediate: [ariaLabel] }];\n  const isNonHiddenInput = element.nodeName === "INPUT" && element.type !== "hidden";\n  if (["BUTTON", "METER", "OUTPUT", "PROGRESS", "SELECT", "TEXTAREA"].includes(element.nodeName) || isNonHiddenInput) {\n    const labels2 = element.labels;\n    if (labels2)\n      return [...labels2].map((label) => elementText(textCache, label));\n  }\n  return [];\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "InvalidCharacterError";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw "Spec Error: no more than three codepoints of lookahead.";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken("");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = "id";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === "url" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = "";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken("");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(""), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = "";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error("Internal parse error");\n  };\n  const consumeANumber = function() {\n    let repr = "";\n    let type = "integer";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error("I\'m infinite-looping!");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = "";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return "" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADSTRING";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADURL";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "WHITESPACE";\n  }\n  toString() {\n    return "WS";\n  }\n  toSource() {\n    return " ";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDO";\n  }\n  toSource() {\n    return "<!--";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDC";\n  }\n  toSource() {\n    return "-->";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ":";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ";";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ",";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n    this.mirror = "";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "{";\n    this.value = "{";\n    this.mirror = "}";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "}";\n    this.value = "}";\n    this.mirror = "{";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "[";\n    this.value = "[";\n    this.mirror = "]";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "]";\n    this.value = "]";\n    this.mirror = "[";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "(";\n    this.value = "(";\n    this.mirror = ")";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ")";\n    this.value = ")";\n    this.mirror = "(";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "~=";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "|=";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "^=";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "$=";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "*=";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "||";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "EOF";\n  }\n  toSource() {\n    return "";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = "DELIM";\n    this.value = "";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return "DELIM(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === "\\\\")\n      return "\\\\\\n";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "IDENT";\n    this.value = val;\n  }\n  toString() {\n    return "IDENT(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "FUNCTION";\n    this.value = val;\n    this.mirror = ")";\n  }\n  toString() {\n    return "FUNCTION(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value) + "(";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "AT-KEYWORD";\n    this.value = val;\n  }\n  toString() {\n    return "AT(" + this.value + ")";\n  }\n  toSource() {\n    return "@" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "HASH";\n    this.value = val;\n    this.type = "unrestricted";\n  }\n  toString() {\n    return "HASH(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === "id")\n      return "#" + escapeIdent(this.value);\n    else\n      return "#" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "STRING";\n    this.value = val;\n  }\n  toString() {\n    return \'"\' + escapeString(this.value) + \'"\';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "URL";\n    this.value = val;\n  }\n  toString() {\n    return "URL(" + this.value + ")";\n  }\n  toSource() {\n    return \'url("\' + escapeString(this.value) + \'")\';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "NUMBER";\n    this.type = "integer";\n    this.repr = "";\n  }\n  toString() {\n    if (this.type === "integer")\n      return "INT(" + this.value + ")";\n    return "NUMBER(" + this.value + ")";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "PERCENTAGE";\n    this.repr = "";\n  }\n  toString() {\n    return "PERCENTAGE(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + "%";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "DIMENSION";\n    this.type = "integer";\n    this.repr = "";\n    this.unit = "";\n  }\n  toString() {\n    return "DIM(" + this.value + "," + this.unit + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = "\\\\65 " + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = "" + string;\n  let result = "";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + code.toString(16) + " ";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code === 34 || code === 92)\n      result += "\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector "${selector}"`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    while (!isCloseParen() && !isEOF())\n      s += tokens[pos++].toSource();\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "left-of", "right-of", "above", "below", "near"]);\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);\nvar customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse("[" + part.body + "]");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === "css" ? "" : p.name + "=";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction visitAllSelectorParts(selector, visitor) {\n  const visit = (selector2, nested) => {\n    for (const part of selector2.parts) {\n      visitor(part, nested);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body.parsed, true);\n    }\n  };\n  visit(selector, false);\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expressiion");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/reactSelectorEngine.ts\nfunction getFunctionComponentName(component) {\n  return component.displayName || component.name || "Anonymous";\n}\nfunction getComponentName(reactElement) {\n  if (reactElement.type) {\n    switch (typeof reactElement.type) {\n      case "function":\n        return getFunctionComponentName(reactElement.type);\n      case "string":\n        return reactElement.type;\n      case "object":\n        return reactElement.type.displayName || (reactElement.type.render ? getFunctionComponentName(reactElement.type.render) : "");\n    }\n  }\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === "string")\n      return elementType;\n    if (typeof elementType === "function")\n      return elementType.displayName || elementType.name || "Anonymous";\n  }\n  return "";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === "function" || typeof elementType === "string";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = reactElement.memoizedProps || ((_a = reactElement._currentElement) == null ? void 0 : _a.props);\n  if (!props || typeof props === "string")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = reactElement.stateNode || reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode);\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    const reactNode = node;\n    const rootKey = Object.keys(reactNode).find((key) => key.startsWith("__reactContainer") && reactNode[key] !== null);\n    if (rootKey) {\n      roots.push(reactNode[rootKey].stateNode.current);\n    } else {\n      const legacyRootKey = "_reactRootContainer";\n      if (reactNode.hasOwnProperty(legacyRootKey) && reactNode[legacyRootKey] !== null) {\n        roots.push(reactNode[legacyRootKey]._internalRoot.current);\n      }\n    }\n    if (node instanceof Element && node.hasAttribute("data-reactroot")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar ReactEngine = {\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const reactRoots = findReactRoots(scope.ownerDocument || scope);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n};\n\n// packages/playwright-core/src/server/injected/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, "").replace(/\\\\/g, "/");\n  let result = normalized.substring(normalized.lastIndexOf("/") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : "";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function saveComponentName(instance2, key) {\n    instance2.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance2) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance2.type || {});\n    if (name)\n      return name;\n    if (instance2.root === instance2)\n      return "Root";\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components)\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\n        return saveComponentName(instance2, key);\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components)\n      if (instance2.appContext.components[key] === instance2.type)\n        return saveComponentName(instance2, key);\n    return "Anonymous Component";\n  }\n  function isBeingDestroyed(instance2) {\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\n  }\n  function isFragment(instance2) {\n    return instance2.subTree.type.toString() === "Symbol(Fragment)";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance2) {\n    if (isFragment(instance2))\n      return getFragmentRootElements(instance2.subTree);\n    return [instance2.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance2),\n      props: instance2.props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction buildComponentsTreeVue2(instance) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function getInstanceName(instance2) {\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\n    if (name)\n      return name;\n    return instance2.$root === instance2 ? "Root" : "Anonymous Component";\n  }\n  function getInternalInstanceChildren(instance2) {\n    if (instance2.$children)\n      return instance2.$children;\n    if (Array.isArray(instance2.subTree.children))\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\n      rootElements: [instance2.$el],\n      props: instance2._props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const document = root.ownerDocument || root;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = /* @__PURE__ */ new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar VueEngine = {\n  queryAll(scope, selector) {\n    const document = scope.ownerDocument || scope;\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n};\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "`") + char;\n  throw new Error("Invalid escape char");\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();\n}\nfunction cssEscape(s) {\n  let result = "";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\nfunction normalizeWhiteSpace(text) {\n  return text.replace(/\\u200b/g, "").trim().replace(/\\s+/g, " ");\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== "string")\n    return String(text).replace(/>>/g, "\\\\>\\\\>");\n  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== "string")\n    return String(value).replace(/>>/g, "\\\\>\\\\>");\n  return `"${value.replace(/\\\\/g, "\\\\\\\\").replace(/["]/g, \'\\\\"\')}"${exact ? "s" : "i"}`;\n}\n\n// packages/playwright-core/src/server/injected/roleSelectorEngine.ts\nvar kSupportedAttributes = ["selected", "checked", "pressed", "expanded", "level", "disabled", "name", "include-hidden"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`"${attr}" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `"${role2}"`).join(", ")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== "<truthy>" && !values.includes(attr.value))\n    throw new Error(`"${attr.name}" must be one of ${values.map((v) => JSON.stringify(v)).join(", ")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`"${attr.name}" does not support "${attr.op}" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  const options = { role };\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case "checked": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.checked = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "pressed": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.pressed = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "selected": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.selected = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "expanded": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.expanded = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "level": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === "string")\n          attr.value = +attr.value;\n        if (attr.op !== "=" || typeof attr.value !== "number" || Number.isNaN(attr.value))\n          throw new Error(`"level" attribute must be compared to a number`);\n        options.level = attr.value;\n        break;\n      }\n      case "disabled": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.disabled = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      case "name": {\n        if (attr.op === "<truthy>")\n          throw new Error(`"name" attribute must have a value`);\n        if (typeof attr.value !== "string" && !(attr.value instanceof RegExp))\n          throw new Error(`"name" attribute must be a string or a regular expression`);\n        options.name = attr.value;\n        options.nameOp = attr.op;\n        options.exact = attr.caseSensitive;\n        break;\n      }\n      case "include-hidden": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        options.includeHidden = attr.op === "<truthy>" ? true : attr.value;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute "${attr.name}", must be one of ${kSupportedAttributes.map((a) => `"${a}"`).join(", ")}.`);\n      }\n    }\n  }\n  return options;\n}\nfunction queryRole(scope, options, internal) {\n  const result = [];\n  const match = (element) => {\n    if (getAriaRole(element) !== options.role)\n      return;\n    if (options.selected !== void 0 && getAriaSelected(element) !== options.selected)\n      return;\n    if (options.checked !== void 0 && getAriaChecked(element) !== options.checked)\n      return;\n    if (options.pressed !== void 0 && getAriaPressed(element) !== options.pressed)\n      return;\n    if (options.expanded !== void 0 && getAriaExpanded(element) !== options.expanded)\n      return;\n    if (options.level !== void 0 && getAriaLevel(element) !== options.level)\n      return;\n    if (options.disabled !== void 0 && getAriaDisabled(element) !== options.disabled)\n      return;\n    if (!options.includeHidden) {\n      const isHidden = isElementHiddenForAria(element);\n      if (isHidden)\n        return;\n    }\n    if (options.name !== void 0) {\n      const accessibleName = normalizeWhiteSpace(getElementAccessibleName(element, !!options.includeHidden));\n      if (typeof options.name === "string")\n        options.name = normalizeWhiteSpace(options.name);\n      if (internal && !options.exact && options.nameOp === "=")\n        options.nameOp = "*=";\n      if (!matchesAttributePart(accessibleName, { name: "", jsonPath: [], op: options.nameOp || "=", value: options.name, caseSensitive: !!options.exact }))\n        return;\n    }\n    result.push(element);\n  };\n  const query = (root) => {\n    const shadows = [];\n    if (root.shadowRoot)\n      shadows.push(root.shadowRoot);\n    for (const element of root.querySelectorAll("*")) {\n      match(element);\n      if (element.shadowRoot)\n        shadows.push(element.shadowRoot);\n    }\n    shadows.forEach(query);\n  };\n  query(scope);\n  return result;\n}\nfunction createRoleEngine(internal) {\n  return {\n    queryAll: (scope, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      const role = parsed.name.toLowerCase();\n      if (!role)\n        throw new Error(`Role must not be empty`);\n      const options = validateAttributes(parsed.attributes, role);\n      beginAriaCaches();\n      try {\n        return queryRole(scope, options, internal);\n      } finally {\n        endAriaCaches();\n      }\n    }\n  };\n}\n\n// packages/playwright-core/src/server/injected/layoutSelectorUtils.ts\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nvar kLayoutSelectorNames = ["left-of", "right-of", "above", "below", "near"];\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\n  const box = element.getBoundingClientRect();\n  const scorer = { "left-of": boxLeftOf, "right-of": boxRightOf, "above": boxAbove, "below": boxBelow, "near": boxNear }[name];\n  let bestScore;\n  for (const e of inner) {\n    if (e === element)\n      continue;\n    const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n    if (score === void 0)\n      continue;\n    if (bestScore === void 0 || score < bestScore)\n      bestScore = score;\n  }\n  return bestScore;\n}\n\n// packages/playwright-core/src/server/injected/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor(extraEngines) {\n    this._engines = /* @__PURE__ */ new Map();\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\n    this._cacheMatches = /* @__PURE__ */ new Map();\n    this._cacheQuery = /* @__PURE__ */ new Map();\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\n    this._cacheText = /* @__PURE__ */ new Map();\n    this._retainCacheCounter = 0;\n    for (const [name, engine] of extraEngines)\n      this._engines.set(name, engine);\n    this._engines.set("not", notEngine);\n    this._engines.set("is", isEngine);\n    this._engines.set("where", isEngine);\n    this._engines.set("has", hasEngine);\n    this._engines.set("scope", scopeEngine);\n    this._engines.set("light", lightEngine);\n    this._engines.set("visible", visibleEngine);\n    this._engines.set("text", textEngine);\n    this._engines.set("text-is", textIsEngine);\n    this._engines.set("text-matches", textMatchesEngine);\n    this._engines.set("has-text", hasTextEngine);\n    this._engines.set("right-of", createLayoutEngine("right-of"));\n    this._engines.set("left-of", createLayoutEngine("left-of"));\n    this._engines.set("above", createLayoutEngine("above"));\n    this._engines.set("below", createLayoutEngine("below"));\n    this._engines.set("near", createLayoutEngine("near"));\n    this._engines.set("nth-match", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join("|") !== parserNames.join("|"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join("|")} vs ${parserNames.join("|")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === "object" && s && (Array.isArray(s) || "simples" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector "${s}"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow, context.originalScope], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        if (this._hasScopeClause(selector))\n          context = this._expandContextForScopeMatching(context);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = /* @__PURE__ */ new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _hasScopeClause(selector) {\n    return selector.simples.some((simple) => simple.selector.functions.some((f) => f.name === "scope"));\n  }\n  _expandContextForScopeMatching(context) {\n    if (context.scope.nodeType !== 1)\n      return context;\n    const scope = parentElementOrShadowHost(context.scope);\n    if (!scope)\n      return context;\n    return { ...context, scope, originalScope: context.originalScope || context.scope };\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow, context.originalScope], () => {\n      if (element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || "*");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let css = simple.css;\n      const funcs = simple.functions;\n      if (css === "*" && funcs.length)\n        css = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css !== void 0) {\n        elements = this._queryCSS(context, css);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow, context.originalScope], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === ">") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === "+") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === "") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === "~") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "~")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === ">=") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator "${combinator}"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, "*").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, context.originalScope, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css) {\n    return element.matches(css);\n  }\n  _queryCSS(context, css) {\n    return this._cached(this._cacheQueryCSS, css, [context.scope, context.pierceShadow, context.originalScope], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll("*")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine "${name}"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"has" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9)\n      return element === actualScope.documentElement;\n    return element === actualScope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    const actualScope = context.originalScope || context.scope;\n    if (actualScope.nodeType === 9) {\n      const root = actualScope.documentElement;\n      return root ? [root] : [];\n    }\n    if (actualScope.nodeType === 1)\n      return [actualScope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"not" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`"visible" engine expects no arguments`);\n    return isElementVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => normalizeWhiteSpace(elementText2.full).toLowerCase().includes(text);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text-is" engine expects a single string`);\n    const text = normalizeWhiteSpace(args[0]);\n    const matcher = (elementText2) => {\n      if (!text && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === text);\n    };\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== "none";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== "string" || args.length > 2 || args.length === 2 && typeof args[1] !== "string")\n      throw new Error(`"text-matches" engine expects a regexp body and optional regexp flags`);\n    const re = new RegExp(args[0], args.length === 2 ? args[1] : void 0);\n    const matcher = (elementText2) => re.test(elementText2.full);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === "self";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"has-text" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const text = normalizeWhiteSpace(args[0]).toLowerCase();\n    const matcher = (elementText2) => normalizeWhiteSpace(elementText2.full).toLowerCase().includes(text);\n    return matcher(elementText(evaluator._cacheText, element));\n  }\n};\nfunction createLayoutEngine(name) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === "number" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`"${name}" engine expects a selector list and optional maximum distance in pixels`);\n      const inner = evaluator.query(context, queryArgs);\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\n      if (score === void 0)\n        return false;\n      evaluator._markScore(element, score);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`"nth-match" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== "number" || index < 1)\n      throw new Error(`"nth-match" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = /* @__PURE__ */ new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  for (const e of elements)\n    append(e).taken = true;\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kTextScoreRange = 10;\nvar kExactPenalty = kTextScoreRange / 2;\nvar kTestIdScore = 1;\nvar kOtherTestIdScore = 2;\nvar kIframeByAttributeScore = 10;\nvar kBeginPenalizedScore = 50;\nvar kPlaceholderScore = 100;\nvar kLabelScore = 120;\nvar kRoleWithNameScore = 140;\nvar kAltTextScore = 160;\nvar kTextScore = 180;\nvar kTitleScore = 200;\nvar kTextScoreRegex = 250;\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\nvar kTextScoreExact = kTextScore + kExactPenalty;\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\nvar kEndPenalizedScore = 300;\nvar kCSSIdScore = 500;\nvar kRoleWithoutNameScore = 510;\nvar kCSSInputTypeNameScore = 520;\nvar kCSSTagNameScore = 530;\nvar kNthScore = 1e4;\nvar kCSSFallbackScore = 1e7;\nfunction generateSelector(injectedScript, targetElement, options) {\n  var _a;\n  injectedScript._evaluator.begin();\n  beginAriaCaches();\n  try {\n    targetElement = closestCrossShadow(targetElement, "button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]", options.root) || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, options);\n    const selector = joinTokens(targetTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    endAriaCaches();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(injectedScript, targetElement, options) {\n  if (options.root && !isInsideScope(options.root, targetElement))\n    throw new Error(`Target element must belong to the root\'s subtree`);\n  if (targetElement === options.root)\n    return [{ engine: "css", selector: ":scope", score: 1 }];\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    var _a;\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildNoTextCandidates(injectedScript, element, options).filter((token) => !options.omitInternalEngines || !token.engine.startsWith("internal:")).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, (_a = options.root) != null ? _a : targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true) || cssFallback(injectedScript, targetElement, options);\n}\nfunction buildNoTextCandidates(injectedScript, element, options) {\n  const candidates = [];\n  {\n    for (const attr of ["data-testid", "data-test-id", "data-test"]) {\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\n        candidates.push({ engine: "css", selector: `[${attr}=${quoteAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\n    }\n    const idAttr = element.getAttribute("id");\n    if (idAttr && !isGuidLike(idAttr))\n      candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\n  }\n  if (element.nodeName === "IFRAME") {\n    for (const attribute of ["name", "title"]) {\n      if (element.getAttribute(attribute))\n        candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\n    }\n    if (element.getAttribute(options.testIdAttributeName))\n      candidates.push({ engine: "css", selector: `[${options.testIdAttributeName}=${quoteAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\n    penalizeScoreForLength([candidates]);\n    return candidates;\n  }\n  if (element.getAttribute(options.testIdAttributeName))\n    candidates.push({ engine: "internal:testid", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\n  if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n    const input = element;\n    if (input.placeholder) {\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, false)}]`, score: kPlaceholderScore });\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\n    }\n  }\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\n  for (const label of labels) {\n    const labelText = label.full.trim();\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, false), score: kLabelScore });\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole))\n    candidates.push({ engine: "internal:role", selector: ariaRole, score: kRoleWithoutNameScore });\n  if (element.getAttribute("alt") && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName)) {\n    candidates.push({ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(element.getAttribute("alt"), false)}]`, score: kAltTextScore });\n    candidates.push({ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(element.getAttribute("alt"), true)}]`, score: kAltTextScoreExact });\n  }\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "FRAME", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute("name"))}]`, score: kCSSInputTypeNameScore });\n  if (element.getAttribute("title")) {\n    candidates.push({ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(element.getAttribute("title"), false)}]`, score: kTitleScore });\n    candidates.push({ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(element.getAttribute("title"), true)}]`, score: kTitleScoreExact });\n  }\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute("type"))}]`, score: kCSSInputTypeNameScore });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.getAttribute("type") !== "hidden")\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\n  penalizeScoreForLength([candidates]);\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const candidates = [];\n  const fullText = normalizeWhiteSpace(elementText(injectedScript._evaluator._cacheText, element).full);\n  const text = fullText.substring(0, 80);\n  if (text) {\n    const escaped = escapeForTextSelector(text, false);\n    if (isTargetNode) {\n      candidates.push([{ engine: "internal:text", selector: escaped, score: kTextScore }]);\n      candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\n    }\n    const cssToken = { engine: "css", selector: element.nodeName.toLowerCase(), score: kCSSTagNameScore };\n    candidates.push([cssToken, { engine: "internal:has-text", selector: escaped, score: kTextScore }]);\n    if (fullText.length <= 80)\n      candidates.push([cssToken, { engine: "internal:has-text", selector: "/^" + escapeRegExp(fullText) + "$/", score: kTextScoreRegex }]);\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole)) {\n    const ariaName = getElementAccessibleName(element, false);\n    if (ariaName) {\n      candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore }]);\n      candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact }]);\n    }\n  }\n  penalizeScoreForLength(candidates);\n  return candidates;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id="${cssEscape(id)}"]`;\n}\nfunction cssFallback(injectedScript, targetElement, options) {\n  var _a;\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" > ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, root, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kCSSFallbackScore };\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = "";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + cssEscape(classes.slice(0, i + 1).join("."));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction quoteAttributeValue(text) {\n  return `"${cssEscape(text).replace(/\\\\ /g, " ")}"`;\n}\nfunction penalizeScoreForLength(groups) {\n  for (const group of groups) {\n    for (const token of group) {\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\n    }\n  }\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    if (result[0] === targetElement && result.length === 1) {\n      return tokens;\n    }\n    const index = result.indexOf(targetElement);\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false, playSafe = false) {\n  return asLocators(lang, selector, isFrameLocator, playSafe)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, playSafe = false, maxOutputSize = 20) {\n  if (playSafe) {\n    try {\n      return innerAsLocators(generators[lang], parseSelector(selector), isFrameLocator, maxOutputSize);\n    } catch (e) {\n      return [selector];\n    }\n  } else {\n    return innerAsLocators(generators[lang], parseSelector(selector), isFrameLocator, maxOutputSize);\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  for (let index = 0; index < parts.length - 1; index++) {\n    if (parts[index].name === "nth" && parts[index + 1].name === "internal:control" && parts[index + 1].body === "enter-frame") {\n      const [nth] = parts.splice(index, 1);\n      parts.splice(index + 1, 0, nth);\n    }\n  }\n  const tokens = [];\n  let nextBase = isFrameLocator ? "frame-locator" : "page";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = "locator";\n    if (part.name === "nth") {\n      if (part.body === "0")\n        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);\n      else if (part.body === "-1")\n        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);\n      else\n        tokens.push([factory.generateLocator(base, "nth", part.body)]);\n      continue;\n    }\n    if (part.name === "internal:text") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "text", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:has-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has-not-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));\n      continue;\n    }\n    if (part.name === "internal:has-not") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));\n      continue;\n    }\n    if (part.name === "internal:and") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));\n      continue;\n    }\n    if (part.name === "internal:or") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));\n      continue;\n    }\n    if (part.name === "internal:label") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "label", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:role") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === "name") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === "level" && typeof attr.value === "string")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === "internal:testid") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, "test-id", value)]);\n      continue;\n    }\n    if (part.name === "internal:attr") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === "placeholder") {\n        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);\n        continue;\n      }\n      if (name === "alt") {\n        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);\n        continue;\n      }\n      if (name === "title") {\n        tokens.push([factory.generateLocator(base, "title", text, { exact })]);\n        continue;\n      }\n    }\n    let locatorType = "default";\n    const nextPart = parts[index + 1];\n    if (nextPart && nextPart.name === "internal:control" && nextPart.body === "enter-frame") {\n      locatorType = "frame";\n      nextBase = "frame-locator";\n      index++;\n    }\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, locatorType, selectorPart);\n    if (locatorType === "default" && nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });\n        const options = {};\n        if (nextPart.name === "internal:has-text")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, "default", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    tokens.push([locatorPart]);\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => "");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return currentTokens.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith(\'"\')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith(\'"s\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith(\'"i\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frameLocator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${options.name}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case "has":\n        return `filter({ has: ${body} })`;\n      case "hasNot":\n        return `filter({ hasNot: ${body} })`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${body})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return String(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return String(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, "\'");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frame_locator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first`;\n      case "last":\n        return `last`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === "string" ? this.quote(value) : value;\n          if (typeof value === "boolean")\n            valueString = value ? "True" : "False";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case "has-not-text":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case "has":\n        return `filter(has=${body})`;\n      case "hasNot":\n        return `filter(has_not=${body})`;\n      case "and":\n        return `and_(${body})`;\n      case "or":\n        return `or_(${body})`;\n      case "test-id":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("get_by_text", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("get_by_alt_text", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("get_by_placeholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("get_by_label", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("get_by_title", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";\n    return `re.compile(r"${body.source.replace(/\\\\\\//, "/").replace(/"/g, \'\\\\"\')}"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case "page":\n        clazz = "Page";\n        break;\n      case "frame-locator":\n        clazz = "FrameLocator";\n        break;\n      case "locator":\n        clazz = "Locator";\n        break;\n    }\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frameLocator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case "has-text":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case "has-not-text":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case "has":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case "hasNot":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact(clazz, "getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case "frame":\n        return `FrameLocator(${this.quote(body)})`;\n      case "nth":\n        return `Nth(${body})`;\n      case "first":\n        return `First`;\n      case "last":\n        return `Last`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case "has-text":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case "has":\n        return `Filter(new() { Has = ${body} })`;\n      case "hasNot":\n        return `Filter(new() { HasNot = ${body} })`;\n      case "and":\n        return `And(${body})`;\n      case "or":\n        return `Or(${body})`;\n      case "test-id":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("GetByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("GetByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("GetByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("GetByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";\n    return `new Regex(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: new JavaScriptLocatorFactory(),\n  python: new PythonLocatorFactory(),\n  java: new JavaLocatorFactory(),\n  csharp: new CSharpLocatorFactory(),\n  jsonl: new JsonlLocatorFactory()\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/playwright-core/src/server/injected/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._highlightEntries = [];\n    this._language = "javascript";\n    this._injectedScript = injectedScript;\n    const document = injectedScript.document;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement("x-pw-glass");\n    this._glassPaneElement.style.position = "fixed";\n    this._glassPaneElement.style.top = "0";\n    this._glassPaneElement.style.right = "0";\n    this._glassPaneElement.style.bottom = "0";\n    this._glassPaneElement.style.left = "0";\n    this._glassPaneElement.style.zIndex = "2147483647";\n    this._glassPaneElement.style.pointerEvents = "none";\n    this._glassPaneElement.style.display = "flex";\n    this._glassPaneElement.style.backgroundColor = "transparent";\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? "open" : "closed" });\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n    const styleElement = document.createElement("style");\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\n                      \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n    this._glassPaneShadow.appendChild(styleElement);\n  }\n  install() {\n    this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\n  }\n  setLanguage(language) {\n    this._language = language;\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this.updateHighlight(this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement), stringifySelector(selector), false);\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  isInstalled() {\n    return this._glassPaneElement.parentElement === this._injectedScript.document.documentElement && !this._glassPaneElement.nextElementSibling;\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n    if (this._isUnderTest)\n      console.error("Action point for test: " + JSON.stringify({ x, y }));\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._highlightEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._highlightEntries = [];\n  }\n  updateHighlight(elements, selector, isRecording) {\n    let color;\n    if (isRecording)\n      color = "#dc6f6f7f";\n    else\n      color = elements.length > 1 ? "#f6b26b7f" : "#6fa8dc7f";\n    this._innerUpdateHighlight(elements, { color, tooltipText: selector ? asLocator(this._language, selector) : "" });\n  }\n  maskElements(elements, color) {\n    this._innerUpdateHighlight(elements, { color: color ? color : "#F0F" });\n  }\n  _innerUpdateHighlight(elements, options) {\n    if (this._highlightIsUpToDate(elements, options.tooltipText))\n      return;\n    this.clearHighlight();\n    for (let i = 0; i < elements.length; ++i) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (options.tooltipText) {\n        tooltipElement = this._injectedScript.document.createElement("x-pw-tooltip");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        const suffix = elements.length > 1 ? ` [${i + 1} of ${elements.length}]` : "";\n        tooltipElement.textContent = options.tooltipText + suffix;\n        tooltipElement.style.top = "0";\n        tooltipElement.style.left = "0";\n        tooltipElement.style.display = "flex";\n      }\n      this._highlightEntries.push({ targetElement: elements[i], tooltipElement, highlightElement, tooltipText: options.tooltipText });\n    }\n    for (const entry of this._highlightEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const tooltipWidth = entry.tooltipElement.offsetWidth;\n      const tooltipHeight = entry.tooltipElement.offsetHeight;\n      const totalWidth = this._glassPaneElement.offsetWidth;\n      const totalHeight = this._glassPaneElement.offsetHeight;\n      let anchorLeft = entry.box.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\n        anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = entry.box.bottom + 5;\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        if (entry.box.top > tooltipHeight + 5) {\n          anchorTop = entry.box.top - tooltipHeight - 5;\n        } else {\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._highlightEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + "px";\n        entry.tooltipElement.style.left = entry.tooltipLeft + "px";\n      }\n      const box = entry.box;\n      entry.highlightElement.style.backgroundColor = options.color;\n      entry.highlightElement.style.left = box.x + "px";\n      entry.highlightElement.style.top = box.y + "px";\n      entry.highlightElement.style.width = box.width + "px";\n      entry.highlightElement.style.height = box.height + "px";\n      entry.highlightElement.style.display = "block";\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n  }\n  _highlightIsUpToDate(elements, tooltipText) {\n    if (elements.length !== this._highlightEntries.length)\n      return false;\n    for (let i = 0; i < this._highlightEntries.length; ++i) {\n      if (tooltipText !== this._highlightEntries[i].tooltipText)\n        return false;\n      if (elements[i] !== this._highlightEntries[i].targetElement)\n        return false;\n      const oldBox = this._highlightEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box = elements[i].getBoundingClientRect();\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    const highlightElement = this._injectedScript.document.createElement("x-pw-highlight");\n    highlightElement.style.position = "absolute";\n    highlightElement.style.top = "0";\n    highlightElement.style.left = "0";\n    highlightElement.style.width = "0";\n    highlightElement.style.height = "0";\n    highlightElement.style.boxSizing = "border-box";\n    return highlightElement;\n  }\n};\n\n// packages/playwright-core/src/server/injected/injectedScript.ts\nvar InjectedScript = class {\n  constructor(window, isUnderTest, sdkLanguage, testIdAttributeNameForStrictErrorAndConsoleCodegen, stableRafCount, browserName, customEngines) {\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = "data-testid";\n    this.window = window;\n    this.document = window.document;\n    this.isUnderTest = isUnderTest;\n    this._sdkLanguage = sdkLanguage;\n    this._testIdAttributeNameForStrictErrorAndConsoleCodegen = testIdAttributeNameForStrictErrorAndConsoleCodegen;\n    this._evaluator = new SelectorEvaluatorImpl(/* @__PURE__ */ new Map());\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set("xpath", XPathEngine);\n    this._engines.set("xpath:light", XPathEngine);\n    this._engines.set("_react", ReactEngine);\n    this._engines.set("_vue", VueEngine);\n    this._engines.set("role", createRoleEngine(false));\n    this._engines.set("text", this._createTextEngine(true, false));\n    this._engines.set("text:light", this._createTextEngine(false, false));\n    this._engines.set("id", this._createAttributeEngine("id", true));\n    this._engines.set("id:light", this._createAttributeEngine("id", false));\n    this._engines.set("data-testid", this._createAttributeEngine("data-testid", true));\n    this._engines.set("data-testid:light", this._createAttributeEngine("data-testid", false));\n    this._engines.set("data-test-id", this._createAttributeEngine("data-test-id", true));\n    this._engines.set("data-test-id:light", this._createAttributeEngine("data-test-id", false));\n    this._engines.set("data-test", this._createAttributeEngine("data-test", true));\n    this._engines.set("data-test:light", this._createAttributeEngine("data-test", false));\n    this._engines.set("css", this._createCSSEngine());\n    this._engines.set("nth", { queryAll: () => [] });\n    this._engines.set("visible", this._createVisibleEngine());\n    this._engines.set("internal:control", this._createControlEngine());\n    this._engines.set("internal:has", this._createHasEngine());\n    this._engines.set("internal:has-not", this._createHasNotEngine());\n    this._engines.set("internal:and", { queryAll: () => [] });\n    this._engines.set("internal:or", { queryAll: () => [] });\n    this._engines.set("internal:label", this._createInternalLabelEngine());\n    this._engines.set("internal:text", this._createTextEngine(true, true));\n    this._engines.set("internal:has-text", this._createInternalHasTextEngine());\n    this._engines.set("internal:has-not-text", this._createInternalHasNotTextEngine());\n    this._engines.set("internal:attr", this._createNamedAttributeEngine());\n    this._engines.set("internal:testid", this._createNamedAttributeEngine());\n    this._engines.set("internal:role", createRoleEngine(true));\n    for (const { name, engine } of customEngines)\n      this._engines.set(name, engine);\n    this._stableRafCount = stableRafCount;\n    this._browserName = browserName;\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (isUnderTest)\n      this.window.__injectedScript = this;\n  }\n  eval(expression) {\n    return this.window.eval(expression);\n  }\n  testIdAttributeNameForStrictErrorAndConsoleCodegen() {\n    return this._testIdAttributeNameForStrictErrorAndConsoleCodegen;\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    visitAllSelectorParts(result, (part) => {\n      if (!this._engines.has(part.name))\n        throw this.createStacklessError(`Unknown engine "${part.name}" while parsing selector ${selector}`);\n    });\n    return result;\n  }\n  generateSelector(targetElement, options) {\n    return generateSelector(this, targetElement, { ...options, testIdAttributeName: this._testIdAttributeNameForStrictErrorAndConsoleCodegen }).selector;\n  }\n  querySelector(selector, root, strict) {\n    const result = this.querySelectorAll(selector, root);\n    if (strict && result.length > 1)\n      throw this.strictModeViolationError(selector, result);\n    return result[0];\n  }\n  _queryNth(elements, part) {\n    const list = [...elements];\n    let nth = +part.body;\n    if (nth === -1)\n      nth = list.length - 1;\n    return new Set(list.slice(nth, nth + 1));\n  }\n  _queryLayoutSelector(elements, part, originalRoot) {\n    const name = part.name;\n    const body = part.body;\n    const result = [];\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\n    for (const element of elements) {\n      const score = layoutSelectorScore(name, element, inner, body.distance);\n      if (score !== void 0)\n        result.push({ element, score });\n    }\n    result.sort((a, b) => a.score - b.score);\n    return new Set(result.map((r) => r.element));\n  }\n  querySelectorAll(selector, root) {\n    if (selector.capture !== void 0) {\n      if (selector.parts.some((part) => part.name === "nth"))\n        throw this.createStacklessError(`Can\'t query n-th element in a request with the capture.`);\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\n      if (selector.capture < selector.parts.length - 1) {\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\n        const has = { name: "internal:has", body: { parsed }, source: stringifySelector(parsed) };\n        withHas.parts.push(has);\n      }\n      return this.querySelectorAll(withHas, root);\n    }\n    if (!root["querySelectorAll"])\n      throw this.createStacklessError("Node is not queryable.");\n    if (selector.capture !== void 0) {\n      throw this.createStacklessError("Internal error: there should not be a capture in the selector.");\n    }\n    this._evaluator.begin();\n    try {\n      let roots = /* @__PURE__ */ new Set([root]);\n      for (const part of selector.parts) {\n        if (part.name === "nth") {\n          roots = this._queryNth(roots, part);\n        } else if (part.name === "internal:and") {\n          const andElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(andElements.filter((e) => roots.has(e)));\n        } else if (part.name === "internal:or") {\n          const orElements = this.querySelectorAll(part.body.parsed, root);\n          roots = new Set(sortInDOMOrder(/* @__PURE__ */ new Set([...roots, ...orElements])));\n        } else if (kLayoutSelectorNames.includes(part.name)) {\n          roots = this._queryLayoutSelector(roots, part, root);\n        } else {\n          const next = /* @__PURE__ */ new Set();\n          for (const root2 of roots) {\n            const all = this._queryEngineAll(part, root2);\n            for (const one of all)\n              next.add(one);\n          }\n          roots = next;\n        }\n      }\n      return [...roots];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    const result = this._engines.get(part.name).queryAll(root, part.body);\n    for (const element of result) {\n      if (!("nodeName" in element))\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n    }\n    return result;\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css, functions: [] }, combinator: "" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    return {\n      queryAll: (root, body) => {\n        return this._evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow, internal) {\n    const queryAll = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector, internal);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === "lax" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\n        if (matches === "none")\n          lastDidNotMatchSelf = element;\n        if (matches === "self" || matches === "selfAndChildren" && kind === "strict" && !internal)\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, "*");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return { queryAll };\n  }\n  _createInternalHasTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [element] : [];\n      }\n    };\n  }\n  _createInternalHasNotTextEngine() {\n    return {\n      queryAll: (root, selector) => {\n        if (root.nodeType !== 1)\n          return [];\n        const element = root;\n        const text = elementText(this._evaluator._cacheText, element);\n        const { matcher } = createTextMatcher(selector, true);\n        return matcher(text) ? [] : [element];\n      }\n    };\n  }\n  _createInternalLabelEngine() {\n    return {\n      queryAll: (root, selector) => {\n        const { matcher } = createTextMatcher(selector, true);\n        const allElements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, "*");\n        return allElements.filter((element) => {\n          return getElementLabels(this._evaluator._cacheText, element).some((label) => matcher(label));\n        });\n      }\n    };\n  }\n  _createNamedAttributeEngine() {\n    const queryAll = (root, selector) => {\n      const parsed = parseAttributeSelector(selector, true);\n      if (parsed.name || parsed.attributes.length !== 1)\n        throw new Error("Malformed attribute selector: " + selector);\n      const { name, value, caseSensitive } = parsed.attributes[0];\n      const lowerCaseValue = caseSensitive ? null : value.toLowerCase();\n      let matcher;\n      if (value instanceof RegExp)\n        matcher = (s) => !!s.match(value);\n      else if (caseSensitive)\n        matcher = (s) => s === value;\n      else\n        matcher = (s) => s.toLowerCase().includes(lowerCaseValue);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: true }, `[${name}]`);\n      return elements.filter((e) => matcher(e.getAttribute(name)));\n    };\n    return { queryAll };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === "enter-frame")\n          return [];\n        if (body === "return-empty")\n          return [];\n        if (body === "component") {\n          if (root.nodeType !== 1)\n            return [];\n          return [root.childElementCount === 1 ? root.firstElementChild : root];\n        }\n        throw new Error(`Internal error, unknown internal:control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createHasNotEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [] : [root];\n    };\n    return { queryAll };\n  }\n  _createVisibleEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      return isElementVisible(root) === Boolean(body) ? [root] : [];\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = this.window.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports.default();\n    })()`);\n    return new constrFunction(this, params);\n  }\n  isVisible(element) {\n    return isElementVisible(element);\n  }\n  async viewportRatio(element) {\n    return await new Promise((resolve) => {\n      const observer = new IntersectionObserver((entries) => {\n        resolve(entries[0].intersectionRatio);\n        observer.disconnect();\n      });\n      observer.observe(element);\n      requestAnimationFrame(() => {\n      });\n    });\n  }\n  pollRaf(predicate) {\n    return this.poll(predicate, (next) => requestAnimationFrame(next));\n  }\n  poll(predicate, scheduleNext) {\n    return this._runAbortableTask((progress) => {\n      let fulfill;\n      let reject;\n      const result = new Promise((f, r) => {\n        fulfill = f;\n        reject = r;\n      });\n      const next = () => {\n        if (progress.aborted)\n          return;\n        try {\n          const success = predicate(progress);\n          if (success !== progress.continuePolling)\n            fulfill(success);\n          else\n            scheduleNext(next);\n        } catch (e) {\n          progress.log("  " + e.message);\n          reject(e);\n        }\n      };\n      next();\n      return result;\n    });\n  }\n  _runAbortableTask(task) {\n    let unsentLog = [];\n    let takeNextLogsCallback;\n    let taskFinished = false;\n    const logReady = () => {\n      if (!takeNextLogsCallback)\n        return;\n      takeNextLogsCallback(unsentLog);\n      unsentLog = [];\n      takeNextLogsCallback = void 0;\n    };\n    const takeNextLogs = () => new Promise((fulfill) => {\n      takeNextLogsCallback = fulfill;\n      if (unsentLog.length || taskFinished)\n        logReady();\n    });\n    let lastMessage = "";\n    const progress = {\n      injectedScript: this,\n      aborted: false,\n      continuePolling: Symbol("continuePolling"),\n      log: (message) => {\n        lastMessage = message;\n        unsentLog.push({ message });\n        logReady();\n      },\n      logRepeating: (message) => {\n        if (message !== lastMessage)\n          progress.log(message);\n      }\n    };\n    const run = () => {\n      const result = task(progress);\n      result.finally(() => {\n        taskFinished = true;\n        logReady();\n      });\n      return result;\n    };\n    return {\n      takeNextLogs,\n      run,\n      cancel: () => {\n        progress.aborted = true;\n      },\n      takeLastLogs: () => unsentLog\n    };\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || "", 10), top: parseInt(style.borderTopWidth || "", 10) };\n  }\n  describeIFrameStyle(iframe) {\n    if (!iframe.ownerDocument || !iframe.ownerDocument.defaultView)\n      return "error:notconnected";\n    const defaultView = iframe.ownerDocument.defaultView;\n    for (let e = iframe; e; e = parentElementOrShadowHost(e)) {\n      if (defaultView.getComputedStyle(e).transform !== "none")\n        return "transformed";\n    }\n    const iframeStyle = defaultView.getComputedStyle(iframe);\n    return {\n      left: parseInt(iframeStyle.borderLeftWidth || "", 10) + parseInt(iframeStyle.paddingLeft || "", 10),\n      top: parseInt(iframeStyle.borderTopWidth || "", 10) + parseInt(iframeStyle.paddingTop || "", 10)\n    };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (behavior === "none")\n      return element;\n    if (!element.matches("input, textarea, select")) {\n      if (behavior === "button-link")\n        element = element.closest("button, [role=button], a, [role=link]") || element;\n      else\n        element = element.closest("button, [role=button], [role=checkbox], [role=radio]") || element;\n    }\n    if (behavior === "follow-label") {\n      if (!element.matches("input, textarea, button, select, [role=button], [role=checkbox], [role=radio]") && !element.isContentEditable) {\n        element = element.closest("label") || element;\n      }\n      if (element.nodeName === "LABEL")\n        element = element.control || element;\n    }\n    return element;\n  }\n  waitForElementStatesAndPerformAction(node, states, force, callback) {\n    let lastRect;\n    let counter = 0;\n    let samePositionCounter = 0;\n    let lastTime = 0;\n    return this.pollRaf((progress) => {\n      if (force) {\n        progress.log(`    forcing action`);\n        return callback(node, progress);\n      }\n      for (const state of states) {\n        if (state !== "stable") {\n          const result = this.elementState(node, state);\n          if (typeof result !== "boolean")\n            return result;\n          if (!result) {\n            progress.logRepeating(`    element is not ${state} - waiting...`);\n            return progress.continuePolling;\n          }\n          continue;\n        }\n        const element = this.retarget(node, "no-follow-label");\n        if (!element)\n          return "error:notconnected";\n        if (++counter === 1)\n          return progress.continuePolling;\n        const time = performance.now();\n        if (this._stableRafCount > 1 && time - lastTime < 15)\n          return progress.continuePolling;\n        lastTime = time;\n        const clientRect = element.getBoundingClientRect();\n        const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n        const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (samePosition)\n          ++samePositionCounter;\n        else\n          samePositionCounter = 0;\n        const isStable = samePositionCounter >= this._stableRafCount;\n        const isStableForLogs = isStable || !lastRect;\n        lastRect = rect;\n        if (!isStableForLogs)\n          progress.logRepeating(`    element is not stable - waiting...`);\n        if (!isStable)\n          return progress.continuePolling;\n      }\n      return callback(node, progress);\n    });\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, ["stable", "visible", "hidden"].includes(state) ? "none" : "follow-label");\n    if (!element || !element.isConnected) {\n      if (state === "hidden")\n        return true;\n      return "error:notconnected";\n    }\n    if (state === "visible")\n      return this.isVisible(element);\n    if (state === "hidden")\n      return !this.isVisible(element);\n    const disabled = getAriaDisabled(element);\n    if (state === "disabled")\n      return disabled;\n    if (state === "enabled")\n      return !disabled;\n    const editable = !(["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.hasAttribute("readonly"));\n    if (state === "editable")\n      return !disabled && editable;\n    if (state === "checked" || state === "unchecked") {\n      const need = state === "checked";\n      const checked = getChecked(element, false);\n      if (checked === "error")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      return need === checked;\n    }\n    throw this.createStacklessError(`Unexpected element state "${state}"`);\n  }\n  selectOptions(optionsToSelect, node, progress) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() !== "select")\n      throw this.createStacklessError("Element is not a <select> element");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.valueOrLabel !== void 0)\n          matches = matches && (optionToSelect.valueOrLabel === option.value || optionToSelect.valueOrLabel === option.label);\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length) {\n      progress.logRepeating("    did not find some options - waiting... ");\n      return progress.continuePolling;\n    }\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    progress.log("    selected specified option(s)");\n    select.dispatchEvent(new Event("input", { "bubbles": true }));\n    select.dispatchEvent(new Event("change", { "bubbles": true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(value, node, progress) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set(["color", "date", "time", "datetime", "datetime-local", "month", "range", "week"]);\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set(["", "email", "number", "password", "search", "tel", "text", "url"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type)) {\n        progress.log(`    input of type "${type}" cannot be filled`);\n        throw this.createStacklessError(`Input of type "${type}" cannot be filled`);\n      }\n      if (type === "number") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError("Cannot type text into input[type=number]");\n      }\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError("Malformed value");\n        element.dispatchEvent(new Event("input", { "bubbles": true }));\n        element.dispatchEvent(new Event("change", { "bubbles": true }));\n        return "done";\n      }\n    } else if (element.nodeName.toLowerCase() === "textarea") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");\n    }\n    this.selectText(element);\n    return "needsinput";\n  }\n  selectText(node) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      input.select();\n      input.focus();\n      return "done";\n    }\n    if (element.nodeName.toLowerCase() === "textarea") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return "done";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return "done";\n  }\n  _activelyFocused(node) {\n    const activeElement = node.getRootNode().activeElement;\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\n    return { activeElement, isFocused };\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\n      activeElement.blur();\n    }\n    node.focus();\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === "input") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return "done";\n  }\n  blurNode(node) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    node.blur();\n    return "done";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return "Node is not of type HTMLElement";\n    const element = node;\n    if (element.nodeName !== "INPUT")\n      return "Not an <input> element";\n    const input = element;\n    const type = (input.getAttribute("type") || "").toLowerCase();\n    if (type !== "file")\n      return "Not an input[type=file] element";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event("input", { "bubbles": true }));\n    input.dispatchEvent(new Event("change", { "bubbles": true }));\n  }\n  expectHitTarget(hitPoint, targetElement) {\n    const roots = [];\n    let parentElement = targetElement;\n    while (parentElement) {\n      const root = enclosingShadowRootOrDocument(parentElement);\n      if (!root)\n        break;\n      roots.push(root);\n      if (root.nodeType === 9)\n        break;\n      parentElement = root.host;\n    }\n    let hitElement;\n    for (let index = roots.length - 1; index >= 0; index--) {\n      const root = roots[index];\n      const elements = root.elementsFromPoint(hitPoint.x, hitPoint.y);\n      const singleElement = root.elementFromPoint(hitPoint.x, hitPoint.y);\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\n        const style = this.window.getComputedStyle(singleElement);\n        if ((style == null ? void 0 : style.display) === "contents") {\n          elements.unshift(singleElement);\n        }\n      }\n      if (elements[0] && elements[0].shadowRoot === root && elements[1] === singleElement) {\n        elements.shift();\n      }\n      const innerElement = elements[0];\n      if (!innerElement)\n        break;\n      hitElement = innerElement;\n      if (index && innerElement !== roots[index - 1].host)\n        break;\n    }\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return "done";\n    const hitTargetDescription = this.previewNode(hitParents[0] || this.document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\n    const element = this.retarget(node, "button-link");\n    if (!element || !element.isConnected)\n      return "error:notconnected";\n    if (hitPoint) {\n      const preliminaryResult = this.expectHitTarget(hitPoint, element);\n      if (preliminaryResult !== "done")\n        return preliminaryResult.hitTargetDescription;\n    }\n    if (action === "drag")\n      return { stop: () => "done" };\n    const events = {\n      "hover": kHoverHitTargetInterceptorEvents,\n      "tap": kTapHitTargetInterceptorEvents,\n      "mouse": kMouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!this.window.TouchEvent && event instanceof this.window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point)\n        result = this.expectHitTarget({ x: point.clientX, y: point.clientY }, element);\n      if (blockAllEvents || result !== "done" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || "done";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInit) {\n    let event;\n    eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInit };\n    switch (eventType.get(type)) {\n      case "mouse":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case "keyboard":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case "touch":\n        event = new TouchEvent(type, eventInit);\n        break;\n      case "pointer":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case "focus":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case "drag":\n        event = new DragEvent(type, eventInit);\n        break;\n      case "wheel":\n        event = new WheelEvent(type, eventInit);\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || ""}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === "style")\n        continue;\n      if (!value && booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}="${value}"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    let attrText = attrs.join("");\n    if (attrText.length > 50)\n      attrText = attrText.substring(0, 49) + "\\u2026";\n    if (autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    let text = onlyText ? element.textContent || "" : children.length ? "\\u2026" : "";\n    if (text.length > 50)\n      text = text.substring(0, 49) + "\\u2026";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`);\n  }\n  strictModeViolationError(selector, matches) {\n    const infos = matches.slice(0, 10).map((m) => ({\n      preview: this.previewNode(m),\n      selector: this.generateSelector(m)\n    }));\n    const lines = infos.map((info, i) => `\n    ${i + 1}) ${info.preview} aka ${asLocator(this._sdkLanguage, info.selector)}`);\n    if (infos.length < matches.length)\n      lines.push("\\n    ...");\n    return this.createStacklessError(`strict mode violation: ${asLocator(this._sdkLanguage, stringifySelector(selector))} resolved to ${matches.length} elements:${lines.join("")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === "firefox") {\n      const error2 = new Error("Error: " + message);\n      error2.stack = "";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  maskSelectors(selectors, color) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, this.document.documentElement));\n    this._highlight.maskElements(elements.flat(), color);\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this);\n      this._highlight.install();\n    }\n    this._highlight.runHighlightOnRaf(selector);\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  markTargetElements(markedElements, callId) {\n    const customEvent = new CustomEvent("__playwright_target__", {\n      bubbles: true,\n      cancelable: true,\n      detail: callId,\n      composed: false\n    });\n    for (const element of markedElements)\n      element.dispatchEvent(customEvent);\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = "__playwright_global_listeners_check__";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    this.window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(this.document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      this.window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      this.window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(this.document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of kAllHitTargetInterceptorEvents)\n        this.window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  async expect(element, options, elements) {\n    const isArray = options.expression === "to.have.count" || options.expression.endsWith(".array");\n    if (isArray)\n      return this.expectArray(elements, options);\n    if (!element) {\n      if (!options.isNot && options.expression === "to.be.hidden")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.visible")\n        return { matches: false };\n      if (!options.isNot && options.expression === "to.be.detached")\n        return { matches: true };\n      if (options.isNot && options.expression === "to.be.attached")\n        return { matches: false };\n      if (options.isNot && options.expression === "to.be.in.viewport")\n        return { matches: false };\n      return { matches: options.isNot, missingRecevied: true };\n    }\n    return await this.expectSingleElement(element, options);\n  }\n  async expectSingleElement(element, options) {\n    var _a, _b;\n    const expression = options.expression;\n    {\n      let elementState;\n      if (expression === "to.be.checked") {\n        elementState = this.elementState(element, "checked");\n      } else if (expression === "to.be.unchecked") {\n        elementState = this.elementState(element, "unchecked");\n      } else if (expression === "to.be.disabled") {\n        elementState = this.elementState(element, "disabled");\n      } else if (expression === "to.be.editable") {\n        elementState = this.elementState(element, "editable");\n      } else if (expression === "to.be.readonly") {\n        elementState = !this.elementState(element, "editable");\n      } else if (expression === "to.be.empty") {\n        if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA")\n          elementState = !element.value;\n        else\n          elementState = !((_a = element.textContent) == null ? void 0 : _a.trim());\n      } else if (expression === "to.be.enabled") {\n        elementState = this.elementState(element, "enabled");\n      } else if (expression === "to.be.focused") {\n        elementState = this._activelyFocused(element).isFocused;\n      } else if (expression === "to.be.hidden") {\n        elementState = this.elementState(element, "hidden");\n      } else if (expression === "to.be.visible") {\n        elementState = this.elementState(element, "visible");\n      } else if (expression === "to.be.attached") {\n        elementState = true;\n      } else if (expression === "to.be.detached") {\n        elementState = false;\n      }\n      if (elementState !== void 0) {\n        if (elementState === "error:notcheckbox")\n          throw this.createStacklessError("Element is not a checkbox");\n        if (elementState === "error:notconnected")\n          throw this.createStacklessError("Element is not connected");\n        return { received: elementState, matches: elementState };\n      }\n    }\n    {\n      if (expression === "to.have.property") {\n        const received = element[options.expressionArg];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      if (expression === "to.be.in.viewport") {\n        const ratio = await this.viewportRatio(element);\n        return { received: `viewport ratio ${ratio}`, matches: ratio > 0 && ratio > ((_b = options.expectedNumber) != null ? _b : 0) - 1e-9 };\n      }\n    }\n    {\n      if (expression === "to.have.values") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "SELECT" || !element.multiple)\n          throw this.createStacklessError("Not a select element with a multiple attribute");\n        const received = [...element.selectedOptions].map((o) => o.value);\n        if (received.length !== options.expectedText.length)\n          return { received, matches: false };\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\n      }\n    }\n    {\n      let received;\n      if (expression === "to.have.attribute") {\n        const value = element.getAttribute(options.expressionArg);\n        if (value === null)\n          return { received: null, matches: false };\n        received = value;\n      } else if (expression === "to.have.class") {\n        received = element.classList.toString();\n      } else if (expression === "to.have.css") {\n        received = this.window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === "to.have.id") {\n        received = element.id;\n      } else if (expression === "to.have.text") {\n        received = options.useInnerText ? element.innerText : elementText(/* @__PURE__ */ new Map(), element).full;\n      } else if (expression === "to.have.title") {\n        received = this.document.title;\n      } else if (expression === "to.have.url") {\n        received = this.document.location.href;\n      } else if (expression === "to.have.value") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")\n          throw this.createStacklessError("Not an input element");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === "to.have.count") {\n      const received2 = elements.length;\n      const matches = received2 === options.expectedNumber;\n      return { received: received2, matches };\n    }\n    let received;\n    if (expression === "to.have.text.array" || expression === "to.contain.text.array")\n      received = elements.map((e) => options.useInnerText ? e.innerText : elementText(/* @__PURE__ */ new Map(), e).full);\n    else if (expression === "to.have.class.array")\n      received = elements.map((e) => e.classList.toString());\n    if (received && options.expectedText) {\n      const lengthShouldMatch = expression !== "to.contain.text.array";\n      const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n      if (!matchesLength)\n        return { received, matches: false };\n      const matchers = options.expectedText.map((e) => new ExpectedTextMatcher(e));\n      let mIndex = 0, rIndex = 0;\n      while (mIndex < matchers.length && rIndex < received.length) {\n        if (matchers[mIndex].matches(received[rIndex]))\n          ++mIndex;\n        ++rIndex;\n      }\n      return { received, matches: mIndex === matchers.length };\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  getElementAccessibleName(element, includeHidden) {\n    return getElementAccessibleName(element, !!includeHidden);\n  }\n  getAriaRole(element) {\n    return getAriaRole(element);\n  }\n};\nvar autoClosingTags = /* @__PURE__ */ new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "MENUITEM", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);\nvar booleanAttributes = /* @__PURE__ */ new Set(["checked", "selected", "disabled", "readonly", "multiple"]);\nfunction oneLine(s) {\n  return s.replace(/\\n/g, "\\u21B5").replace(/\\t/g, "\\u21C6");\n}\nvar eventType = /* @__PURE__ */ new Map([\n  ["auxclick", "mouse"],\n  ["click", "mouse"],\n  ["dblclick", "mouse"],\n  ["mousedown", "mouse"],\n  ["mouseeenter", "mouse"],\n  ["mouseleave", "mouse"],\n  ["mousemove", "mouse"],\n  ["mouseout", "mouse"],\n  ["mouseover", "mouse"],\n  ["mouseup", "mouse"],\n  ["mouseleave", "mouse"],\n  ["mousewheel", "mouse"],\n  ["keydown", "keyboard"],\n  ["keyup", "keyboard"],\n  ["keypress", "keyboard"],\n  ["textInput", "keyboard"],\n  ["touchstart", "touch"],\n  ["touchmove", "touch"],\n  ["touchend", "touch"],\n  ["touchcancel", "touch"],\n  ["pointerover", "pointer"],\n  ["pointerout", "pointer"],\n  ["pointerenter", "pointer"],\n  ["pointerleave", "pointer"],\n  ["pointerdown", "pointer"],\n  ["pointerup", "pointer"],\n  ["pointermove", "pointer"],\n  ["pointercancel", "pointer"],\n  ["gotpointercapture", "pointer"],\n  ["lostpointercapture", "pointer"],\n  ["focus", "focus"],\n  ["blur", "focus"],\n  ["drag", "drag"],\n  ["dragstart", "drag"],\n  ["dragend", "drag"],\n  ["dragover", "drag"],\n  ["dragenter", "drag"],\n  ["dragleave", "drag"],\n  ["dragexit", "drag"],\n  ["drop", "drag"],\n  ["wheel", "wheel"]\n]);\nvar kHoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousemove"]);\nvar kTapHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["pointerdown", "pointerup", "touchstart", "touchend", "touchcancel"]);\nvar kMouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousedown", "mouseup", "pointerdown", "pointerup", "click", "auxclick", "dblclick", "contextmenu"]);\nvar kAllHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...kHoverHitTargetInterceptorEvents, ...kTapHitTargetInterceptorEvents, ...kMouseHitTargetInterceptorEvents]);\nfunction cssUnquote(s) {\n  s = s.substring(1, s.length - 1);\n  if (!s.includes("\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === "\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join("");\n}\nfunction createTextMatcher(selector, internal) {\n  if (selector[0] === "/" && selector.lastIndexOf("/") > 0) {\n    const lastSlash = selector.lastIndexOf("/");\n    const re = new RegExp(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: (elementText2) => re.test(elementText2.full), kind: "regex" };\n  }\n  const unquote = internal ? JSON.parse.bind(JSON) : cssUnquote;\n  let strict = false;\n  if (selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 1] === \'"\') {\n    selector = unquote(selector);\n    strict = true;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "i") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = false;\n  } else if (internal && selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 2] === \'"\' && selector[selector.length - 1] === "s") {\n    selector = unquote(selector.substring(0, selector.length - 1));\n    strict = true;\n  } else if (selector.length > 1 && selector[0] === "\'" && selector[selector.length - 1] === "\'") {\n    selector = unquote(selector);\n    strict = true;\n  }\n  selector = normalizeWhiteSpace(selector);\n  if (strict) {\n    if (internal)\n      return { kind: "strict", matcher: (elementText2) => normalizeWhiteSpace(elementText2.full) === selector };\n    const strictTextNodeMatcher = (elementText2) => {\n      if (!selector && !elementText2.immediate.length)\n        return true;\n      return elementText2.immediate.some((s) => normalizeWhiteSpace(s) === selector);\n    };\n    return { matcher: strictTextNodeMatcher, kind: "strict" };\n  }\n  selector = selector.toLowerCase();\n  return { kind: "lax", matcher: (elementText2) => normalizeWhiteSpace(elementText2.full).toLowerCase().includes(selector) };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._ignoreCase = expected.ignoreCase;\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\n    if (expected.regexSource) {\n      const flags = new Set((expected.regexFlags || "").split(""));\n      if (expected.ignoreCase === false)\n        flags.delete("i");\n      if (expected.ignoreCase === true)\n        flags.add("i");\n      this._regex = new RegExp(expected.regexSource, [...flags].join(""));\n    }\n  }\n  matches(text) {\n    if (!this._regex)\n      text = this.normalize(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  normalize(s) {\n    if (!s)\n      return s;\n    if (this._normalizeWhiteSpace)\n      s = normalizeWhiteSpace(s);\n    if (this._ignoreCase)\n      s = s.toLocaleLowerCase();\n    return s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === "object" && typeof b === "object") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === "number" && typeof b === "number")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/protocolError.js
var require_protocolError = __commonJS({
  "node_modules/playwright-core/lib/server/protocolError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProtocolError = void 0;
    exports2.isSessionClosedError = isSessionClosedError;
    var ProtocolError = class extends Error {
      constructor(sessionClosed, message) {
        super(message);
        this.sessionClosed = void 0;
        this.sessionClosed = sessionClosed || false;
      }
    };
    exports2.ProtocolError = ProtocolError;
    function isSessionClosedError(e) {
      return e instanceof ProtocolError && e.sessionClosed;
    }
  }
});

// node_modules/playwright-core/lib/generated/utilityScriptSource.js
var require_utilityScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/utilityScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = '\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n// packages/playwright-core/src/server/injected/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/server/isomorphic/utilityScriptSerializers.ts\nfunction source() {\n  function isRegExp(obj) {\n    try {\n      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isDate(obj) {\n    try {\n      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isURL(obj) {\n    try {\n      return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n    } catch (error) {\n      return false;\n    }\n  }\n  function isError(obj) {\n    var _a;\n    try {\n      return obj instanceof Error || obj && ((_a = Object.getPrototypeOf(obj)) == null ? void 0 : _a.name) === "Error";\n    } catch (error) {\n      return false;\n    }\n  }\n  function parseEvaluationResultValue2(value, handles = [], refs = /* @__PURE__ */ new Map()) {\n    if (Object.is(value, void 0))\n      return void 0;\n    if (typeof value === "object" && value) {\n      if ("ref" in value)\n        return refs.get(value.ref);\n      if ("v" in value) {\n        if (value.v === "undefined")\n          return void 0;\n        if (value.v === "null")\n          return null;\n        if (value.v === "NaN")\n          return NaN;\n        if (value.v === "Infinity")\n          return Infinity;\n        if (value.v === "-Infinity")\n          return -Infinity;\n        if (value.v === "-0")\n          return -0;\n        return void 0;\n      }\n      if ("d" in value)\n        return new Date(value.d);\n      if ("u" in value)\n        return new URL(value.u);\n      if ("bi" in value)\n        return BigInt(value.bi);\n      if ("r" in value)\n        return new RegExp(value.r.p, value.r.f);\n      if ("a" in value) {\n        const result2 = [];\n        refs.set(value.id, result2);\n        for (const a of value.a)\n          result2.push(parseEvaluationResultValue2(a, handles, refs));\n        return result2;\n      }\n      if ("o" in value) {\n        const result2 = {};\n        refs.set(value.id, result2);\n        for (const { k, v } of value.o)\n          result2[k] = parseEvaluationResultValue2(v, handles, refs);\n        return result2;\n      }\n      if ("h" in value)\n        return handles[value.h];\n    }\n    return value;\n  }\n  function serializeAsCallArgument2(value, handleSerializer) {\n    return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n  }\n  function serialize(value, handleSerializer, visitorInfo) {\n    if (value && typeof value === "object") {\n      if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n        return "ref: <Window>";\n      if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n        return "ref: <Document>";\n      if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n        return "ref: <Node>";\n    }\n    return innerSerialize(value, handleSerializer, visitorInfo);\n  }\n  function innerSerialize(value, handleSerializer, visitorInfo) {\n    const result2 = handleSerializer(value);\n    if ("fallThrough" in result2)\n      value = result2.fallThrough;\n    else\n      return result2;\n    if (typeof value === "symbol")\n      return { v: "undefined" };\n    if (Object.is(value, void 0))\n      return { v: "undefined" };\n    if (Object.is(value, null))\n      return { v: "null" };\n    if (Object.is(value, NaN))\n      return { v: "NaN" };\n    if (Object.is(value, Infinity))\n      return { v: "Infinity" };\n    if (Object.is(value, -Infinity))\n      return { v: "-Infinity" };\n    if (Object.is(value, -0))\n      return { v: "-0" };\n    if (typeof value === "boolean")\n      return value;\n    if (typeof value === "number")\n      return value;\n    if (typeof value === "string")\n      return value;\n    if (typeof value === "bigint")\n      return { bi: value.toString() };\n    if (isError(value)) {\n      const error = value;\n      if ("captureStackTrace" in globalThis.Error) {\n        return error.stack || "";\n      }\n      return `${error.name}: ${error.message}\n${error.stack}`;\n    }\n    if (isDate(value))\n      return { d: value.toJSON() };\n    if (isURL(value))\n      return { u: value.toJSON() };\n    if (isRegExp(value))\n      return { r: { p: value.source, f: value.flags } };\n    const id = visitorInfo.visited.get(value);\n    if (id)\n      return { ref: id };\n    if (Array.isArray(value)) {\n      const a = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (let i = 0; i < value.length; ++i)\n        a.push(serialize(value[i], handleSerializer, visitorInfo));\n      return { a, id: id2 };\n    }\n    if (typeof value === "object") {\n      const o = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (const name of Object.keys(value)) {\n        let item;\n        try {\n          item = value[name];\n        } catch (e) {\n          continue;\n        }\n        if (name === "toJSON" && typeof item === "function")\n          o.push({ k: name, v: { o: [], id: 0 } });\n        else\n          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n      }\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        return innerSerialize(value.toJSON(), handleSerializer, visitorInfo);\n      return { o, id: id2 };\n    }\n  }\n  return { parseEvaluationResultValue: parseEvaluationResultValue2, serializeAsCallArgument: serializeAsCallArgument2 };\n}\nvar result = source();\nvar parseEvaluationResultValue = result.parseEvaluationResultValue;\nvar serializeAsCallArgument = result.serializeAsCallArgument;\n\n// packages/playwright-core/src/server/injected/utilityScript.ts\nvar UtilityScript = class {\n  constructor() {\n    this.serializeAsCallArgument = serializeAsCallArgument;\n    this.parseEvaluationResultValue = parseEvaluationResultValue;\n  }\n  evaluate(isFunction, returnByValue, exposeUtilityScript, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = this.parseEvaluationResultValue(args[i], handles);\n    if (exposeUtilityScript)\n      parameters.unshift(this);\n    let result2 = globalThis.eval(expression);\n    if (isFunction === true) {\n      result2 = result2(...parameters);\n    } else if (isFunction === false) {\n      result2 = result2;\n    } else {\n      if (typeof result2 === "function")\n        result2 = result2(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result2) : result2;\n  }\n  jsonValue(returnByValue, value) {\n    if (Object.is(value, void 0))\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/isomorphic/utilityScriptSerializers.js
var require_utilityScriptSerializers = __commonJS({
  "node_modules/playwright-core/lib/server/isomorphic/utilityScriptSerializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.serializeAsCallArgument = exports2.parseEvaluationResultValue = void 0;
    exports2.source = source;
    function source() {
      function isRegExp(obj) {
        try {
          return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
        } catch (error) {
          return false;
        }
      }
      function isDate(obj) {
        try {
          return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
        } catch (error) {
          return false;
        }
      }
      function isURL(obj) {
        try {
          return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";
        } catch (error) {
          return false;
        }
      }
      function isError(obj) {
        try {
          var _Object$getPrototypeO;
          return obj instanceof Error || obj && ((_Object$getPrototypeO = Object.getPrototypeOf(obj)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.name) === "Error";
        } catch (error) {
          return false;
        }
      }
      function parseEvaluationResultValue2(value, handles = [], refs = /* @__PURE__ */ new Map()) {
        if (Object.is(value, void 0))
          return void 0;
        if (typeof value === "object" && value) {
          if ("ref" in value)
            return refs.get(value.ref);
          if ("v" in value) {
            if (value.v === "undefined")
              return void 0;
            if (value.v === "null")
              return null;
            if (value.v === "NaN")
              return NaN;
            if (value.v === "Infinity")
              return Infinity;
            if (value.v === "-Infinity")
              return -Infinity;
            if (value.v === "-0")
              return -0;
            return void 0;
          }
          if ("d" in value)
            return new Date(value.d);
          if ("u" in value)
            return new URL(value.u);
          if ("bi" in value)
            return BigInt(value.bi);
          if ("r" in value)
            return new RegExp(value.r.p, value.r.f);
          if ("a" in value) {
            const result2 = [];
            refs.set(value.id, result2);
            for (const a of value.a)
              result2.push(parseEvaluationResultValue2(a, handles, refs));
            return result2;
          }
          if ("o" in value) {
            const result2 = {};
            refs.set(value.id, result2);
            for (const {
              k,
              v
            } of value.o)
              result2[k] = parseEvaluationResultValue2(v, handles, refs);
            return result2;
          }
          if ("h" in value)
            return handles[value.h];
        }
        return value;
      }
      function serializeAsCallArgument2(value, handleSerializer) {
        return serialize(value, handleSerializer, {
          visited: /* @__PURE__ */ new Map(),
          lastId: 0
        });
      }
      function serialize(value, handleSerializer, visitorInfo) {
        if (value && typeof value === "object") {
          if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)
            return "ref: <Window>";
          if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)
            return "ref: <Document>";
          if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)
            return "ref: <Node>";
        }
        return innerSerialize(value, handleSerializer, visitorInfo);
      }
      function innerSerialize(value, handleSerializer, visitorInfo) {
        const result2 = handleSerializer(value);
        if ("fallThrough" in result2)
          value = result2.fallThrough;
        else
          return result2;
        if (typeof value === "symbol")
          return {
            v: "undefined"
          };
        if (Object.is(value, void 0))
          return {
            v: "undefined"
          };
        if (Object.is(value, null))
          return {
            v: "null"
          };
        if (Object.is(value, NaN))
          return {
            v: "NaN"
          };
        if (Object.is(value, Infinity))
          return {
            v: "Infinity"
          };
        if (Object.is(value, -Infinity))
          return {
            v: "-Infinity"
          };
        if (Object.is(value, -0))
          return {
            v: "-0"
          };
        if (typeof value === "boolean")
          return value;
        if (typeof value === "number")
          return value;
        if (typeof value === "string")
          return value;
        if (typeof value === "bigint")
          return {
            bi: value.toString()
          };
        if (isError(value)) {
          const error = value;
          if ("captureStackTrace" in globalThis.Error) {
            return error.stack || "";
          }
          return `${error.name}: ${error.message}
${error.stack}`;
        }
        if (isDate(value))
          return {
            d: value.toJSON()
          };
        if (isURL(value))
          return {
            u: value.toJSON()
          };
        if (isRegExp(value))
          return {
            r: {
              p: value.source,
              f: value.flags
            }
          };
        const id = visitorInfo.visited.get(value);
        if (id)
          return {
            ref: id
          };
        if (Array.isArray(value)) {
          const a = [];
          const id2 = ++visitorInfo.lastId;
          visitorInfo.visited.set(value, id2);
          for (let i = 0; i < value.length; ++i)
            a.push(serialize(value[i], handleSerializer, visitorInfo));
          return {
            a,
            id: id2
          };
        }
        if (typeof value === "object") {
          const o = [];
          const id2 = ++visitorInfo.lastId;
          visitorInfo.visited.set(value, id2);
          for (const name of Object.keys(value)) {
            let item;
            try {
              item = value[name];
            } catch (e) {
              continue;
            }
            if (name === "toJSON" && typeof item === "function")
              o.push({
                k: name,
                v: {
                  o: [],
                  id: 0
                }
              });
            else
              o.push({
                k: name,
                v: serialize(item, handleSerializer, visitorInfo)
              });
          }
          if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")
            return innerSerialize(value.toJSON(), handleSerializer, visitorInfo);
          return {
            o,
            id: id2
          };
        }
      }
      return {
        parseEvaluationResultValue: parseEvaluationResultValue2,
        serializeAsCallArgument: serializeAsCallArgument2
      };
    }
    var result = source();
    var parseEvaluationResultValue = result.parseEvaluationResultValue;
    exports2.parseEvaluationResultValue = parseEvaluationResultValue;
    var serializeAsCallArgument = result.serializeAsCallArgument;
    exports2.serializeAsCallArgument = serializeAsCallArgument;
  }
});

// node_modules/playwright-core/lib/server/javascript.js
var require_javascript = __commonJS({
  "node_modules/playwright-core/lib/server/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaScriptErrorInEvaluate = exports2.JSHandle = exports2.ExecutionContext = void 0;
    exports2.evaluate = evaluate;
    exports2.evaluateExpression = evaluateExpression;
    exports2.isJavaScriptErrorInEvaluate = isJavaScriptErrorInEvaluate;
    exports2.normalizeEvaluationExpression = normalizeEvaluationExpression;
    exports2.parseUnserializableValue = parseUnserializableValue;
    exports2.sparseArrayToString = sparseArrayToString;
    var utilityScriptSource = _interopRequireWildcard(require_utilityScriptSource());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _instrumentation = require_instrumentation();
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ExecutionContext = class extends _instrumentation.SdkObject {
      constructor(parent, delegate, worldNameForTest) {
        super(parent, "execution-context");
        this._delegate = void 0;
        this._utilityScriptPromise = void 0;
        this._contextDestroyedRace = new _manualPromise.ScopedRace();
        this.worldNameForTest = void 0;
        this.worldNameForTest = worldNameForTest;
        this._delegate = delegate;
      }
      contextDestroyed(error) {
        this._contextDestroyedRace.scopeClosed(error);
      }
      _raceAgainstContextDestroyed(promise) {
        return __async(this, null, function* () {
          return this._contextDestroyedRace.race(promise);
        });
      }
      rawEvaluateJSON(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateJSON(expression));
      }
      rawEvaluateHandle(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(expression));
      }
      rawCallFunctionNoReply(func, ...args) {
        this._delegate.rawCallFunctionNoReply(func, ...args);
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return this._raceAgainstContextDestroyed(this._delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds));
      }
      getProperties(context, objectId) {
        return this._raceAgainstContextDestroyed(this._delegate.getProperties(context, objectId));
      }
      createHandle(remoteObject) {
        return this._delegate.createHandle(this, remoteObject);
      }
      releaseHandle(objectId) {
        return this._delegate.releaseHandle(objectId);
      }
      adoptIfNeeded(handle) {
        return null;
      }
      utilityScript() {
        if (!this._utilityScriptPromise) {
          const source = `
      (() => {
        const module = {};
        ${utilityScriptSource.source}
        return new (module.exports.UtilityScript())();
      })();`;
          this._utilityScriptPromise = this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(source).then((objectId) => new JSHandle(this, "object", "UtilityScript", objectId)));
        }
        return this._utilityScriptPromise;
      }
      objectCount(objectId) {
        return __async(this, null, function* () {
          return this._delegate.objectCount(objectId);
        });
      }
      doSlowMo() {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.ExecutionContext = ExecutionContext;
    var JSHandle = class extends _instrumentation.SdkObject {
      constructor(context, type, preview, objectId, value) {
        super(context, "handle");
        this.__jshandle = true;
        this._context = void 0;
        this._disposed = false;
        this._objectId = void 0;
        this._value = void 0;
        this._objectType = void 0;
        this._preview = void 0;
        this._previewCallback = void 0;
        this._context = context;
        this._objectId = objectId;
        this._value = value;
        this._objectType = type;
        this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
        if (this._objectId && globalThis.leakedJSHandles)
          globalThis.leakedJSHandles.set(this, new Error("Leaked JSHandle"));
      }
      callFunctionNoReply(func, arg) {
        this._context.rawCallFunctionNoReply(func, this, arg);
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          return evaluate(this._context, true, pageFunction, this, arg);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          return evaluate(this._context, false, pageFunction, this, arg);
        });
      }
      evaluateExpression(expression, options, arg) {
        return __async(this, null, function* () {
          const value = yield evaluateExpression(this._context, expression, __spreadProps(__spreadValues({}, options), {
            returnByValue: true
          }), this, arg);
          yield this._context.doSlowMo();
          return value;
        });
      }
      evaluateExpressionHandle(expression, options, arg) {
        return __async(this, null, function* () {
          const value = yield evaluateExpression(this._context, expression, __spreadProps(__spreadValues({}, options), {
            returnByValue: false
          }), this, arg);
          yield this._context.doSlowMo();
          return value;
        });
      }
      getProperty(propertyName) {
        return __async(this, null, function* () {
          const objectHandle = yield this.evaluateHandle((object, propertyName2) => {
            const result2 = {
              __proto__: null
            };
            result2[propertyName2] = object[propertyName2];
            return result2;
          }, propertyName);
          const properties = yield objectHandle.getProperties();
          const result = properties.get(propertyName);
          objectHandle.dispose();
          return result;
        });
      }
      getProperties() {
        return __async(this, null, function* () {
          if (!this._objectId)
            return /* @__PURE__ */ new Map();
          return this._context.getProperties(this._context, this._objectId);
        });
      }
      rawValue() {
        return this._value;
      }
      jsonValue() {
        return __async(this, null, function* () {
          if (!this._objectId)
            return this._value;
          const utilityScript = yield this._context.utilityScript();
          const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
          return this._context.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this._objectId) {
          this._context.releaseHandle(this._objectId).catch((e) => {
          });
          if (globalThis.leakedJSHandles)
            globalThis.leakedJSHandles.delete(this);
        }
      }
      toString() {
        return this._preview;
      }
      _setPreviewCallback(callback) {
        this._previewCallback = callback;
      }
      preview() {
        return this._preview;
      }
      worldNameForTest() {
        return this._context.worldNameForTest;
      }
      _setPreview(preview) {
        this._preview = preview;
        if (this._previewCallback)
          this._previewCallback(preview);
      }
      objectCount() {
        return __async(this, null, function* () {
          if (!this._objectId)
            throw new Error("Can only count objects for a handle that points to the constructor prototype");
          return this._context.objectCount(this._objectId);
        });
      }
    };
    exports2.JSHandle = JSHandle;
    function evaluate(context, returnByValue, pageFunction, ...args) {
      return __async(this, null, function* () {
        return evaluateExpression(context, String(pageFunction), {
          returnByValue,
          isFunction: typeof pageFunction === "function"
        }, ...args);
      });
    }
    function evaluateExpression(context, expression, options, ...args) {
      return __async(this, null, function* () {
        const utilityScript = yield context.utilityScript();
        expression = normalizeEvaluationExpression(expression, options.isFunction);
        const handles = [];
        const toDispose = [];
        const pushHandle = (handle) => {
          handles.push(handle);
          return handles.length - 1;
        };
        args = args.map((arg) => (0, _utilityScriptSerializers.serializeAsCallArgument)(arg, (handle) => {
          if (handle instanceof JSHandle) {
            if (!handle._objectId)
              return {
                fallThrough: handle._value
              };
            if (handle._disposed)
              throw new Error("JSHandle is disposed!");
            const adopted = context.adoptIfNeeded(handle);
            if (adopted === null)
              return {
                h: pushHandle(Promise.resolve(handle))
              };
            toDispose.push(adopted);
            return {
              h: pushHandle(adopted)
            };
          }
          return {
            fallThrough: handle
          };
        }));
        const utilityScriptObjectIds = [];
        for (const handle of yield Promise.all(handles)) {
          if (handle._context !== context)
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          utilityScriptObjectIds.push(handle._objectId);
        }
        const utilityScriptValues = [options.isFunction, options.returnByValue, options.exposeUtilityScript, expression, args.length, ...args];
        const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
        try {
          return yield context.evaluateWithArguments(script, options.returnByValue || false, utilityScript, utilityScriptValues, utilityScriptObjectIds);
        } finally {
          toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
        }
      });
    }
    function parseUnserializableValue(unserializableValue) {
      if (unserializableValue === "NaN")
        return NaN;
      if (unserializableValue === "Infinity")
        return Infinity;
      if (unserializableValue === "-Infinity")
        return -Infinity;
      if (unserializableValue === "-0")
        return -0;
    }
    function normalizeEvaluationExpression(expression, isFunction) {
      expression = expression.trim();
      if (isFunction) {
        try {
          new Function("(" + expression + ")");
        } catch (e1) {
          if (expression.startsWith("async "))
            expression = "async function " + expression.substring("async ".length);
          else
            expression = "function " + expression;
          try {
            new Function("(" + expression + ")");
          } catch (e2) {
            throw new Error("Passed function is not well-serializable!");
          }
        }
      }
      if (/^(async)?\s*function(\s|\()/.test(expression))
        expression = "(" + expression + ")";
      return expression;
    }
    var JavaScriptErrorInEvaluate = class extends Error {
    };
    exports2.JavaScriptErrorInEvaluate = JavaScriptErrorInEvaluate;
    function isJavaScriptErrorInEvaluate(error) {
      return error instanceof JavaScriptErrorInEvaluate;
    }
    function sparseArrayToString(entries) {
      const arrayEntries = [];
      for (const {
        name,
        value
      } of entries) {
        const index = +name;
        if (isNaN(index) || index < 0)
          continue;
        arrayEntries.push({
          index,
          value
        });
      }
      arrayEntries.sort((a, b) => a.index - b.index);
      let lastIndex = -1;
      const tokens = [];
      for (const {
        index,
        value
      } of arrayEntries) {
        const emptyItems = index - lastIndex - 1;
        if (emptyItems === 1)
          tokens.push(`empty`);
        else if (emptyItems > 1)
          tokens.push(`empty x ${emptyItems}`);
        tokens.push(String(value));
        lastIndex = index;
      }
      return "[" + tokens.join(", ") + "]";
    }
  }
});

// node_modules/playwright-core/lib/server/progress.js
var require_progress = __commonJS({
  "node_modules/playwright-core/lib/server/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProgressController = void 0;
    var _errors = require_errors();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var ProgressController = class {
      constructor(metadata, sdkObject) {
        this._forceAbortPromise = new _manualPromise.ManualPromise();
        this._cleanups = [];
        this._logName = "api";
        this._state = "before";
        this._deadline = 0;
        this._timeout = 0;
        this.metadata = void 0;
        this.instrumentation = void 0;
        this.sdkObject = void 0;
        this.metadata = metadata;
        this.sdkObject = sdkObject;
        this.instrumentation = sdkObject.instrumentation;
        this._forceAbortPromise.catch((e) => null);
      }
      setLogName(logName) {
        this._logName = logName;
      }
      abort(error) {
        this._forceAbortPromise.reject(error);
      }
      run(task, timeout) {
        return __async(this, null, function* () {
          var _this$sdkObject$attri;
          if (timeout) {
            this._timeout = timeout;
            this._deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
          }
          (0, _utils.assert)(this._state === "before");
          this._state = "running";
          (_this$sdkObject$attri = this.sdkObject.attribution.context) === null || _this$sdkObject$attri === void 0 ? void 0 : _this$sdkObject$attri._activeProgressControllers.add(this);
          const progress2 = {
            log: (message) => {
              progress2.logEntry({
                message
              });
            },
            logEntry: (entry) => {
              if ("message" in entry) {
                const message = entry.message;
                if (this._state === "running")
                  this.metadata.log.push(message);
                this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
              }
            },
            timeUntilDeadline: () => this._deadline ? this._deadline - (0, _utils.monotonicTime)() : 2147483647,
            isRunning: () => this._state === "running",
            cleanupWhenAborted: (cleanup) => {
              if (this._state === "running")
                this._cleanups.push(cleanup);
              else
                runCleanup(cleanup);
            },
            throwIfAborted: () => {
              if (this._state === "aborted")
                throw new AbortedError();
            },
            beforeInputAction: (element) => __async(this, null, function* () {
              yield this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
            }),
            metadata: this.metadata
          };
          const timeoutError = new _errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
          const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress2.timeUntilDeadline());
          try {
            const promise = task(progress2);
            const result = yield Promise.race([promise, this._forceAbortPromise]);
            this._state = "finished";
            return result;
          } catch (e) {
            this._state = "aborted";
            yield Promise.all(this._cleanups.splice(0).map(runCleanup));
            throw e;
          } finally {
            var _this$sdkObject$attri2;
            (_this$sdkObject$attri2 = this.sdkObject.attribution.context) === null || _this$sdkObject$attri2 === void 0 ? void 0 : _this$sdkObject$attri2._activeProgressControllers.delete(this);
            clearTimeout(timer);
          }
        });
      }
    };
    exports2.ProgressController = ProgressController;
    function runCleanup(cleanup) {
      return __async(this, null, function* () {
        try {
          yield cleanup();
        } catch (e) {
        }
      });
    }
    var AbortedError = class extends Error {
    };
  }
});

// node_modules/playwright-core/lib/server/dom.js
var require_dom = __commonJS({
  "node_modules/playwright-core/lib/server/dom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NonRecoverableDOMError = exports2.InjectedScriptPollHandler = exports2.FrameExecutionContext = exports2.ElementHandle = void 0;
    exports2.assertDone = assertDone;
    exports2.isNonRecoverableDOMError = isNonRecoverableDOMError;
    exports2.kUnableToAdoptErrorMessage = void 0;
    exports2.throwRetargetableDOMError = throwRetargetableDOMError;
    var _utilsBundle = require_utilsBundle();
    var injectedScriptSource = _interopRequireWildcard(require_injectedScriptSource());
    var _protocolError = require_protocolError();
    var js = _interopRequireWildcard(require_javascript());
    var _progress = require_progress();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var NonRecoverableDOMError = class extends Error {
    };
    exports2.NonRecoverableDOMError = NonRecoverableDOMError;
    function isNonRecoverableDOMError(error) {
      return error instanceof NonRecoverableDOMError;
    }
    var FrameExecutionContext = class extends js.ExecutionContext {
      constructor(delegate, frame, world) {
        super(frame, delegate, world || "content-script");
        this.frame = void 0;
        this._injectedScriptPromise = void 0;
        this.world = void 0;
        this.frame = frame;
        this.world = world;
      }
      adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
          return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluate(this, true, pageFunction, arg);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluate(this, false, pageFunction, arg);
        });
      }
      evaluateExpression(expression, options, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(this, expression, __spreadProps(__spreadValues({}, options), {
            returnByValue: true
          }), arg);
        });
      }
      evaluateExpressionHandle(expression, options, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(this, expression, __spreadProps(__spreadValues({}, options), {
            returnByValue: false
          }), arg);
        });
      }
      createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
          return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
      }
      injectedScript() {
        if (!this._injectedScriptPromise) {
          const custom = [];
          const selectorsRegistry = this.frame._page.context().selectors();
          for (const [name, {
            source: source2
          }] of selectorsRegistry._engines)
            custom.push(`{ name: '${name}', engine: (${source2}) }`);
          const sdkLanguage = this.frame.attribution.playwright.options.sdkLanguage;
          const source = `
        (() => {
        const module = {};
        ${injectedScriptSource.source}
        return new (module.exports.InjectedScript())(
          globalThis,
          ${(0, _utils.isUnderTest)()},
          "${sdkLanguage}",
          ${JSON.stringify(selectorsRegistry.testIdAttributeName())},
          ${this.frame._page._delegate.rafCountForStablePosition()},
          "${this.frame._page._browserContext._browser.options.name}",
          [${custom.join(",\n")}]
        );
        })();
      `;
          this._injectedScriptPromise = this.rawEvaluateHandle(source).then((objectId) => new js.JSHandle(this, "object", "InjectedScript", objectId));
        }
        return this._injectedScriptPromise;
      }
    };
    exports2.FrameExecutionContext = FrameExecutionContext;
    var ElementHandle = class extends js.JSHandle {
      constructor(context, objectId) {
        super(context, "node", void 0, objectId);
        this.__elementhandle = true;
        this._page = void 0;
        this._frame = void 0;
        this._page = context.frame._page;
        this._frame = context.frame;
        this._initializePreview().catch((e) => {
        });
      }
      _initializePreview() {
        return __async(this, null, function* () {
          const utility = yield this._context.injectedScript();
          this._setPreview(yield utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
        });
      }
      asElement() {
        return this;
      }
      evaluateInUtility(pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            return yield utility.evaluate(pageFunction, [yield utility.injectedScript(), this, arg]);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      evaluateHandleInUtility(pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            return yield utility.evaluateHandle(pageFunction, [yield utility.injectedScript(), this, arg]);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      evaluatePoll(progress2, pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            const poll = yield utility.evaluateHandle(pageFunction, [yield utility.injectedScript(), this, arg]);
            const pollHandler = new InjectedScriptPollHandler(progress2, poll);
            return yield pollHandler.finish();
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      ownerFrame() {
        return __async(this, null, function* () {
          const frameId = yield this._page._delegate.getOwnerFrame(this);
          if (!frameId)
            return null;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            return frame;
          for (const page of this._page._browserContext.pages()) {
            const frame2 = page._frameManager.frame(frameId);
            if (frame2)
              return frame2;
          }
          return null;
        });
      }
      isIframeElement() {
        return __async(this, null, function* () {
          return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === "IFRAME" || node.nodeName === "FRAME"), {});
        });
      }
      contentFrame() {
        return __async(this, null, function* () {
          const isFrameElement = throwRetargetableDOMError(yield this.isIframeElement());
          if (!isFrameElement)
            return null;
          return this._page._delegate.getContentFrame(this);
        });
      }
      getAttribute(metadata, name) {
        return __async(this, null, function* () {
          return this._frame.getAttribute(metadata, ":scope", name, {}, this);
        });
      }
      inputValue(metadata) {
        return __async(this, null, function* () {
          return this._frame.inputValue(metadata, ":scope", {}, this);
        });
      }
      textContent(metadata) {
        return __async(this, null, function* () {
          return this._frame.textContent(metadata, ":scope", {}, this);
        });
      }
      innerText(metadata) {
        return __async(this, null, function* () {
          return this._frame.innerText(metadata, ":scope", {}, this);
        });
      }
      innerHTML(metadata) {
        return __async(this, null, function* () {
          return this._frame.innerHTML(metadata, ":scope", {}, this);
        });
      }
      dispatchEvent(_0, _1) {
        return __async(this, arguments, function* (metadata, type, eventInit = {}) {
          return this._frame.dispatchEvent(metadata, ":scope", type, eventInit, {}, this);
        });
      }
      _scrollRectIntoViewIfNeeded(rect) {
        return __async(this, null, function* () {
          return yield this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
        });
      }
      _waitAndScrollIntoViewIfNeeded(progress2, waitForVisible) {
        return __async(this, null, function* () {
          const timeouts = [0, 50, 100, 250];
          while (progress2.isRunning()) {
            assertDone(throwRetargetableDOMError(yield this._waitForElementStates(progress2, waitForVisible ? ["visible", "stable"] : ["stable"], false)));
            progress2.throwIfAborted();
            const result = throwRetargetableDOMError(yield this._scrollRectIntoViewIfNeeded());
            if (result === "error:notvisible") {
              if (!waitForVisible) {
                var _timeouts$shift;
                const timeout = (_timeouts$shift = timeouts.shift()) !== null && _timeouts$shift !== void 0 ? _timeouts$shift : 500;
                progress2.log(`  element is not displayed, retrying in ${timeout}ms`);
                yield new Promise((f) => setTimeout(f, timeout));
              }
              continue;
            }
            assertDone(result);
            return;
          }
        });
      }
      scrollIntoViewIfNeeded(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this._waitAndScrollIntoViewIfNeeded(progress2, false), this._page._timeoutSettings.timeout(options));
        });
      }
      _clickablePoint() {
        return __async(this, null, function* () {
          const intersectQuadWithViewport = (quad) => {
            return quad.map((point) => ({
              x: Math.min(Math.max(point.x, 0), metrics.width),
              y: Math.min(Math.max(point.y, 0), metrics.height)
            }));
          };
          const computeQuadArea = (quad) => {
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
              const p1 = quad[i];
              const p2 = quad[(i + 1) % quad.length];
              area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
          };
          const [quads, metrics] = yield Promise.all([this._page._delegate.getContentQuads(this), this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({
            width: innerWidth,
            height: innerHeight
          })))]);
          if (!quads || !quads.length)
            return "error:notvisible";
          const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
          if (!filtered.length)
            return "error:notinviewport";
          const result = {
            x: 0,
            y: 0
          };
          for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
          }
          compensateHalfIntegerRoundingError(result);
          return result;
        });
      }
      _offsetPoint(offset) {
        return __async(this, null, function* () {
          const [box, border] = yield Promise.all([this.boundingBox(), this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch((e) => {
          })]);
          if (!box || !border)
            return "error:notvisible";
          if (border === "error:notconnected")
            return border;
          return {
            x: box.x + border.left + offset.x,
            y: box.y + border.top + offset.y
          };
        });
      }
      _retryPointerAction(progress2, actionName, waitForEnabled, action, options) {
        return __async(this, null, function* () {
          let retry = 0;
          const waitTime = [0, 20, 100, 100, 500];
          const scrollOptions = [void 0, {
            block: "end",
            inline: "end"
          }, {
            block: "center",
            inline: "center"
          }, {
            block: "start",
            inline: "start"
          }];
          while (progress2.isRunning()) {
            if (retry) {
              progress2.log(`retrying ${actionName} action${options.trial ? " (trial run)" : ""}, attempt #${retry}`);
              const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];
              if (timeout) {
                progress2.log(`  waiting ${timeout}ms`);
                const result2 = yield this.evaluateInUtility(([injected, node, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout);
                if (result2 === "error:notconnected")
                  return result2;
              }
            } else {
              progress2.log(`attempting ${actionName} action${options.trial ? " (trial run)" : ""}`);
            }
            const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
            const result = yield this._performPointerAction(progress2, actionName, waitForEnabled, action, forceScrollOptions, options);
            ++retry;
            if (result === "error:notvisible") {
              if (options.force)
                throw new NonRecoverableDOMError("Element is not visible");
              progress2.log("  element is not visible");
              continue;
            }
            if (result === "error:notinviewport") {
              if (options.force)
                throw new NonRecoverableDOMError("Element is outside of the viewport");
              progress2.log("  element is outside of the viewport");
              continue;
            }
            if (typeof result === "object" && "hitTargetDescription" in result) {
              progress2.log(`  ${result.hitTargetDescription} intercepts pointer events`);
              continue;
            }
            return result;
          }
          return "done";
        });
      }
      _performPointerAction(progress2, actionName, waitForEnabled, action, forceScrollOptions, options) {
        return __async(this, null, function* () {
          const {
            force = false,
            position
          } = options;
          if (options.__testHookBeforeStable)
            yield options.__testHookBeforeStable();
          const result = yield this._waitForElementStates(progress2, waitForEnabled ? ["visible", "enabled", "stable"] : ["visible", "stable"], force);
          if (result !== "done")
            return result;
          if (options.__testHookAfterStable)
            yield options.__testHookAfterStable();
          progress2.log("  scrolling into view if needed");
          progress2.throwIfAborted();
          if (forceScrollOptions) {
            const scrolled = yield this.evaluateInUtility(([injected, node, options2]) => {
              if (node.nodeType === 1)
                node.scrollIntoView(options2);
            }, forceScrollOptions);
            if (scrolled === "error:notconnected")
              return scrolled;
          } else {
            const scrolled = yield this._scrollRectIntoViewIfNeeded(position ? {
              x: position.x,
              y: position.y,
              width: 0,
              height: 0
            } : void 0);
            if (scrolled !== "done")
              return scrolled;
          }
          progress2.log("  done scrolling");
          const maybePoint = position ? yield this._offsetPoint(position) : yield this._clickablePoint();
          if (typeof maybePoint === "string")
            return maybePoint;
          const point = roundPoint(maybePoint);
          progress2.metadata.point = point;
          yield progress2.beforeInputAction(this);
          let hitTargetInterceptionHandle;
          if (!options.force) {
            if (options.__testHookBeforeHitTarget)
              yield options.__testHookBeforeHitTarget();
            const frameCheckResult = yield this._checkFrameIsHitTarget(point);
            if (frameCheckResult === "error:notconnected" || "hitTargetDescription" in frameCheckResult)
              return frameCheckResult;
            const hitPoint = frameCheckResult.framePoint;
            const actionType = actionName === "move and up" ? "drag" : actionName === "hover" || actionName === "tap" ? actionName : "mouse";
            const handle = yield this.evaluateHandleInUtility(([injected, node, {
              actionType: actionType2,
              hitPoint: hitPoint2,
              trial
            }]) => injected.setupHitTargetInterceptor(node, actionType2, hitPoint2, trial), {
              actionType,
              hitPoint,
              trial: !!options.trial
            });
            if (handle === "error:notconnected")
              return handle;
            if (!handle._objectId) {
              const error = handle.rawValue();
              if (error === "error:notconnected")
                return error;
              return {
                hitTargetDescription: error
              };
            }
            hitTargetInterceptionHandle = handle;
            progress2.cleanupWhenAborted(() => {
              hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => {
              });
              hitTargetInterceptionHandle.dispose();
            });
          }
          const actionResult = yield this._page._frameManager.waitForSignalsCreatedBy(progress2, options.noWaitAfter, () => __async(this, null, function* () {
            if (options.__testHookBeforePointerAction)
              yield options.__testHookBeforePointerAction();
            progress2.throwIfAborted();
            let restoreModifiers;
            if (options && options.modifiers)
              restoreModifiers = yield this._page.keyboard._ensureModifiers(options.modifiers);
            progress2.log(`  performing ${actionName} action`);
            yield action(point);
            if (restoreModifiers)
              yield this._page.keyboard._ensureModifiers(restoreModifiers);
            if (hitTargetInterceptionHandle) {
              const stopHitTargetInterception = hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => "done").finally(() => {
                var _hitTargetInterceptio;
                (_hitTargetInterceptio = hitTargetInterceptionHandle) === null || _hitTargetInterceptio === void 0 ? void 0 : _hitTargetInterceptio.dispose();
              });
              if (!options.noWaitAfter) {
                const hitTargetResult = yield stopHitTargetInterception;
                if (hitTargetResult !== "done")
                  return hitTargetResult;
              }
            }
            progress2.log(`  ${options.trial ? "trial " : ""}${actionName} action done`);
            progress2.log("  waiting for scheduled navigations to finish");
            if (options.__testHookAfterPointerAction)
              yield options.__testHookAfterPointerAction();
            return "done";
          }), "input");
          if (actionResult !== "done")
            return actionResult;
          progress2.log("  navigations have finished");
          return "done";
        });
      }
      hover(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._hover(progress2, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _hover(progress2, options) {
        return this._retryPointerAction(progress2, "hover", false, (point) => this._page.mouse.move(point.x, point.y), options);
      }
      click(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._click(progress2, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _click(progress2, options) {
        return this._retryPointerAction(progress2, "click", true, (point) => this._page.mouse.click(point.x, point.y, options), options);
      }
      dblclick(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._dblclick(progress2, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _dblclick(progress2, options) {
        return this._retryPointerAction(progress2, "dblclick", true, (point) => this._page.mouse.dblclick(point.x, point.y, options), options);
      }
      tap(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._tap(progress2, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _tap(progress2, options) {
        return this._retryPointerAction(progress2, "tap", true, (point) => this._page.touchscreen.tap(point.x, point.y), options);
      }
      selectOption(metadata, elements, values, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._selectOption(progress2, elements, values, options);
            return throwRetargetableDOMError(result);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _selectOption(progress2, elements, values, options) {
        return __async(this, null, function* () {
          const optionsToSelect = [...elements, ...values];
          yield progress2.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress2, options.noWaitAfter, () => __async(this, null, function* () {
            progress2.throwIfAborted();
            progress2.log("  selecting specified option(s)");
            const result = yield this.evaluatePoll(progress2, ([injected, node, {
              optionsToSelect: optionsToSelect2,
              force
            }]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled"], force, injected.selectOptions.bind(injected, optionsToSelect2));
            }, {
              optionsToSelect,
              force: options.force
            });
            return result;
          }));
        });
      }
      fill(_0, _1) {
        return __async(this, arguments, function* (metadata, value, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._fill(progress2, value, options);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _fill(progress2, value, options) {
        return __async(this, null, function* () {
          progress2.log(`elementHandle.fill("${value}")`);
          yield progress2.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress2, options.noWaitAfter, () => __async(this, null, function* () {
            progress2.log("  waiting for element to be visible, enabled and editable");
            const filled = yield this.evaluatePoll(progress2, ([injected, node, {
              value: value2,
              force
            }]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled", "editable"], force, injected.fill.bind(injected, value2));
            }, {
              value,
              force: options.force
            });
            progress2.throwIfAborted();
            if (filled === "error:notconnected")
              return filled;
            progress2.log("  element is visible, enabled and editable");
            if (filled === "needsinput") {
              progress2.throwIfAborted();
              if (value)
                yield this._page.keyboard.insertText(value);
              else
                yield this._page.keyboard.press("Delete");
            } else {
              assertDone(filled);
            }
            return "done";
          }), "input");
        });
      }
      selectText(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            progress2.throwIfAborted();
            const result = yield this.evaluatePoll(progress2, ([injected, node, force]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible"], force, injected.selectText.bind(injected));
            }, options.force);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      setInputFiles(metadata, items, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._setInputFiles(progress2, items, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setInputFiles(progress2, items, options) {
        return __async(this, null, function* () {
          const {
            files,
            localPaths
          } = items;
          let filePayloads;
          if (files) {
            filePayloads = [];
            for (const payload of files) {
              filePayloads.push({
                name: payload.name,
                mimeType: payload.mimeType || _utilsBundle.mime.getType(payload.name) || "application/octet-stream",
                buffer: payload.buffer.toString("base64")
              });
            }
          }
          const multiple = files && files.length > 1 || localPaths && localPaths.length > 1;
          const result = yield this.evaluateHandleInUtility(([injected, node, multiple2]) => {
            const element = injected.retarget(node, "follow-label");
            if (!element)
              return;
            if (element.tagName !== "INPUT")
              throw injected.createStacklessError("Node is not an HTMLInputElement");
            if (multiple2 && !element.multiple)
              throw injected.createStacklessError("Non-multiple file input can only accept single file");
            return element;
          }, multiple);
          if (result === "error:notconnected" || !result.asElement())
            return "error:notconnected";
          const retargeted = result.asElement();
          yield progress2.beforeInputAction(this);
          yield this._page._frameManager.waitForSignalsCreatedBy(progress2, options.noWaitAfter, () => __async(this, null, function* () {
            progress2.throwIfAborted();
            if (localPaths)
              yield this._page._delegate.setInputFilePaths(progress2, retargeted, localPaths);
            else
              yield this._page._delegate.setInputFiles(retargeted, filePayloads);
          }));
          return "done";
        });
      }
      focus(metadata) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._focus(progress2);
            return assertDone(throwRetargetableDOMError(result));
          }), 0);
        });
      }
      _focus(progress2, resetSelectionIfNotFocused) {
        return __async(this, null, function* () {
          progress2.throwIfAborted();
          return yield this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused2]) => injected.focusNode(node, resetSelectionIfNotFocused2), resetSelectionIfNotFocused);
        });
      }
      _blur(progress2) {
        return __async(this, null, function* () {
          progress2.throwIfAborted();
          return yield this.evaluateInUtility(([injected, node]) => injected.blurNode(node), {});
        });
      }
      type(metadata, text, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._type(progress2, text, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _type(progress2, text, options) {
        return __async(this, null, function* () {
          progress2.log(`elementHandle.type("${text}")`);
          yield progress2.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress2, options.noWaitAfter, () => __async(this, null, function* () {
            const result = yield this._focus(progress2, true);
            if (result !== "done")
              return result;
            progress2.throwIfAborted();
            yield this._page.keyboard.type(text, options);
            return "done";
          }), "input");
        });
      }
      press(metadata, key, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._press(progress2, key, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _press(progress2, key, options) {
        return __async(this, null, function* () {
          progress2.log(`elementHandle.press("${key}")`);
          yield progress2.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress2, options.noWaitAfter, () => __async(this, null, function* () {
            const result = yield this._focus(progress2, true);
            if (result !== "done")
              return result;
            progress2.throwIfAborted();
            yield this._page.keyboard.press(key, options);
            return "done";
          }), "input");
        });
      }
      check(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._setChecked(progress2, true, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      uncheck(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            const result = yield this._setChecked(progress2, false, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setChecked(progress2, state, options) {
        return __async(this, null, function* () {
          const isChecked = () => __async(this, null, function* () {
            const result2 = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
            return throwRetargetableDOMError(result2);
          });
          if ((yield isChecked()) === state)
            return "done";
          const result = yield this._click(progress2, options);
          if (result !== "done")
            return result;
          if (options.trial)
            return "done";
          if ((yield isChecked()) !== state)
            throw new NonRecoverableDOMError("Clicking the checkbox did not change its state");
          return "done";
        });
      }
      boundingBox() {
        return __async(this, null, function* () {
          return this._page._delegate.getBoundingBox(this);
        });
      }
      screenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this._page._screenshotter.screenshotElement(progress2, this, options), this._page._timeoutSettings.timeout(options));
        });
      }
      querySelector(selector, options) {
        return __async(this, null, function* () {
          return this._frame.selectors.query(selector, options, this);
        });
      }
      querySelectorAll(selector) {
        return __async(this, null, function* () {
          return this._frame.selectors.queryAll(selector, this);
        });
      }
      evalOnSelector(selector, strict, expression, isFunction, arg) {
        return __async(this, null, function* () {
          return this._frame.evalOnSelector(selector, strict, expression, isFunction, arg, this);
        });
      }
      evalOnSelectorAll(selector, expression, isFunction, arg) {
        return __async(this, null, function* () {
          return this._frame.evalOnSelectorAll(selector, expression, isFunction, arg, this);
        });
      }
      isVisible(metadata) {
        return __async(this, null, function* () {
          return this._frame.isVisible(metadata, ":scope", {}, this);
        });
      }
      isHidden(metadata) {
        return __async(this, null, function* () {
          return this._frame.isHidden(metadata, ":scope", {}, this);
        });
      }
      isEnabled(metadata) {
        return __async(this, null, function* () {
          return this._frame.isEnabled(metadata, ":scope", {}, this);
        });
      }
      isDisabled(metadata) {
        return __async(this, null, function* () {
          return this._frame.isDisabled(metadata, ":scope", {}, this);
        });
      }
      isEditable(metadata) {
        return __async(this, null, function* () {
          return this._frame.isEditable(metadata, ":scope", {}, this);
        });
      }
      isChecked(metadata) {
        return __async(this, null, function* () {
          return this._frame.isChecked(metadata, ":scope", {}, this);
        });
      }
      waitForElementState(_0, _1) {
        return __async(this, arguments, function* (metadata, state, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            progress2.log(`  waiting for element to be ${state}`);
            const result = yield this.evaluatePoll(progress2, ([injected, node, state2]) => {
              return injected.waitForElementStatesAndPerformAction(node, [state2], false, () => "done");
            }, state);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForSelector(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._frame.waitForSelector(metadata, selector, options, this);
        });
      }
      _adoptTo(context) {
        return __async(this, null, function* () {
          if (this._context !== context) {
            const adopted = yield this._page._delegate.adoptElementHandle(this, context);
            this.dispose();
            return adopted;
          }
          return this;
        });
      }
      _waitForElementStates(progress2, states, force) {
        return __async(this, null, function* () {
          const title = joinWithAnd(states);
          progress2.log(`  waiting for element to be ${title}`);
          const result = yield this.evaluatePoll(progress2, ([injected, node, {
            states: states2,
            force: force2
          }]) => {
            return injected.waitForElementStatesAndPerformAction(node, states2, force2, () => "done");
          }, {
            states,
            force
          });
          if (result === "error:notconnected")
            return result;
          progress2.log(`  element is ${title}`);
          return result;
        });
      }
      _checkFrameIsHitTarget(point) {
        return __async(this, null, function* () {
          let frame = this._frame;
          const data = [];
          while (frame.parentFrame()) {
            const frameElement = yield frame.frameElement();
            const box = yield frameElement.boundingBox();
            const style = yield frameElement.evaluateInUtility(([injected, iframe]) => injected.describeIFrameStyle(iframe), {}).catch((e) => "error:notconnected");
            if (!box || style === "error:notconnected")
              return "error:notconnected";
            if (style === "transformed") {
              return {
                framePoint: void 0
              };
            }
            const pointInFrame = {
              x: point.x - box.x - style.left,
              y: point.y - box.y - style.top
            };
            data.push({
              frame,
              frameElement,
              pointInFrame
            });
            frame = frame.parentFrame();
          }
          data.push({
            frame,
            frameElement: null,
            pointInFrame: point
          });
          for (let i = data.length - 1; i > 0; i--) {
            const element = data[i - 1].frameElement;
            const point2 = data[i].pointInFrame;
            const hitTargetResult = yield element.evaluateInUtility(([injected, element2, hitPoint]) => {
              return injected.expectHitTarget(hitPoint, element2);
            }, point2);
            if (hitTargetResult !== "done")
              return hitTargetResult;
          }
          return {
            framePoint: data[0].pointInFrame
          };
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    var InjectedScriptPollHandler = class {
      constructor(progress2, poll) {
        this._progress = void 0;
        this._poll = void 0;
        this._progress = progress2;
        this._poll = poll;
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
      }
      _streamLogs() {
        return __async(this, null, function* () {
          while (this._poll && this._progress.isRunning()) {
            const log = yield this._poll.evaluate((poll) => poll.takeNextLogs()).catch((e) => []);
            if (!this._poll || !this._progress.isRunning())
              return;
            for (const entry of log)
              this._progress.logEntry(entry);
          }
        });
      }
      finishHandle() {
        return __async(this, null, function* () {
          try {
            const result = yield this._poll.evaluateHandle((poll) => poll.run());
            yield this._finishInternal();
            return result;
          } finally {
            yield this.cancel();
          }
        });
      }
      finish() {
        return __async(this, null, function* () {
          try {
            const result = yield this._poll.evaluate((poll) => poll.run());
            yield this._finishInternal();
            return result;
          } finally {
            yield this.cancel();
          }
        });
      }
      _finishInternal() {
        return __async(this, null, function* () {
          if (!this._poll)
            return;
          const log = yield this._poll.evaluate((poll) => poll.takeLastLogs()).catch((e) => []);
          for (const entry of log)
            this._progress.logEntry(entry);
        });
      }
      cancel() {
        return __async(this, null, function* () {
          if (!this._poll)
            return;
          const copy = this._poll;
          this._poll = null;
          yield copy.evaluate((p) => p.cancel()).catch((e) => {
          });
          copy.dispose();
        });
      }
    };
    exports2.InjectedScriptPollHandler = InjectedScriptPollHandler;
    function throwRetargetableDOMError(result) {
      if (result === "error:notconnected")
        throw new Error("Element is not attached to the DOM");
      return result;
    }
    function assertDone(result) {
    }
    function roundPoint(point) {
      return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100
      };
    }
    function compensateHalfIntegerRoundingError(point) {
      const remainderX = point.x - Math.floor(point.x);
      if (remainderX > 0.49 && remainderX < 0.51)
        point.x -= 0.02;
      const remainderY = point.y - Math.floor(point.y);
      if (remainderY > 0.49 && remainderY < 0.51)
        point.y -= 0.02;
    }
    function joinWithAnd(strings) {
      if (strings.length < 1)
        return strings.join(", ");
      return strings.slice(0, strings.length - 1).join(", ") + " and " + strings[strings.length - 1];
    }
    var kUnableToAdoptErrorMessage = "Unable to adopt element handle from a different document";
    exports2.kUnableToAdoptErrorMessage = kUnableToAdoptErrorMessage;
  }
});

// node_modules/playwright-core/lib/server/types.js
var require_types = __commonJS({
  "node_modules/playwright-core/lib/server/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kLifecycleEvents = void 0;
    var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports2.kLifecycleEvents = kLifecycleEvents;
  }
});

// node_modules/playwright-core/lib/server/frameSelectors.js
var require_frameSelectors = __commonJS({
  "node_modules/playwright-core/lib/server/frameSelectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FrameSelectors = void 0;
    var _selectorParser = require_selectorParser();
    var _locatorGenerators = require_locatorGenerators();
    var FrameSelectors = class {
      constructor(frame) {
        this.frame = void 0;
        this.frame = frame;
      }
      _parseSelector(selector, options) {
        const strict = typeof (options === null || options === void 0 ? void 0 : options.strict) === "boolean" ? options.strict : !!this.frame._page.context()._options.strictSelectors;
        return this.frame._page.context().selectors().parseSelector(selector, strict);
      }
      query(selector, options, scope) {
        return __async(this, null, function* () {
          const resolved = yield this.resolveInjectedForSelector(selector, options, scope);
          if (!resolved)
            return null;
          const handle = yield resolved.injected.evaluateHandle((injected, {
            info,
            scope: scope2
          }) => {
            return injected.querySelector(info.parsed, scope2 || document, info.strict);
          }, {
            info: resolved.info,
            scope: resolved.scope
          });
          const elementHandle = handle.asElement();
          if (!elementHandle) {
            handle.dispose();
            return null;
          }
          return adoptIfNeeded(elementHandle, yield resolved.frame._mainContext());
        });
      }
      queryArrayInMainWorld(selector, scope) {
        return __async(this, null, function* () {
          const resolved = yield this.resolveInjectedForSelector(selector, {
            mainWorld: true
          }, scope);
          if (!resolved)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          return yield resolved.injected.evaluateHandle((injected, {
            info,
            scope: scope2
          }) => {
            return injected.querySelectorAll(info.parsed, scope2 || document);
          }, {
            info: resolved.info,
            scope: resolved.scope
          });
        });
      }
      queryCount(selector) {
        return __async(this, null, function* () {
          const resolved = yield this.resolveInjectedForSelector(selector);
          if (!resolved)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          return yield resolved.injected.evaluate((injected, {
            info
          }) => {
            return injected.querySelectorAll(info.parsed, document).length;
          }, {
            info: resolved.info
          });
        });
      }
      queryAll(selector, scope) {
        return __async(this, null, function* () {
          const resolved = yield this.resolveInjectedForSelector(selector, {}, scope);
          if (!resolved)
            return [];
          const arrayHandle = yield resolved.injected.evaluateHandle((injected, {
            info,
            scope: scope2
          }) => {
            return injected.querySelectorAll(info.parsed, scope2 || document);
          }, {
            info: resolved.info,
            scope: resolved.scope
          });
          const properties = yield arrayHandle.getProperties();
          arrayHandle.dispose();
          const targetContext = yield resolved.frame._mainContext();
          const result = [];
          for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
              result.push(adoptIfNeeded(elementHandle, targetContext));
            else
              property.dispose();
          }
          return Promise.all(result);
        });
      }
      resolveFrameForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}, scope) {
          let frame = this.frame;
          const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
          for (const chunk of frameChunks) {
            (0, _selectorParser.visitAllSelectorParts)(chunk, (part, nested) => {
              if (nested && part.name === "internal:control" && part.body === "enter-frame") {
                const locator = (0, _locatorGenerators.asLocator)(this.frame._page.attribution.playwright.options.sdkLanguage, selector);
                throw new _selectorParser.InvalidSelectorError(`Frame locators are not allowed inside composite locators, while querying "${locator}"`);
              }
            });
          }
          for (let i = 0; i < frameChunks.length - 1; ++i) {
            const info = this._parseSelector(frameChunks[i], options);
            const context = yield frame._context(info.world);
            const injectedScript = yield context.injectedScript();
            const handle = yield injectedScript.evaluateHandle((injected, {
              info: info2,
              scope: scope2,
              selectorString
            }) => {
              const element2 = injected.querySelector(info2.parsed, scope2 || document, info2.strict);
              if (element2 && element2.nodeName !== "IFRAME" && element2.nodeName !== "FRAME")
                throw injected.createStacklessError(`Selector "${selectorString}" resolved to ${injected.previewNode(element2)}, <iframe> was expected`);
              return element2;
            }, {
              info,
              scope: i === 0 ? scope : void 0,
              selectorString: (0, _selectorParser.stringifySelector)(info.parsed)
            });
            const element = handle.asElement();
            if (!element)
              return null;
            const maybeFrame = yield frame._page._delegate.getContentFrame(element);
            element.dispose();
            if (!maybeFrame)
              return null;
            frame = maybeFrame;
          }
          if (frame !== this.frame)
            scope = void 0;
          return {
            frame,
            info: frame.selectors._parseSelector(frameChunks[frameChunks.length - 1], options),
            scope
          };
        });
      }
      resolveInjectedForSelector(selector, options, scope) {
        return __async(this, null, function* () {
          const resolved = yield this.resolveFrameForSelector(selector, options, scope);
          if (!resolved)
            return;
          const context = yield resolved.frame._context(options !== null && options !== void 0 && options.mainWorld ? "main" : resolved.info.world);
          const injected = yield context.injectedScript();
          return {
            injected,
            info: resolved.info,
            frame: resolved.frame,
            scope: resolved.scope
          };
        });
      }
    };
    exports2.FrameSelectors = FrameSelectors;
    function adoptIfNeeded(handle, context) {
      return __async(this, null, function* () {
        if (handle._context === context)
          return handle;
        const adopted = handle._page._delegate.adoptElementHandle(handle, context);
        handle.dispose();
        return adopted;
      });
    }
  }
});

// node_modules/playwright-core/lib/server/frames.js
var require_frames = __commonJS({
  "node_modules/playwright-core/lib/server/frames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NavigationAbortedError = exports2.FrameManager = exports2.Frame = void 0;
    var dom = _interopRequireWildcard(require_dom());
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var js = _interopRequireWildcard(require_javascript());
    var network = _interopRequireWildcard(require_network2());
    var _page = require_page();
    var types = _interopRequireWildcard(require_types());
    var _browserContext = require_browserContext();
    var _progress = require_progress();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    var _protocolError = require_protocolError();
    var _selectorParser = require_selectorParser();
    var _locatorGenerators = require_locatorGenerators();
    var _frameSelectors = require_frameSelectors();
    var _errors = require_errors();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var NavigationAbortedError = class extends Error {
      constructor(documentId, message) {
        super(message);
        this.documentId = void 0;
        this.documentId = documentId;
      }
    };
    exports2.NavigationAbortedError = NavigationAbortedError;
    var kDummyFrameId = "<dummy>";
    var FrameManager = class {
      constructor(page) {
        this._page = void 0;
        this._frames = /* @__PURE__ */ new Map();
        this._mainFrame = void 0;
        this._consoleMessageTags = /* @__PURE__ */ new Map();
        this._signalBarriers = /* @__PURE__ */ new Set();
        this._webSockets = /* @__PURE__ */ new Map();
        this._openedDialogs = /* @__PURE__ */ new Set();
        this._closeAllOpeningDialogs = false;
        this._page = page;
        this._mainFrame = void 0;
      }
      createDummyMainFrameIfNeeded() {
        if (!this._mainFrame)
          this.frameAttached(kDummyFrameId, null);
      }
      dispose() {
        for (const frame of this._frames.values()) {
          frame._stopNetworkIdleTimer();
          frame._invalidateNonStallingEvaluations("Target crashed");
        }
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
          frames.push(frame);
          for (const subframe of frame.childFrames())
            collect(subframe);
        }
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
          if (this._mainFrame) {
            this._frames.delete(this._mainFrame._id);
            this._mainFrame._id = frameId;
          } else {
            (0, _utils.assert)(!this._frames.has(frameId));
            this._mainFrame = new Frame(this._page, frameId, parentFrame);
          }
          this._frames.set(frameId, this._mainFrame);
          return this._mainFrame;
        } else {
          (0, _utils.assert)(!this._frames.has(frameId));
          const frame = new Frame(this._page, frameId, parentFrame);
          this._frames.set(frameId, frame);
          this._page.emit(_page.Page.Events.FrameAttached, frame);
          return frame;
        }
      }
      waitForSignalsCreatedBy(progress2, noWaitAfter, action, source) {
        return __async(this, null, function* () {
          if (noWaitAfter)
            return action();
          const barrier = new SignalBarrier(progress2);
          this._signalBarriers.add(barrier);
          if (progress2)
            progress2.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
          const result = yield action();
          if (source === "input")
            yield this._page._delegate.inputActionEpilogue();
          yield barrier.waitFor();
          this._signalBarriers.delete(barrier);
          yield new Promise((0, _utils.makeWaitForNextTask)());
          return result;
        });
      }
      frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.retain();
      }
      frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.release();
      }
      frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        for (const barrier of this._signalBarriers)
          barrier.addFrameNavigation(frame);
        if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
          return;
        }
        frame.setPendingDocument({
          documentId,
          request: void 0
        });
      }
      frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        this.clearWebSockets(frame);
        frame._url = url;
        frame._name = name;
        let keepPending;
        const pendingDocument = frame.pendingDocument();
        if (pendingDocument) {
          if (pendingDocument.documentId === void 0) {
            pendingDocument.documentId = documentId;
          }
          if (pendingDocument.documentId === documentId) {
            frame._currentDocument = pendingDocument;
          } else {
            keepPending = pendingDocument;
            frame._currentDocument = {
              documentId,
              request: void 0
            };
          }
          frame.setPendingDocument(void 0);
        } else {
          frame._currentDocument = {
            documentId,
            request: void 0
          };
        }
        frame._onClearLifecycle();
        const navigationEvent = {
          url,
          name,
          newDocument: frame._currentDocument,
          isPublic: true
        };
        this._fireInternalFrameNavigation(frame, navigationEvent);
        if (!initial) {
          _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
          this._page.frameNavigatedToNewDocument(frame);
        }
        frame.setPendingDocument(keepPending);
      }
      frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._url = url;
        const navigationEvent = {
          url,
          name: frame._name,
          isPublic: true
        };
        this._fireInternalFrameNavigation(frame, navigationEvent);
        _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
      }
      frameAbortedNavigation(frameId, errorText, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame || !frame.pendingDocument())
          return;
        if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
          return;
        const navigationEvent = {
          url: frame._url,
          name: frame._name,
          newDocument: frame.pendingDocument(),
          error: new NavigationAbortedError(documentId, errorText),
          isPublic: !(documentId && frame._redirectedNavigations.has(documentId))
        };
        frame.setPendingDocument(void 0);
        this._fireInternalFrameNavigation(frame, navigationEvent);
      }
      frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame) {
          this._removeFramesRecursively(frame);
          this._page.mainFrame()._recalculateNetworkIdle();
        }
      }
      frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (frame)
          frame._onLifecycleEvent(event);
      }
      requestStarted(request, route) {
        const frame = request.frame();
        this._inflightRequestStarted(request);
        if (request._documentId)
          frame.setPendingDocument({
            documentId: request._documentId,
            request
          });
        if (request._isFavicon) {
          if (route)
            route.continue(request, {
              isFallback: true
            });
          return;
        }
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Request, request);
        if (route) {
          var _this$_page$_serverRe, _this$_page, _this$_page$_clientRe, _this$_page2, _this$_page$_browserC, _this$_page$_browserC2;
          const r = new network.Route(request, route);
          if ((_this$_page$_serverRe = (_this$_page = this._page)._serverRequestInterceptor) !== null && _this$_page$_serverRe !== void 0 && _this$_page$_serverRe.call(_this$_page, r, request))
            return;
          if ((_this$_page$_clientRe = (_this$_page2 = this._page)._clientRequestInterceptor) !== null && _this$_page$_clientRe !== void 0 && _this$_page$_clientRe.call(_this$_page2, r, request))
            return;
          if ((_this$_page$_browserC = (_this$_page$_browserC2 = this._page._browserContext)._requestInterceptor) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.call(_this$_page$_browserC2, r, request))
            return;
          r.continue({
            isFallback: true
          });
        }
      }
      requestReceivedResponse(response) {
        if (response.request()._isFavicon)
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Response, response);
      }
      reportRequestFinished(request, response) {
        this._inflightRequestFinished(request);
        if (request._isFavicon)
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFinished, {
          request,
          response
        });
      }
      requestFailed(request, canceled) {
        const frame = request.frame();
        this._inflightRequestFinished(request);
        if (frame.pendingDocument() && frame.pendingDocument().request === request) {
          let errorText = request.failure().errorText;
          if (canceled)
            errorText += "; maybe frame was detached?";
          this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
        }
        if (request._isFavicon)
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFailed, request);
      }
      dialogDidOpen(dialog) {
        for (const frame of this._frames.values())
          frame._invalidateNonStallingEvaluations("JavaScript dialog interrupted evaluation");
        if (this._closeAllOpeningDialogs)
          dialog.close().then(() => {
          });
        else
          this._openedDialogs.add(dialog);
      }
      dialogWillClose(dialog) {
        this._openedDialogs.delete(dialog);
      }
      closeOpenDialogs() {
        return __async(this, null, function* () {
          yield Promise.all([...this._openedDialogs].map((dialog) => dialog.close())).catch(() => {
          });
          this._openedDialogs.clear();
        });
      }
      setCloseAllOpeningDialogs(closeDialogs) {
        this._closeAllOpeningDialogs = closeDialogs;
      }
      removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
      }
      _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        if (!this._page.isClosed())
          this._page.emit(_page.Page.Events.FrameDetached, frame);
      }
      _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        if (!frame._inflightRequests.has(request))
          return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
          frame._startNetworkIdleTimer();
      }
      _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
          frame._stopNetworkIdleTimer();
      }
      interceptConsoleMessage(message) {
        if (message.type() !== "debug")
          return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
          return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
      }
      clearWebSockets(frame) {
        if (frame.parentFrame())
          return;
        this._webSockets.clear();
      }
      onWebSocketCreated(requestId, url) {
        const ws2 = new network.WebSocket(this._page, url);
        this._webSockets.set(requestId, ws2);
      }
      onWebSocketRequest(requestId) {
        const ws2 = this._webSockets.get(requestId);
        if (ws2 && ws2.markAsNotified())
          this._page.emit(_page.Page.Events.WebSocket, ws2);
      }
      onWebSocketResponse(requestId, status, statusText) {
        const ws2 = this._webSockets.get(requestId);
        if (status < 400)
          return;
        if (ws2)
          ws2.error(`${statusText}: ${status}`);
      }
      onWebSocketFrameSent(requestId, opcode, data) {
        const ws2 = this._webSockets.get(requestId);
        if (ws2)
          ws2.frameSent(opcode, data);
      }
      webSocketFrameReceived(requestId, opcode, data) {
        const ws2 = this._webSockets.get(requestId);
        if (ws2)
          ws2.frameReceived(opcode, data);
      }
      webSocketClosed(requestId) {
        const ws2 = this._webSockets.get(requestId);
        if (ws2)
          ws2.closed();
        this._webSockets.delete(requestId);
      }
      webSocketError(requestId, errorMessage) {
        const ws2 = this._webSockets.get(requestId);
        if (ws2)
          ws2.error(errorMessage);
      }
      _fireInternalFrameNavigation(frame, event) {
        frame.emit(Frame.Events.InternalNavigation, event);
      }
    };
    exports2.FrameManager = FrameManager;
    var Frame = class extends _instrumentation.SdkObject {
      constructor(page, id, parentFrame) {
        super(page, "frame");
        this._id = void 0;
        this._firedLifecycleEvents = /* @__PURE__ */ new Set();
        this._firedNetworkIdleSelf = false;
        this._currentDocument = void 0;
        this._pendingDocument = void 0;
        this._page = void 0;
        this._parentFrame = void 0;
        this._url = "";
        this._detached = false;
        this._contextData = /* @__PURE__ */ new Map();
        this._childFrames = /* @__PURE__ */ new Set();
        this._name = "";
        this._inflightRequests = /* @__PURE__ */ new Set();
        this._networkIdleTimer = void 0;
        this._setContentCounter = 0;
        this._detachedPromise = void 0;
        this._detachedCallback = () => {
        };
        this._raceAgainstEvaluationStallingEventsPromises = /* @__PURE__ */ new Set();
        this._redirectedNavigations = /* @__PURE__ */ new Map();
        this.selectors = void 0;
        this.attribution.frame = this;
        this._id = id;
        this._page = page;
        this._parentFrame = parentFrame;
        this._currentDocument = {
          documentId: void 0,
          request: void 0
        };
        this.selectors = new _frameSelectors.FrameSelectors(this);
        this._detachedPromise = new Promise((x) => this._detachedCallback = x);
        this._contextData.set("main", {
          contextPromise: new _manualPromise.ManualPromise(),
          context: null
        });
        this._contextData.set("utility", {
          contextPromise: new _manualPromise.ManualPromise(),
          context: null
        });
        this._setContext("main", null);
        this._setContext("utility", null);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._firedLifecycleEvents.add("commit");
        if (id !== kDummyFrameId)
          this._startNetworkIdleTimer();
      }
      isDetached() {
        return this._detached;
      }
      _onLifecycleEvent(event) {
        if (this._firedLifecycleEvents.has(event))
          return;
        this._firedLifecycleEvents.add(event);
        this.emit(Frame.Events.AddLifecycle, event);
        if (this === this._page.mainFrame() && this._url !== "about:blank")
          _debugLogger.debugLogger.log("api", `  "${event}" event fired`);
        this._page.mainFrame()._recalculateNetworkIdle();
      }
      _onClearLifecycle() {
        for (const event of this._firedLifecycleEvents)
          this.emit(Frame.Events.RemoveLifecycle, event);
        this._firedLifecycleEvents.clear();
        this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request) => request === this._currentDocument.request));
        this._stopNetworkIdleTimer();
        if (this._inflightRequests.size === 0)
          this._startNetworkIdleTimer();
        this._page.mainFrame()._recalculateNetworkIdle(this);
        this._onLifecycleEvent("commit");
      }
      setPendingDocument(documentInfo) {
        this._pendingDocument = documentInfo;
        if (documentInfo)
          this._invalidateNonStallingEvaluations("Navigation interrupted the evaluation");
      }
      pendingDocument() {
        return this._pendingDocument;
      }
      _invalidateNonStallingEvaluations(message) {
        if (!this._raceAgainstEvaluationStallingEventsPromises.size)
          return;
        const error = new Error(message);
        for (const promise of this._raceAgainstEvaluationStallingEventsPromises)
          promise.reject(error);
      }
      raceAgainstEvaluationStallingEvents(cb) {
        return __async(this, null, function* () {
          if (this._pendingDocument)
            throw new Error("Frame is currently attempting a navigation");
          if (this._page._frameManager._openedDialogs.size)
            throw new Error("Open JavaScript dialog prevents evaluation");
          const promise = new _manualPromise.ManualPromise();
          this._raceAgainstEvaluationStallingEventsPromises.add(promise);
          try {
            return yield Promise.race([cb(), promise]);
          } finally {
            this._raceAgainstEvaluationStallingEventsPromises.delete(promise);
          }
        });
      }
      nonStallingRawEvaluateInExistingMainContext(expression) {
        return this.raceAgainstEvaluationStallingEvents(() => {
          const context = this._existingMainContext();
          if (!context)
            throw new Error("Frame does not yet have a main execution context");
          return context.rawEvaluateJSON(expression);
        });
      }
      nonStallingEvaluateInExistingContext(expression, isFunction, world) {
        return this.raceAgainstEvaluationStallingEvents(() => {
          var _this$_contextData$ge;
          const context = (_this$_contextData$ge = this._contextData.get(world)) === null || _this$_contextData$ge === void 0 ? void 0 : _this$_contextData$ge.context;
          if (!context)
            throw new Error("Frame does not yet have the execution context");
          return context.evaluateExpression(expression, {
            isFunction
          });
        });
      }
      _recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle) {
        let isNetworkIdle = this._firedNetworkIdleSelf;
        for (const child of this._childFrames) {
          child._recalculateNetworkIdle(frameThatAllowsRemovingNetworkIdle);
          if (!child._firedLifecycleEvents.has("networkidle"))
            isNetworkIdle = false;
        }
        if (isNetworkIdle && !this._firedLifecycleEvents.has("networkidle")) {
          this._firedLifecycleEvents.add("networkidle");
          this.emit(Frame.Events.AddLifecycle, "networkidle");
          if (this === this._page.mainFrame() && this._url !== "about:blank")
            _debugLogger.debugLogger.log("api", `  "networkidle" event fired`);
        }
        if (frameThatAllowsRemovingNetworkIdle !== this && this._firedLifecycleEvents.has("networkidle") && !isNetworkIdle) {
          this._firedLifecycleEvents.delete("networkidle");
          this.emit(Frame.Events.RemoveLifecycle, "networkidle");
        }
      }
      raceNavigationAction(progress2, options, action) {
        return __async(this, null, function* () {
          return Promise.race([this._page._disconnectedPromise.then(() => {
            throw new Error("Navigation failed because page was closed!");
          }), this._page._crashedPromise.then(() => {
            throw new Error("Navigation failed because page crashed!");
          }), this._detachedPromise.then(() => {
            throw new Error("Navigating frame was detached!");
          }), action().catch((e) => {
            if (e instanceof NavigationAbortedError && e.documentId) {
              const data = this._redirectedNavigations.get(e.documentId);
              if (data) {
                progress2.log(`waiting for redirected navigation to "${data.url}"`);
                return data.gotoPromise;
              }
            }
            throw e;
          })]);
        });
      }
      redirectNavigation(url, documentId, referer) {
        const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
        const data = {
          url,
          gotoPromise: controller.run((progress2) => this._gotoAction(progress2, url, {
            referer
          }), 0)
        };
        this._redirectedNavigations.set(documentId, data);
        data.gotoPromise.finally(() => this._redirectedNavigations.delete(documentId));
      }
      goto(_0, _1) {
        return __async(this, arguments, function* (metadata, url, options = {}) {
          const constructedNavigationURL = (0, _utils.constructURLBasedOnBaseURL)(this._page._browserContext._options.baseURL, url);
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this._goto(progress2, constructedNavigationURL, options), this._page._timeoutSettings.navigationTimeout(options));
        });
      }
      _goto(progress2, url, options) {
        return __async(this, null, function* () {
          return this.raceNavigationAction(progress2, options, () => __async(this, null, function* () {
            return this._gotoAction(progress2, url, options);
          }));
        });
      }
      _gotoAction(progress2, url, options) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          progress2.log(`navigating to "${url}", waiting until "${waitUntil}"`);
          const headers = this._page.extraHTTPHeaders() || [];
          const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
          let referer = refererHeader ? refererHeader.value : void 0;
          if (options.referer !== void 0) {
            if (referer !== void 0 && referer !== options.referer)
              throw new Error('"referer" is already specified as extra HTTP header');
            referer = options.referer;
          }
          url = _helper.helper.completeUserURL(url);
          const sameDocument = _helper.helper.waitForEvent(progress2, this, Frame.Events.InternalNavigation, (e) => !e.newDocument);
          const navigateResult = yield this._page._delegate.navigateFrame(this, url, referer);
          let event;
          if (navigateResult.newDocumentId) {
            sameDocument.dispose();
            event = yield _helper.helper.waitForEvent(progress2, this, Frame.Events.InternalNavigation, (event2) => {
              return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
            }).promise;
            if (event.newDocument.documentId !== navigateResult.newDocumentId) {
              throw new NavigationAbortedError(navigateResult.newDocumentId, `Navigation to "${url}" is interrupted by another navigation to "${event.url}"`);
            }
            if (event.error)
              throw event.error;
          } else {
            event = yield sameDocument.promise;
          }
          if (!this._firedLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress2, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
          const request = event.newDocument ? event.newDocument.request : void 0;
          const response = request ? request._finalRequest().response() : null;
          return response;
        });
      }
      _waitForNavigation(progress2, requiresNewDocument, options) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          progress2.log(`waiting for navigation until "${waitUntil}"`);
          const navigationEvent = yield _helper.helper.waitForEvent(progress2, this, Frame.Events.InternalNavigation, (event) => {
            if (event.error)
              return true;
            if (requiresNewDocument && !event.newDocument)
              return false;
            progress2.log(`  navigated to "${this._url}"`);
            return true;
          }).promise;
          if (navigationEvent.error)
            throw navigationEvent.error;
          if (!this._firedLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress2, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
          const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
          return request ? request._finalRequest().response() : null;
        });
      }
      _waitForLoadState(progress2, state) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("state", state);
          if (!this._firedLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress2, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return this._page._delegate.getFrameElement(this);
        });
      }
      _context(world) {
        return this._contextData.get(world).contextPromise.then((contextOrError) => {
          if (contextOrError instanceof js.ExecutionContext)
            return contextOrError;
          throw contextOrError;
        });
      }
      _mainContext() {
        return this._context("main");
      }
      _existingMainContext() {
        var _this$_contextData$ge2;
        return ((_this$_contextData$ge2 = this._contextData.get("main")) === null || _this$_contextData$ge2 === void 0 ? void 0 : _this$_contextData$ge2.context) || null;
      }
      _utilityContext() {
        return this._context("utility");
      }
      evaluateExpression(_0) {
        return __async(this, arguments, function* (expression, options = {}, arg) {
          var _options$world;
          const context = yield this._context((_options$world = options.world) !== null && _options$world !== void 0 ? _options$world : "main");
          const value = yield context.evaluateExpression(expression, options, arg);
          return value;
        });
      }
      evaluateExpressionHandle(_0) {
        return __async(this, arguments, function* (expression, options = {}, arg) {
          var _options$world2;
          const context = yield this._context((_options$world2 = options.world) !== null && _options$world2 !== void 0 ? _options$world2 : "main");
          const value = yield context.evaluateExpressionHandle(expression, options, arg);
          return value;
        });
      }
      querySelector(selector, options) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("api", `    finding element using the selector "${selector}"`);
          return this.selectors.query(selector, options);
        });
      }
      waitForSelector(metadata, selector, options, scope) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          if (options.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options.waitFor && options.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const {
            state = "visible"
          } = options;
          if (!["attached", "detached", "visible", "hidden"].includes(state))
            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
          return controller.run((progress2) => __async(this, null, function* () {
            progress2.log(`waiting for ${this._asLocator(selector)}${state === "attached" ? "" : " to be " + state}`);
            const promise = this.retryWithProgressAndTimeouts(progress2, [0, 20, 50, 100, 100, 500], (continuePolling) => __async(this, null, function* () {
              const resolved = yield this.selectors.resolveInjectedForSelector(selector, options, scope);
              progress2.throwIfAborted();
              if (!resolved) {
                if (state === "hidden" || state === "detached")
                  return null;
                return continuePolling;
              }
              const result = yield resolved.injected.evaluateHandle((injected, {
                info,
                root
              }) => {
                const elements = injected.querySelectorAll(info.parsed, root || document);
                const element2 = elements[0];
                const visible2 = element2 ? injected.isVisible(element2) : false;
                let log2 = "";
                if (elements.length > 1) {
                  if (info.strict)
                    throw injected.strictModeViolationError(info.parsed, elements);
                  log2 = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
                } else if (element2) {
                  log2 = `  locator resolved to ${visible2 ? "visible" : "hidden"} ${injected.previewNode(element2)}`;
                }
                return {
                  log: log2,
                  element: element2,
                  visible: visible2,
                  attached: !!element2
                };
              }, {
                info: resolved.info,
                root: resolved.frame === this ? scope : void 0
              });
              const {
                log,
                visible,
                attached
              } = yield result.evaluate((r) => ({
                log: r.log,
                visible: r.visible,
                attached: r.attached
              }));
              if (log)
                progress2.log(log);
              const success = {
                attached,
                detached: !attached,
                visible,
                hidden: !visible
              }[state];
              if (!success) {
                result.dispose();
                return continuePolling;
              }
              if (options.omitReturnValue) {
                result.dispose();
                return null;
              }
              const element = state === "attached" || state === "visible" ? yield result.evaluateHandle((r) => r.element) : null;
              result.dispose();
              if (!element)
                return null;
              if (options.__testHookBeforeAdoptNode)
                yield options.__testHookBeforeAdoptNode();
              try {
                return yield element._adoptTo(yield resolved.frame._mainContext());
              } catch (e) {
                return continuePolling;
              }
            }));
            return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dispatchEvent(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, type, eventInit = {}, options = {}, scope) {
          yield this._callOnElementOnceMatches(metadata, selector, (injectedScript, element, data) => {
            injectedScript.dispatchEvent(element, data.type, data.eventInit);
          }, {
            type,
            eventInit
          }, __spreadValues({
            mainWorld: true
          }, options), scope);
        });
      }
      evalOnSelector(selector, strict, expression, isFunction, arg, scope) {
        return __async(this, null, function* () {
          const handle = yield this.selectors.query(selector, {
            strict
          }, scope);
          if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          const result = yield handle.evaluateExpression(expression, {
            isFunction
          }, arg);
          handle.dispose();
          return result;
        });
      }
      evalOnSelectorAll(selector, expression, isFunction, arg, scope) {
        return __async(this, null, function* () {
          const arrayHandle = yield this.selectors.queryArrayInMainWorld(selector, scope);
          const result = yield arrayHandle.evaluateExpression(expression, {
            isFunction
          }, arg);
          arrayHandle.dispose();
          return result;
        });
      }
      maskSelectors(selectors, color) {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          const injectedScript = yield context.injectedScript();
          yield injectedScript.evaluate((injected, {
            parsed,
            color: color2
          }) => {
            injected.maskSelectors(parsed, color2);
          }, {
            parsed: selectors,
            color
          });
        });
      }
      querySelectorAll(selector) {
        return __async(this, null, function* () {
          return this.selectors.queryAll(selector);
        });
      }
      queryCount(selector) {
        return __async(this, null, function* () {
          return yield this.selectors.queryCount(selector);
        });
      }
      content() {
        return __async(this, null, function* () {
          try {
            const context = yield this._utilityContext();
            return yield context.evaluate(() => {
              let retVal = "";
              if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
              if (document.documentElement)
                retVal += document.documentElement.outerHTML;
              return retVal;
            });
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
          }
        });
      }
      setContent(_0, _1) {
        return __async(this, arguments, function* (metadata, html, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            yield this.raceNavigationAction(progress2, options, () => __async(this, null, function* () {
              const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
              progress2.log(`setting frame content, waiting until "${waitUntil}"`);
              const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
              const context = yield this._utilityContext();
              const lifecyclePromise = new Promise((resolve, reject) => {
                this._page._frameManager._consoleMessageTags.set(tag, () => {
                  this._onClearLifecycle();
                  this._waitForLoadState(progress2, waitUntil).then(resolve).catch(reject);
                });
              });
              const contentPromise = context.evaluate(({
                html: html2,
                tag: tag2
              }) => {
                window.stop();
                document.open();
                console.debug(tag2);
                document.write(html2);
                document.close();
              }, {
                html,
                tag
              });
              yield Promise.all([contentPromise, lifecyclePromise]);
              return null;
            }));
          }), this._page._timeoutSettings.navigationTimeout(options));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      addScriptTag(params) {
        return __async(this, null, function* () {
          const {
            url = null,
            content = null,
            type = ""
          } = params;
          if (!url && !content)
            throw new Error("Provide an object with a `url`, `path` or `content` property");
          const context = yield this._mainContext();
          return this._raceWithCSPError(() => __async(this, null, function* () {
            if (url !== null)
              return (yield context.evaluateHandle(addScriptUrl, {
                url,
                type
              })).asElement();
            const result = (yield context.evaluateHandle(addScriptContent, {
              content,
              type
            })).asElement();
            if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
              yield context.evaluate(() => true);
            return result;
          }));
          function addScriptUrl(params2) {
            return __async(this, null, function* () {
              const script = document.createElement("script");
              script.src = params2.url;
              if (params2.type)
                script.type = params2.type;
              const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
              });
              document.head.appendChild(script);
              yield promise;
              return script;
            });
          }
          function addScriptContent(params2) {
            const script = document.createElement("script");
            script.type = params2.type || "text/javascript";
            script.text = params2.content;
            let error = null;
            script.onerror = (e) => error = e;
            document.head.appendChild(script);
            if (error)
              throw error;
            return script;
          }
        });
      }
      addStyleTag(params) {
        return __async(this, null, function* () {
          const {
            url = null,
            content = null
          } = params;
          if (!url && !content)
            throw new Error("Provide an object with a `url`, `path` or `content` property");
          const context = yield this._mainContext();
          return this._raceWithCSPError(() => __async(this, null, function* () {
            if (url !== null)
              return (yield context.evaluateHandle(addStyleUrl, url)).asElement();
            return (yield context.evaluateHandle(addStyleContent, content)).asElement();
          }));
          function addStyleUrl(url2) {
            return __async(this, null, function* () {
              const link = document.createElement("link");
              link.rel = "stylesheet";
              link.href = url2;
              const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
              });
              document.head.appendChild(link);
              yield promise;
              return link;
            });
          }
          function addStyleContent(content2) {
            return __async(this, null, function* () {
              const style = document.createElement("style");
              style.type = "text/css";
              style.appendChild(document.createTextNode(content2));
              const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
              });
              document.head.appendChild(style);
              yield promise;
              return style;
            });
          }
        });
      }
      _raceWithCSPError(func) {
        return __async(this, null, function* () {
          const listeners = [];
          let result;
          let error;
          let cspMessage;
          const actionPromise = func().then((r) => result = r).catch((e) => error = e);
          const errorPromise = new Promise((resolve) => {
            listeners.push(_eventsHelper.eventsHelper.addEventListener(this._page._browserContext, _browserContext.BrowserContext.Events.Console, (message) => {
              if (message.page() !== this._page || message.type() !== "error")
                return;
              if (message.text().includes("Content-Security-Policy") || message.text().includes("Content Security Policy")) {
                cspMessage = message;
                resolve();
              }
            }));
          });
          yield Promise.race([actionPromise, errorPromise]);
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          if (cspMessage)
            throw new Error(cspMessage.text());
          if (error)
            throw error;
          return result;
        });
      }
      retryWithProgressAndTimeouts(progress2, timeouts, action) {
        return __async(this, null, function* () {
          const continuePolling = Symbol("continuePolling");
          timeouts = [0, ...timeouts];
          let timeoutIndex = 0;
          while (progress2.isRunning()) {
            const timeout = timeouts[Math.min(timeoutIndex++, timeouts.length - 1)];
            if (timeout) {
              yield Promise.race([this._page._disconnectedPromise, this._page._crashedPromise, this._detachedPromise, new Promise((f) => setTimeout(f, timeout))]);
            }
            progress2.throwIfAborted();
            try {
              const result = yield action(continuePolling);
              if (result === continuePolling)
                continue;
              return result;
            } catch (e) {
              if (this._isErrorThatCannotBeRetried(e))
                throw e;
              continue;
            }
          }
          progress2.throwIfAborted();
          return void 0;
        });
      }
      _isErrorThatCannotBeRetried(e) {
        if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
          return true;
        if (dom.isNonRecoverableDOMError(e) || (0, _selectorParser.isInvalidSelectorError)(e))
          return true;
        if (this.isDetached())
          return true;
        return false;
      }
      _retryWithProgressIfNotConnected(progress2, selector, strict, action) {
        return __async(this, null, function* () {
          progress2.log(`waiting for ${this._asLocator(selector)}`);
          return this.retryWithProgressAndTimeouts(progress2, [0, 20, 50, 100, 100, 500], (continuePolling) => __async(this, null, function* () {
            const resolved = yield this.selectors.resolveInjectedForSelector(selector, {
              strict
            });
            progress2.throwIfAborted();
            if (!resolved)
              return continuePolling;
            const result = yield resolved.injected.evaluateHandle((injected, {
              info
            }) => {
              const elements = injected.querySelectorAll(info.parsed, document);
              const element2 = elements[0];
              let log2 = "";
              if (elements.length > 1) {
                if (info.strict)
                  throw injected.strictModeViolationError(info.parsed, elements);
                log2 = `  locator resolved to ${elements.length} elements. Proceeding with the first one: ${injected.previewNode(elements[0])}`;
              } else if (element2) {
                log2 = `  locator resolved to ${injected.previewNode(element2)}`;
              }
              return {
                log: log2,
                success: !!element2,
                element: element2
              };
            }, {
              info: resolved.info
            });
            const {
              log,
              success
            } = yield result.evaluate((r) => ({
              log: r.log,
              success: r.success
            }));
            if (log)
              progress2.log(log);
            if (!success) {
              result.dispose();
              return continuePolling;
            }
            const element = yield result.evaluateHandle((r) => r.element);
            result.dispose();
            try {
              const result2 = yield action(element);
              if (result2 === "error:notconnected") {
                progress2.log("element was detached from the DOM, retrying");
                return continuePolling;
              }
              return result2;
            } finally {
              element === null || element === void 0 ? void 0 : element.dispose();
            }
          }));
        });
      }
      rafrafTimeoutScreenshotElementWithProgress(progress2, selector, timeout, options) {
        return __async(this, null, function* () {
          return yield this._retryWithProgressIfNotConnected(progress2, selector, true, (handle) => __async(this, null, function* () {
            yield handle._frame.rafrafTimeout(timeout);
            return yield this._page._screenshotter.screenshotElement(progress2, handle, options);
          }));
        });
      }
      click(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._click(progress2, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._dblclick(progress2, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dragAndDrop(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, source, target, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress2) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, source, options.strict, (handle) => __async(this, null, function* () {
              return handle._retryPointerAction(progress2, "move and down", false, (point) => __async(this, null, function* () {
                yield this._page.mouse.move(point.x, point.y);
                yield this._page.mouse.down();
              }), __spreadProps(__spreadValues({}, options), {
                position: options.sourcePosition,
                timeout: progress2.timeUntilDeadline()
              }));
            })));
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, target, options.strict, (handle) => __async(this, null, function* () {
              return handle._retryPointerAction(progress2, "move and up", false, (point) => __async(this, null, function* () {
                yield this._page.mouse.move(point.x, point.y);
                yield this._page.mouse.up();
              }), __spreadProps(__spreadValues({}, options), {
                position: options.targetPosition,
                timeout: progress2.timeUntilDeadline()
              }));
            })));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      tap(metadata, selector, options) {
        return __async(this, null, function* () {
          if (!this._page._browserContext._options.hasTouch)
            throw new Error("The page does not support tap. Use hasTouch context option to enable touch support.");
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._tap(progress2, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      fill(metadata, selector, value, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._fill(progress2, value, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      focus(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress2) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._focus(progress2)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      blur(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress2) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._blur(progress2)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      textContent(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._callOnElementOnceMatches(metadata, selector, (injected, element) => element.textContent, void 0, options, scope);
        });
      }
      innerText(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._callOnElementOnceMatches(metadata, selector, (injectedScript, element) => {
            if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
              throw injectedScript.createStacklessError("Node is not an HTMLElement");
            return element.innerText;
          }, void 0, options, scope);
        });
      }
      innerHTML(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._callOnElementOnceMatches(metadata, selector, (injected, element) => element.innerHTML, void 0, options, scope);
        });
      }
      getAttribute(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, name, options = {}, scope) {
          return this._callOnElementOnceMatches(metadata, selector, (injected, element, data) => element.getAttribute(data.name), {
            name
          }, options, scope);
        });
      }
      inputValue(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._callOnElementOnceMatches(metadata, selector, (injectedScript, node) => {
            const element = injectedScript.retarget(node, "follow-label");
            if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
              throw injectedScript.createStacklessError("Node is not an <input>, <textarea> or <select> element");
            return element.value;
          }, void 0, options, scope);
        });
      }
      highlight(selector) {
        return __async(this, null, function* () {
          const resolved = yield this.selectors.resolveInjectedForSelector(selector);
          if (!resolved)
            return;
          return yield resolved.injected.evaluate((injected, {
            info
          }) => {
            return injected.highlight(info.parsed);
          }, {
            info: resolved.info
          });
        });
      }
      hideHighlight() {
        return __async(this, null, function* () {
          return this.raceAgainstEvaluationStallingEvents(() => __async(this, null, function* () {
            const context = yield this._utilityContext();
            const injectedScript = yield context.injectedScript();
            return yield injectedScript.evaluate((injected) => {
              return injected.hideHighlight();
            });
          }));
        });
      }
      _elementState(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, state, options = {}, scope) {
          const result = yield this._callOnElementOnceMatches(metadata, selector, (injected, element, data) => {
            return injected.elementState(element, data.state);
          }, {
            state
          }, options, scope);
          return dom.throwRetargetableDOMError(result);
        });
      }
      isVisible(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            progress2.log(`  checking visibility of ${this._asLocator(selector)}`);
            const resolved = yield this.selectors.resolveInjectedForSelector(selector, options, scope);
            if (!resolved)
              return false;
            return yield resolved.injected.evaluate((injected, {
              info,
              root
            }) => {
              const element = injected.querySelector(info.parsed, root || document, info.strict);
              const state = element ? injected.elementState(element, "visible") : false;
              return state === "error:notconnected" ? false : state;
            }, {
              info: resolved.info,
              root: resolved.frame === this ? scope : void 0
            });
          }), this._page._timeoutSettings.timeout({})).catch((e) => {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return false;
          });
        });
      }
      isHidden(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return !(yield this.isVisible(metadata, selector, options, scope));
        });
      }
      isDisabled(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._elementState(metadata, selector, "disabled", options, scope);
        });
      }
      isEnabled(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._elementState(metadata, selector, "enabled", options, scope);
        });
      }
      isEditable(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._elementState(metadata, selector, "editable", options, scope);
        });
      }
      isChecked(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}, scope) {
          return this._elementState(metadata, selector, "checked", options, scope);
        });
      }
      hover(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._hover(progress2, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      selectOption(_0, _1, _2, _3) {
        return __async(this, arguments, function* (metadata, selector, elements, values, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._selectOption(progress2, elements, values, options));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      setInputFiles(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, items, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._setInputFiles(progress2, items, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      type(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, text, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._type(progress2, text, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      press(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, key, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._press(progress2, key, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      check(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._setChecked(progress2, true, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      uncheck(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress2, selector, options.strict, (handle) => handle._setChecked(progress2, false, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForTimeout(metadata, timeout) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run(() => __async(this, null, function* () {
            yield new Promise((resolve) => setTimeout(resolve, timeout));
          }));
        });
      }
      expect(metadata, selector, options) {
        return __async(this, null, function* () {
          let timeout = this._page._timeoutSettings.timeout(options);
          const start = timeout > 0 ? (0, _utils.monotonicTime)() : 0;
          const lastIntermediateResult = {
            isSet: false
          };
          const resultOneShot = yield this._expectInternal(metadata, selector, options, true, timeout, lastIntermediateResult);
          if (resultOneShot.matches !== options.isNot)
            return resultOneShot;
          if (timeout > 0) {
            const elapsed = (0, _utils.monotonicTime)() - start;
            timeout -= elapsed;
          }
          if (timeout < 0)
            return {
              matches: options.isNot,
              log: metadata.log,
              timedOut: true,
              received: lastIntermediateResult.received
            };
          return yield this._expectInternal(metadata, selector, options, false, timeout, lastIntermediateResult);
        });
      }
      _expectInternal(metadata, selector, options, oneShot, timeout, lastIntermediateResult) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            if (oneShot) {
              progress2.log(`${metadata.apiName}${timeout ? ` with timeout ${timeout}ms` : ""}`);
              progress2.log(`waiting for ${this._asLocator(selector)}`);
            }
            return yield this.retryWithProgressAndTimeouts(progress2, [100, 250, 500, 1e3], (continuePolling) => __async(this, null, function* () {
              var _info$world;
              const selectorInFrame = yield this.selectors.resolveFrameForSelector(selector, {
                strict: true
              });
              progress2.throwIfAborted();
              const {
                frame,
                info
              } = selectorInFrame || {
                frame: this,
                info: void 0
              };
              const world = options.expression === "to.have.property" ? "main" : (_info$world = info === null || info === void 0 ? void 0 : info.world) !== null && _info$world !== void 0 ? _info$world : "utility";
              const context = yield frame._context(world);
              const injected = yield context.injectedScript();
              progress2.throwIfAborted();
              const {
                log,
                matches,
                received,
                missingRecevied
              } = yield injected.evaluate((_0, _1) => __async(this, [_0, _1], function* (injected2, {
                info: info2,
                options: options2,
                callId
              }) {
                const elements = info2 ? injected2.querySelectorAll(info2.parsed, document) : [];
                const isArray = options2.expression === "to.have.count" || options2.expression.endsWith(".array");
                let log2 = "";
                if (isArray)
                  log2 = `  locator resolved to ${elements.length} element${elements.length === 1 ? "" : "s"}`;
                else if (elements.length > 1)
                  throw injected2.strictModeViolationError(info2.parsed, elements);
                else if (elements.length)
                  log2 = `  locator resolved to ${injected2.previewNode(elements[0])}`;
                if (callId)
                  injected2.markTargetElements(new Set(elements), callId);
                return __spreadValues({
                  log: log2
                }, yield injected2.expect(elements[0], options2, elements));
              }), {
                info,
                options,
                callId: metadata.id
              });
              if (log)
                progress2.log(log);
              if (matches === options.isNot && !missingRecevied) {
                lastIntermediateResult.received = received;
                lastIntermediateResult.isSet = true;
                if (!Array.isArray(received))
                  progress2.log(`  unexpected value "${renderUnexpectedValue(options.expression, received)}"`);
              }
              if (!oneShot && matches === options.isNot) {
                return continuePolling;
              }
              return {
                matches,
                received
              };
            }));
          }), oneShot ? 0 : timeout).catch((e) => {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e))
              throw e;
            const result = {
              matches: options.isNot,
              log: metadata.log
            };
            if (lastIntermediateResult.isSet)
              result.received = lastIntermediateResult.received;
            if (e instanceof _errors.TimeoutError)
              result.timedOut = true;
            return result;
          });
        });
      }
      _waitForFunctionExpression(metadata, expression, isFunction, arg, options, world = "main") {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          if (typeof options.pollingInterval === "number")
            (0, _utils.assert)(options.pollingInterval > 0, "Cannot poll with non-positive interval: " + options.pollingInterval);
          expression = js.normalizeEvaluationExpression(expression, isFunction);
          return controller.run((progress2) => __async(this, null, function* () {
            return this.retryWithProgressAndTimeouts(progress2, [100], () => __async(this, null, function* () {
              const context = world === "main" ? yield this._mainContext() : yield this._utilityContext();
              const injectedScript = yield context.injectedScript();
              const handle = yield injectedScript.evaluateHandle((injected, {
                expression: expression2,
                isFunction: isFunction2,
                polling,
                arg: arg2
              }) => {
                const predicate = () => {
                  let result2 = globalThis.eval(expression2);
                  if (isFunction2 === true) {
                    result2 = result2(arg2);
                  } else if (isFunction2 === false) {
                    result2 = result2;
                  } else {
                    if (typeof result2 === "function")
                      result2 = result2(arg2);
                  }
                  return result2;
                };
                let fulfill;
                let reject;
                let aborted = false;
                const result = new Promise((f, r) => {
                  fulfill = f;
                  reject = r;
                });
                const next = () => {
                  if (aborted)
                    return;
                  try {
                    const success = predicate();
                    if (success) {
                      fulfill(success);
                      return;
                    }
                    if (typeof polling !== "number")
                      requestAnimationFrame(next);
                    else
                      setTimeout(next, polling);
                  } catch (e) {
                    reject(e);
                  }
                };
                next();
                return {
                  result,
                  abort: () => aborted = true
                };
              }, {
                expression,
                isFunction,
                polling: options.pollingInterval,
                arg
              });
              progress2.cleanupWhenAborted(() => handle.evaluate((h) => h.abort()).catch(() => {
              }));
              return handle.evaluateHandle((h) => h.result);
            }));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForFunctionValueInUtility(progress2, pageFunction) {
        return __async(this, null, function* () {
          const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
          const handle = yield this._waitForFunctionExpression((0, _instrumentation.serverSideCallMetadata)(), expression, true, void 0, {
            timeout: progress2.timeUntilDeadline()
          }, "utility");
          return JSON.parse(handle.rawValue());
        });
      }
      title() {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          return context.evaluate(() => document.title);
        });
      }
      rafrafTimeout(timeout) {
        return __async(this, null, function* () {
          if (timeout === 0)
            return;
          const context = yield this._utilityContext();
          yield Promise.all([
            context.evaluate(() => new Promise((x) => {
              requestAnimationFrame(() => {
                requestAnimationFrame(x);
              });
            })),
            new Promise((fulfill) => setTimeout(fulfill, timeout))
          ]);
        });
      }
      _onDetached() {
        this._stopNetworkIdleTimer();
        this._detached = true;
        this._detachedCallback();
        const error = new Error("Frame was detached");
        for (const data of this._contextData.values()) {
          if (data.context)
            data.context.contextDestroyed(error);
          data.contextPromise.resolve(error);
        }
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
      _callOnElementOnceMatches(_0, _1, _2, _3) {
        return __async(this, arguments, function* (metadata, selector, body, taskData, options = {}, scope) {
          const callbackText = body.toString();
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => __async(this, null, function* () {
            progress2.log(`waiting for ${this._asLocator(selector)}`);
            const promise = this.retryWithProgressAndTimeouts(progress2, [0, 20, 50, 100, 100, 500], (continuePolling) => __async(this, null, function* () {
              const resolved = yield this.selectors.resolveInjectedForSelector(selector, options, scope);
              progress2.throwIfAborted();
              if (!resolved)
                return continuePolling;
              const {
                log,
                success,
                value
              } = yield resolved.injected.evaluate((injected, {
                info,
                callbackText: callbackText2,
                taskData: taskData2,
                callId,
                root
              }) => {
                const callback = injected.eval(callbackText2);
                const element = injected.querySelector(info.parsed, root || document, info.strict);
                if (!element)
                  return {
                    success: false
                  };
                const log2 = `  locator resolved to ${injected.previewNode(element)}`;
                if (callId)
                  injected.markTargetElements(/* @__PURE__ */ new Set([element]), callId);
                return {
                  log: log2,
                  success: true,
                  value: callback(injected, element, taskData2)
                };
              }, {
                info: resolved.info,
                callbackText,
                taskData,
                callId: progress2.metadata.id,
                root: resolved.frame === this ? scope : void 0
              });
              if (log)
                progress2.log(log);
              if (!success)
                return continuePolling;
              return value;
            }));
            return scope ? scope._context._raceAgainstContextDestroyed(promise) : promise;
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setContext(world, context) {
        const data = this._contextData.get(world);
        data.context = context;
        if (context)
          data.contextPromise.resolve(context);
        else
          data.contextPromise = new _manualPromise.ManualPromise();
      }
      _contextCreated(world, context) {
        const data = this._contextData.get(world);
        if (data.context) {
          data.context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
          this._setContext(world, null);
        }
        this._setContext(world, context);
      }
      _contextDestroyed(context) {
        if (this._detached)
          return;
        context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
        for (const [world, data] of this._contextData) {
          if (data.context === context)
            this._setContext(world, null);
        }
      }
      _startNetworkIdleTimer() {
        (0, _utils.assert)(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has("networkidle") || this._detached)
          return;
        this._networkIdleTimer = setTimeout(() => {
          this._firedNetworkIdleSelf = true;
          this._page.mainFrame()._recalculateNetworkIdle();
        }, 500);
      }
      _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
          clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = void 0;
        this._firedNetworkIdleSelf = false;
      }
      extendInjectedScript(source, arg) {
        return __async(this, null, function* () {
          const context = yield this._context("main");
          const injectedScriptHandle = yield context.injectedScript();
          return injectedScriptHandle.evaluateHandle((injectedScript, {
            source: source2,
            arg: arg2
          }) => {
            return injectedScript.extend(source2, arg2);
          }, {
            source,
            arg
          });
        });
      }
      resetStorageForCurrentOriginBestEffort(newStorage) {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          yield context.evaluate((_0) => __async(this, [_0], function* ({
            ls
          }) {
            sessionStorage.clear();
            localStorage.clear();
            for (const entry of ls || [])
              localStorage[entry.name] = entry.value;
            const registrations = navigator.serviceWorker ? yield navigator.serviceWorker.getRegistrations() : [];
            yield Promise.all(registrations.map((r) => __async(this, null, function* () {
              if (!r.installing && !r.waiting && !r.active)
                r.unregister().catch(() => {
                });
              else
                yield r.unregister().catch(() => {
                });
            })));
            for (const db of (yield (_indexedDB$databases = (_indexedDB = indexedDB).databases) === null || _indexedDB$databases === void 0 ? void 0 : _indexedDB$databases.call(_indexedDB)) || []) {
              var _indexedDB$databases, _indexedDB;
              if (db.name)
                indexedDB.deleteDatabase(db.name);
            }
          }), {
            ls: newStorage === null || newStorage === void 0 ? void 0 : newStorage.localStorage
          }).catch(() => {
          });
        });
      }
      _asLocator(selector) {
        return (0, _locatorGenerators.asLocator)(this._page.attribution.playwright.options.sdkLanguage, selector);
      }
    };
    exports2.Frame = Frame;
    Frame.Events = {
      InternalNavigation: "internalnavigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
    var SignalBarrier = class {
      constructor(progress2) {
        this._progress = void 0;
        this._protectCount = 0;
        this._promise = new _manualPromise.ManualPromise();
        this._progress = progress2;
        this.retain();
      }
      waitFor() {
        this.release();
        return this._promise;
      }
      addFrameNavigation(frame) {
        return __async(this, null, function* () {
          if (frame.parentFrame())
            return;
          this.retain();
          const waiter = _helper.helper.waitForEvent(null, frame, Frame.Events.InternalNavigation, (e) => {
            if (!e.isPublic)
              return false;
            if (!e.error && this._progress)
              this._progress.log(`  navigated to "${frame._url}"`);
            return true;
          });
          yield Promise.race([frame._page._disconnectedPromise, frame._page._crashedPromise, frame._detachedPromise, waiter.promise]).catch((e) => {
          });
          waiter.dispose();
          this.release();
        });
      }
      retain() {
        ++this._protectCount;
      }
      release() {
        --this._protectCount;
        if (!this._protectCount)
          this._promise.resolve();
      }
    };
    function verifyLifecycle(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
    function renderUnexpectedValue(expression, received) {
      if (expression === "to.be.checked")
        return received ? "checked" : "unchecked";
      if (expression === "to.be.unchecked")
        return received ? "unchecked" : "checked";
      if (expression === "to.be.visible")
        return received ? "visible" : "hidden";
      if (expression === "to.be.hidden")
        return received ? "hidden" : "visible";
      if (expression === "to.be.enabled")
        return received ? "enabled" : "disabled";
      if (expression === "to.be.disabled")
        return received ? "disabled" : "enabled";
      if (expression === "to.be.editable")
        return received ? "editable" : "readonly";
      if (expression === "to.be.readonly")
        return received ? "readonly" : "editable";
      if (expression === "to.be.empty")
        return received ? "empty" : "not empty";
      if (expression === "to.be.focused")
        return received ? "focused" : "not focused";
      return received;
    }
  }
});

// node_modules/playwright-core/lib/server/usKeyboardLayout.js
var require_usKeyboardLayout = __commonJS({
  "node_modules/playwright-core/lib/server/usKeyboardLayout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keypadLocation = exports2.USKeyboardLayout = void 0;
    var keypadLocation = 3;
    exports2.keypadLocation = keypadLocation;
    var USKeyboardLayout = {
      "Escape": {
        "keyCode": 27,
        "key": "Escape"
      },
      "F1": {
        "keyCode": 112,
        "key": "F1"
      },
      "F2": {
        "keyCode": 113,
        "key": "F2"
      },
      "F3": {
        "keyCode": 114,
        "key": "F3"
      },
      "F4": {
        "keyCode": 115,
        "key": "F4"
      },
      "F5": {
        "keyCode": 116,
        "key": "F5"
      },
      "F6": {
        "keyCode": 117,
        "key": "F6"
      },
      "F7": {
        "keyCode": 118,
        "key": "F7"
      },
      "F8": {
        "keyCode": 119,
        "key": "F8"
      },
      "F9": {
        "keyCode": 120,
        "key": "F9"
      },
      "F10": {
        "keyCode": 121,
        "key": "F10"
      },
      "F11": {
        "keyCode": 122,
        "key": "F11"
      },
      "F12": {
        "keyCode": 123,
        "key": "F12"
      },
      "Backquote": {
        "keyCode": 192,
        "shiftKey": "~",
        "key": "`"
      },
      "Digit1": {
        "keyCode": 49,
        "shiftKey": "!",
        "key": "1"
      },
      "Digit2": {
        "keyCode": 50,
        "shiftKey": "@",
        "key": "2"
      },
      "Digit3": {
        "keyCode": 51,
        "shiftKey": "#",
        "key": "3"
      },
      "Digit4": {
        "keyCode": 52,
        "shiftKey": "$",
        "key": "4"
      },
      "Digit5": {
        "keyCode": 53,
        "shiftKey": "%",
        "key": "5"
      },
      "Digit6": {
        "keyCode": 54,
        "shiftKey": "^",
        "key": "6"
      },
      "Digit7": {
        "keyCode": 55,
        "shiftKey": "&",
        "key": "7"
      },
      "Digit8": {
        "keyCode": 56,
        "shiftKey": "*",
        "key": "8"
      },
      "Digit9": {
        "keyCode": 57,
        "shiftKey": "(",
        "key": "9"
      },
      "Digit0": {
        "keyCode": 48,
        "shiftKey": ")",
        "key": "0"
      },
      "Minus": {
        "keyCode": 189,
        "shiftKey": "_",
        "key": "-"
      },
      "Equal": {
        "keyCode": 187,
        "shiftKey": "+",
        "key": "="
      },
      "Backslash": {
        "keyCode": 220,
        "shiftKey": "|",
        "key": "\\"
      },
      "Backspace": {
        "keyCode": 8,
        "key": "Backspace"
      },
      "Tab": {
        "keyCode": 9,
        "key": "Tab"
      },
      "KeyQ": {
        "keyCode": 81,
        "shiftKey": "Q",
        "key": "q"
      },
      "KeyW": {
        "keyCode": 87,
        "shiftKey": "W",
        "key": "w"
      },
      "KeyE": {
        "keyCode": 69,
        "shiftKey": "E",
        "key": "e"
      },
      "KeyR": {
        "keyCode": 82,
        "shiftKey": "R",
        "key": "r"
      },
      "KeyT": {
        "keyCode": 84,
        "shiftKey": "T",
        "key": "t"
      },
      "KeyY": {
        "keyCode": 89,
        "shiftKey": "Y",
        "key": "y"
      },
      "KeyU": {
        "keyCode": 85,
        "shiftKey": "U",
        "key": "u"
      },
      "KeyI": {
        "keyCode": 73,
        "shiftKey": "I",
        "key": "i"
      },
      "KeyO": {
        "keyCode": 79,
        "shiftKey": "O",
        "key": "o"
      },
      "KeyP": {
        "keyCode": 80,
        "shiftKey": "P",
        "key": "p"
      },
      "BracketLeft": {
        "keyCode": 219,
        "shiftKey": "{",
        "key": "["
      },
      "BracketRight": {
        "keyCode": 221,
        "shiftKey": "}",
        "key": "]"
      },
      "CapsLock": {
        "keyCode": 20,
        "key": "CapsLock"
      },
      "KeyA": {
        "keyCode": 65,
        "shiftKey": "A",
        "key": "a"
      },
      "KeyS": {
        "keyCode": 83,
        "shiftKey": "S",
        "key": "s"
      },
      "KeyD": {
        "keyCode": 68,
        "shiftKey": "D",
        "key": "d"
      },
      "KeyF": {
        "keyCode": 70,
        "shiftKey": "F",
        "key": "f"
      },
      "KeyG": {
        "keyCode": 71,
        "shiftKey": "G",
        "key": "g"
      },
      "KeyH": {
        "keyCode": 72,
        "shiftKey": "H",
        "key": "h"
      },
      "KeyJ": {
        "keyCode": 74,
        "shiftKey": "J",
        "key": "j"
      },
      "KeyK": {
        "keyCode": 75,
        "shiftKey": "K",
        "key": "k"
      },
      "KeyL": {
        "keyCode": 76,
        "shiftKey": "L",
        "key": "l"
      },
      "Semicolon": {
        "keyCode": 186,
        "shiftKey": ":",
        "key": ";"
      },
      "Quote": {
        "keyCode": 222,
        "shiftKey": '"',
        "key": "'"
      },
      "Enter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r"
      },
      "ShiftLeft": {
        "keyCode": 160,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 1
      },
      "KeyZ": {
        "keyCode": 90,
        "shiftKey": "Z",
        "key": "z"
      },
      "KeyX": {
        "keyCode": 88,
        "shiftKey": "X",
        "key": "x"
      },
      "KeyC": {
        "keyCode": 67,
        "shiftKey": "C",
        "key": "c"
      },
      "KeyV": {
        "keyCode": 86,
        "shiftKey": "V",
        "key": "v"
      },
      "KeyB": {
        "keyCode": 66,
        "shiftKey": "B",
        "key": "b"
      },
      "KeyN": {
        "keyCode": 78,
        "shiftKey": "N",
        "key": "n"
      },
      "KeyM": {
        "keyCode": 77,
        "shiftKey": "M",
        "key": "m"
      },
      "Comma": {
        "keyCode": 188,
        "shiftKey": "<",
        "key": ","
      },
      "Period": {
        "keyCode": 190,
        "shiftKey": ">",
        "key": "."
      },
      "Slash": {
        "keyCode": 191,
        "shiftKey": "?",
        "key": "/"
      },
      "ShiftRight": {
        "keyCode": 161,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 2
      },
      "ControlLeft": {
        "keyCode": 162,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 1
      },
      "MetaLeft": {
        "keyCode": 91,
        "key": "Meta",
        "location": 1
      },
      "AltLeft": {
        "keyCode": 164,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 1
      },
      "Space": {
        "keyCode": 32,
        "key": " "
      },
      "AltRight": {
        "keyCode": 165,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 2
      },
      "AltGraph": {
        "keyCode": 225,
        "key": "AltGraph"
      },
      "MetaRight": {
        "keyCode": 92,
        "key": "Meta",
        "location": 2
      },
      "ContextMenu": {
        "keyCode": 93,
        "key": "ContextMenu"
      },
      "ControlRight": {
        "keyCode": 163,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 2
      },
      "PrintScreen": {
        "keyCode": 44,
        "key": "PrintScreen"
      },
      "ScrollLock": {
        "keyCode": 145,
        "key": "ScrollLock"
      },
      "Pause": {
        "keyCode": 19,
        "key": "Pause"
      },
      "PageUp": {
        "keyCode": 33,
        "key": "PageUp"
      },
      "PageDown": {
        "keyCode": 34,
        "key": "PageDown"
      },
      "Insert": {
        "keyCode": 45,
        "key": "Insert"
      },
      "Delete": {
        "keyCode": 46,
        "key": "Delete"
      },
      "Home": {
        "keyCode": 36,
        "key": "Home"
      },
      "End": {
        "keyCode": 35,
        "key": "End"
      },
      "ArrowLeft": {
        "keyCode": 37,
        "key": "ArrowLeft"
      },
      "ArrowUp": {
        "keyCode": 38,
        "key": "ArrowUp"
      },
      "ArrowRight": {
        "keyCode": 39,
        "key": "ArrowRight"
      },
      "ArrowDown": {
        "keyCode": 40,
        "key": "ArrowDown"
      },
      "NumLock": {
        "keyCode": 144,
        "key": "NumLock"
      },
      "NumpadDivide": {
        "keyCode": 111,
        "key": "/",
        "location": 3
      },
      "NumpadMultiply": {
        "keyCode": 106,
        "key": "*",
        "location": 3
      },
      "NumpadSubtract": {
        "keyCode": 109,
        "key": "-",
        "location": 3
      },
      "Numpad7": {
        "keyCode": 36,
        "shiftKeyCode": 103,
        "key": "Home",
        "shiftKey": "7",
        "location": 3
      },
      "Numpad8": {
        "keyCode": 38,
        "shiftKeyCode": 104,
        "key": "ArrowUp",
        "shiftKey": "8",
        "location": 3
      },
      "Numpad9": {
        "keyCode": 33,
        "shiftKeyCode": 105,
        "key": "PageUp",
        "shiftKey": "9",
        "location": 3
      },
      "Numpad4": {
        "keyCode": 37,
        "shiftKeyCode": 100,
        "key": "ArrowLeft",
        "shiftKey": "4",
        "location": 3
      },
      "Numpad5": {
        "keyCode": 12,
        "shiftKeyCode": 101,
        "key": "Clear",
        "shiftKey": "5",
        "location": 3
      },
      "Numpad6": {
        "keyCode": 39,
        "shiftKeyCode": 102,
        "key": "ArrowRight",
        "shiftKey": "6",
        "location": 3
      },
      "NumpadAdd": {
        "keyCode": 107,
        "key": "+",
        "location": 3
      },
      "Numpad1": {
        "keyCode": 35,
        "shiftKeyCode": 97,
        "key": "End",
        "shiftKey": "1",
        "location": 3
      },
      "Numpad2": {
        "keyCode": 40,
        "shiftKeyCode": 98,
        "key": "ArrowDown",
        "shiftKey": "2",
        "location": 3
      },
      "Numpad3": {
        "keyCode": 34,
        "shiftKeyCode": 99,
        "key": "PageDown",
        "shiftKey": "3",
        "location": 3
      },
      "Numpad0": {
        "keyCode": 45,
        "shiftKeyCode": 96,
        "key": "Insert",
        "shiftKey": "0",
        "location": 3
      },
      "NumpadDecimal": {
        "keyCode": 46,
        "shiftKeyCode": 110,
        "key": "\0",
        "shiftKey": ".",
        "location": 3
      },
      "NumpadEnter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r",
        "location": 3
      }
    };
    exports2.USKeyboardLayout = USKeyboardLayout;
  }
});

// node_modules/playwright-core/lib/server/input.js
var require_input = __commonJS({
  "node_modules/playwright-core/lib/server/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keypadLocation = exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = void 0;
    var _utils = require_utils();
    var keyboardLayout = _interopRequireWildcard(require_usKeyboardLayout());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var keypadLocation = keyboardLayout.keypadLocation;
    exports2.keypadLocation = keypadLocation;
    var kModifiers = ["Alt", "Control", "Meta", "Shift"];
    var Keyboard = class {
      constructor(raw, page) {
        this._pressedModifiers = /* @__PURE__ */ new Set();
        this._pressedKeys = /* @__PURE__ */ new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      down(key) {
        return __async(this, null, function* () {
          const description = this._keyDescriptionForString(key);
          const autoRepeat = this._pressedKeys.has(description.code);
          this._pressedKeys.add(description.code);
          if (kModifiers.includes(description.key))
            this._pressedModifiers.add(description.key);
          const text = description.text;
          yield this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
        });
      }
      _keyDescriptionForString(keyString) {
        let description = usKeyboardLayout.get(keyString);
        (0, _utils.assert)(description, `Unknown key: "${keyString}"`);
        const shift = this._pressedModifiers.has("Shift");
        description = shift && description.shifted ? description.shifted : description;
        if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
          return __spreadProps(__spreadValues({}, description), {
            text: ""
          });
        return description;
      }
      up(key) {
        return __async(this, null, function* () {
          const description = this._keyDescriptionForString(key);
          if (kModifiers.includes(description.key))
            this._pressedModifiers.delete(description.key);
          this._pressedKeys.delete(description.code);
          yield this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
        });
      }
      insertText(text) {
        return __async(this, null, function* () {
          yield this._raw.sendText(text);
        });
      }
      type(text, options) {
        return __async(this, null, function* () {
          const delay = options && options.delay || void 0;
          for (const char of text) {
            if (usKeyboardLayout.has(char)) {
              yield this.press(char, {
                delay
              });
            } else {
              if (delay)
                yield new Promise((f) => setTimeout(f, delay));
              yield this.insertText(char);
            }
          }
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          function split(keyString) {
            const keys = [];
            let building = "";
            for (const char of keyString) {
              if (char === "+" && building) {
                keys.push(building);
                building = "";
              } else {
                building += char;
              }
            }
            keys.push(building);
            return keys;
          }
          const tokens = split(key);
          const promises = [];
          key = tokens[tokens.length - 1];
          for (let i = 0; i < tokens.length - 1; ++i)
            promises.push(this.down(tokens[i]));
          promises.push(this.down(key));
          if (options.delay) {
            yield Promise.all(promises);
            yield new Promise((f) => setTimeout(f, options.delay));
          }
          promises.push(this.up(key));
          for (let i = tokens.length - 2; i >= 0; --i)
            promises.push(this.up(tokens[i]));
          yield Promise.all(promises);
        });
      }
      _ensureModifiers(modifiers) {
        return __async(this, null, function* () {
          for (const modifier of modifiers) {
            if (!kModifiers.includes(modifier))
              throw new Error("Unknown modifier " + modifier);
          }
          const restore = Array.from(this._pressedModifiers);
          const promises = [];
          for (const key of kModifiers) {
            const needDown = modifiers.includes(key);
            const isDown = this._pressedModifiers.has(key);
            if (needDown && !isDown)
              promises.push(this.down(key));
            else if (!needDown && isDown)
              promises.push(this.up(key));
          }
          yield Promise.all(promises);
          return restore;
        });
      }
      _modifiers() {
        return this._pressedModifiers;
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(raw, page) {
        this._keyboard = void 0;
        this._x = 0;
        this._y = 0;
        this._lastButton = "none";
        this._buttons = /* @__PURE__ */ new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
        this._keyboard = this._page.keyboard;
      }
      move(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          const {
            steps = 1
          } = options;
          const fromX = this._x;
          const fromY = this._y;
          this._x = x;
          this._y = y;
          for (let i = 1; i <= steps; i++) {
            const middleX = fromX + (x - fromX) * (i / steps);
            const middleY = fromY + (y - fromY) * (i / steps);
            yield this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options.forClick);
          }
        });
      }
      down() {
        return __async(this, arguments, function* (options = {}) {
          const {
            button = "left",
            clickCount = 1
          } = options;
          this._lastButton = button;
          this._buttons.add(button);
          yield this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
        });
      }
      up() {
        return __async(this, arguments, function* (options = {}) {
          const {
            button = "left",
            clickCount = 1
          } = options;
          this._lastButton = "none";
          this._buttons.delete(button);
          yield this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
        });
      }
      click(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          const {
            delay = null,
            clickCount = 1
          } = options;
          if (delay) {
            this.move(x, y, {
              forClick: true
            });
            for (let cc = 1; cc <= clickCount; ++cc) {
              yield this.down(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              }));
              yield new Promise((f) => setTimeout(f, delay));
              yield this.up(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              }));
              if (cc < clickCount)
                yield new Promise((f) => setTimeout(f, delay));
            }
          } else {
            const promises = [];
            promises.push(this.move(x, y, {
              forClick: true
            }));
            for (let cc = 1; cc <= clickCount; ++cc) {
              promises.push(this.down(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              })));
              promises.push(this.up(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              })));
            }
            yield Promise.all(promises);
          }
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this.click(x, y, __spreadProps(__spreadValues({}, options), {
            clickCount: 2
          }));
        });
      }
      wheel(deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
        });
      }
    };
    exports2.Mouse = Mouse;
    var aliases = /* @__PURE__ */ new Map([["ShiftLeft", ["Shift"]], ["ControlLeft", ["Control"]], ["AltLeft", ["Alt"]], ["MetaLeft", ["Meta"]], ["Enter", ["\n", "\r"]]]);
    var usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);
    function buildLayoutClosure(layout) {
      const result = /* @__PURE__ */ new Map();
      for (const code in layout) {
        const definition = layout[code];
        const description = {
          key: definition.key || "",
          keyCode: definition.keyCode || 0,
          keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
          code,
          text: definition.text || "",
          location: definition.location || 0
        };
        if (definition.key.length === 1)
          description.text = description.key;
        let shiftedDescription;
        if (definition.shiftKey) {
          (0, _utils.assert)(definition.shiftKey.length === 1);
          shiftedDescription = __spreadValues({}, description);
          shiftedDescription.key = definition.shiftKey;
          shiftedDescription.text = definition.shiftKey;
          if (definition.shiftKeyCode)
            shiftedDescription.keyCode = definition.shiftKeyCode;
        }
        result.set(code, __spreadProps(__spreadValues({}, description), {
          shifted: shiftedDescription
        }));
        if (aliases.has(code)) {
          for (const alias of aliases.get(code))
            result.set(alias, description);
        }
        if (definition.location)
          continue;
        if (description.key.length === 1)
          result.set(description.key, description);
        if (shiftedDescription)
          result.set(shiftedDescription.key, __spreadProps(__spreadValues({}, shiftedDescription), {
            shifted: void 0
          }));
      }
      return result;
    }
    var Touchscreen = class {
      constructor(raw, page) {
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      tap(x, y) {
        return __async(this, null, function* () {
          if (!this._page._browserContext._options.hasTouch)
            throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
          yield this._raw.tap(x, y, this._page.keyboard._modifiers());
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/server/screenshotter.js
var require_screenshotter = __commonJS({
  "node_modules/playwright-core/lib/server/screenshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Screenshotter = void 0;
    exports2.validateScreenshotOptions = validateScreenshotOptions;
    var _helper = require_helper();
    var _utils = require_utils();
    var _multimap = require_multimap();
    function inPagePrepareForScreenshots(hideCaret, disableAnimations) {
      const collectRoots = (root, roots = []) => {
        roots.push(root);
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
        do {
          const node = walker.currentNode;
          const shadowRoot = node instanceof Element ? node.shadowRoot : null;
          if (shadowRoot)
            collectRoots(shadowRoot, roots);
        } while (walker.nextNode());
        return roots;
      };
      let documentRoots;
      const memoizedRoots = () => {
        var _documentRoots;
        return (_documentRoots = documentRoots) !== null && _documentRoots !== void 0 ? _documentRoots : documentRoots = collectRoots(document);
      };
      const styleTags = [];
      if (hideCaret) {
        for (const root of memoizedRoots()) {
          const styleTag = document.createElement("style");
          styleTag.textContent = `
        *:not(#playwright-aaaaaaaaaa.playwright-bbbbbbbbbbb.playwright-cccccccccc.playwright-dddddddddd.playwright-eeeeeeeee) {
          caret-color: transparent !important;
        }
      `;
          if (root === document)
            document.documentElement.append(styleTag);
          else
            root.append(styleTag);
          styleTags.push(styleTag);
        }
      }
      const infiniteAnimationsToResume = /* @__PURE__ */ new Set();
      const cleanupCallbacks = [];
      if (disableAnimations) {
        const handleAnimations = (root) => {
          for (const animation of root.getAnimations()) {
            if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))
              continue;
            const endTime = animation.effect.getComputedTiming().endTime;
            if (Number.isFinite(endTime)) {
              try {
                animation.finish();
              } catch (e) {
              }
            } else {
              try {
                animation.cancel();
                infiniteAnimationsToResume.add(animation);
              } catch (e) {
              }
            }
          }
        };
        for (const root of memoizedRoots()) {
          const handleRootAnimations = handleAnimations.bind(null, root);
          handleRootAnimations();
          root.addEventListener("transitionrun", handleRootAnimations);
          root.addEventListener("animationstart", handleRootAnimations);
          cleanupCallbacks.push(() => {
            root.removeEventListener("transitionrun", handleRootAnimations);
            root.removeEventListener("animationstart", handleRootAnimations);
          });
        }
      }
      window.__cleanupScreenshot = () => {
        for (const styleTag of styleTags)
          styleTag.remove();
        for (const animation of infiniteAnimationsToResume) {
          try {
            animation.play();
          } catch (e) {
          }
        }
        for (const cleanupCallback of cleanupCallbacks)
          cleanupCallback();
        delete window.__cleanupScreenshot;
      };
    }
    var Screenshotter = class {
      constructor(page) {
        this._queue = new TaskQueue();
        this._page = void 0;
        this._page = page;
        this._queue = new TaskQueue();
      }
      _originalViewportSize(progress2) {
        return __async(this, null, function* () {
          const originalViewportSize = this._page.viewportSize();
          let viewportSize = originalViewportSize;
          if (!viewportSize)
            viewportSize = yield this._page.mainFrame().waitForFunctionValueInUtility(progress2, () => ({
              width: window.innerWidth,
              height: window.innerHeight
            }));
          return {
            viewportSize,
            originalViewportSize
          };
        });
      }
      _fullPageSize(progress2) {
        return __async(this, null, function* () {
          const fullPageSize = yield this._page.mainFrame().waitForFunctionValueInUtility(progress2, () => {
            if (!document.body || !document.documentElement)
              return null;
            return {
              width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
              height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
            };
          });
          return fullPageSize;
        });
      }
      screenshotPage(progress2, options) {
        return __async(this, null, function* () {
          const format = validateScreenshotOptions(options);
          return this._queue.postTask(() => __async(this, null, function* () {
            progress2.log("taking page screenshot");
            const {
              viewportSize
            } = yield this._originalViewportSize(progress2);
            yield this._preparePageForScreenshot(progress2, options.caret !== "initial", options.animations === "disabled");
            progress2.throwIfAborted();
            if (options.fullPage) {
              const fullPageSize = yield this._fullPageSize(progress2);
              let documentRect = {
                x: 0,
                y: 0,
                width: fullPageSize.width,
                height: fullPageSize.height
              };
              const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
              if (options.clip)
                documentRect = trimClipToSize(options.clip, documentRect);
              const buffer2 = yield this._screenshot(progress2, format, documentRect, void 0, fitsViewport, options);
              progress2.throwIfAborted();
              yield this._restorePageAfterScreenshot();
              return buffer2;
            }
            const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : __spreadValues({
              x: 0,
              y: 0
            }, viewportSize);
            const buffer = yield this._screenshot(progress2, format, void 0, viewportRect, true, options);
            progress2.throwIfAborted();
            yield this._restorePageAfterScreenshot();
            return buffer;
          }));
        });
      }
      screenshotElement(progress2, handle, options) {
        return __async(this, null, function* () {
          const format = validateScreenshotOptions(options);
          return this._queue.postTask(() => __async(this, null, function* () {
            progress2.log("taking element screenshot");
            const {
              viewportSize
            } = yield this._originalViewportSize(progress2);
            yield this._preparePageForScreenshot(progress2, options.caret !== "initial", options.animations === "disabled");
            progress2.throwIfAborted();
            yield handle._waitAndScrollIntoViewIfNeeded(progress2, true);
            progress2.throwIfAborted();
            const boundingBox = yield handle.boundingBox();
            (0, _utils.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
            (0, _utils.assert)(boundingBox.width !== 0, "Node has 0 width.");
            (0, _utils.assert)(boundingBox.height !== 0, "Node has 0 height.");
            const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
            progress2.throwIfAborted();
            const scrollOffset = yield this._page.mainFrame().waitForFunctionValueInUtility(progress2, () => ({
              x: window.scrollX,
              y: window.scrollY
            }));
            const documentRect = __spreadValues({}, boundingBox);
            documentRect.x += scrollOffset.x;
            documentRect.y += scrollOffset.y;
            const buffer = yield this._screenshot(progress2, format, _helper.helper.enclosingIntRect(documentRect), void 0, fitsViewport, options);
            progress2.throwIfAborted();
            yield this._restorePageAfterScreenshot();
            return buffer;
          }));
        });
      }
      _preparePageForScreenshot(progress2, hideCaret, disableAnimations) {
        return __async(this, null, function* () {
          if (!hideCaret && !disableAnimations)
            return;
          if (disableAnimations)
            progress2.log("  disabled all CSS animations");
          yield Promise.all(this._page.frames().map((frame) => __async(this, null, function* () {
            yield frame.nonStallingEvaluateInExistingContext("(" + inPagePrepareForScreenshots.toString() + `)(${hideCaret}, ${disableAnimations})`, false, "utility").catch(() => {
            });
          })));
          progress2.cleanupWhenAborted(() => this._restorePageAfterScreenshot());
        });
      }
      _restorePageAfterScreenshot() {
        return __async(this, null, function* () {
          yield Promise.all(this._page.frames().map((frame) => __async(this, null, function* () {
            frame.nonStallingEvaluateInExistingContext("window.__cleanupScreenshot && window.__cleanupScreenshot()", false, "utility").catch(() => {
            });
          })));
        });
      }
      _maskElements(progress2, options) {
        return __async(this, null, function* () {
          const framesToParsedSelectors = new _multimap.MultiMap();
          const cleanup = () => __async(this, null, function* () {
            yield Promise.all([...framesToParsedSelectors.keys()].map((frame) => __async(this, null, function* () {
              yield frame.hideHighlight();
            })));
          });
          if (!options.mask || !options.mask.length)
            return cleanup;
          yield Promise.all((options.mask || []).map((_0) => __async(this, [_0], function* ({
            frame,
            selector
          }) {
            const pair = yield frame.selectors.resolveFrameForSelector(selector);
            if (pair)
              framesToParsedSelectors.set(pair.frame, pair.info.parsed);
          })));
          progress2.throwIfAborted();
          yield Promise.all([...framesToParsedSelectors.keys()].map((frame) => __async(this, null, function* () {
            yield frame.maskSelectors(framesToParsedSelectors.get(frame), options.maskColor);
          })));
          progress2.cleanupWhenAborted(cleanup);
          return cleanup;
        });
      }
      _screenshot(progress2, format, documentRect, viewportRect, fitsViewport, options) {
        return __async(this, null, function* () {
          var _options$quality;
          if (options.__testHookBeforeScreenshot)
            yield options.__testHookBeforeScreenshot();
          progress2.throwIfAborted();
          const shouldSetDefaultBackground = options.omitBackground && format === "png";
          if (shouldSetDefaultBackground) {
            yield this._page._delegate.setBackgroundColor({
              r: 0,
              g: 0,
              b: 0,
              a: 0
            });
            progress2.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
          }
          progress2.throwIfAborted();
          const cleanupHighlight = yield this._maskElements(progress2, options);
          progress2.throwIfAborted();
          const quality = format === "jpeg" ? (_options$quality = options.quality) !== null && _options$quality !== void 0 ? _options$quality : 80 : void 0;
          const buffer = yield this._page._delegate.takeScreenshot(progress2, format, documentRect, viewportRect, quality, fitsViewport, options.scale || "device");
          progress2.throwIfAborted();
          yield cleanupHighlight();
          progress2.throwIfAborted();
          if (shouldSetDefaultBackground)
            yield this._page._delegate.setBackgroundColor();
          progress2.throwIfAborted();
          if (options.__testHookAfterScreenshot)
            yield options.__testHookAfterScreenshot();
          return buffer;
        });
      }
    };
    exports2.Screenshotter = Screenshotter;
    var TaskQueue = class {
      constructor() {
        this._chain = void 0;
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    function trimClipToSize(clip, size) {
      const p1 = {
        x: Math.max(0, Math.min(clip.x, size.width)),
        y: Math.max(0, Math.min(clip.y, size.height))
      };
      const p2 = {
        x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
        y: Math.max(0, Math.min(clip.y + clip.height, size.height))
      };
      const result = {
        x: p1.x,
        y: p1.y,
        width: p2.x - p1.x,
        height: p2.y - p1.y
      };
      (0, _utils.assert)(result.width && result.height, "Clipped area is either empty or outside the resulting image");
      return result;
    }
    function validateScreenshotOptions(options) {
      let format = null;
      if (options.type) {
        (0, _utils.assert)(options.type === "png" || options.type === "jpeg", "Unknown options.type value: " + options.type);
        format = options.type;
      }
      if (!format)
        format = "png";
      if (options.quality !== void 0) {
        (0, _utils.assert)(format === "jpeg", "options.quality is unsupported for the " + format + " screenshots");
        (0, _utils.assert)(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
        (0, _utils.assert)(Number.isInteger(options.quality), "Expected options.quality to be an integer");
        (0, _utils.assert)(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
      }
      if (options.clip) {
        (0, _utils.assert)(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
        (0, _utils.assert)(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
        (0, _utils.assert)(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
        (0, _utils.assert)(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
        (0, _utils.assert)(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
        (0, _utils.assert)(options.clip.height !== 0, "Expected options.clip.height not to be 0.");
      }
      return format;
    }
  }
});

// node_modules/playwright-core/lib/server/console.js
var require_console = __commonJS({
  "node_modules/playwright-core/lib/server/console.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessage = void 0;
    var _instrumentation = require_instrumentation();
    var ConsoleMessage = class extends _instrumentation.SdkObject {
      constructor(page, type, text, args, location2) {
        super(page, "console-message");
        this._type = void 0;
        this._text = void 0;
        this._args = void 0;
        this._location = void 0;
        this._page = void 0;
        this._page = page;
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location2 || {
          url: "",
          lineNumber: 0,
          columnNumber: 0
        };
      }
      page() {
        return this._page;
      }
      type() {
        return this._type;
      }
      text() {
        if (this._text === void 0)
          this._text = this._args.map((arg) => arg.preview()).join(" ");
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/server/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/playwright-core/lib/server/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Accessibility = void 0;
    var Accessibility = class {
      constructor(getAXTree) {
        this._getAXTree = void 0;
        this._getAXTree = getAXTree;
      }
      snapshot() {
        return __async(this, arguments, function* (options = {}) {
          const {
            interestingOnly = true,
            root = null
          } = options;
          const {
            tree,
            needle
          } = yield this._getAXTree(root || void 0);
          if (!interestingOnly) {
            if (root)
              return needle && serializeTree(needle)[0];
            return serializeTree(tree)[0];
          }
          const interestingNodes = /* @__PURE__ */ new Set();
          collectInterestingNodes(interestingNodes, tree, false);
          if (root && (!needle || !interestingNodes.has(needle)))
            return null;
          return serializeTree(needle || tree, interestingNodes)[0];
        });
      }
    };
    exports2.Accessibility = Accessibility;
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
  }
});

// node_modules/playwright-core/lib/server/fileChooser.js
var require_fileChooser = __commonJS({
  "node_modules/playwright-core/lib/server/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/server/page.js
var require_page = __commonJS({
  "node_modules/playwright-core/lib/server/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Worker = exports2.PageBinding = exports2.Page = void 0;
    var frames = _interopRequireWildcard(require_frames());
    var input = _interopRequireWildcard(require_input());
    var js = _interopRequireWildcard(require_javascript());
    var network = _interopRequireWildcard(require_network2());
    var _screenshotter = require_screenshotter();
    var _timeoutSettings = require_timeoutSettings();
    var _browserContext = require_browserContext();
    var _console = require_console();
    var accessibility = _interopRequireWildcard(require_accessibility());
    var _fileChooser = require_fileChooser();
    var _progress = require_progress();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _debugLogger = require_debugLogger();
    var _comparators = require_comparators();
    var _instrumentation = require_instrumentation();
    var _selectorParser = require_selectorParser();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Page = class extends _instrumentation.SdkObject {
      constructor(delegate, browserContext) {
        super(browserContext, "page");
        this._closedState = "open";
        this._closedPromise = new _manualPromise.ManualPromise();
        this._disconnected = false;
        this._initialized = false;
        this._eventsToEmitAfterInitialized = [];
        this._disconnectedPromise = new _manualPromise.ManualPromise();
        this._crashedPromise = new _manualPromise.ManualPromise();
        this._browserContext = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.touchscreen = void 0;
        this._timeoutSettings = void 0;
        this._delegate = void 0;
        this._emulatedSize = void 0;
        this._extraHTTPHeaders = void 0;
        this._emulatedMedia = {};
        this._interceptFileChooser = false;
        this._pageBindings = /* @__PURE__ */ new Map();
        this.initScripts = [];
        this._screenshotter = void 0;
        this._frameManager = void 0;
        this.accessibility = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this.pdf = void 0;
        this.coverage = void 0;
        this._clientRequestInterceptor = void 0;
        this._serverRequestInterceptor = void 0;
        this._ownedContext = void 0;
        this._pageIsError = void 0;
        this._video = null;
        this._opener = void 0;
        this._isServerSideOnly = false;
        this._frameThrottler = new FrameThrottler(10, 35, 200);
        this.attribution.page = this;
        this._delegate = delegate;
        this._browserContext = browserContext;
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
        this.mouse = new input.Mouse(delegate.rawMouse, this);
        this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new _screenshotter.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
          this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
      }
      initOpener(opener) {
        return __async(this, null, function* () {
          if (!opener)
            return;
          const openerPage = yield opener.pageOrError();
          if (openerPage instanceof Page && !openerPage.isClosed())
            this._opener = openerPage;
        });
      }
      reportAsNew(error = void 0, contextEvent = _browserContext.BrowserContext.Events.Page) {
        if (error) {
          if (this._browserContext.isClosingOrClosed())
            return;
          this._setIsError(error);
        }
        this._initialized = true;
        this.emitOnContext(contextEvent, this);
        for (const {
          event,
          args
        } of this._eventsToEmitAfterInitialized)
          this._browserContext.emit(event, ...args);
        this._eventsToEmitAfterInitialized = [];
        if (this.isClosed())
          this.emit(Page.Events.Close);
        else
          this.instrumentation.onPageOpen(this);
      }
      initializedOrUndefined() {
        return this._initialized ? this : void 0;
      }
      emitOnContext(event, ...args) {
        if (this._isServerSideOnly)
          return;
        this._browserContext.emit(event, ...args);
      }
      emitOnContextOnceInitialized(event, ...args) {
        if (this._isServerSideOnly)
          return;
        if (this._initialized)
          this._browserContext.emit(event, ...args);
        else
          this._eventsToEmitAfterInitialized.push({
            event,
            args
          });
      }
      resetForReuse(metadata) {
        return __async(this, null, function* () {
          this.setDefaultNavigationTimeout(void 0);
          this.setDefaultTimeout(void 0);
          yield this._removeExposedBindings();
          yield this._removeInitScripts();
          yield this.setClientRequestInterceptor(void 0);
          yield this._setServerRequestInterceptor(void 0);
          yield this.setFileChooserIntercepted(false);
          yield this.mainFrame().goto(metadata, "about:blank");
          this._emulatedSize = void 0;
          this._emulatedMedia = {};
          this._extraHTTPHeaders = void 0;
          this._interceptFileChooser = false;
          yield Promise.all([this._delegate.updateEmulatedViewportSize(), this._delegate.updateEmulateMedia(), this._delegate.updateFileChooserInterception()]);
          yield this._delegate.resetForReuse();
        });
      }
      _didClose() {
        this._frameManager.dispose();
        this._frameThrottler.dispose();
        (0, _utils.assert)(this._closedState !== "closed", "Page closed twice");
        this._closedState = "closed";
        this.emit(Page.Events.Close);
        this._closedPromise.resolve();
        this.instrumentation.onPageClose(this);
      }
      _didCrash() {
        this._frameManager.dispose();
        this._frameThrottler.dispose();
        this.emit(Page.Events.Crash);
        this._crashedPromise.resolve(new Error("Page crashed"));
        this.instrumentation.onPageClose(this);
      }
      _didDisconnect() {
        this._frameManager.dispose();
        this._frameThrottler.dispose();
        (0, _utils.assert)(!this._disconnected, "Page disconnected twice");
        this._disconnected = true;
        this._disconnectedPromise.resolve(new Error("Page closed"));
      }
      _onFileChooserOpened(handle) {
        return __async(this, null, function* () {
          let multiple;
          try {
            multiple = yield handle.evaluate((element) => !!element.multiple);
          } catch (e) {
            return;
          }
          if (!this.listenerCount(Page.Events.FileChooser)) {
            handle.dispose();
            return;
          }
          const fileChooser = new _fileChooser.FileChooser(this, handle, multiple);
          this.emit(Page.Events.FileChooser, fileChooser);
        });
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return this._opener;
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      frames() {
        return this._frameManager.frames();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      exposeBinding(name, needsHandle, playwrightBinding) {
        return __async(this, null, function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
          if (this._browserContext._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered in the browser context`);
          const binding = new PageBinding(name, playwrightBinding, needsHandle);
          this._pageBindings.set(name, binding);
          yield this._delegate.exposeBinding(binding);
        });
      }
      _removeExposedBindings() {
        return __async(this, null, function* () {
          for (const key of this._pageBindings.keys()) {
            if (!key.startsWith("__pw"))
              this._pageBindings.delete(key);
          }
          yield this._delegate.removeExposedBindings();
        });
      }
      setExtraHTTPHeaders(headers) {
        this._extraHTTPHeaders = headers;
        return this._delegate.updateExtraHTTPHeaders();
      }
      extraHTTPHeaders() {
        return this._extraHTTPHeaders;
      }
      _onBindingCalled(payload, context) {
        return __async(this, null, function* () {
          if (this._disconnected || this._closedState === "closed")
            return;
          yield PageBinding.dispatch(this, payload, context);
        });
      }
      _addConsoleMessage(type, args, location2, text) {
        const message = new _console.ConsoleMessage(this, type, text, args, location2);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted) {
          args.forEach((arg) => arg.dispose());
          return;
        }
        this.emitOnContextOnceInitialized(_browserContext.BrowserContext.Events.Console, message);
      }
      reload(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this.mainFrame().raceNavigationAction(progress2, options, () => __async(this, null, function* () {
            const [response] = yield Promise.all([
              this.mainFrame()._waitForNavigation(progress2, true, options),
              this._delegate.reload()
            ]);
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      goBack(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this.mainFrame().raceNavigationAction(progress2, options, () => __async(this, null, function* () {
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress2, false, options).catch((e) => {
              error = e;
              return null;
            });
            const result = yield this._delegate.goBack();
            if (!result)
              return null;
            const response = yield waitPromise;
            if (error)
              throw error;
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      goForward(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this.mainFrame().raceNavigationAction(progress2, options, () => __async(this, null, function* () {
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress2, false, options).catch((e) => {
              error = e;
              return null;
            });
            const result = yield this._delegate.goForward();
            if (!result)
              return null;
            const response = yield waitPromise;
            if (error)
              throw error;
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      emulateMedia(options) {
        return __async(this, null, function* () {
          if (options.media !== void 0)
            this._emulatedMedia.media = options.media;
          if (options.colorScheme !== void 0)
            this._emulatedMedia.colorScheme = options.colorScheme;
          if (options.reducedMotion !== void 0)
            this._emulatedMedia.reducedMotion = options.reducedMotion;
          if (options.forcedColors !== void 0)
            this._emulatedMedia.forcedColors = options.forcedColors;
          yield this._delegate.updateEmulateMedia();
        });
      }
      emulatedMedia() {
        var _contextOptions$color, _contextOptions$reduc, _contextOptions$force;
        const contextOptions = this._browserContext._options;
        return {
          media: this._emulatedMedia.media || "no-override",
          colorScheme: this._emulatedMedia.colorScheme !== void 0 ? this._emulatedMedia.colorScheme : (_contextOptions$color = contextOptions.colorScheme) !== null && _contextOptions$color !== void 0 ? _contextOptions$color : "light",
          reducedMotion: this._emulatedMedia.reducedMotion !== void 0 ? this._emulatedMedia.reducedMotion : (_contextOptions$reduc = contextOptions.reducedMotion) !== null && _contextOptions$reduc !== void 0 ? _contextOptions$reduc : "no-preference",
          forcedColors: this._emulatedMedia.forcedColors !== void 0 ? this._emulatedMedia.forcedColors : (_contextOptions$force = contextOptions.forcedColors) !== null && _contextOptions$force !== void 0 ? _contextOptions$force : "none"
        };
      }
      setViewportSize(viewportSize) {
        return __async(this, null, function* () {
          this._emulatedSize = {
            viewport: __spreadValues({}, viewportSize),
            screen: __spreadValues({}, viewportSize)
          };
          yield this._delegate.updateEmulatedViewportSize();
        });
      }
      viewportSize() {
        var _this$emulatedSize;
        return ((_this$emulatedSize = this.emulatedSize()) === null || _this$emulatedSize === void 0 ? void 0 : _this$emulatedSize.viewport) || null;
      }
      emulatedSize() {
        if (this._emulatedSize)
          return this._emulatedSize;
        const contextOptions = this._browserContext._options;
        return contextOptions.viewport ? {
          viewport: contextOptions.viewport,
          screen: contextOptions.screen || contextOptions.viewport
        } : null;
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._delegate.bringToFront();
        });
      }
      addInitScript(source) {
        return __async(this, null, function* () {
          this.initScripts.push(source);
          yield this._delegate.addInitScript(source);
        });
      }
      _removeInitScripts() {
        return __async(this, null, function* () {
          this.initScripts.splice(0, this.initScripts.length);
          yield this._delegate.removeInitScripts();
        });
      }
      needsRequestInterception() {
        return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
      }
      setClientRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._clientRequestInterceptor = handler;
          yield this._delegate.updateRequestInterception();
        });
      }
      _setServerRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._serverRequestInterceptor = handler;
          yield this._delegate.updateRequestInterception();
        });
      }
      expectScreenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const locator = options.locator;
          const rafrafScreenshot = locator ? (progress2, timeout) => __async(this, null, function* () {
            return yield locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress2, locator.selector, timeout, options.screenshotOptions || {});
          }) : (progress2, timeout) => __async(this, null, function* () {
            yield this.mainFrame().rafrafTimeout(timeout);
            return yield this._screenshotter.screenshotPage(progress2, options.screenshotOptions || {});
          });
          const comparator = (0, _comparators.getComparator)("image/png");
          const controller = new _progress.ProgressController(metadata, this);
          if (!options.expected && options.isNot)
            return {
              errorMessage: '"not" matcher requires expected result'
            };
          try {
            const format = (0, _screenshotter.validateScreenshotOptions)(options.screenshotOptions || {});
            if (format !== "png")
              throw new Error("Only PNG screenshots are supported");
          } catch (error) {
            return {
              errorMessage: error.message
            };
          }
          let intermediateResult = void 0;
          const areEqualScreenshots = (actual, expected, previous) => {
            const comparatorResult = actual && expected ? comparator(actual, expected, options.comparatorOptions) : void 0;
            if (comparatorResult !== void 0 && !!comparatorResult === !!options.isNot)
              return true;
            if (comparatorResult)
              intermediateResult = {
                errorMessage: comparatorResult.errorMessage,
                diff: comparatorResult.diff,
                actual,
                previous
              };
            return false;
          };
          const callTimeout = this._timeoutSettings.timeout(options);
          return controller.run((progress2) => __async(this, null, function* () {
            let actual;
            let previous;
            const pollIntervals = [0, 100, 250, 500];
            progress2.log(`${metadata.apiName}${callTimeout ? ` with timeout ${callTimeout}ms` : ""}`);
            if (options.expected)
              progress2.log(`  verifying given screenshot expectation`);
            else
              progress2.log(`  generating new stable screenshot expectation`);
            let isFirstIteration = true;
            while (true) {
              var _pollIntervals$shift;
              progress2.throwIfAborted();
              if (this.isClosed())
                throw new Error("The page has closed");
              const screenshotTimeout = (_pollIntervals$shift = pollIntervals.shift()) !== null && _pollIntervals$shift !== void 0 ? _pollIntervals$shift : 1e3;
              if (screenshotTimeout)
                progress2.log(`waiting ${screenshotTimeout}ms before taking screenshot`);
              previous = actual;
              actual = yield rafrafScreenshot(progress2, screenshotTimeout).catch((e) => {
                progress2.log(`failed to take screenshot - ` + e.message);
                return void 0;
              });
              if (!actual)
                continue;
              const expectation = options.expected && isFirstIteration ? options.expected : previous;
              if (areEqualScreenshots(actual, expectation, previous))
                break;
              if (intermediateResult)
                progress2.log(intermediateResult.errorMessage);
              isFirstIteration = false;
            }
            if (!isFirstIteration)
              progress2.log(`captured a stable screenshot`);
            if (!options.expected)
              return {
                actual
              };
            if (isFirstIteration) {
              progress2.log(`screenshot matched expectation`);
              return {};
            }
            if (areEqualScreenshots(actual, options.expected, previous)) {
              progress2.log(`screenshot matched expectation`);
              return {};
            }
            throw new Error(intermediateResult.errorMessage);
          }), callTimeout).catch((e) => {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e))
              throw e;
            return __spreadProps(__spreadValues({
              log: e.message ? [...metadata.log, e.message] : metadata.log
            }, intermediateResult), {
              errorMessage: e.message
            });
          });
        });
      }
      screenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress2) => this._screenshotter.screenshotPage(progress2, options), this._timeoutSettings.timeout(options));
        });
      }
      close(metadata, options) {
        return __async(this, null, function* () {
          if (this._closedState === "closed")
            return;
          const runBeforeUnload = !!options && !!options.runBeforeUnload;
          if (this._closedState !== "closing") {
            this._closedState = "closing";
            (0, _utils.assert)(!this._disconnected, "Target closed");
            yield this._delegate.closePage(runBeforeUnload).catch((e) => _debugLogger.debugLogger.log("error", e));
          }
          if (!runBeforeUnload)
            yield this._closedPromise;
          if (this._ownedContext)
            yield this._ownedContext.close(metadata);
        });
      }
      _setIsError(error) {
        this._pageIsError = error;
        this._frameManager.createDummyMainFrameIfNeeded();
      }
      isClosed() {
        return this._closedState === "closed";
      }
      isClosedOrClosingOrCrashed() {
        return this._closedState !== "open" || this._crashedPromise.isDone();
      }
      _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(Page.Events.Worker, worker);
      }
      _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.didClose();
        this._workers.delete(workerId);
      }
      _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
          worker.didClose();
          this._workers.delete(workerId);
        }
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          this._interceptFileChooser = enabled;
          yield this._delegate.updateFileChooserInterception();
        });
      }
      fileChooserIntercepted() {
        return this._interceptFileChooser;
      }
      frameNavigatedToNewDocument(frame) {
        this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
        const url = frame.url();
        if (!url.startsWith("http"))
          return;
        const purl = network.parsedURL(url);
        if (purl)
          this._browserContext.addVisitedOrigin(purl.origin);
      }
      allBindings() {
        return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
      }
      getBinding(name) {
        return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
      }
      setScreencastOptions(options) {
        this._delegate.setScreencastOptions(options).catch((e) => _debugLogger.debugLogger.log("error", e));
        this._frameThrottler.setThrottlingEnabled(!!options);
      }
      throttleScreencastFrameAck(ack) {
        this._frameThrottler.ack(ack);
      }
      temporarlyDisableTracingScreencastThrottling() {
        this._frameThrottler.recharge();
      }
      firePageError(error) {
        this.emit(Page.Events.PageError, error);
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield Promise.all(this.frames().map((frame) => frame.hideHighlight().catch(() => {
          })));
        });
      }
      markAsServerSideOnly() {
        this._isServerSideOnly = true;
      }
    };
    exports2.Page = Page;
    Page.Events = {
      Close: "close",
      Crash: "crash",
      Download: "download",
      FileChooser: "filechooser",
      PageError: "pageerror",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
    var Worker = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "worker");
        this._url = void 0;
        this._executionContextPromise = void 0;
        this._executionContextCallback = void 0;
        this._existingExecutionContext = null;
        this._url = url;
        this._executionContextCallback = () => {
        };
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
      }
      _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(this, delegate, "worker");
        this._executionContextCallback(this._existingExecutionContext);
      }
      url() {
        return this._url;
      }
      didClose() {
        if (this._existingExecutionContext)
          this._existingExecutionContext.contextDestroyed(new Error("Worker was closed"));
        this.emit(Worker.Events.Close, this);
      }
      evaluateExpression(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(yield this._executionContextPromise, expression, {
            returnByValue: true,
            isFunction
          }, arg);
        });
      }
      evaluateExpressionHandle(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(yield this._executionContextPromise, expression, {
            returnByValue: false,
            isFunction
          }, arg);
        });
      }
    };
    exports2.Worker = Worker;
    Worker.Events = {
      Close: "close"
    };
    var PageBinding = class {
      constructor(name, playwrightFunction, needsHandle) {
        this.name = void 0;
        this.playwrightFunction = void 0;
        this.source = void 0;
        this.needsHandle = void 0;
        this.name = name;
        this.playwrightFunction = playwrightFunction;
        this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${_utilityScriptSerializers.source})())`;
        this.needsHandle = needsHandle;
      }
      static dispatch(page, payload, context) {
        return __async(this, null, function* () {
          const {
            name,
            seq,
            serializedArgs
          } = JSON.parse(payload);
          try {
            (0, _utils.assert)(context.world);
            const binding = page.getBinding(name);
            let result;
            if (binding.needsHandle) {
              const handle = yield context.evaluateHandle(takeHandle, {
                name,
                seq
              }).catch((e) => null);
              result = yield binding.playwrightFunction({
                frame: context.frame,
                page,
                context: page._browserContext
              }, handle);
            } else {
              const args = serializedArgs.map((a) => (0, _utilityScriptSerializers.parseEvaluationResultValue)(a));
              result = yield binding.playwrightFunction({
                frame: context.frame,
                page,
                context: page._browserContext
              }, ...args);
            }
            context.evaluate(deliverResult, {
              name,
              seq,
              result
            }).catch((e) => _debugLogger.debugLogger.log("error", e));
          } catch (error) {
            if ((0, _utils.isError)(error))
              context.evaluate(deliverError, {
                name,
                seq,
                message: error.message,
                stack: error.stack
              }).catch((e) => _debugLogger.debugLogger.log("error", e));
            else
              context.evaluate(deliverErrorValue, {
                name,
                seq,
                error
              }).catch((e) => _debugLogger.debugLogger.log("error", e));
          }
          function takeHandle(arg) {
            const handle = globalThis[arg.name]["handles"].get(arg.seq);
            globalThis[arg.name]["handles"].delete(arg.seq);
            return handle;
          }
          function deliverResult(arg) {
            globalThis[arg.name]["callbacks"].get(arg.seq).resolve(arg.result);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
          function deliverError(arg) {
            const error = new Error(arg.message);
            error.stack = arg.stack;
            globalThis[arg.name]["callbacks"].get(arg.seq).reject(error);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
          function deliverErrorValue(arg) {
            globalThis[arg.name]["callbacks"].get(arg.seq).reject(arg.error);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
        });
      }
    };
    exports2.PageBinding = PageBinding;
    function addPageBinding(bindingName, needsHandle, utilityScriptSerializers) {
      const binding = globalThis[bindingName];
      if (binding.__installed)
        return;
      globalThis[bindingName] = (...args) => {
        const me = globalThis[bindingName];
        if (needsHandle && args.slice(1).some((arg) => arg !== void 0))
          throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
        let callbacks = me["callbacks"];
        if (!callbacks) {
          callbacks = /* @__PURE__ */ new Map();
          me["callbacks"] = callbacks;
        }
        const seq = (me["lastSeq"] || 0) + 1;
        me["lastSeq"] = seq;
        let handles = me["handles"];
        if (!handles) {
          handles = /* @__PURE__ */ new Map();
          me["handles"] = handles;
        }
        const promise = new Promise((resolve, reject) => callbacks.set(seq, {
          resolve,
          reject
        }));
        let payload;
        if (needsHandle) {
          handles.set(seq, args[0]);
          payload = {
            name: bindingName,
            seq
          };
        } else {
          const serializedArgs = [];
          for (let i = 0; i < args.length; i++) {
            serializedArgs[i] = utilityScriptSerializers.serializeAsCallArgument(args[i], (v) => {
              return {
                fallThrough: v
              };
            });
          }
          payload = {
            name: bindingName,
            seq,
            serializedArgs
          };
        }
        binding(JSON.stringify(payload));
        return promise;
      };
      globalThis[bindingName].__installed = true;
    }
    var FrameThrottler = class {
      constructor(nonThrottledFrames, defaultInterval, throttlingInterval) {
        this._acks = [];
        this._defaultInterval = void 0;
        this._throttlingInterval = void 0;
        this._nonThrottledFrames = void 0;
        this._budget = void 0;
        this._throttlingEnabled = false;
        this._timeoutId = void 0;
        this._nonThrottledFrames = nonThrottledFrames;
        this._budget = nonThrottledFrames;
        this._defaultInterval = defaultInterval;
        this._throttlingInterval = throttlingInterval;
        this._tick();
      }
      dispose() {
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
          this._timeoutId = void 0;
        }
      }
      setThrottlingEnabled(enabled) {
        this._throttlingEnabled = enabled;
      }
      recharge() {
        for (const ack of this._acks)
          ack();
        this._acks = [];
        this._budget = this._nonThrottledFrames;
        if (this._timeoutId) {
          clearTimeout(this._timeoutId);
          this._tick();
        }
      }
      ack(ack) {
        if (!this._timeoutId) {
          ack();
          return;
        }
        this._acks.push(ack);
      }
      _tick() {
        const ack = this._acks.shift();
        if (ack) {
          --this._budget;
          ack();
        }
        if (this._throttlingEnabled && this._budget <= 0) {
          this._timeoutId = setTimeout(() => this._tick(), this._throttlingInterval);
        } else {
          this._timeoutId = setTimeout(() => this._tick(), this._defaultInterval);
        }
      }
    };
  }
});

// node_modules/playwright-core/lib/protocol/debug.js
var require_debug2 = __commonJS({
  "node_modules/playwright-core/lib/protocol/debug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.slowMoActions = exports2.pausesBeforeInputActions = exports2.commandsWithTracingSnapshots = void 0;
    var slowMoActions = /* @__PURE__ */ new Set(["Page.goBack", "Page.goForward", "Page.reload", "Page.keyboardDown", "Page.keyboardUp", "Page.keyboardInsertText", "Page.keyboardType", "Page.keyboardPress", "Page.mouseMove", "Page.mouseDown", "Page.mouseUp", "Page.mouseClick", "Page.mouseWheel", "Page.touchscreenTap", "Frame.blur", "Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.dispatchEvent", "Frame.fill", "Frame.focus", "Frame.goto", "Frame.hover", "Frame.press", "Frame.selectOption", "Frame.setInputFiles", "Frame.setInputFilePaths", "Frame.tap", "Frame.type", "Frame.uncheck", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.dispatchEvent", "ElementHandle.fill", "ElementHandle.focus", "ElementHandle.hover", "ElementHandle.press", "ElementHandle.scrollIntoViewIfNeeded", "ElementHandle.selectOption", "ElementHandle.selectText", "ElementHandle.setInputFiles", "ElementHandle.setInputFilePaths", "ElementHandle.tap", "ElementHandle.type", "ElementHandle.uncheck"]);
    exports2.slowMoActions = slowMoActions;
    var commandsWithTracingSnapshots = /* @__PURE__ */ new Set(["EventTarget.waitForEventInfo", "BrowserContext.waitForEventInfo", "Page.waitForEventInfo", "WebSocket.waitForEventInfo", "ElectronApplication.waitForEventInfo", "AndroidDevice.waitForEventInfo", "Page.emulateMedia", "Page.goBack", "Page.goForward", "Page.reload", "Page.expectScreenshot", "Page.screenshot", "Page.setViewportSize", "Page.keyboardDown", "Page.keyboardUp", "Page.keyboardInsertText", "Page.keyboardType", "Page.keyboardPress", "Page.mouseMove", "Page.mouseDown", "Page.mouseUp", "Page.mouseClick", "Page.mouseWheel", "Page.touchscreenTap", "Frame.evalOnSelector", "Frame.evalOnSelectorAll", "Frame.addScriptTag", "Frame.addStyleTag", "Frame.blur", "Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.dispatchEvent", "Frame.evaluateExpression", "Frame.evaluateExpressionHandle", "Frame.fill", "Frame.focus", "Frame.getAttribute", "Frame.goto", "Frame.hover", "Frame.innerHTML", "Frame.innerText", "Frame.inputValue", "Frame.isChecked", "Frame.isDisabled", "Frame.isEnabled", "Frame.isHidden", "Frame.isVisible", "Frame.isEditable", "Frame.press", "Frame.selectOption", "Frame.setContent", "Frame.setInputFiles", "Frame.setInputFilePaths", "Frame.tap", "Frame.textContent", "Frame.type", "Frame.uncheck", "Frame.waitForTimeout", "Frame.waitForFunction", "Frame.waitForSelector", "Frame.expect", "JSHandle.evaluateExpression", "ElementHandle.evaluateExpression", "JSHandle.evaluateExpressionHandle", "ElementHandle.evaluateExpressionHandle", "ElementHandle.evalOnSelector", "ElementHandle.evalOnSelectorAll", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.dispatchEvent", "ElementHandle.fill", "ElementHandle.focus", "ElementHandle.hover", "ElementHandle.innerHTML", "ElementHandle.innerText", "ElementHandle.inputValue", "ElementHandle.isChecked", "ElementHandle.isDisabled", "ElementHandle.isEditable", "ElementHandle.isEnabled", "ElementHandle.isHidden", "ElementHandle.isVisible", "ElementHandle.press", "ElementHandle.screenshot", "ElementHandle.scrollIntoViewIfNeeded", "ElementHandle.selectOption", "ElementHandle.selectText", "ElementHandle.setInputFiles", "ElementHandle.setInputFilePaths", "ElementHandle.tap", "ElementHandle.textContent", "ElementHandle.type", "ElementHandle.uncheck", "ElementHandle.waitForElementState", "ElementHandle.waitForSelector"]);
    exports2.commandsWithTracingSnapshots = commandsWithTracingSnapshots;
    var pausesBeforeInputActions = /* @__PURE__ */ new Set(["Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.fill", "Frame.hover", "Frame.press", "Frame.selectOption", "Frame.setInputFiles", "Frame.setInputFilePaths", "Frame.tap", "Frame.type", "Frame.uncheck", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.press", "ElementHandle.selectOption", "ElementHandle.setInputFiles", "ElementHandle.setInputFilePaths", "ElementHandle.tap", "ElementHandle.type", "ElementHandle.uncheck"]);
    exports2.pausesBeforeInputActions = pausesBeforeInputActions;
  }
});

// node_modules/playwright-core/lib/server/debugger.js
var require_debugger = __commonJS({
  "node_modules/playwright-core/lib/server/debugger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Debugger = void 0;
    exports2.shouldSlowMo = shouldSlowMo;
    var _events = require("events");
    var _utils = require_utils();
    var _browserContext = require_browserContext();
    var _debug = require_debug2();
    var symbol = Symbol("Debugger");
    var Debugger = class extends _events.EventEmitter {
      constructor(context) {
        super();
        this._pauseOnNextStatement = false;
        this._pausedCallsMetadata = /* @__PURE__ */ new Map();
        this._enabled = void 0;
        this._context = void 0;
        this._muted = false;
        this._slowMo = void 0;
        this._context = context;
        this._context[symbol] = this;
        this._enabled = (0, _utils.debugMode)() === "inspector";
        if (this._enabled)
          this.pauseOnNextStatement();
        context.instrumentation.addListener(this, context);
        this._context.once(_browserContext.BrowserContext.Events.Close, () => {
          this._context.instrumentation.removeListener(this);
        });
        this._slowMo = this._context._browser.options.slowMo;
      }
      setMuted(muted) {
        return __async(this, null, function* () {
          this._muted = muted;
        });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata))
            yield this.pause(sdkObject, metadata);
        });
      }
      _doSlowMo() {
        return __async(this, null, function* () {
          yield new Promise((f) => setTimeout(f, this._slowMo));
        });
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._slowMo && shouldSlowMo(metadata))
            yield this._doSlowMo();
        });
      }
      onBeforeInputAction(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          if (this._enabled && this._pauseOnNextStatement)
            yield this.pause(sdkObject, metadata);
        });
      }
      pause(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          this._enabled = true;
          metadata.pauseStartTime = (0, _utils.monotonicTime)();
          const result = new Promise((resolve) => {
            this._pausedCallsMetadata.set(metadata, {
              resolve,
              sdkObject
            });
          });
          this.emit(Debugger.Events.PausedStateChanged);
          return result;
        });
      }
      resume(step) {
        if (!this.isPaused())
          return;
        this._pauseOnNextStatement = step;
        const endTime = (0, _utils.monotonicTime)();
        for (const [metadata, {
          resolve
        }] of this._pausedCallsMetadata) {
          metadata.pauseEndTime = endTime;
          resolve();
        }
        this._pausedCallsMetadata.clear();
        this.emit(Debugger.Events.PausedStateChanged);
      }
      pauseOnNextStatement() {
        this._pauseOnNextStatement = true;
      }
      isPaused(metadata) {
        if (metadata)
          return this._pausedCallsMetadata.has(metadata);
        return !!this._pausedCallsMetadata.size;
      }
      pausedDetails() {
        const result = [];
        for (const [metadata, {
          sdkObject
        }] of this._pausedCallsMetadata)
          result.push({
            metadata,
            sdkObject
          });
        return result;
      }
    };
    exports2.Debugger = Debugger;
    Debugger.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
    function shouldPauseOnCall(sdkObject, metadata) {
      var _sdkObject$attributio;
      if (sdkObject.attribution.playwright.options.isServer)
        return false;
      if (!((_sdkObject$attributio = sdkObject.attribution.browser) !== null && _sdkObject$attributio !== void 0 && _sdkObject$attributio.options.headful) && !(0, _utils.isUnderTest)())
        return false;
      return metadata.method === "pause";
    }
    function shouldPauseBeforeStep(metadata) {
      if (!metadata.apiName)
        return false;
      if (metadata.method === "close")
        return true;
      if (metadata.method === "waitForSelector" || metadata.method === "waitForEventInfo")
        return false;
      const step = metadata.type + "." + metadata.method;
      return _debug.commandsWithTracingSnapshots.has(step) && !_debug.pausesBeforeInputActions.has(metadata.type + "." + metadata.method);
    }
    function shouldSlowMo(metadata) {
      return _debug.slowMoActions.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/playwright-core/lib/server/artifact.js
var require_artifact = __commonJS({
  "node_modules/playwright-core/lib/server/artifact.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Artifact = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Artifact = class extends _instrumentation.SdkObject {
      constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
        super(parent, "artifact");
        this._localPath = void 0;
        this._unaccessibleErrorMessage = void 0;
        this._cancelCallback = void 0;
        this._finishedPromise = new _manualPromise.ManualPromise();
        this._saveCallbacks = [];
        this._finished = false;
        this._deleted = false;
        this._failureError = null;
        this._localPath = localPath;
        this._unaccessibleErrorMessage = unaccessibleErrorMessage;
        this._cancelCallback = cancelCallback;
      }
      finishedPromise() {
        return this._finishedPromise;
      }
      localPath() {
        return this._localPath;
      }
      localPathAfterFinished() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            throw new Error(this._unaccessibleErrorMessage);
          yield this._finishedPromise;
          if (this._failureError)
            return null;
          return this._localPath;
        });
      }
      saveAs(saveCallback) {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        if (this._deleted)
          throw new Error(`File already deleted. Save before deleting.`);
        if (this._failureError)
          throw new Error(`File not found on disk. Check download.failure() for details.`);
        if (this._finished) {
          saveCallback(this._localPath).catch((e) => {
          });
          return;
        }
        this._saveCallbacks.push(saveCallback);
      }
      failureError() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            return this._unaccessibleErrorMessage;
          yield this._finishedPromise;
          return this._failureError;
        });
      }
      cancel() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._cancelCallback !== void 0);
          return this._cancelCallback();
        });
      }
      delete() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            return;
          const fileName = yield this.localPathAfterFinished();
          if (this._deleted)
            return;
          this._deleted = true;
          if (fileName)
            yield _fs.default.promises.unlink(fileName).catch((e) => {
            });
        });
      }
      deleteOnContextClose() {
        return __async(this, null, function* () {
          if (this._deleted)
            return;
          this._deleted = true;
          if (!this._unaccessibleErrorMessage)
            yield _fs.default.promises.unlink(this._localPath).catch((e) => {
            });
          yield this.reportFinished("File deleted upon browser context closure.");
        });
      }
      reportFinished(error) {
        return __async(this, null, function* () {
          if (this._finished)
            return;
          this._finished = true;
          this._failureError = error || null;
          if (error) {
            for (const callback of this._saveCallbacks)
              yield callback("", error);
          } else {
            for (const callback of this._saveCallbacks)
              yield callback(this._localPath);
          }
          this._saveCallbacks = [];
          this._finishedPromise.resolve();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/server/har/harTracer.js
var require_harTracer = __commonJS({
  "node_modules/playwright-core/lib/server/har/harTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarTracer = void 0;
    var _browserContext = require_browserContext();
    var _fetch = require_fetch();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network2());
    var _utils = require_utils();
    var _eventsHelper = require_eventsHelper();
    var _utilsBundle = require_utilsBundle();
    var _manualPromise = require_manualPromise();
    var _userAgent = require_userAgent();
    var _network2 = require_network();
    var _frames = require_frames();
    var _mimeType = require_mimeType();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FALLBACK_HTTP_VERSION = "HTTP/1.1";
    var HarTracer = class {
      constructor(context, page, delegate, options) {
        this._context = void 0;
        this._barrierPromises = /* @__PURE__ */ new Set();
        this._delegate = void 0;
        this._options = void 0;
        this._pageEntries = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._started = false;
        this._entrySymbol = void 0;
        this._baseURL = void 0;
        this._page = void 0;
        this._context = context;
        this._page = page;
        this._delegate = delegate;
        this._options = options;
        if (options.slimMode) {
          options.omitSecurityDetails = true;
          options.omitCookies = true;
          options.omitTiming = true;
          options.omitServerIP = true;
          options.omitSizes = true;
          options.omitPages = true;
        }
        this._entrySymbol = Symbol("requestHarEntry");
        this._baseURL = context instanceof _fetch.APIRequestContext ? context._defaultOptions().baseURL : context._options.baseURL;
      }
      start() {
        if (this._started)
          return;
        this._started = true;
        const apiRequest = this._context instanceof _fetch.APIRequestContext ? this._context : this._context.fetchRequest;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.Request, (event) => this._onAPIRequest(event)), _eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.RequestFinished, (event) => this._onAPIRequestFinished(event))];
        if (this._context instanceof _browserContext.BrowserContext) {
          this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, (page) => this._createPageEntryIfNeeded(page)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Request, (request) => this._onRequest(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFinished, ({
            request,
            response
          }) => this._onRequestFinished(request, response).catch(() => {
          })), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFailed, (request) => this._onRequestFailed(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Response, (response) => this._onResponse(response)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestAborted, (request) => this._onRequestAborted(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFulfilled, (request) => this._onRequestFulfilled(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestContinued, (request) => this._onRequestContinued(request)));
        }
      }
      _shouldIncludeEntryWithUrl(urlString) {
        return !this._options.urlFilter || (0, _network2.urlMatches)(this._baseURL, urlString, this._options.urlFilter);
      }
      _entryForRequest(request) {
        return request[this._entrySymbol];
      }
      _createPageEntryIfNeeded(page) {
        if (!page)
          return;
        if (this._options.omitPages)
          return;
        if (this._page && page !== this._page)
          return;
        let pageEntry = this._pageEntries.get(page);
        if (!pageEntry) {
          pageEntry = {
            startedDateTime: new Date(),
            id: page.guid,
            title: "",
            pageTimings: this._options.omitTiming ? {} : {
              onContentLoad: -1,
              onLoad: -1
            }
          };
          page.mainFrame().on(_frames.Frame.Events.AddLifecycle, (event) => {
            if (event === "load")
              this._onLoad(page, pageEntry);
            if (event === "domcontentloaded")
              this._onDOMContentLoaded(page, pageEntry);
          });
          this._pageEntries.set(page, pageEntry);
        }
        return pageEntry;
      }
      _onDOMContentLoaded(page, pageEntry) {
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            domContentLoaded: performance.timing.domContentLoadedEventStart
          };
        }), {
          isFunction: true,
          world: "utility"
        }).then((result) => {
          pageEntry.title = result.title;
          if (!this._options.omitTiming)
            pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _onLoad(page, pageEntry) {
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            loaded: performance.timing.loadEventStart
          };
        }), {
          isFunction: true,
          world: "utility"
        }).then((result) => {
          pageEntry.title = result.title;
          if (!this._options.omitTiming)
            pageEntry.pageTimings.onLoad = result.loaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _addBarrier(target, promise) {
        if (!target)
          return null;
        if (!this._options.waitForContentOnStop)
          return;
        const race = Promise.race([new Promise((f) => target.on("close", () => {
          this._barrierPromises.delete(race);
          f();
        })), promise]);
        this._barrierPromises.add(race);
        race.then(() => this._barrierPromises.delete(race));
      }
      _onAPIRequest(event) {
        var _event$postData;
        if (!this._shouldIncludeEntryWithUrl(event.url.toString()))
          return;
        const harEntry = createHarEntry(event.method, event.url, void 0, this._options);
        harEntry._apiRequest = true;
        if (!this._options.omitCookies)
          harEntry.request.cookies = event.cookies;
        harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({
          name,
          value
        }));
        harEntry.request.postData = this._postDataForBuffer(event.postData || null, event.headers["content-type"], this._options.content);
        if (!this._options.omitSizes)
          harEntry.request.bodySize = ((_event$postData = event.postData) === null || _event$postData === void 0 ? void 0 : _event$postData.length) || 0;
        event[this._entrySymbol] = harEntry;
        if (this._started)
          this._delegate.onEntryStarted(harEntry);
      }
      _onAPIRequestFinished(event) {
        const harEntry = this._entryForRequest(event.requestEvent);
        if (!harEntry)
          return;
        harEntry.response.status = event.statusCode;
        harEntry.response.statusText = event.statusMessage;
        harEntry.response.httpVersion = event.httpVersion;
        harEntry.response.redirectURL = event.headers.location || "";
        for (let i = 0; i < event.rawHeaders.length; i += 2) {
          harEntry.response.headers.push({
            name: event.rawHeaders[i],
            value: event.rawHeaders[i + 1]
          });
        }
        harEntry.response.cookies = this._options.omitCookies ? [] : event.cookies.map((c) => {
          return __spreadProps(__spreadValues({}, c), {
            expires: c.expires === -1 ? void 0 : new Date(c.expires)
          });
        });
        const content = harEntry.response.content;
        const contentType = event.headers["content-type"];
        if (contentType)
          content.mimeType = contentType;
        this._storeResponseContent(event.body, content, "other");
        if (this._started)
          this._delegate.onEntryFinished(harEntry);
      }
      _onRequest(request) {
        var _request$frame, _request$frame2;
        if (!this._shouldIncludeEntryWithUrl(request.url()))
          return;
        const page = (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page;
        if (this._page && page !== this._page)
          return;
        const url = network.parsedURL(request.url());
        if (!url)
          return;
        const pageEntry = this._createPageEntryIfNeeded(page);
        const harEntry = createHarEntry(request.method(), url, (_request$frame2 = request.frame()) === null || _request$frame2 === void 0 ? void 0 : _request$frame2.guid, this._options);
        if (pageEntry)
          harEntry.pageref = pageEntry.id;
        this._recordRequestHeadersAndCookies(harEntry, request.headers());
        harEntry.request.postData = this._postDataForRequest(request, this._options.content);
        if (!this._options.omitSizes)
          harEntry.request.bodySize = request.bodySize();
        if (request.redirectedFrom()) {
          const fromEntry = this._entryForRequest(request.redirectedFrom());
          if (fromEntry)
            fromEntry.response.redirectURL = request.url();
        }
        request[this._entrySymbol] = harEntry;
        (0, _utils.assert)(this._started);
        this._delegate.onEntryStarted(harEntry);
      }
      _recordRequestHeadersAndCookies(harEntry, headers) {
        if (!this._options.omitCookies) {
          harEntry.request.cookies = [];
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "cookie"))
            harEntry.request.cookies.push(...header.value.split(";").map(parseCookie));
        }
        harEntry.request.headers = headers;
      }
      _recordRequestOverrides(harEntry, request) {
        if (!request._hasOverrides() || !this._options.recordRequestOverrides)
          return;
        harEntry.request.method = request.method();
        harEntry.request.url = request.url();
        harEntry.request.postData = this._postDataForRequest(request, this._options.content);
        this._recordRequestHeadersAndCookies(harEntry, request.headers());
      }
      _onRequestFinished(request, response) {
        return __async(this, null, function* () {
          var _request$frame3;
          if (!response)
            return;
          const harEntry = this._entryForRequest(request);
          if (!harEntry)
            return;
          const page = (_request$frame3 = request.frame()) === null || _request$frame3 === void 0 ? void 0 : _request$frame3._page;
          if (!this._options.omitServerIP) {
            this._addBarrier(page || request.serviceWorker(), response.serverAddr().then((server) => {
              if (server !== null && server !== void 0 && server.ipAddress)
                harEntry.serverIPAddress = server.ipAddress;
              if (server !== null && server !== void 0 && server.port)
                harEntry._serverPort = server.port;
            }));
          }
          if (!this._options.omitSecurityDetails) {
            this._addBarrier(page || request.serviceWorker(), response.securityDetails().then((details) => {
              if (details)
                harEntry._securityDetails = details;
            }));
          }
          const httpVersion = response.httpVersion();
          harEntry.request.httpVersion = httpVersion;
          harEntry.response.httpVersion = httpVersion;
          const compressionCalculationBarrier = this._options.omitSizes ? void 0 : {
            _encodedBodySize: -1,
            _decodedBodySize: -1,
            barrier: new _manualPromise.ManualPromise(),
            _check: function() {
              if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
                harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
                this.barrier.resolve();
              }
            },
            setEncodedBodySize: function(encodedBodySize) {
              this._encodedBodySize = encodedBodySize;
              this._check();
            },
            setDecodedBodySize: function(decodedBodySize) {
              this._decodedBodySize = decodedBodySize;
              this._check();
            }
          };
          if (compressionCalculationBarrier)
            this._addBarrier(page || request.serviceWorker(), compressionCalculationBarrier.barrier);
          const promise = response.body().then((buffer) => {
            if (this._options.skipScripts && request.resourceType() === "script") {
              compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(0);
              return;
            }
            const content = harEntry.response.content;
            compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(buffer.length);
            this._storeResponseContent(buffer, content, request.resourceType());
          }).catch(() => {
            compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(0);
          }).then(() => {
            if (this._started)
              this._delegate.onEntryFinished(harEntry);
          });
          this._addBarrier(page || request.serviceWorker(), promise);
          const timing = response.timing();
          harEntry.timings.receive = response.request()._responseEndTiming !== -1 ? _helper.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
          this._computeHarEntryTotalTime(harEntry);
          if (!this._options.omitSizes) {
            this._addBarrier(page || request.serviceWorker(), response.sizes().then((sizes) => {
              harEntry.response.bodySize = sizes.responseBodySize;
              harEntry.response.headersSize = sizes.responseHeadersSize;
              harEntry.response._transferSize = sizes.transferSize;
              harEntry.request.headersSize = sizes.requestHeadersSize;
              compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setEncodedBodySize(sizes.responseBodySize);
            }));
          }
        });
      }
      _onRequestFailed(request) {
        return __async(this, null, function* () {
          const harEntry = this._entryForRequest(request);
          if (!harEntry)
            return;
          if (request._failureText !== null)
            harEntry.response._failureText = request._failureText;
          this._recordRequestOverrides(harEntry, request);
          if (this._started)
            this._delegate.onEntryFinished(harEntry);
        });
      }
      _onRequestAborted(request) {
        const harEntry = this._entryForRequest(request);
        if (harEntry)
          harEntry._wasAborted = true;
      }
      _onRequestFulfilled(request) {
        const harEntry = this._entryForRequest(request);
        if (harEntry)
          harEntry._wasFulfilled = true;
      }
      _onRequestContinued(request) {
        const harEntry = this._entryForRequest(request);
        if (harEntry)
          harEntry._wasContinued = true;
      }
      _storeResponseContent(buffer, content, resourceType) {
        if (!buffer) {
          content.size = 0;
          return;
        }
        if (!this._options.omitSizes)
          content.size = buffer.length;
        if (this._options.content === "embed") {
          if ((0, _mimeType.isTextualMimeType)(content.mimeType) && resourceType !== "font") {
            content.text = buffer.toString();
          } else {
            content.text = buffer.toString("base64");
            content.encoding = "base64";
          }
        } else if (this._options.content === "attach") {
          const sha1 = (0, _utils.calculateSha1)(buffer) + "." + (_utilsBundle.mime.getExtension(content.mimeType) || "dat");
          if (this._options.includeTraceInfo)
            content._sha1 = sha1;
          else
            content._file = sha1;
          if (this._started)
            this._delegate.onContentBlob(sha1, buffer);
        }
      }
      _onResponse(response) {
        var _response$frame;
        const harEntry = this._entryForRequest(response.request());
        if (!harEntry)
          return;
        const page = (_response$frame = response.frame()) === null || _response$frame === void 0 ? void 0 : _response$frame._page;
        const pageEntry = this._createPageEntryIfNeeded(page);
        const request = response.request();
        if (this._options.includeTraceInfo)
          harEntry._monotonicTime = (0, _utils.monotonicTime)();
        harEntry.response = {
          status: response.status(),
          statusText: response.statusText(),
          httpVersion: response.httpVersion(),
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: this._options.omitSizes ? void 0 : -1
        };
        if (!this._options.omitTiming) {
          const timing = response.timing();
          if (pageEntry && pageEntry.startedDateTime.valueOf() > timing.startTime)
            pageEntry.startedDateTime = new Date(timing.startTime);
          const dns = timing.domainLookupEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
          const connect = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
          const ssl = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
          const wait = timing.responseStart !== -1 ? _helper.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
          const receive = -1;
          harEntry.timings = {
            dns,
            connect,
            ssl,
            send: 0,
            wait,
            receive
          };
          this._computeHarEntryTotalTime(harEntry);
        }
        this._recordRequestOverrides(harEntry, request);
        this._addBarrier(page || request.serviceWorker(), request.rawRequestHeaders().then((headers) => {
          this._recordRequestHeadersAndCookies(harEntry, headers);
        }));
        this._recordResponseHeaders(harEntry, response.headers());
        this._addBarrier(page || request.serviceWorker(), response.rawResponseHeaders().then((headers) => {
          this._recordResponseHeaders(harEntry, headers);
        }));
      }
      _recordResponseHeaders(harEntry, headers) {
        if (!this._options.omitCookies) {
          harEntry.response.cookies = headers.filter((header) => header.name.toLowerCase() === "set-cookie").map((header) => parseCookie(header.value));
        }
        harEntry.response.headers = headers;
        const contentType = headers.find((header) => header.name.toLowerCase() === "content-type");
        if (contentType)
          harEntry.response.content.mimeType = contentType.value;
      }
      _computeHarEntryTotalTime(harEntry) {
        harEntry.time = [harEntry.timings.dns, harEntry.timings.connect, harEntry.timings.ssl, harEntry.timings.wait, harEntry.timings.receive].reduce((pre, cur) => (cur || -1) > 0 ? cur + pre : pre, 0);
      }
      flush() {
        return __async(this, null, function* () {
          yield Promise.all(this._barrierPromises);
        });
      }
      stop() {
        this._started = false;
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._barrierPromises.clear();
        const context = this._context instanceof _browserContext.BrowserContext ? this._context : void 0;
        const log = {
          version: "1.2",
          creator: {
            name: "Playwright",
            version: (0, _userAgent.getPlaywrightVersion)()
          },
          browser: {
            name: (context === null || context === void 0 ? void 0 : context._browser.options.name) || "",
            version: (context === null || context === void 0 ? void 0 : context._browser.version()) || ""
          },
          pages: this._pageEntries.size ? Array.from(this._pageEntries.values()) : void 0,
          entries: []
        };
        if (!this._options.omitTiming) {
          for (const pageEntry of log.pages || []) {
            if (typeof pageEntry.pageTimings.onContentLoad === "number" && pageEntry.pageTimings.onContentLoad >= 0)
              pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();
            else
              pageEntry.pageTimings.onContentLoad = -1;
            if (typeof pageEntry.pageTimings.onLoad === "number" && pageEntry.pageTimings.onLoad >= 0)
              pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();
            else
              pageEntry.pageTimings.onLoad = -1;
          }
        }
        this._pageEntries.clear();
        return log;
      }
      _postDataForRequest(request, content) {
        const postData = request.postDataBuffer();
        if (!postData)
          return;
        const contentType = request.headerValue("content-type");
        return this._postDataForBuffer(postData, contentType, content);
      }
      _postDataForBuffer(postData, contentType, content) {
        var _contentType;
        if (!postData)
          return;
        (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : contentType = "application/octet-stream";
        const result = {
          mimeType: contentType,
          text: "",
          params: []
        };
        if (content === "embed" && contentType !== "application/octet-stream")
          result.text = postData.toString();
        if (content === "attach") {
          const sha1 = (0, _utils.calculateSha1)(postData) + "." + (_utilsBundle.mime.getExtension(contentType) || "dat");
          if (this._options.includeTraceInfo)
            result._sha1 = sha1;
          else
            result._file = sha1;
          this._delegate.onContentBlob(sha1, postData);
        }
        if (contentType === "application/x-www-form-urlencoded") {
          const parsed = new URLSearchParams(postData.toString());
          for (const [name, value] of parsed.entries())
            result.params.push({
              name,
              value
            });
        }
        return result;
      }
    };
    exports2.HarTracer = HarTracer;
    function createHarEntry(method, url, frameref, options) {
      const harEntry = {
        _frameref: options.includeTraceInfo ? frameref : void 0,
        _monotonicTime: options.includeTraceInfo ? (0, _utils.monotonicTime)() : void 0,
        startedDateTime: new Date(),
        time: -1,
        request: {
          method,
          url: url.toString(),
          httpVersion: FALLBACK_HTTP_VERSION,
          cookies: [],
          headers: [],
          queryString: [...url.searchParams].map((e) => ({
            name: e[0],
            value: e[1]
          })),
          headersSize: -1,
          bodySize: -1
        },
        response: {
          status: -1,
          statusText: "",
          httpVersion: FALLBACK_HTTP_VERSION,
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: options.omitSizes ? void 0 : -1
        },
        cache: {},
        timings: {
          send: -1,
          wait: -1,
          receive: -1
        }
      };
      return harEntry;
    }
    function parseCookie(c) {
      const cookie = {
        name: "",
        value: ""
      };
      let first = true;
      for (const pair of c.split(/; */)) {
        const indexOfEquals = pair.indexOf("=");
        const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
        const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
        if (first) {
          first = false;
          cookie.name = name;
          cookie.value = value;
          continue;
        }
        if (name === "Domain")
          cookie.domain = value;
        if (name === "Expires")
          cookie.expires = new Date(value);
        if (name === "HttpOnly")
          cookie.httpOnly = true;
        if (name === "Max-Age")
          cookie.expires = new Date(Date.now() + +value * 1e3);
        if (name === "Path")
          cookie.path = value;
        if (name === "SameSite")
          cookie.sameSite = value;
        if (name === "Secure")
          cookie.secure = true;
      }
      return cookie;
    }
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js
var require_snapshotterInjected = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.frameSnapshotStreamer = frameSnapshotStreamer;
    function frameSnapshotStreamer(snapshotStreamer) {
      if (window[snapshotStreamer])
        return;
      const kShadowAttribute = "__playwright_shadow_root_";
      const kValueAttribute = "__playwright_value_";
      const kCheckedAttribute = "__playwright_checked_";
      const kSelectedAttribute = "__playwright_selected_";
      const kScrollTopAttribute = "__playwright_scroll_top_";
      const kScrollLeftAttribute = "__playwright_scroll_left_";
      const kStyleSheetAttribute = "__playwright_style_sheet_";
      const kTargetAttribute = "__playwright_target__";
      const kCustomElementsAttribute = "__playwright_custom_elements__";
      const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
      const kCachedData = Symbol("__playwright_snapshot_cache_");
      const kEndOfList = Symbol("__playwright_end_of_list_");
      function resetCachedData(obj) {
        delete obj[kCachedData];
      }
      function ensureCachedData(obj) {
        if (!obj[kCachedData])
          obj[kCachedData] = {};
        return obj[kCachedData];
      }
      function removeHash(url) {
        try {
          const u = new URL(url);
          u.hash = "";
          return u.toString();
        } catch (e) {
          return url;
        }
      }
      class Streamer {
        constructor() {
          this._removeNoScript = true;
          this._lastSnapshotNumber = 0;
          this._staleStyleSheets = /* @__PURE__ */ new Set();
          this._readingStyleSheet = false;
          this._fakeBase = void 0;
          this._observer = void 0;
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "replaceSync", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, "replace", (sheet) => this._invalidateStyleSheet(sheet));
          this._fakeBase = document.createElement("base");
          this._observer = new MutationObserver((list) => this._handleMutations(list));
          const observerConfig = {
            attributes: true,
            subtree: true
          };
          this._observer.observe(document, observerConfig);
          this._refreshListenersWhenNeeded();
        }
        _refreshListenersWhenNeeded() {
          this._refreshListeners();
          const customEventName = "__playwright_snapshotter_global_listeners_check__";
          let seenEvent = false;
          const handleCustomEvent = () => seenEvent = true;
          window.addEventListener(customEventName, handleCustomEvent);
          const observer = new MutationObserver((entries) => {
            const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));
            if (newDocumentElement) {
              seenEvent = false;
              window.dispatchEvent(new CustomEvent(customEventName));
              if (!seenEvent) {
                window.addEventListener(customEventName, handleCustomEvent);
                this._refreshListeners();
              }
            }
          });
          observer.observe(document, {
            childList: true
          });
        }
        _refreshListeners() {
          document.addEventListener("__playwright_target__", (event) => {
            if (!event.detail)
              return;
            const callId = event.detail;
            event.target.__playwright_target__ = callId;
          });
        }
        _interceptNativeMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            const result = native.call(this, ...args);
            cb(this, result);
            return result;
          };
        }
        _interceptNativeAsyncMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            return __async(this, null, function* () {
              const result = yield native.call(this, ...args);
              cb(this, result);
              return result;
            });
          };
        }
        _interceptNativeGetter(obj, prop, cb) {
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          Object.defineProperty(obj, prop, __spreadProps(__spreadValues({}, descriptor), {
            get: function() {
              const result = descriptor.get.call(this);
              cb(this, result);
              return result;
            }
          }));
        }
        _handleMutations(list) {
          for (const mutation of list)
            ensureCachedData(mutation.target).attributesCached = void 0;
        }
        _invalidateStyleSheet(sheet) {
          if (this._readingStyleSheet)
            return;
          this._staleStyleSheets.add(sheet);
        }
        _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === void 0) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
            } catch (e) {
              data.cssText = "";
            }
          }
          return data.cssText;
        }
        _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet)) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
              data.cssRef = snapshotNumber;
              return data.cssText;
            } catch (e) {
            }
          }
          return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
        }
        markIframe(iframeElement, frameId) {
          iframeElement[kSnapshotFrameId] = frameId;
        }
        reset() {
          this._staleStyleSheets.clear();
          const visitNode = (node) => {
            resetCachedData(node);
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (element.shadowRoot)
                visitNode(element.shadowRoot);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitNode(child);
          };
          visitNode(document.documentElement);
          visitNode(this._fakeBase);
        }
        __sanitizeMetaAttribute(name, value, httpEquiv) {
          if (name === "charset")
            return "utf-8";
          if (httpEquiv.toLowerCase() !== "content-type" || name !== "content")
            return value;
          const [type, ...params] = value.split(";");
          if (type !== "text/html" || params.length <= 0)
            return value;
          const charsetParamIdx = params.findIndex((param) => param.trim().startsWith("charset="));
          if (charsetParamIdx > -1)
            params[charsetParamIdx] = "charset=utf-8";
          return `${type}; ${params.join("; ")}`;
        }
        _sanitizeUrl(url) {
          if (url.startsWith("javascript:") || url.startsWith("vbscript:"))
            return "";
          return url;
        }
        _sanitizeSrcSet(srcset) {
          return srcset.split(",").map((src) => {
            src = src.trim();
            const spaceIndex = src.lastIndexOf(" ");
            if (spaceIndex === -1)
              return this._sanitizeUrl(src);
            return this._sanitizeUrl(src.substring(0, spaceIndex).trim()) + src.substring(spaceIndex);
          }).join(", ");
        }
        _resolveUrl(base, url) {
          if (url === "")
            return "";
          try {
            return new URL(url, base).href;
          } catch (e) {
            return url;
          }
        }
        _getSheetBase(sheet) {
          let rootSheet = sheet;
          while (rootSheet.parentStyleSheet)
            rootSheet = rootSheet.parentStyleSheet;
          if (rootSheet.ownerNode)
            return rootSheet.ownerNode.baseURI;
          return document.baseURI;
        }
        _getSheetText(sheet) {
          this._readingStyleSheet = true;
          try {
            const rules = [];
            for (const rule of sheet.cssRules)
              rules.push(rule.cssText);
            return rules.join("\n");
          } finally {
            this._readingStyleSheet = false;
          }
        }
        captureSnapshot() {
          const timestamp = performance.now();
          const snapshotNumber = ++this._lastSnapshotNumber;
          let nodeCounter = 0;
          let shadowDomNesting = 0;
          let headNesting = 0;
          this._handleMutations(this._observer.takeRecords());
          const definedCustomElements = /* @__PURE__ */ new Set();
          const visitNode = (node) => {
            const nodeType = node.nodeType;
            const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node.nodeName;
            if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
              return;
            if (nodeName === "SCRIPT")
              return;
            if (nodeName === "LINK" && nodeType === Node.ELEMENT_NODE) {
              var _getAttribute;
              const rel = (_getAttribute = node.getAttribute("rel")) === null || _getAttribute === void 0 ? void 0 : _getAttribute.toLowerCase();
              if (rel === "preload" || rel === "prefetch")
                return;
            }
            if (this._removeNoScript && nodeName === "NOSCRIPT")
              return;
            if (nodeName === "META" && node.httpEquiv.toLowerCase() === "content-security-policy")
              return;
            if ((nodeName === "IFRAME" || nodeName === "FRAME") && headNesting)
              return;
            const data = ensureCachedData(node);
            const values = [];
            let equals = !!data.cached;
            let extraNodes = 0;
            const expectValue = (value) => {
              equals = equals && data.cached[values.length] === value;
              values.push(value);
            };
            const checkAndReturn = (n) => {
              data.attributesCached = true;
              if (equals)
                return {
                  equals: true,
                  n: [[snapshotNumber - data.ref[0], data.ref[1]]]
                };
              nodeCounter += extraNodes;
              data.ref = [snapshotNumber, nodeCounter++];
              data.cached = values;
              return {
                equals: false,
                n
              };
            };
            if (nodeType === Node.TEXT_NODE) {
              const value = node.nodeValue || "";
              expectValue(value);
              return checkAndReturn(value);
            }
            if (nodeName === "STYLE") {
              const sheet = node.sheet;
              let cssText;
              if (sheet)
                cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
              cssText = cssText || node.textContent || "";
              expectValue(cssText);
              extraNodes++;
              return checkAndReturn([nodeName, {}, cssText]);
            }
            const attrs = {};
            const result2 = [nodeName, attrs];
            const visitChild = (child) => {
              const snapshot = visitNode(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            const visitChildStyleSheet = (child) => {
              const snapshot = visitStyleSheet(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              attrs[kShadowAttribute] = "open";
            if (nodeType === Node.ELEMENT_NODE) {
              var _window$customElement;
              const element = node;
              if (element.localName.includes("-") && (_window$customElement = window.customElements) !== null && _window$customElement !== void 0 && _window$customElement.get(element.localName))
                definedCustomElements.add(element.localName);
              if (nodeName === "INPUT" || nodeName === "TEXTAREA") {
                const value = element.value;
                expectValue(kValueAttribute);
                expectValue(value);
                attrs[kValueAttribute] = value;
              }
              if (nodeName === "INPUT" && ["checkbox", "radio"].includes(element.type)) {
                const value = element.checked ? "true" : "false";
                expectValue(kCheckedAttribute);
                expectValue(value);
                attrs[kCheckedAttribute] = value;
              }
              if (nodeName === "OPTION") {
                const value = element.selected ? "true" : "false";
                expectValue(kSelectedAttribute);
                expectValue(value);
                attrs[kSelectedAttribute] = value;
              }
              if (element.scrollTop) {
                expectValue(kScrollTopAttribute);
                expectValue(element.scrollTop);
                attrs[kScrollTopAttribute] = "" + element.scrollTop;
              }
              if (element.scrollLeft) {
                expectValue(kScrollLeftAttribute);
                expectValue(element.scrollLeft);
                attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
              }
              if (element.shadowRoot) {
                ++shadowDomNesting;
                visitChild(element.shadowRoot);
                --shadowDomNesting;
              }
              if ("__playwright_target__" in element) {
                expectValue(kTargetAttribute);
                expectValue(element["__playwright_target__"]);
                attrs[kTargetAttribute] = element["__playwright_target__"];
              }
            }
            if (nodeName === "HEAD") {
              ++headNesting;
              this._fakeBase.setAttribute("href", document.baseURI);
              visitChild(this._fakeBase);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitChild(child);
            if (nodeName === "HEAD")
              --headNesting;
            expectValue(kEndOfList);
            let documentOrShadowRoot = null;
            if (node.ownerDocument.documentElement === node)
              documentOrShadowRoot = node.ownerDocument;
            else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              documentOrShadowRoot = node;
            if (documentOrShadowRoot) {
              for (const sheet of documentOrShadowRoot.adoptedStyleSheets || [])
                visitChildStyleSheet(sheet);
              expectValue(kEndOfList);
            }
            if (nodeName === "IFRAME" || nodeName === "FRAME") {
              const element = node;
              const frameId = element[kSnapshotFrameId];
              const name = "src";
              const value = frameId ? `/snapshot/${frameId}` : "";
              expectValue(name);
              expectValue(value);
              attrs[name] = value;
            }
            if (nodeName === "BODY" && definedCustomElements.size) {
              const value = [...definedCustomElements].join(",");
              expectValue(kCustomElementsAttribute);
              expectValue(value);
              attrs[kCustomElementsAttribute] = value;
            }
            if (equals && data.attributesCached && !shadowDomNesting)
              return checkAndReturn(result2);
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              for (let i = 0; i < element.attributes.length; i++) {
                const name = element.attributes[i].name;
                if (nodeName === "LINK" && name === "integrity")
                  continue;
                if (nodeName === "IFRAME" && (name === "src" || name === "srcdoc" || name === "sandbox"))
                  continue;
                if (nodeName === "FRAME" && name === "src")
                  continue;
                let value = element.attributes[i].value;
                if (nodeName === "META")
                  value = this.__sanitizeMetaAttribute(name, value, node.httpEquiv);
                else if (name === "src" && nodeName === "IMG")
                  value = this._sanitizeUrl(value);
                else if (name === "srcset" && nodeName === "IMG")
                  value = this._sanitizeSrcSet(value);
                else if (name === "srcset" && nodeName === "SOURCE")
                  value = this._sanitizeSrcSet(value);
                else if (name === "href" && nodeName === "LINK")
                  value = this._sanitizeUrl(value);
                else if (name.startsWith("on"))
                  value = "";
                expectValue(name);
                expectValue(value);
                attrs[name] = value;
              }
              expectValue(kEndOfList);
            }
            if (result2.length === 2 && !Object.keys(attrs).length)
              result2.pop();
            return checkAndReturn(result2);
          };
          const visitStyleSheet = (sheet) => {
            const data = ensureCachedData(sheet);
            const oldCSSText = data.cssText;
            const cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet, true);
            if (cssText === oldCSSText)
              return {
                equals: true,
                n: [[snapshotNumber - data.ref[0], data.ref[1]]]
              };
            data.ref = [snapshotNumber, nodeCounter++];
            return {
              equals: false,
              n: ["template", {
                [kStyleSheetAttribute]: cssText
              }]
            };
          };
          let html;
          if (document.documentElement) {
            const {
              n
            } = visitNode(document.documentElement);
            html = n;
          } else {
            html = ["html"];
          }
          const result = {
            html,
            doctype: document.doctype ? document.doctype.name : void 0,
            resourceOverrides: [],
            viewport: {
              width: window.innerWidth,
              height: window.innerHeight
            },
            url: location.href,
            timestamp,
            collectionTime: 0
          };
          for (const sheet of this._staleStyleSheets) {
            if (sheet.href === null)
              continue;
            const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
            if (content === void 0) {
              continue;
            }
            const base = this._getSheetBase(sheet);
            const url = removeHash(this._resolveUrl(base, sheet.href));
            result.resourceOverrides.push({
              url,
              content,
              contentType: "text/css"
            });
          }
          result.collectionTime = performance.now() - result.timestamp;
          return result;
        }
      }
      window[snapshotStreamer] = new Streamer();
    }
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js
var require_snapshotter = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Snapshotter = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _eventsHelper = require_eventsHelper();
    var _debugLogger = require_debugLogger();
    var _snapshotterInjected = require_snapshotterInjected();
    var _utils = require_utils();
    var _utilsBundle = require_utilsBundle();
    var Snapshotter = class {
      constructor(context, delegate) {
        this._context = void 0;
        this._delegate = void 0;
        this._eventListeners = [];
        this._snapshotStreamer = void 0;
        this._initialized = false;
        this._started = false;
        this._context = context;
        this._delegate = delegate;
        const guid = (0, _utils.createGuid)();
        this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
      }
      started() {
        return this._started;
      }
      start() {
        return __async(this, null, function* () {
          this._started = true;
          if (!this._initialized) {
            this._initialized = true;
            yield this._initialize();
          }
          yield this.reset();
        });
      }
      reset() {
        return __async(this, null, function* () {
          if (this._started)
            yield this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
        });
      }
      stop() {
        return __async(this, null, function* () {
          this._started = false;
        });
      }
      resetForReuse() {
        this._initialized = false;
      }
      _initialize() {
        return __async(this, null, function* () {
          for (const page of this._context.pages())
            this._onPage(page);
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._onPage.bind(this))];
          const initScript = `(${_snapshotterInjected.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
          yield this._context.addInitScript(initScript);
          yield this._runInAllFrames(initScript);
        });
      }
      _runInAllFrames(expression) {
        return __async(this, null, function* () {
          const frames = [];
          for (const page of this._context.pages())
            frames.push(...page.frames());
          yield Promise.all(frames.map((frame) => {
            return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
          }));
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      captureSnapshot(page, callId, snapshotName, element) {
        return __async(this, null, function* () {
          const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
          element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element2, callId2) => {
            const customEvent = new CustomEvent("__playwright_target__", {
              bubbles: true,
              cancelable: true,
              detail: callId2,
              composed: false
            });
            element2.dispatchEvent(customEvent);
          }, callId);
          const snapshots = page.frames().map((frame) => __async(this, null, function* () {
            const data = yield frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
            if (!data || !this._started)
              return;
            const snapshot = {
              callId,
              snapshotName,
              pageId: page.guid,
              frameId: frame.guid,
              frameUrl: data.url,
              doctype: data.doctype,
              html: data.html,
              viewport: data.viewport,
              timestamp: (0, _utils.monotonicTime)(),
              collectionTime: data.collectionTime,
              resourceOverrides: [],
              isMainFrame: page.mainFrame() === frame
            };
            for (const {
              url,
              content,
              contentType
            } of data.resourceOverrides) {
              if (typeof content === "string") {
                const buffer = Buffer.from(content);
                const sha1 = (0, _utils.calculateSha1)(buffer) + "." + (_utilsBundle.mime.getExtension(contentType) || "dat");
                this._delegate.onSnapshotterBlob({
                  sha1,
                  buffer
                });
                snapshot.resourceOverrides.push({
                  url,
                  sha1
                });
              } else {
                snapshot.resourceOverrides.push({
                  url,
                  ref: content
                });
              }
            }
            this._delegate.onFrameSnapshot(snapshot);
          }));
          yield Promise.all(snapshots);
        });
      }
      _onPage(page) {
        for (const frame of page.frames())
          this._annotateFrameHierarchy(frame);
        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
      }
      _annotateFrameHierarchy(frame) {
        return __async(this, null, function* () {
          try {
            const frameElement = yield frame.frameElement();
            const parent = frame.parentFrame();
            if (!parent)
              return;
            const context = yield parent._mainContext();
            yield context === null || context === void 0 ? void 0 : context.evaluate(({
              snapshotStreamer,
              frameElement: frameElement2,
              frameId
            }) => {
              window[snapshotStreamer].markIframe(frameElement2, frameId);
            }, {
              snapshotStreamer: this._snapshotStreamer,
              frameElement,
              frameId: frame.guid
            });
            frameElement.dispose();
          } catch (e) {
          }
        });
      }
    };
    exports2.Snapshotter = Snapshotter;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/tracing.js
var require_tracing = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Tracing = void 0;
    exports2.shouldCaptureSnapshot = shouldCaptureSnapshot;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _debug = require_debug2();
    var _manualPromise = require_manualPromise();
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _artifact = require_artifact();
    var _browserContext = require_browserContext();
    var _instrumentation = require_instrumentation();
    var _page = require_page();
    var _harTracer = require_harTracer();
    var _snapshotter = require_snapshotter();
    var _zipBundle = require_zipBundle();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var version = 4;
    var kScreencastOptions = {
      width: 800,
      height: 600,
      quality: 90
    };
    var Tracing = class extends _instrumentation.SdkObject {
      constructor(context, tracesDir) {
        super(context, "tracing");
        this._writeChain = Promise.resolve();
        this._snapshotter = void 0;
        this._harTracer = void 0;
        this._screencastListeners = [];
        this._eventListeners = [];
        this._context = void 0;
        this._state = void 0;
        this._isStopping = false;
        this._precreatedTracesDir = void 0;
        this._tracesTmpDir = void 0;
        this._allResources = /* @__PURE__ */ new Set();
        this._contextCreatedEvent = void 0;
        this._context = context;
        this._precreatedTracesDir = tracesDir;
        this._harTracer = new _harTracer.HarTracer(context, null, this, {
          content: "attach",
          includeTraceInfo: true,
          recordRequestOverrides: false,
          waitForContentOnStop: false,
          skipScripts: true
        });
        const testIdAttributeName = "selectors" in context ? context.selectors().testIdAttributeName() : void 0;
        this._contextCreatedEvent = {
          version,
          type: "context-options",
          browserName: "",
          options: {},
          platform: process.platform,
          wallTime: 0,
          sdkLanguage: context.attribution.playwright.options.sdkLanguage,
          testIdAttributeName
        };
        if (context instanceof _browserContext.BrowserContext) {
          this._snapshotter = new _snapshotter.Snapshotter(context, this);
          (0, _utils.assert)(tracesDir, "tracesDir must be specified for BrowserContext");
          this._contextCreatedEvent.browserName = context._browser.options.name;
          this._contextCreatedEvent.options = context._options;
        }
      }
      resetForReuse() {
        var _this$_snapshotter;
        (_this$_snapshotter = this._snapshotter) === null || _this$_snapshotter === void 0 ? void 0 : _this$_snapshotter.resetForReuse();
      }
      start(options) {
        return __async(this, null, function* () {
          if (this._isStopping)
            throw new Error("Cannot start tracing while stopping");
          this._contextCreatedEvent.sdkLanguage = this._context.attribution.playwright.options.sdkLanguage;
          if (this._state) {
            const o = this._state.options;
            if (!o.screenshots !== !options.screenshots || !o.snapshots !== !options.snapshots)
              throw new Error("Tracing has been already started with different options");
            if (options.name && options.name !== this._state.traceName)
              yield this._changeTraceName(this._state, options.name);
            return;
          }
          const traceName = options.name || (0, _utils.createGuid)();
          const tracesDir = this._createTracesDirIfNeeded();
          this._state = {
            options,
            traceName,
            tracesDir,
            traceFile: {
              file: _path.default.join(tracesDir, traceName + ".trace"),
              buffer: []
            },
            networkFile: {
              file: _path.default.join(tracesDir, traceName + ".network"),
              buffer: []
            },
            resourcesDir: _path.default.join(tracesDir, "resources"),
            chunkOrdinal: 0,
            traceSha1s: /* @__PURE__ */ new Set(),
            networkSha1s: /* @__PURE__ */ new Set(),
            recording: false,
            callIds: /* @__PURE__ */ new Set()
          };
          const state = this._state;
          this._writeChain = _fs.default.promises.mkdir(state.resourcesDir, {
            recursive: true
          }).then(() => _fs.default.promises.writeFile(state.networkFile.file, ""));
          if (options.snapshots)
            this._harTracer.start();
        });
      }
      startChunk() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_snapshotter2;
          if (this._state && this._state.recording)
            yield this.stopChunk({
              mode: "discard"
            });
          if (!this._state)
            throw new Error("Must start tracing before starting a new chunk");
          if (this._isStopping)
            throw new Error("Cannot start a trace chunk while stopping");
          const state = this._state;
          const suffix = state.chunkOrdinal ? `-${state.chunkOrdinal}` : ``;
          state.chunkOrdinal++;
          state.traceFile = {
            file: _path.default.join(state.tracesDir, `${state.traceName}${suffix}.trace`),
            buffer: []
          };
          state.recording = true;
          state.callIds.clear();
          if (options.name && options.name !== this._state.traceName)
            this._changeTraceName(this._state, options.name);
          this._appendTraceOperation(() => __async(this, null, function* () {
            yield (0, _fileUtils.mkdirIfNeeded)(state.traceFile.file);
            const event = __spreadProps(__spreadValues({}, this._contextCreatedEvent), {
              title: options.title,
              wallTime: Date.now()
            });
            yield appendEventAndFlushIfNeeded(state.traceFile, event);
          }));
          this._context.instrumentation.addListener(this, this._context);
          this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Console, this._onConsoleMessage.bind(this)));
          if (state.options.screenshots)
            this._startScreencast();
          if (state.options.snapshots)
            yield (_this$_snapshotter2 = this._snapshotter) === null || _this$_snapshotter2 === void 0 ? void 0 : _this$_snapshotter2.start();
          return {
            traceName: state.traceName
          };
        });
      }
      _startScreencast() {
        if (!(this._context instanceof _browserContext.BrowserContext))
          return;
        for (const page of this._context.pages())
          this._startScreencastInPage(page);
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._startScreencastInPage.bind(this)));
      }
      _stopScreencast() {
        _eventsHelper.eventsHelper.removeEventListeners(this._screencastListeners);
        if (!(this._context instanceof _browserContext.BrowserContext))
          return;
        for (const page of this._context.pages())
          page.setScreencastOptions(null);
      }
      _changeTraceName(state, name) {
        return __async(this, null, function* () {
          yield this._appendTraceOperation(() => __async(this, null, function* () {
            yield flushTraceFile(state.traceFile);
            yield flushTraceFile(state.networkFile);
            const oldNetworkFile = state.networkFile;
            state.traceName = name;
            state.traceFile = {
              file: _path.default.join(state.tracesDir, name + ".trace"),
              buffer: []
            };
            state.networkFile = {
              file: _path.default.join(state.tracesDir, name + ".network"),
              buffer: []
            };
            yield _fs.default.promises.copyFile(oldNetworkFile.file, state.networkFile.file);
          }));
        });
      }
      stop() {
        return __async(this, null, function* () {
          if (!this._state)
            return;
          if (this._isStopping)
            throw new Error(`Tracing is already stopping`);
          if (this._state.recording)
            throw new Error(`Must stop trace file before stopping tracing`);
          this._harTracer.stop();
          yield this._writeChain;
          this._state = void 0;
        });
      }
      deleteTmpTracesDir() {
        return __async(this, null, function* () {
          if (this._tracesTmpDir)
            yield (0, _fileUtils.removeFolders)([this._tracesTmpDir]);
        });
      }
      _createTracesDirIfNeeded() {
        if (this._precreatedTracesDir)
          return this._precreatedTracesDir;
        this._tracesTmpDir = _fs.default.mkdtempSync(_path.default.join(_os.default.tmpdir(), "playwright-tracing-"));
        return this._tracesTmpDir;
      }
      dispose() {
        return __async(this, null, function* () {
          var _this$_snapshotter3;
          (_this$_snapshotter3 = this._snapshotter) === null || _this$_snapshotter3 === void 0 ? void 0 : _this$_snapshotter3.dispose();
          this._harTracer.stop();
          yield this._writeChain;
        });
      }
      stopChunk(params) {
        return __async(this, null, function* () {
          var _this$_state, _this$_snapshotter4;
          if (this._isStopping)
            throw new Error(`Tracing is already stopping`);
          this._isStopping = true;
          if (!this._state || !this._state.recording) {
            this._isStopping = false;
            if (params.mode !== "discard")
              throw new Error(`Must start tracing before stopping`);
            return {};
          }
          const state = this._state;
          this._context.instrumentation.removeListener(this);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          if ((_this$_state = this._state) !== null && _this$_state !== void 0 && _this$_state.options.screenshots)
            this._stopScreencast();
          if (state.options.snapshots)
            yield (_this$_snapshotter4 = this._snapshotter) === null || _this$_snapshotter4 === void 0 ? void 0 : _this$_snapshotter4.stop();
          return (yield this._appendTraceOperation(() => __async(this, null, function* () {
            if (params.mode === "discard")
              return {};
            yield flushTraceFile(state.traceFile);
            yield flushTraceFile(state.networkFile);
            const networkFile = _path.default.join(state.tracesDir, state.traceName + `-pwnetcopy-${state.chunkOrdinal}.network`);
            yield _fs.default.promises.copyFile(state.networkFile.file, networkFile);
            const entries = [];
            entries.push({
              name: "trace.trace",
              value: state.traceFile.file
            });
            entries.push({
              name: "trace.network",
              value: networkFile
            });
            for (const sha1 of /* @__PURE__ */ new Set([...state.traceSha1s, ...state.networkSha1s]))
              entries.push({
                name: _path.default.join("resources", sha1),
                value: _path.default.join(state.resourcesDir, sha1)
              });
            if (params.mode === "entries")
              return {
                entries
              };
            const artifact = yield this._exportZip(entries, state).catch(() => void 0);
            return {
              artifact
            };
          })).finally(() => {
            state.traceSha1s = /* @__PURE__ */ new Set();
            this._isStopping = false;
            state.recording = false;
          })) || {};
        });
      }
      _exportZip(entries, state) {
        const zipFile = new _zipBundle.yazl.ZipFile();
        const result = new _manualPromise.ManualPromise();
        zipFile.on("error", (error) => result.reject(error));
        for (const entry of entries)
          zipFile.addFile(entry.value, entry.name);
        zipFile.end();
        const zipFileName = state.traceFile.file + ".zip";
        zipFile.outputStream.pipe(_fs.default.createWriteStream(zipFileName)).on("close", () => {
          const artifact = new _artifact.Artifact(this._context, zipFileName);
          artifact.reportFinished();
          result.resolve(artifact);
        }).on("error", (error) => result.reject(error));
        return result;
      }
      _captureSnapshot(snapshotName, sdkObject, metadata, element) {
        return __async(this, null, function* () {
          if (!this._snapshotter)
            return;
          if (!sdkObject.attribution.page)
            return;
          if (!this._snapshotter.started())
            return;
          if (!shouldCaptureSnapshot(metadata))
            return;
          yield this._snapshotter.captureSnapshot(sdkObject.attribution.page, metadata.id, snapshotName, element).catch(() => {
          });
        });
      }
      onBeforeCall(sdkObject, metadata) {
        var _sdkObject$attributio, _this$_state2;
        const event = createBeforeActionTraceEvent(metadata);
        if (!event)
          return Promise.resolve();
        (_sdkObject$attributio = sdkObject.attribution.page) === null || _sdkObject$attributio === void 0 ? void 0 : _sdkObject$attributio.temporarlyDisableTracingScreencastThrottling();
        event.beforeSnapshot = `before@${metadata.id}`;
        (_this$_state2 = this._state) === null || _this$_state2 === void 0 ? void 0 : _this$_state2.callIds.add(metadata.id);
        this._appendTraceEvent(event);
        return this._captureSnapshot(event.beforeSnapshot, sdkObject, metadata);
      }
      onBeforeInputAction(sdkObject, metadata, element) {
        var _this$_state3, _sdkObject$attributio2;
        if (!((_this$_state3 = this._state) !== null && _this$_state3 !== void 0 && _this$_state3.callIds.has(metadata.id)))
          return Promise.resolve();
        const event = createInputActionTraceEvent(metadata);
        if (!event)
          return Promise.resolve();
        (_sdkObject$attributio2 = sdkObject.attribution.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.temporarlyDisableTracingScreencastThrottling();
        event.inputSnapshot = `input@${metadata.id}`;
        this._appendTraceEvent(event);
        return this._captureSnapshot(event.inputSnapshot, sdkObject, metadata, element);
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          var _this$_state4, _this$_state5, _sdkObject$attributio3;
          if (!((_this$_state4 = this._state) !== null && _this$_state4 !== void 0 && _this$_state4.callIds.has(metadata.id)))
            return;
          (_this$_state5 = this._state) === null || _this$_state5 === void 0 ? void 0 : _this$_state5.callIds.delete(metadata.id);
          const event = createAfterActionTraceEvent(metadata);
          if (!event)
            return;
          (_sdkObject$attributio3 = sdkObject.attribution.page) === null || _sdkObject$attributio3 === void 0 ? void 0 : _sdkObject$attributio3.temporarlyDisableTracingScreencastThrottling();
          event.afterSnapshot = `after@${metadata.id}`;
          this._appendTraceEvent(event);
          return this._captureSnapshot(event.afterSnapshot, sdkObject, metadata);
        });
      }
      onEvent(sdkObject, event) {
        if (!sdkObject.attribution.context)
          return;
        if (event.method === "console" || event.method === "__create__" && event.class === "ConsoleMessage") {
          return;
        }
        this._appendTraceEvent(event);
      }
      onEntryStarted(entry) {
      }
      onEntryFinished(entry) {
        const event = {
          type: "resource-snapshot",
          snapshot: entry
        };
        this._appendTraceOperation(() => __async(this, null, function* () {
          const visited = visitTraceEvent(event, this._state.networkSha1s);
          yield appendEventAndFlushIfNeeded(this._state.networkFile, visited);
        }));
      }
      onContentBlob(sha1, buffer) {
        this._appendResource(sha1, buffer);
      }
      onSnapshotterBlob(blob) {
        this._appendResource(blob.sha1, blob.buffer);
      }
      onFrameSnapshot(snapshot) {
        this._appendTraceEvent({
          type: "frame-snapshot",
          snapshot
        });
      }
      _onConsoleMessage(message) {
        const object = {
          type: "object",
          class: "ConsoleMessage",
          guid: message.guid,
          initializer: {
            type: message.type(),
            text: message.text(),
            location: message.location()
          }
        };
        this._appendTraceEvent(object);
        const event = {
          type: "event",
          class: "BrowserContext",
          method: "console",
          params: {
            message: {
              guid: message.guid
            }
          },
          time: (0, _utils.monotonicTime)(),
          pageId: message.page().guid
        };
        this._appendTraceEvent(event);
      }
      _startScreencastInPage(page) {
        page.setScreencastOptions(kScreencastOptions);
        const prefix = page.guid;
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.ScreencastFrame, (params) => {
          const suffix = params.timestamp || Date.now();
          const sha1 = `${prefix}-${suffix}.jpeg`;
          const event = {
            type: "screencast-frame",
            pageId: page.guid,
            sha1,
            width: params.width,
            height: params.height,
            timestamp: (0, _utils.monotonicTime)()
          };
          this._appendResource(sha1, params.buffer);
          this._appendTraceEvent(event);
        }));
      }
      _appendTraceEvent(event) {
        this._appendTraceOperation(() => __async(this, null, function* () {
          const visited = visitTraceEvent(event, this._state.traceSha1s);
          yield appendEventAndFlushIfNeeded(this._state.traceFile, visited);
        }));
      }
      _appendResource(sha1, buffer) {
        if (this._allResources.has(sha1))
          return;
        this._allResources.add(sha1);
        const resourcePath = _path.default.join(this._state.resourcesDir, sha1);
        this._appendTraceOperation(() => __async(this, null, function* () {
          yield _fs.default.promises.writeFile(resourcePath, buffer, {
            flag: "wx"
          }).catch(() => {
          });
        }));
      }
      _appendTraceOperation(cb) {
        return __async(this, null, function* () {
          let error;
          let result;
          this._writeChain = this._writeChain.then(() => __async(this, null, function* () {
            if (this._context instanceof _browserContext.BrowserContext && !this._context._browser.isConnected())
              return;
            try {
              result = yield cb();
            } catch (e) {
              error = e;
            }
          }));
          yield this._writeChain;
          if (error)
            throw error;
          return result;
        });
      }
    };
    exports2.Tracing = Tracing;
    function visitTraceEvent(object, sha1s) {
      if (Array.isArray(object))
        return object.map((o) => visitTraceEvent(o, sha1s));
      if (object instanceof Buffer)
        return void 0;
      if (typeof object === "object") {
        const result = {};
        for (const key in object) {
          if (key === "sha1" || key === "_sha1" || key.endsWith("Sha1")) {
            const sha1 = object[key];
            if (sha1)
              sha1s.add(sha1);
          }
          result[key] = visitTraceEvent(object[key], sha1s);
        }
        return result;
      }
      return object;
    }
    function shouldCaptureSnapshot(metadata) {
      return _debug.commandsWithTracingSnapshots.has(metadata.type + "." + metadata.method);
    }
    function createBeforeActionTraceEvent(metadata) {
      if (metadata.internal || metadata.method.startsWith("tracing"))
        return null;
      return {
        type: "before",
        callId: metadata.id,
        startTime: metadata.startTime,
        apiName: metadata.apiName || metadata.type + "." + metadata.method,
        class: metadata.type,
        method: metadata.method,
        params: metadata.params,
        wallTime: metadata.wallTime,
        pageId: metadata.pageId
      };
    }
    function createInputActionTraceEvent(metadata) {
      if (metadata.internal || metadata.method.startsWith("tracing"))
        return null;
      return {
        type: "input",
        callId: metadata.id,
        point: metadata.point
      };
    }
    function createAfterActionTraceEvent(metadata) {
      var _metadata$error;
      if (metadata.internal || metadata.method.startsWith("tracing"))
        return null;
      return {
        type: "after",
        callId: metadata.id,
        endTime: metadata.endTime,
        log: metadata.log,
        error: (_metadata$error = metadata.error) === null || _metadata$error === void 0 ? void 0 : _metadata$error.error,
        result: metadata.result
      };
    }
    function appendEventAndFlushIfNeeded(file, event) {
      return __async(this, null, function* () {
        file.buffer.push(event);
        if (event.type === "event" || event.type === "object")
          return;
        yield flushTraceFile(file);
      });
    }
    function flushTraceFile(file) {
      return __async(this, null, function* () {
        const data = file.buffer.map((e) => Buffer.from(JSON.stringify(e) + "\n"));
        yield _fs.default.promises.appendFile(file.file, Buffer.concat(data));
        file.buffer = [];
      });
    }
  }
});

// node_modules/playwright-core/lib/server/har/harRecorder.js
var require_harRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/har/harRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarRecorder = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _artifact = require_artifact();
    var _harTracer = require_harTracer();
    var _zipBundle = require_zipBundle();
    var _manualPromise = require_manualPromise();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var HarRecorder = class {
      constructor(context, page, options) {
        this._artifact = void 0;
        this._isFlushed = false;
        this._tracer = void 0;
        this._entries = [];
        this._zipFile = null;
        this._writtenZipEntries = /* @__PURE__ */ new Set();
        this._artifact = new _artifact.Artifact(context, _path.default.join(context._browser.options.artifactsDir, `${(0, _utils.createGuid)()}.har`));
        const urlFilterRe = options.urlRegexSource !== void 0 && options.urlRegexFlags !== void 0 ? new RegExp(options.urlRegexSource, options.urlRegexFlags) : void 0;
        const expectsZip = options.path.endsWith(".zip");
        const content = options.content || (expectsZip ? "attach" : "embed");
        this._tracer = new _harTracer.HarTracer(context, page, this, {
          content,
          slimMode: options.mode === "minimal",
          includeTraceInfo: false,
          recordRequestOverrides: true,
          waitForContentOnStop: true,
          skipScripts: false,
          urlFilter: urlFilterRe !== null && urlFilterRe !== void 0 ? urlFilterRe : options.urlGlob
        });
        this._zipFile = content === "attach" || expectsZip ? new _zipBundle.yazl.ZipFile() : null;
        this._tracer.start();
      }
      onEntryStarted(entry) {
        this._entries.push(entry);
      }
      onEntryFinished(entry) {
      }
      onContentBlob(sha1, buffer) {
        if (!this._zipFile || this._writtenZipEntries.has(sha1))
          return;
        this._writtenZipEntries.add(sha1);
        this._zipFile.addBuffer(buffer, sha1);
      }
      flush() {
        return __async(this, null, function* () {
          if (this._isFlushed)
            return;
          this._isFlushed = true;
          yield this._tracer.flush();
          const log = this._tracer.stop();
          log.entries = this._entries;
          const harFileContent = jsonStringify({
            log
          });
          if (this._zipFile) {
            const result = new _manualPromise.ManualPromise();
            this._zipFile.on("error", (error) => result.reject(error));
            this._zipFile.addBuffer(Buffer.from(harFileContent, "utf-8"), "har.har");
            this._zipFile.end();
            this._zipFile.outputStream.pipe(_fs.default.createWriteStream(this._artifact.localPath())).on("close", () => {
              result.resolve();
            });
            yield result;
          } else {
            yield _fs.default.promises.writeFile(this._artifact.localPath(), harFileContent);
          }
        });
      }
      export() {
        return __async(this, null, function* () {
          yield this.flush();
          this._artifact.reportFinished();
          return this._artifact;
        });
      }
    };
    exports2.HarRecorder = HarRecorder;
    function jsonStringify(object) {
      const tokens = [];
      innerJsonStringify(object, tokens, "", false, void 0);
      return tokens.join("");
    }
    function innerJsonStringify(object, tokens, indent, flat, parentKey) {
      if (typeof object !== "object" || object === null) {
        tokens.push(JSON.stringify(object));
        return;
      }
      const isArray = Array.isArray(object);
      if (!isArray && object.constructor.name !== "Object") {
        tokens.push(JSON.stringify(object));
        return;
      }
      const entries = isArray ? object : Object.entries(object).filter((e) => e[1] !== void 0);
      if (!entries.length) {
        tokens.push(isArray ? `[]` : `{}`);
        return;
      }
      const childIndent = `${indent}  `;
      let brackets;
      if (isArray)
        brackets = flat ? {
          open: "[",
          close: "]"
        } : {
          open: `[
${childIndent}`,
          close: `
${indent}]`
        };
      else
        brackets = flat ? {
          open: "{ ",
          close: " }"
        } : {
          open: `{
${childIndent}`,
          close: `
${indent}}`
        };
      tokens.push(brackets.open);
      for (let i = 0; i < entries.length; ++i) {
        const entry = entries[i];
        if (i)
          tokens.push(flat ? `, ` : `,
${childIndent}`);
        if (!isArray)
          tokens.push(`${JSON.stringify(entry[0])}: `);
        const key = isArray ? void 0 : entry[0];
        const flatten = flat || key === "timings" || parentKey === "headers";
        innerJsonStringify(isArray ? entry : entry[1], tokens, childIndent, flatten, key);
      }
      tokens.push(brackets.close);
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/codeGenerator.js
var require_codeGenerator = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/codeGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CodeGenerator = void 0;
    var _events = require("events");
    var CodeGenerator = class extends _events.EventEmitter {
      constructor(browserName, enabled, launchOptions, contextOptions, deviceName, saveStorage) {
        super();
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this._enabled = void 0;
        this._options = void 0;
        launchOptions = __spreadValues({
          headless: false
        }, launchOptions);
        contextOptions = __spreadValues({}, contextOptions);
        this._enabled = enabled;
        this._options = {
          browserName,
          launchOptions,
          contextOptions,
          deviceName,
          saveStorage
        };
        this.restart();
      }
      restart() {
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this.emit("change");
      }
      setEnabled(enabled) {
        this._enabled = enabled;
      }
      addAction(action) {
        if (!this._enabled)
          return;
        this.willPerformAction(action);
        this.didPerformAction(action);
      }
      willPerformAction(action) {
        if (!this._enabled)
          return;
        this._currentAction = action;
      }
      performedActionFailed(action) {
        if (!this._enabled)
          return;
        if (this._currentAction === action)
          this._currentAction = null;
      }
      didPerformAction(actionInContext) {
        if (!this._enabled)
          return;
        const action = actionInContext.action;
        let eraseLastAction = false;
        if (this._lastAction && this._lastAction.frame.pageAlias === actionInContext.frame.pageAlias) {
          const lastAction = this._lastAction.action;
          if (this._lastAction && action.name === "fill" && lastAction.name === "fill") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "click" && lastAction.name === "click") {
            if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "navigate" && lastAction.name === "navigate") {
            if (action.url === lastAction.url) {
              this._currentAction = null;
              return;
            }
          }
          if (lastAction && (action.name === "check" || action.name === "uncheck") && lastAction.name === "click") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
        }
        this._lastAction = actionInContext;
        this._currentAction = null;
        if (eraseLastAction)
          this._actions.pop();
        this._actions.push(actionInContext);
        this.emit("change");
      }
      commitLastAction() {
        if (!this._enabled)
          return;
        const action = this._lastAction;
        if (action)
          action.committed = true;
      }
      signal(pageAlias, frame, signal) {
        if (!this._enabled)
          return;
        if (this._currentAction) {
          this._currentAction.action.signals.push(signal);
          return;
        }
        if (this._lastAction && !this._lastAction.committed) {
          const signals = this._lastAction.action.signals;
          if (signal.name === "navigation" && signals.length && signals[signals.length - 1].name === "download")
            return;
          if (signal.name === "download" && signals.length && signals[signals.length - 1].name === "navigation")
            signals.length = signals.length - 1;
          this._lastAction.action.signals.push(signal);
          this.emit("change");
          return;
        }
        if (signal.name === "navigation") {
          this.addAction({
            frame: {
              pageAlias,
              isMainFrame: frame._page.mainFrame() === frame,
              url: frame.url()
            },
            committed: true,
            action: {
              name: "navigate",
              url: frame.url(),
              signals: []
            }
          });
        }
      }
      generateStructure(languageGenerator) {
        const header = languageGenerator.generateHeader(this._options);
        const footer = languageGenerator.generateFooter(this._options.saveStorage);
        const actions = this._actions.map((a) => languageGenerator.generateAction(a)).filter(Boolean);
        const text = [header, ...actions, footer].join("\n");
        return {
          header,
          footer,
          actions,
          text
        };
      }
    };
    exports2.CodeGenerator = CodeGenerator;
  }
});

// node_modules/playwright-core/lib/server/recorder/utils.js
var require_utils2 = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toClickOptions = toClickOptions;
    exports2.toModifiers = toModifiers;
    function toClickOptions(action) {
      let method = "click";
      if (action.clickCount === 2)
        method = "dblclick";
      const modifiers = toModifiers(action.modifiers);
      const options = {};
      if (action.button !== "left")
        options.button = action.button;
      if (modifiers.length)
        options.modifiers = modifiers;
      if (action.clickCount > 2)
        options.clickCount = action.clickCount;
      if (action.position)
        options.position = action.position;
      return {
        method,
        options
      };
    }
    function toModifiers(modifiers) {
      const result = [];
      if (modifiers & 1)
        result.push("Alt");
      if (modifiers & 2)
        result.push("Control");
      if (modifiers & 4)
        result.push("Meta");
      if (modifiers & 8)
        result.push("Shift");
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/language.js
var require_language = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sanitizeDeviceOptions = sanitizeDeviceOptions;
    exports2.toSignalMap = toSignalMap;
    function sanitizeDeviceOptions(device, options) {
      const cleanedOptions = {};
      for (const property in options) {
        if (JSON.stringify(device[property]) !== JSON.stringify(options[property]))
          cleanedOptions[property] = options[property];
      }
      return cleanedOptions;
    }
    function toSignalMap(action) {
      let popup;
      let download;
      let dialog;
      for (const signal of action.signals) {
        if (signal.name === "popup")
          popup = signal;
        else if (signal.name === "download")
          download = signal;
        else if (signal.name === "dialog")
          dialog = signal;
      }
      return {
        popup,
        download,
        dialog
      };
    }
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptorsSource.json
var require_deviceDescriptorsSource = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptorsSource.json"(exports2, module2) {
    module2.exports = {
      "Blackberry PlayBook": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/17.0 Safari/536.2+",
        viewport: {
          width: 600,
          height: 1024
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Blackberry PlayBook landscape": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/17.0 Safari/536.2+",
        viewport: {
          width: 1024,
          height: 600
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/17.0 Mobile Safari/537.10+",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30 landscape": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/17.0 Mobile Safari/537.10+",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/17.0 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/17.0 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/17.0 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/17.0 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/17.0 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/17.0 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S5": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 740
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 740,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 320,
          height: 658
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+ landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 658,
          height: 320
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        viewport: {
          width: 712,
          height: 1138
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        viewport: {
          width: 1138,
          height: 712
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "iPad (gen 6)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 6) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 810,
          height: 1080
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1080,
          height: 810
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 834,
          height: 1194
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11 landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1194,
          height: 834
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/17.0 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 320,
          height: 568
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/17.0 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 568,
          height: 320
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 812
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/17.0 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 812,
          height: 375
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 896
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 896,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 800,
          height: 364
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 635
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 724,
          height: 325
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 808,
          height: 364
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 378
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Mini": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 629
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Mini landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 712,
          height: 325
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 380
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 629
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 712,
          height: 327
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Kindle Fire HDX": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Kindle Fire HDX landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "LG Optimus L70": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "LG Optimus L70 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        viewport: {
          width: 600,
          height: 960
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        viewport: {
          width: 960,
          height: 600
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 320,
          height: 533
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520 landscape": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 533,
          height: 320
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia N9": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 480,
          height: 854
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Nokia N9 landscape": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 854,
          height: 480
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Pixel 2": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 731
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 731,
          height: 411
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 823
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 823,
          height: 411
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 393,
          height: 786
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 786,
          height: 393
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 353,
          height: 745
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 745,
          height: 353
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G)": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        screen: {
          width: 412,
          height: 892
        },
        viewport: {
          width: 412,
          height: 765
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G) landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        screen: {
          height: 892,
          width: 412
        },
        viewport: {
          width: 840,
          height: 312
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        screen: {
          width: 393,
          height: 851
        },
        viewport: {
          width: 393,
          height: 727
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        screen: {
          width: 851,
          height: 393
        },
        viewport: {
          width: 802,
          height: 293
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Desktop Chrome HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36 Edg/115.0.5790.75",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:115.0) Gecko/20100101 Firefox/115.0",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      },
      "Desktop Safari": {
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "webkit"
      },
      "Desktop Chrome": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.75 Safari/537.36 Edg/115.0.5790.75",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:115.0) Gecko/20100101 Firefox/115.0",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      }
    };
  }
});

// node_modules/playwright-core/lib/server/recorder/javascript.js
var require_javascript2 = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaScriptLanguageGenerator = exports2.JavaScriptFormatter = void 0;
    var _language = require_language();
    var _utils = require_utils2();
    var _stringUtils = require_stringUtils();
    var _locatorGenerators = require_locatorGenerators();
    var deviceDescriptors = require_deviceDescriptorsSource();
    var JavaScriptLanguageGenerator = class {
      constructor(isTest) {
        this.id = void 0;
        this.groupName = "Node.js";
        this.name = void 0;
        this.highlighter = "javascript";
        this._isTest = void 0;
        this.id = isTest ? "playwright-test" : "javascript";
        this.name = isTest ? "Test Runner" : "Library";
        this._isTest = isTest;
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        if (this._isTest && (action.name === "openPage" || action.name === "closePage"))
          return "";
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new JavaScriptFormatter(2);
        if (action.name === "openPage") {
          formatter.add(`const ${pageAlias} = await context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => `.frameLocator(${quote(selector)})`);
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.frame(${formatObject({
            name: actionInContext.frame.name
          })})`;
        } else {
          subject = `${pageAlias}.frame(${formatObject({
            url: actionInContext.frame.url
          })})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
        }
        if (signals.popup)
          formatter.add(`const ${signals.popup.popupAlias}Promise = ${pageAlias}.waitForEvent('popup');`);
        if (signals.download)
          formatter.add(`const download${signals.download.downloadAlias}Promise = ${pageAlias}.waitForEvent('download');`);
        const actionCall = this._generateActionCall(action);
        formatter.add(`await ${subject}.${actionCall};`);
        if (signals.popup)
          formatter.add(`const ${signals.popup.popupAlias} = await ${signals.popup.popupAlias}Promise;`);
        if (signals.download)
          formatter.add(`const download${signals.download.downloadAlias} = await download${signals.download.downloadAlias}Promise;`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsString = formatOptions(options, false);
            return this._asLocator(action.selector) + `.${method}(${optionsString})`;
          }
          case "check":
            return this._asLocator(action.selector) + `.check()`;
          case "uncheck":
            return this._asLocator(action.selector) + `.uncheck()`;
          case "fill":
            return this._asLocator(action.selector) + `.fill(${quote(action.text)})`;
          case "setInputFiles":
            return this._asLocator(action.selector) + `.setInputFiles(${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return this._asLocator(action.selector) + `.press(${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return this._asLocator(action.selector) + `.selectOption(${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      _asLocator(selector) {
        return (0, _locatorGenerators.asLocator)("javascript", selector);
      }
      generateHeader(options) {
        if (this._isTest)
          return this.generateTestHeader(options);
        return this.generateStandaloneHeader(options);
      }
      generateFooter(saveStorage) {
        if (this._isTest)
          return this.generateTestFooter(saveStorage);
        return this.generateStandaloneFooter(saveStorage);
      }
      generateTestHeader(options) {
        const formatter = new JavaScriptFormatter();
        const useText = formatContextOptions(options.contextOptions, options.deviceName);
        formatter.add(`
      import { test, expect${options.deviceName ? ", devices" : ""} } from '@playwright/test';
${useText ? "\ntest.use(" + useText + ");\n" : ""}
      test('test', async ({ page }) => {`);
        return formatter.format();
      }
      generateTestFooter(saveStorage) {
        return `});`;
      }
      generateStandaloneHeader(options) {
        const formatter = new JavaScriptFormatter();
        formatter.add(`
      const { ${options.browserName}${options.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options.browserName}.launch(${formatObjectOrVoid(options.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateStandaloneFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
  await context.storageState({ path: ${quote(saveStorage)} });` : "";
        return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
      }
    };
    exports2.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;
    function formatOptions(value, hasArguments) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + formatObject(value);
    }
    function formatObject(value, indent = "  ") {
      if (typeof value === "string")
        return quote(value);
      if (Array.isArray(value))
        return `[${value.map((o) => formatObject(o)).join(", ")}]`;
      if (typeof value === "object") {
        const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
        if (!keys.length)
          return "{}";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${key}: ${formatObject(value[key])}`);
        return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
      }
      return String(value);
    }
    function formatObjectOrVoid(value, indent = "  ") {
      const result = formatObject(value, indent);
      return result === "{}" ? "" : result;
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && deviceDescriptors[deviceName];
      if (!device)
        return formatObjectOrVoid(options);
      let serializedObject = formatObjectOrVoid((0, _language.sanitizeDeviceOptions)(device, options));
      if (!serializedObject)
        serializedObject = "{\n}";
      const lines = serializedObject.split("\n");
      lines.splice(1, 0, `...devices[${quote(deviceName)}],`);
      return lines.join("\n");
    }
    var JavaScriptFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(2);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]"))
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          const callCarryOver = line.startsWith(".set");
          line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
          if (line.endsWith("{") || line.endsWith("["))
            spaces += this._baseIndent;
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    exports2.JavaScriptFormatter = JavaScriptFormatter;
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, "'");
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/java.js
var require_java = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/java.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaLanguageGenerator = void 0;
    var _language = require_language();
    var _utils = require_utils2();
    var _javascript = require_javascript2();
    var _stringUtils = require_stringUtils();
    var _locatorGenerators = require_locatorGenerators();
    var deviceDescriptors = require_deviceDescriptorsSource();
    var JavaLanguageGenerator = class {
      constructor() {
        this.id = "java";
        this.groupName = "Java";
        this.name = "Library";
        this.highlighter = "java";
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new _javascript.JavaScriptFormatter(6);
        if (action.name === "openPage") {
          formatter.add(`Page ${pageAlias} = context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${pageAlias}.navigate(${quote(action.url)});`);
          return formatter.format();
        }
        let subject;
        let inFrameLocator = false;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => `.frameLocator(${quote(selector)})`);
          subject = `${pageAlias}${locators.join("")}`;
          inFrameLocator = true;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.frame(${quote(actionInContext.frame.name)})`;
        } else {
          subject = `${pageAlias}.frameByUrl(${quote(actionInContext.frame.url)})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
        }
        const actionCall = this._generateActionCall(action, inFrameLocator);
        let code = `${subject}.${actionCall};`;
        if (signals.popup) {
          code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
        }
        if (signals.download) {
          code = `Download download${signals.download.downloadAlias} = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
        }
        formatter.add(code);
        return formatter.format();
      }
      _generateActionCall(action, inFrameLocator) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsText = formatClickOptions(options);
            return this._asLocator(action.selector, inFrameLocator) + `.${method}(${optionsText})`;
          }
          case "check":
            return this._asLocator(action.selector, inFrameLocator) + `.check()`;
          case "uncheck":
            return this._asLocator(action.selector, inFrameLocator) + `.uncheck()`;
          case "fill":
            return this._asLocator(action.selector, inFrameLocator) + `.fill(${quote(action.text)})`;
          case "setInputFiles":
            return this._asLocator(action.selector, inFrameLocator) + `.setInputFiles(${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return this._asLocator(action.selector, inFrameLocator) + `.press(${quote(shortcut)})`;
          }
          case "navigate":
            return `navigate(${quote(action.url)})`;
          case "select":
            return this._asLocator(action.selector, inFrameLocator) + `.selectOption(${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      _asLocator(selector, inFrameLocator) {
        return (0, _locatorGenerators.asLocator)("java", selector, inFrameLocator);
      }
      generateHeader(options) {
        const formatter = new _javascript.JavaScriptFormatter();
        formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;
    import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options.browserName}().launch(${formatLaunchOptions(options.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));
` : "";
        return `${storageStateLine}    }
  }
}`;
      }
    };
    exports2.JavaLanguageGenerator = JavaLanguageGenerator;
    function formatPath(files) {
      if (Array.isArray(files)) {
        if (files.length === 0)
          return "new Path[0]";
        return `new Path[] {${files.map((s) => "Paths.get(" + quote(s) + ")").join(", ")}}`;
      }
      return `Paths.get(${quote(files)})`;
    }
    function formatSelectOption(options) {
      if (Array.isArray(options)) {
        if (options.length === 0)
          return "new String[0]";
        return `new String[] {${options.map((s) => quote(s)).join(", ")}}`;
      }
      return quote(options);
    }
    function formatLaunchOptions(options) {
      const lines = [];
      if (!Object.keys(options).filter((key) => options[key] !== void 0).length)
        return "";
      lines.push("new BrowserType.LaunchOptions()");
      if (options.channel)
        lines.push(`  .setChannel(${quote(options.channel)})`);
      if (typeof options.headless === "boolean")
        lines.push(`  .setHeadless(false)`);
      return lines.join("\n");
    }
    function formatContextOptions(contextOptions, deviceName) {
      var _options$recordHar, _options$recordHar2, _options$recordHar3, _options$recordHar4, _options$recordHar5, _options$recordHar6, _options$recordHar7;
      const lines = [];
      if (!Object.keys(contextOptions).length && !deviceName)
        return "";
      const device = deviceName ? deviceDescriptors[deviceName] : {};
      const options = __spreadValues(__spreadValues({}, device), contextOptions);
      lines.push("new Browser.NewContextOptions()");
      if (options.acceptDownloads)
        lines.push(`  .setAcceptDownloads(true)`);
      if (options.bypassCSP)
        lines.push(`  .setBypassCSP(true)`);
      if (options.colorScheme)
        lines.push(`  .setColorScheme(ColorScheme.${options.colorScheme.toUpperCase()})`);
      if (options.deviceScaleFactor)
        lines.push(`  .setDeviceScaleFactor(${options.deviceScaleFactor})`);
      if (options.geolocation)
        lines.push(`  .setGeolocation(${options.geolocation.latitude}, ${options.geolocation.longitude})`);
      if (options.hasTouch)
        lines.push(`  .setHasTouch(${options.hasTouch})`);
      if (options.isMobile)
        lines.push(`  .setIsMobile(${options.isMobile})`);
      if (options.locale)
        lines.push(`  .setLocale(${quote(options.locale)})`);
      if (options.proxy)
        lines.push(`  .setProxy(new Proxy(${quote(options.proxy.server)}))`);
      if ((_options$recordHar = options.recordHar) !== null && _options$recordHar !== void 0 && _options$recordHar.content)
        lines.push(`  .setRecordHarContent(HarContentPolicy.${(_options$recordHar2 = options.recordHar) === null || _options$recordHar2 === void 0 ? void 0 : _options$recordHar2.content.toUpperCase()})`);
      if ((_options$recordHar3 = options.recordHar) !== null && _options$recordHar3 !== void 0 && _options$recordHar3.mode)
        lines.push(`  .setRecordHarMode(HarMode.${(_options$recordHar4 = options.recordHar) === null || _options$recordHar4 === void 0 ? void 0 : _options$recordHar4.mode.toUpperCase()})`);
      if ((_options$recordHar5 = options.recordHar) !== null && _options$recordHar5 !== void 0 && _options$recordHar5.omitContent)
        lines.push(`  .setRecordHarOmitContent(true)`);
      if ((_options$recordHar6 = options.recordHar) !== null && _options$recordHar6 !== void 0 && _options$recordHar6.path)
        lines.push(`  .setRecordHarPath(Paths.get(${quote(options.recordHar.path)}))`);
      if ((_options$recordHar7 = options.recordHar) !== null && _options$recordHar7 !== void 0 && _options$recordHar7.urlFilter)
        lines.push(`  .setRecordHarUrlFilter(${quote(options.recordHar.urlFilter)})`);
      if (options.serviceWorkers)
        lines.push(`  .setServiceWorkers(ServiceWorkerPolicy.${options.serviceWorkers.toUpperCase()})`);
      if (options.storageState)
        lines.push(`  .setStorageStatePath(Paths.get(${quote(options.storageState)}))`);
      if (options.timezoneId)
        lines.push(`  .setTimezoneId(${quote(options.timezoneId)})`);
      if (options.userAgent)
        lines.push(`  .setUserAgent(${quote(options.userAgent)})`);
      if (options.viewport)
        lines.push(`  .setViewportSize(${options.viewport.width}, ${options.viewport.height})`);
      return lines.join("\n");
    }
    function formatClickOptions(options) {
      const lines = [];
      if (options.button)
        lines.push(`  .setButton(MouseButton.${options.button.toUpperCase()})`);
      if (options.modifiers)
        lines.push(`  .setModifiers(Arrays.asList(${options.modifiers.map((m) => `KeyboardModifier.${m.toUpperCase()}`).join(", ")}))`);
      if (options.clickCount)
        lines.push(`  .setClickCount(${options.clickCount})`);
      if (options.position)
        lines.push(`  .setPosition(${options.position.x}, ${options.position.y})`);
      if (!lines.length)
        return "";
      lines.unshift(`new Locator.ClickOptions()`);
      return lines.join("\n");
    }
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/jsonl.js
var require_jsonl = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/jsonl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonlLanguageGenerator = void 0;
    var _locatorGenerators = require_locatorGenerators();
    var JsonlLanguageGenerator = class {
      constructor() {
        this.id = "jsonl";
        this.groupName = "";
        this.name = "JSONL";
        this.highlighter = "javascript";
      }
      generateAction(actionInContext) {
        const locator = actionInContext.action.selector ? JSON.parse((0, _locatorGenerators.asLocator)("jsonl", actionInContext.action.selector)) : void 0;
        const entry = __spreadProps(__spreadValues({}, actionInContext.action), {
          pageAlias: actionInContext.frame.pageAlias,
          locator
        });
        return JSON.stringify(entry);
      }
      generateHeader(options) {
        return JSON.stringify(options);
      }
      generateFooter(saveStorage) {
        return "";
      }
    };
    exports2.JsonlLanguageGenerator = JsonlLanguageGenerator;
  }
});

// node_modules/playwright-core/lib/server/recorder/csharp.js
var require_csharp = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/csharp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CSharpLanguageGenerator = void 0;
    var _language = require_language();
    var _utils = require_utils2();
    var _stringUtils = require_stringUtils();
    var _locatorGenerators = require_locatorGenerators();
    var deviceDescriptors = require_deviceDescriptorsSource();
    var CSharpLanguageGenerator = class {
      constructor(mode) {
        this.id = void 0;
        this.groupName = ".NET C#";
        this.name = void 0;
        this.highlighter = "csharp";
        this._mode = void 0;
        if (mode === "library") {
          this.name = "Library";
          this.id = "csharp";
        } else if (mode === "mstest") {
          this.name = "MSTest";
          this.id = "csharp-mstest";
        } else if (mode === "nunit") {
          this.name = "NUnit";
          this.id = "csharp-nunit";
        } else {
          throw new Error(`Unknown C# language mode: ${mode}`);
        }
        this._mode = mode;
      }
      generateAction(actionInContext) {
        const action = this._generateActionInner(actionInContext);
        if (action)
          return action + "\n";
        return "";
      }
      _generateActionInner(actionInContext) {
        const action = actionInContext.action;
        if (this._mode !== "library" && (action.name === "openPage" || action.name === "closePage"))
          return "";
        let pageAlias = actionInContext.frame.pageAlias;
        if (this._mode !== "library")
          pageAlias = pageAlias.replace("page", "Page");
        const formatter = new CSharpFormatter(8);
        if (action.name === "openPage") {
          formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => `.FrameLocator(${quote(selector)})`);
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.Frame(${quote(actionInContext.frame.name)})`;
        } else {
          subject = `${pageAlias}.FrameByUrl(${quote(actionInContext.frame.url)})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
        }
        const lines = [];
        const actionCall = this._generateActionCall(action, actionInContext.frame.isMainFrame);
        lines.push(`await ${subject}.${actionCall};`);
        if (signals.download) {
          lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>
{`);
          lines.push(`});`);
        }
        if (signals.popup) {
          lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>
{`);
          lines.push(`});`);
        }
        for (const line of lines)
          formatter.add(line);
        return formatter.format();
      }
      _generateActionCall(action, isPage) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "CloseAsync()";
          case "click": {
            let method = "Click";
            if (action.clickCount === 2)
              method = "DblClick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            if (!Object.entries(options).length)
              return this._asLocator(action.selector) + `.${method}Async()`;
            const optionsString = formatObject(options, "    ", "Locator" + method + "Options");
            return this._asLocator(action.selector) + `.${method}Async(${optionsString})`;
          }
          case "check":
            return this._asLocator(action.selector) + `.CheckAsync()`;
          case "uncheck":
            return this._asLocator(action.selector) + `.UncheckAsync()`;
          case "fill":
            return this._asLocator(action.selector) + `.FillAsync(${quote(action.text)})`;
          case "setInputFiles":
            return this._asLocator(action.selector) + `.SetInputFilesAsync(${formatObject(action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return this._asLocator(action.selector) + `.PressAsync(${quote(shortcut)})`;
          }
          case "navigate":
            return `GotoAsync(${quote(action.url)})`;
          case "select":
            return this._asLocator(action.selector) + `.SelectOptionAsync(${formatObject(action.options)})`;
        }
      }
      _asLocator(selector) {
        return (0, _locatorGenerators.asLocator)("csharp", selector);
      }
      generateHeader(options) {
        if (this._mode === "library")
          return this.generateStandaloneHeader(options);
        return this.generateTestRunnerHeader(options);
      }
      generateStandaloneHeader(options) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      class Program
      {
          public static async Task Main()
          {
              using var playwright = await Playwright.CreateAsync();
              await using var browser = await playwright.${toPascal(options.browserName)}.LaunchAsync(${formatObject(options.launchOptions, "    ", "BrowserTypeLaunchOptions")});
              var context = await browser.NewContextAsync(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        formatter.newLine();
        return formatter.format();
      }
      generateTestRunnerHeader(options) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      using Microsoft.Playwright.${this._mode === "nunit" ? "NUnit" : "MSTest"};
      using Microsoft.Playwright;

      ${this._mode === "nunit" ? `[Parallelizable(ParallelScope.Self)]
      [TestFixture]` : "[TestClass]"}
      public class Tests : PageTest
      {`);
        const formattedContextOptions = formatContextOptions(options.contextOptions, options.deviceName);
        if (formattedContextOptions) {
          formatter.add(`public override BrowserNewContextOptions ContextOptions()
      {
          return ${formattedContextOptions};
      }`);
          formatter.newLine();
        }
        formatter.add(`    [${this._mode === "nunit" ? "Test" : "TestMethod"}]
    public async Task MyTest()
    {`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
        await context.StorageStateAsync(new BrowserContextStorageStateOptions
        {
            Path = ${quote(saveStorage)}
        });
` : "";
        return `${storageStateLine}    }
}
`;
      }
    };
    exports2.CSharpLanguageGenerator = CSharpLanguageGenerator;
    function formatObject(value, indent = "    ", name = "") {
      if (typeof value === "string") {
        if (["permissions", "colorScheme", "modifiers", "button", "recordHarContent", "recordHarMode", "serviceWorkers"].includes(name))
          return `${getClassName(name)}.${toPascal(value)}`;
        return quote(value);
      }
      if (Array.isArray(value))
        return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
      if (typeof value === "object") {
        const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
        if (!keys.length)
          return name ? `new ${getClassName(name)}` : "";
        const tokens = [];
        for (const key of keys) {
          const property = getPropertyName(key);
          tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
        }
        if (name)
          return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
        return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
      }
      if (name === "latitude" || name === "longitude")
        return String(value) + "m";
      return String(value);
    }
    function getClassName(value) {
      switch (value) {
        case "viewport":
          return "ViewportSize";
        case "proxy":
          return "ProxySettings";
        case "permissions":
          return "ContextPermission";
        case "modifiers":
          return "KeyboardModifier";
        case "button":
          return "MouseButton";
        case "recordHarMode":
          return "HarMode";
        case "recordHarContent":
          return "HarContentPolicy";
        case "serviceWorkers":
          return "ServiceWorkerPolicy";
        default:
          return toPascal(value);
      }
    }
    function getPropertyName(key) {
      switch (key) {
        case "storageState":
          return "StorageStatePath";
        case "viewport":
          return "ViewportSize";
        default:
          return toPascal(key);
      }
    }
    function toPascal(value) {
      return value[0].toUpperCase() + value.slice(1);
    }
    function convertContextOptions(options) {
      const result = __spreadValues({}, options);
      if (options.recordHar) {
        result["recordHarPath"] = options.recordHar.path;
        result["recordHarContent"] = options.recordHar.content;
        result["recordHarMode"] = options.recordHar.mode;
        result["recordHarOmitContent"] = options.recordHar.omitContent;
        result["recordHarUrlFilter"] = options.recordHar.urlFilter;
        delete result.recordHar;
      }
      return result;
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && deviceDescriptors[deviceName];
      if (!device) {
        if (!Object.entries(options).length)
          return "";
        return formatObject(convertContextOptions(options), "    ", "BrowserNewContextOptions");
      }
      options = (0, _language.sanitizeDeviceOptions)(device, options);
      if (!Object.entries(options).length)
        return `playwright.Devices[${quote(deviceName)}]`;
      return formatObject(convertContextOptions(options), "    ", `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
    }
    var CSharpFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          line = spaces + extraSpaces + line;
          if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
            spaces += this._baseIndent;
          if (line.endsWith("));"))
            spaces = spaces.substring(this._baseIndent.length);
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/python.js
var require_python = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/python.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PythonLanguageGenerator = void 0;
    var _language = require_language();
    var _utils = require_utils2();
    var _stringUtils = require_stringUtils();
    var _locatorGenerators = require_locatorGenerators();
    var deviceDescriptors = require_deviceDescriptorsSource();
    var PythonLanguageGenerator = class {
      constructor(isAsync, isPyTest) {
        this.id = void 0;
        this.groupName = "Python";
        this.name = void 0;
        this.highlighter = "python";
        this._awaitPrefix = void 0;
        this._asyncPrefix = void 0;
        this._isAsync = void 0;
        this._isPyTest = void 0;
        this.id = isPyTest ? "python-pytest" : isAsync ? "python-async" : "python";
        this.name = isPyTest ? "Pytest" : isAsync ? "Library Async" : "Library";
        this._isAsync = isAsync;
        this._isPyTest = isPyTest;
        this._awaitPrefix = isAsync ? "await " : "";
        this._asyncPrefix = isAsync ? "async " : "";
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        if (this._isPyTest && (action.name === "openPage" || action.name === "closePage"))
          return "";
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new PythonFormatter(4);
        if (action.name === "openPage") {
          formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => `.frame_locator(${quote(selector)})`);
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.frame(${formatOptions({
            name: actionInContext.frame.name
          }, false)})`;
        } else {
          subject = `${pageAlias}.frame(${formatOptions({
            url: actionInContext.frame.url
          }, false)})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog)
          formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
        const actionCall = this._generateActionCall(action);
        let code = `${this._awaitPrefix}${subject}.${actionCall}`;
        if (signals.popup) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as ${signals.popup.popupAlias}_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}${signals.popup.popupAlias}_info.value`;
        }
        if (signals.download) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download${signals.download.downloadAlias}_info {
        ${code}
      }
      download${signals.download.downloadAlias} = ${this._awaitPrefix}download${signals.download.downloadAlias}_info.value`;
        }
        formatter.add(code);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsString = formatOptions(options, false);
            return this._asLocator(action.selector) + `.${method}(${optionsString})`;
          }
          case "check":
            return this._asLocator(action.selector) + `.check()`;
          case "uncheck":
            return this._asLocator(action.selector) + `.uncheck()`;
          case "fill":
            return this._asLocator(action.selector) + `.fill(${quote(action.text)})`;
          case "setInputFiles":
            return this._asLocator(action.selector) + `.set_input_files(${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return this._asLocator(action.selector) + `.press(${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return this._asLocator(action.selector) + `.select_option(${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
        }
      }
      _asLocator(selector) {
        return (0, _locatorGenerators.asLocator)("python", selector);
      }
      generateHeader(options) {
        const formatter = new PythonFormatter();
        if (this._isPyTest) {
          const contextOptions = formatContextOptions(options.contextOptions, options.deviceName, true);
          const fixture = contextOptions ? `

@pytest.fixture(scope="session")
def browser_context_args(browser_context_args, playwright) {
    return {${contextOptions}}
}
` : "";
          formatter.add(`${options.deviceName ? "import pytest\n" : ""}
from playwright.sync_api import Page, expect
${fixture}

def test_example(page: Page) -> None {`);
        } else if (this._isAsync) {
          formatter.add(`
import asyncio

from playwright.async_api import Playwright, async_playwright, expect


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        } else {
          formatter.add(`
from playwright.sync_api import Playwright, sync_playwright, expect


def run(playwright: Playwright) -> None {
    browser = playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        }
        return formatter.format();
      }
      generateFooter(saveStorage) {
        if (this._isPyTest) {
          return "";
        } else if (this._isAsync) {
          const storageStateLine = saveStorage ? `
    await context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
        } else {
          const storageStateLine = saveStorage ? `
    context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
        }
      }
    };
    exports2.PythonLanguageGenerator = PythonLanguageGenerator;
    function formatValue(value) {
      if (value === false)
        return "False";
      if (value === true)
        return "True";
      if (value === void 0)
        return "None";
      if (Array.isArray(value))
        return `[${value.map(formatValue).join(", ")}]`;
      if (typeof value === "string")
        return quote(value);
      if (typeof value === "object")
        return JSON.stringify(value);
      return String(value);
    }
    function formatOptions(value, hasArguments, asDict) {
      const keys = Object.keys(value).filter((key) => value[key] !== void 0).sort();
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + keys.map((key) => {
        if (asDict)
          return `"${(0, _stringUtils.toSnakeCase)(key)}": ${formatValue(value[key])}`;
        return `${(0, _stringUtils.toSnakeCase)(key)}=${formatValue(value[key])}`;
      }).join(", ");
    }
    function convertContextOptions(options) {
      const result = __spreadValues({}, options);
      if (options.recordHar) {
        result["record_har_path"] = options.recordHar.path;
        result["record_har_content"] = options.recordHar.content;
        result["record_har_mode"] = options.recordHar.mode;
        result["record_har_omit_content"] = options.recordHar.omitContent;
        result["record_har_url_filter"] = options.recordHar.urlFilter;
        delete result.recordHar;
      }
      return result;
    }
    function formatContextOptions(options, deviceName, asDict) {
      const device = deviceName && deviceDescriptors[deviceName];
      if (!device)
        return formatOptions(convertContextOptions(options), false, asDict);
      return `**playwright.devices[${quote(deviceName)}]` + formatOptions(convertContextOptions((0, _language.sanitizeDeviceOptions)(device, options)), true, asDict);
    }
    var PythonFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        const lines = [];
        this._lines.forEach((line) => {
          if (line === "")
            return lines.push(line);
          if (line === "}") {
            spaces = spaces.substring(this._baseIndent.length);
            return;
          }
          line = spaces + line;
          if (line.endsWith("{")) {
            spaces += this._baseIndent;
            line = line.substring(0, line.length - 1).trimEnd() + ":";
          }
          return lines.push(this._baseOffset + line);
        });
        return lines.join("\n");
      }
    };
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
  }
});

// node_modules/playwright-core/lib/generated/recorderSource.js
var require_recorderSource = __commonJS({
  "node_modules/playwright-core/lib/generated/recorderSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = '\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n// packages/playwright-core/src/server/injected/recorder.ts\nvar recorder_exports = {};\n__export(recorder_exports, {\n  PollingRecorder: () => PollingRecorder,\n  Recorder: () => Recorder,\n  default: () => recorder_default\n});\nmodule.exports = __toCommonJS(recorder_exports);\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "`") + char;\n  throw new Error("Invalid escape char");\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();\n}\nfunction cssEscape(s) {\n  let result = "";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\nfunction normalizeWhiteSpace(text) {\n  return text.replace(/\\u200b/g, "").trim().replace(/\\s+/g, " ");\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== "string")\n    return String(text).replace(/>>/g, "\\\\>\\\\>");\n  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== "string")\n    return String(value).replace(/>>/g, "\\\\>\\\\>");\n  return `"${value.replace(/\\\\/g, "\\\\\\\\").replace(/["]/g, \'\\\\"\')}"${exact ? "s" : "i"}`;\n}\n\n// packages/playwright-core/src/server/injected/domUtils.ts\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css, scope) {\n  while (element) {\n    const closest = element.closest(css);\n    if (scope && closest !== scope && (closest == null ? void 0 : closest.contains(scope)))\n      return;\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction getElementComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementStyleVisibilityVisible(element, style) {\n  style = style != null ? style : getElementComputedStyle(element);\n  if (!style)\n    return true;\n  if (Element.prototype.checkVisibility) {\n    if (!element.checkVisibility({ checkOpacity: false, checkVisibilityCSS: false }))\n      return false;\n  } else {\n    const detailsOrSummary = element.closest("details,summary");\n    if (detailsOrSummary !== element && (detailsOrSummary == null ? void 0 : detailsOrSummary.nodeName) === "DETAILS" && !detailsOrSummary.open)\n      return false;\n  }\n  if (style.visibility !== "visible")\n    return false;\n  return true;\n}\nfunction isVisibleTextNode(node) {\n  const range = node.ownerDocument.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\n\n// packages/playwright-core/src/server/injected/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n}\nvar kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\nvar kGlobalAriaAttributes = [\n  "aria-atomic",\n  "aria-busy",\n  "aria-controls",\n  "aria-current",\n  "aria-describedby",\n  "aria-details",\n  "aria-disabled",\n  "aria-dropeffect",\n  "aria-errormessage",\n  "aria-flowto",\n  "aria-grabbed",\n  "aria-haspopup",\n  "aria-hidden",\n  "aria-invalid",\n  "aria-keyshortcuts",\n  "aria-label",\n  "aria-labelledby",\n  "aria-live",\n  "aria-owns",\n  "aria-relevant",\n  "aria-roledescription"\n];\nfunction hasGlobalAriaAttribute(e) {\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\n}\nvar kImplicitRoleByTagName = {\n  "A": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "AREA": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "ARTICLE": () => "article",\n  "ASIDE": () => "complementary",\n  "BLOCKQUOTE": () => "blockquote",\n  "BUTTON": () => "button",\n  "CAPTION": () => "caption",\n  "CODE": () => "code",\n  "DATALIST": () => "listbox",\n  "DD": () => "definition",\n  "DEL": () => "deletion",\n  "DETAILS": () => "group",\n  "DFN": () => "term",\n  "DIALOG": () => "dialog",\n  "DT": () => "term",\n  "EM": () => "emphasis",\n  "FIELDSET": () => "group",\n  "FIGURE": () => "figure",\n  "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n  "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n  "H1": () => "heading",\n  "H2": () => "heading",\n  "H3": () => "heading",\n  "H4": () => "heading",\n  "H5": () => "heading",\n  "H6": () => "heading",\n  "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n  "HR": () => "separator",\n  "HTML": () => "document",\n  "IMG": (e) => e.getAttribute("alt") === "" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute("tabindex")))) ? "presentation" : "img",\n  "INPUT": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === "search")\n      return e.hasAttribute("list") ? "combobox" : "searchbox";\n    if (["email", "tel", "text", "url", ""].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute("list"))[0];\n      return list && list.tagName === "DATALIST" ? "combobox" : "textbox";\n    }\n    if (type === "hidden")\n      return "";\n    return {\n      "button": "button",\n      "checkbox": "checkbox",\n      "image": "button",\n      "number": "spinbutton",\n      "radio": "radio",\n      "range": "slider",\n      "reset": "button",\n      "submit": "button"\n    }[type] || "textbox";\n  },\n  "INS": () => "insertion",\n  "LI": () => "listitem",\n  "MAIN": () => "main",\n  "MARK": () => "mark",\n  "MATH": () => "math",\n  "MENU": () => "list",\n  "METER": () => "meter",\n  "NAV": () => "navigation",\n  "OL": () => "list",\n  "OPTGROUP": () => "group",\n  "OPTION": () => "option",\n  "OUTPUT": () => "status",\n  "P": () => "paragraph",\n  "PROGRESS": () => "progressbar",\n  "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n  "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n  "STRONG": () => "strong",\n  "SUB": () => "subscript",\n  "SUP": () => "superscript",\n  "SVG": () => "img",\n  "TABLE": () => "table",\n  "TBODY": () => "rowgroup",\n  "TD": (e) => {\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "TEXTAREA": () => "textbox",\n  "TFOOT": () => "rowgroup",\n  "TH": (e) => {\n    if (e.getAttribute("scope") === "col")\n      return "columnheader";\n    if (e.getAttribute("scope") === "row")\n      return "rowheader";\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "THEAD": () => "rowgroup",\n  "TIME": () => "time",\n  "TR": () => "row",\n  "UL": () => "list"\n};\nvar kPresentationInheritanceParents = {\n  "DD": ["DL", "DIV"],\n  "DIV": ["DL"],\n  "DT": ["DL", "DIV"],\n  "LI": ["OL", "UL"],\n  "TBODY": ["TABLE"],\n  "TD": ["TR"],\n  "TFOOT": ["TABLE"],\n  "TH": ["TR"],\n  "THEAD": ["TABLE"],\n  "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName.toUpperCase()]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\n    if (!parents || !parent || !parents.includes(parent.tagName))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar allRoles = [\n  "alert",\n  "alertdialog",\n  "application",\n  "article",\n  "banner",\n  "blockquote",\n  "button",\n  "caption",\n  "cell",\n  "checkbox",\n  "code",\n  "columnheader",\n  "combobox",\n  "command",\n  "complementary",\n  "composite",\n  "contentinfo",\n  "definition",\n  "deletion",\n  "dialog",\n  "directory",\n  "document",\n  "emphasis",\n  "feed",\n  "figure",\n  "form",\n  "generic",\n  "grid",\n  "gridcell",\n  "group",\n  "heading",\n  "img",\n  "input",\n  "insertion",\n  "landmark",\n  "link",\n  "list",\n  "listbox",\n  "listitem",\n  "log",\n  "main",\n  "marquee",\n  "math",\n  "meter",\n  "menu",\n  "menubar",\n  "menuitem",\n  "menuitemcheckbox",\n  "menuitemradio",\n  "navigation",\n  "none",\n  "note",\n  "option",\n  "paragraph",\n  "presentation",\n  "progressbar",\n  "radio",\n  "radiogroup",\n  "range",\n  "region",\n  "roletype",\n  "row",\n  "rowgroup",\n  "rowheader",\n  "scrollbar",\n  "search",\n  "searchbox",\n  "section",\n  "sectionhead",\n  "select",\n  "separator",\n  "slider",\n  "spinbutton",\n  "status",\n  "strong",\n  "structure",\n  "subscript",\n  "superscript",\n  "switch",\n  "tab",\n  "table",\n  "tablist",\n  "tabpanel",\n  "term",\n  "textbox",\n  "time",\n  "timer",\n  "toolbar",\n  "tooltip",\n  "tree",\n  "treegrid",\n  "treeitem",\n  "widget",\n  "window"\n];\nvar abstractRoles = ["command", "composite", "input", "landmark", "range", "roletype", "section", "sectionhead", "select", "structure", "widget", "window"];\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element) {\n  return !hasGlobalAriaAttribute(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if ((explicitRole === "none" || explicitRole === "presentation") && hasPresentationConflictResolution(element))\n    return getImplicitAriaRole(element);\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === "true";\n}\nfunction isElementHiddenForAria(element) {\n  if (["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(element.tagName))\n    return true;\n  const style = getElementComputedStyle(element);\n  const isSlot = element.nodeName === "SLOT";\n  if ((style == null ? void 0 : style.display) === "contents" && !isSlot) {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && !isElementHiddenForAria(child))\n        return false;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return false;\n    }\n    return true;\n  }\n  const isOptionInsideSelect = element.nodeName === "OPTION" && !!element.closest("select");\n  if (!isOptionInsideSelect && !isSlot && !isElementStyleVisibilityVisible(element, style))\n    return true;\n  return belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element);\n}\nfunction belongsToDisplayNoneOrAriaHiddenOrNonSlotted(element) {\n  let hidden = cacheIsHidden == null ? void 0 : cacheIsHidden.get(element);\n  if (hidden === void 0) {\n    hidden = false;\n    if (element.parentElement && element.parentElement.shadowRoot && !element.assignedSlot)\n      hidden = true;\n    if (!hidden) {\n      const style = getElementComputedStyle(element);\n      hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n    }\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = belongsToDisplayNoneOrAriaHiddenOrNonSlotted(parent);\n    }\n    cacheIsHidden == null ? void 0 : cacheIsHidden.set(element, hidden);\n  }\n  return hidden;\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(" ").filter((id) => !!id);\n    const set = /* @__PURE__ */ new Set();\n    for (const id of ids) {\n      const firstElement = root.querySelector("#" + CSS.escape(id));\n      if (firstElement)\n        set.add(firstElement);\n    }\n    return [...set];\n  } catch (e) {\n    return [];\n  }\n}\nfunction normalizeAccessbileName(s) {\n  return s.replace(/\\r\\n/g, "\\n").replace(/\\u00A0/g, " ").replace(/\\s\\s+/g, " ").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getPseudoContent(pseudoStyle) {\n  if (!pseudoStyle)\n    return "";\n  const content = pseudoStyle.content;\n  if (content[0] === "\'" && content[content.length - 1] === "\'" || content[0] === \'"\' && content[content.length - 1] === \'"\') {\n    const unquoted = content.substring(1, content.length - 1);\n    const display = pseudoStyle.display || "inline";\n    if (display !== "inline")\n      return " " + unquoted + " ";\n    return unquoted;\n  }\n  return "";\n}\nfunction getAriaLabelledByElements(element) {\n  const ref = element.getAttribute("aria-labelledby");\n  if (ref === null)\n    return null;\n  return getIdRefs(element, ref);\n}\nfunction allowsNameFromContent(role, targetDescendant) {\n  const alwaysAllowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n  const descendantAllowsNameFromContent = targetDescendant && ["", "caption", "code", "contentinfo", "definition", "deletion", "emphasis", "insertion", "list", "listitem", "mark", "none", "paragraph", "presentation", "region", "row", "rowgroup", "section", "strong", "subscript", "superscript", "table", "term", "time"].includes(role);\n  return alwaysAllowsNameFromContent || descendantAllowsNameFromContent;\n}\nfunction getElementAccessibleName(element, includeHidden) {\n  const cache = includeHidden ? cacheAccessibleNameHidden : cacheAccessibleName;\n  let accessibleName = cache == null ? void 0 : cache.get(element);\n  if (accessibleName === void 0) {\n    accessibleName = "";\n    const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n    if (!elementProhibitsNaming) {\n      accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\n        includeHidden,\n        visitedElements: /* @__PURE__ */ new Set(),\n        embeddedInLabelledBy: "none",\n        embeddedInLabel: "none",\n        embeddedInTextAlternativeElement: false,\n        embeddedInTargetElement: "self"\n      }));\n    }\n    cache == null ? void 0 : cache.set(element, accessibleName);\n  }\n  return accessibleName;\n}\nfunction getElementAccessibleNameInternal(element, options) {\n  if (options.visitedElements.has(element))\n    return "";\n  const childOptions = {\n    ...options,\n    embeddedInLabel: options.embeddedInLabel === "self" ? "descendant" : options.embeddedInLabel,\n    embeddedInLabelledBy: options.embeddedInLabelledBy === "self" ? "descendant" : options.embeddedInLabelledBy,\n    embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden && options.embeddedInLabelledBy !== "self" && isElementHiddenForAria(element)) {\n    options.visitedElements.add(element);\n    return "";\n  }\n  const labelledBy = getAriaLabelledByElements(element);\n  if (options.embeddedInLabelledBy === "none") {\n    const accessibleName = (labelledBy || []).map((ref) => getElementAccessibleNameInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: "self",\n      embeddedInTargetElement: "none",\n      embeddedInLabel: "none",\n      embeddedInTextAlternativeElement: false\n    })).join(" ");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || "";\n  if (options.embeddedInLabel !== "none" || options.embeddedInLabelledBy !== "none") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = (labelledBy || []).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === "textbox") {\n        options.visitedElements.add(element);\n        if (element.tagName === "INPUT" || element.tagName === "TEXTAREA")\n          return element.value;\n        return element.textContent || "";\n      }\n      if (["combobox", "listbox"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (element.tagName === "SELECT") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter((e) => getAriaRole(e) === "option") : [];\n        }\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(" ");\n      }\n      if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute("aria-valuetext"))\n          return element.getAttribute("aria-valuetext") || "";\n        if (element.hasAttribute("aria-valuenow"))\n          return element.getAttribute("aria-valuenow") || "";\n        return element.getAttribute("value") || "";\n      }\n      if (["menu"].includes(role)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute("aria-label") || "";\n  if (ariaLabel.trim()) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (!["presentation", "none"].includes(role)) {\n    if (element.tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || "";\n      if (value.trim())\n        return value;\n      if (element.type === "submit")\n        return "Submit";\n      if (element.type === "reset")\n        return "Reset";\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "INPUT" && element.type === "image") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length && options.embeddedInLabelledBy === "none") {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      if (title.trim())\n        return title;\n      return "Submit";\n    }\n    if (!labelledBy && element.tagName === "BUTTON") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n    }\n    if (!labelledBy && (element.tagName === "TEXTAREA" || element.tagName === "SELECT" || element.tagName === "INPUT")) {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n      const usePlaceholder = element.tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || element.tagName === "TEXTAREA";\n      const placeholder = element.getAttribute("placeholder") || "";\n      const title = element.getAttribute("title") || "";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (!labelledBy && element.tagName === "FIELDSET") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "LEGEND") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (!labelledBy && element.tagName === "FIGURE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "FIGCAPTION") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "IMG") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "TABLE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "CAPTION") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const summary = element.getAttribute("summary") || "";\n      if (summary)\n        return summary;\n    }\n    if (element.tagName === "AREA") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName.toUpperCase() === "SVG" || element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName.toUpperCase() === "TITLE" && child.ownerSVGElement) {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInLabelledBy: "self"\n          });\n        }\n      }\n    }\n    if (element.ownerSVGElement && element.tagName.toUpperCase() === "A") {\n      const title = element.getAttribute("xlink:title") || "";\n      if (title.trim()) {\n        options.visitedElements.add(element);\n        return title;\n      }\n    }\n  }\n  if (allowsNameFromContent(role, options.embeddedInTargetElement === "descendant") || options.embeddedInLabelledBy !== "none" || options.embeddedInLabel !== "none" || options.embeddedInTextAlternativeElement) {\n    options.visitedElements.add(element);\n    const tokens = [];\n    const visit = (node, skipSlotted) => {\n      var _a;\n      if (skipSlotted && node.assignedSlot)\n        return;\n      if (node.nodeType === 1) {\n        const display = ((_a = getElementComputedStyle(node)) == null ? void 0 : _a.display) || "inline";\n        let token = getElementAccessibleNameInternal(node, childOptions);\n        if (display !== "inline" || node.nodeName === "BR")\n          token = " " + token + " ";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || "");\n      }\n    };\n    tokens.push(getPseudoContent(getElementComputedStyle(element, "::before")));\n    const assignedNodes = element.nodeName === "SLOT" ? element.assignedNodes() : [];\n    if (assignedNodes.length) {\n      for (const child of assignedNodes)\n        visit(child, false);\n    } else {\n      for (let child = element.firstChild; child; child = child.nextSibling)\n        visit(child, true);\n      if (element.shadowRoot) {\n        for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n          visit(child, true);\n      }\n      for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n        visit(owned, true);\n    }\n    tokens.push(getPseudoContent(getElementComputedStyle(element, "::after")));\n    const accessibleName = tokens.join("");\n    if (accessibleName.trim())\n      return accessibleName;\n  }\n  if (!["presentation", "none"].includes(role) || element.tagName === "IFRAME") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute("title") || "";\n    if (title.trim())\n      return title;\n  }\n  options.visitedElements.add(element);\n  return "";\n}\nvar cacheAccessibleName;\nvar cacheAccessibleNameHidden;\nvar cacheIsHidden;\nvar cachesCounter = 0;\nfunction beginAriaCaches() {\n  ++cachesCounter;\n  cacheAccessibleName != null ? cacheAccessibleName : cacheAccessibleName = /* @__PURE__ */ new Map();\n  cacheAccessibleNameHidden != null ? cacheAccessibleNameHidden : cacheAccessibleNameHidden = /* @__PURE__ */ new Map();\n  cacheIsHidden != null ? cacheIsHidden : cacheIsHidden = /* @__PURE__ */ new Map();\n}\nfunction endAriaCaches() {\n  if (!--cachesCounter) {\n    cacheAccessibleName = void 0;\n    cacheAccessibleNameHidden = void 0;\n    cacheIsHidden = void 0;\n  }\n}\n\n// packages/playwright-core/src/server/injected/selectorUtils.ts\nfunction shouldSkipForTextMatching(element) {\n  const document = element.ownerDocument;\n  return element.nodeName === "SCRIPT" || element.nodeName === "NOSCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction getElementLabels(textCache, element) {\n  const labels = getAriaLabelledByElements(element);\n  if (labels)\n    return labels.map((label) => elementText(textCache, label));\n  const ariaLabel = element.getAttribute("aria-label");\n  if (ariaLabel !== null && !!ariaLabel.trim())\n    return [{ full: ariaLabel, immediate: [ariaLabel] }];\n  const isNonHiddenInput = element.nodeName === "INPUT" && element.type !== "hidden";\n  if (["BUTTON", "METER", "OUTPUT", "PROGRESS", "SELECT", "TEXTAREA"].includes(element.nodeName) || isNonHiddenInput) {\n    const labels2 = element.labels;\n    if (labels2)\n      return [...labels2].map((label) => elementText(textCache, label));\n  }\n  return [];\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kTextScoreRange = 10;\nvar kExactPenalty = kTextScoreRange / 2;\nvar kTestIdScore = 1;\nvar kOtherTestIdScore = 2;\nvar kIframeByAttributeScore = 10;\nvar kBeginPenalizedScore = 50;\nvar kPlaceholderScore = 100;\nvar kLabelScore = 120;\nvar kRoleWithNameScore = 140;\nvar kAltTextScore = 160;\nvar kTextScore = 180;\nvar kTitleScore = 200;\nvar kTextScoreRegex = 250;\nvar kPlaceholderScoreExact = kPlaceholderScore + kExactPenalty;\nvar kLabelScoreExact = kLabelScore + kExactPenalty;\nvar kRoleWithNameScoreExact = kRoleWithNameScore + kExactPenalty;\nvar kAltTextScoreExact = kAltTextScore + kExactPenalty;\nvar kTextScoreExact = kTextScore + kExactPenalty;\nvar kTitleScoreExact = kTitleScore + kExactPenalty;\nvar kEndPenalizedScore = 300;\nvar kCSSIdScore = 500;\nvar kRoleWithoutNameScore = 510;\nvar kCSSInputTypeNameScore = 520;\nvar kCSSTagNameScore = 530;\nvar kNthScore = 1e4;\nvar kCSSFallbackScore = 1e7;\nfunction generateSelector(injectedScript, targetElement, options) {\n  var _a;\n  injectedScript._evaluator.begin();\n  beginAriaCaches();\n  try {\n    targetElement = closestCrossShadow(targetElement, "button,select,input,[role=button],[role=checkbox],[role=radio],a,[role=link]", options.root) || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, options);\n    const selector = joinTokens(targetTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, (_a = options.root) != null ? _a : targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    endAriaCaches();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(injectedScript, targetElement, options) {\n  if (options.root && !isInsideScope(options.root, targetElement))\n    throw new Error(`Target element must belong to the root\'s subtree`);\n  if (targetElement === options.root)\n    return [{ engine: "css", selector: ":scope", score: 1 }];\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    var _a;\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildNoTextCandidates(injectedScript, element, options).filter((token) => !options.omitInternalEngines || !token.engine.startsWith("internal:")).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, (_a = options.root) != null ? _a : targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent && parent !== options.root; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true) || cssFallback(injectedScript, targetElement, options);\n}\nfunction buildNoTextCandidates(injectedScript, element, options) {\n  const candidates = [];\n  {\n    for (const attr of ["data-testid", "data-test-id", "data-test"]) {\n      if (attr !== options.testIdAttributeName && element.getAttribute(attr))\n        candidates.push({ engine: "css", selector: `[${attr}=${quoteAttributeValue(element.getAttribute(attr))}]`, score: kOtherTestIdScore });\n    }\n    const idAttr = element.getAttribute("id");\n    if (idAttr && !isGuidLike(idAttr))\n      candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: kCSSIdScore });\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSTagNameScore });\n  }\n  if (element.nodeName === "IFRAME") {\n    for (const attribute of ["name", "title"]) {\n      if (element.getAttribute(attribute))\n        candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: kIframeByAttributeScore });\n    }\n    if (element.getAttribute(options.testIdAttributeName))\n      candidates.push({ engine: "css", selector: `[${options.testIdAttributeName}=${quoteAttributeValue(element.getAttribute(options.testIdAttributeName))}]`, score: kTestIdScore });\n    penalizeScoreForLength([candidates]);\n    return candidates;\n  }\n  if (element.getAttribute(options.testIdAttributeName))\n    candidates.push({ engine: "internal:testid", selector: `[${options.testIdAttributeName}=${escapeForAttributeSelector(element.getAttribute(options.testIdAttributeName), true)}]`, score: kTestIdScore });\n  if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {\n    const input = element;\n    if (input.placeholder) {\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, false)}]`, score: kPlaceholderScore });\n      candidates.push({ engine: "internal:attr", selector: `[placeholder=${escapeForAttributeSelector(input.placeholder, true)}]`, score: kPlaceholderScoreExact });\n    }\n  }\n  const labels = getElementLabels(injectedScript._evaluator._cacheText, element);\n  for (const label of labels) {\n    const labelText = label.full.trim();\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, false), score: kLabelScore });\n    candidates.push({ engine: "internal:label", selector: escapeForTextSelector(labelText, true), score: kLabelScoreExact });\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole))\n    candidates.push({ engine: "internal:role", selector: ariaRole, score: kRoleWithoutNameScore });\n  if (element.getAttribute("alt") && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName)) {\n    candidates.push({ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(element.getAttribute("alt"), false)}]`, score: kAltTextScore });\n    candidates.push({ engine: "internal:attr", selector: `[alt=${escapeForAttributeSelector(element.getAttribute("alt"), true)}]`, score: kAltTextScoreExact });\n  }\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "FRAME", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute("name"))}]`, score: kCSSInputTypeNameScore });\n  if (element.getAttribute("title")) {\n    candidates.push({ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(element.getAttribute("title"), false)}]`, score: kTitleScore });\n    candidates.push({ engine: "internal:attr", selector: `[title=${escapeForAttributeSelector(element.getAttribute("title"), true)}]`, score: kTitleScoreExact });\n  }\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute("type"))}]`, score: kCSSInputTypeNameScore });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.getAttribute("type") !== "hidden")\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: kCSSInputTypeNameScore + 1 });\n  penalizeScoreForLength([candidates]);\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, isTargetNode) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const candidates = [];\n  const fullText = normalizeWhiteSpace(elementText(injectedScript._evaluator._cacheText, element).full);\n  const text = fullText.substring(0, 80);\n  if (text) {\n    const escaped = escapeForTextSelector(text, false);\n    if (isTargetNode) {\n      candidates.push([{ engine: "internal:text", selector: escaped, score: kTextScore }]);\n      candidates.push([{ engine: "internal:text", selector: escapeForTextSelector(text, true), score: kTextScoreExact }]);\n    }\n    const cssToken = { engine: "css", selector: element.nodeName.toLowerCase(), score: kCSSTagNameScore };\n    candidates.push([cssToken, { engine: "internal:has-text", selector: escaped, score: kTextScore }]);\n    if (fullText.length <= 80)\n      candidates.push([cssToken, { engine: "internal:has-text", selector: "/^" + escapeRegExp(fullText) + "$/", score: kTextScoreRegex }]);\n  }\n  const ariaRole = getAriaRole(element);\n  if (ariaRole && !["none", "presentation"].includes(ariaRole)) {\n    const ariaName = getElementAccessibleName(element, false);\n    if (ariaName) {\n      candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, false)}]`, score: kRoleWithNameScore }]);\n      candidates.push([{ engine: "internal:role", selector: `${ariaRole}[name=${escapeForAttributeSelector(ariaName, true)}]`, score: kRoleWithNameScoreExact }]);\n    }\n  }\n  penalizeScoreForLength(candidates);\n  return candidates;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id="${cssEscape(id)}"]`;\n}\nfunction cssFallback(injectedScript, targetElement, options) {\n  var _a;\n  const root = (_a = options.root) != null ? _a : targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" > ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, root, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kCSSFallbackScore };\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, root);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = "";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + cssEscape(classes.slice(0, i + 1).join("."));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction quoteAttributeValue(text) {\n  return `"${cssEscape(text).replace(/\\\\ /g, " ")}"`;\n}\nfunction penalizeScoreForLength(groups) {\n  for (const group of groups) {\n    for (const token of group) {\n      if (token.score > kBeginPenalizedScore && token.score < kEndPenalizedScore)\n        token.score += Math.min(kTextScoreRange, token.selector.length / 10 | 0);\n    }\n  }\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    if (result[0] === targetElement && result.length === 1) {\n      return tokens;\n    }\n    const index = result.indexOf(targetElement);\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "InvalidCharacterError";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw "Spec Error: no more than three codepoints of lookahead.";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken("");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = "id";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === "url" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = "";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken("");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(""), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = "";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error("Internal parse error");\n  };\n  const consumeANumber = function() {\n    let repr = "";\n    let type = "integer";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error("I\'m infinite-looping!");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = "";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return "" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADSTRING";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADURL";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "WHITESPACE";\n  }\n  toString() {\n    return "WS";\n  }\n  toSource() {\n    return " ";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDO";\n  }\n  toSource() {\n    return "<!--";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDC";\n  }\n  toSource() {\n    return "-->";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ":";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ";";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ",";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n    this.mirror = "";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "{";\n    this.value = "{";\n    this.mirror = "}";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "}";\n    this.value = "}";\n    this.mirror = "{";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "[";\n    this.value = "[";\n    this.mirror = "]";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "]";\n    this.value = "]";\n    this.mirror = "[";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "(";\n    this.value = "(";\n    this.mirror = ")";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ")";\n    this.value = ")";\n    this.mirror = "(";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "~=";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "|=";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "^=";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "$=";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "*=";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "||";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "EOF";\n  }\n  toSource() {\n    return "";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = "DELIM";\n    this.value = "";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return "DELIM(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === "\\\\")\n      return "\\\\\\n";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "IDENT";\n    this.value = val;\n  }\n  toString() {\n    return "IDENT(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "FUNCTION";\n    this.value = val;\n    this.mirror = ")";\n  }\n  toString() {\n    return "FUNCTION(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value) + "(";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "AT-KEYWORD";\n    this.value = val;\n  }\n  toString() {\n    return "AT(" + this.value + ")";\n  }\n  toSource() {\n    return "@" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "HASH";\n    this.value = val;\n    this.type = "unrestricted";\n  }\n  toString() {\n    return "HASH(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === "id")\n      return "#" + escapeIdent(this.value);\n    else\n      return "#" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "STRING";\n    this.value = val;\n  }\n  toString() {\n    return \'"\' + escapeString(this.value) + \'"\';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "URL";\n    this.value = val;\n  }\n  toString() {\n    return "URL(" + this.value + ")";\n  }\n  toSource() {\n    return \'url("\' + escapeString(this.value) + \'")\';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "NUMBER";\n    this.type = "integer";\n    this.repr = "";\n  }\n  toString() {\n    if (this.type === "integer")\n      return "INT(" + this.value + ")";\n    return "NUMBER(" + this.value + ")";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "PERCENTAGE";\n    this.repr = "";\n  }\n  toString() {\n    return "PERCENTAGE(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + "%";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "DIMENSION";\n    this.type = "integer";\n    this.repr = "";\n    this.unit = "";\n  }\n  toString() {\n    return "DIM(" + this.value + "," + this.unit + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = "\\\\65 " + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = "" + string;\n  let result = "";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + code.toString(16) + " ";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code === 34 || code === 92)\n      result += "\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector "${selector}"`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    while (!isCloseParen() && !isEOF())\n      s += tokens[pos++].toSource();\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "left-of", "right-of", "above", "below", "near"]);\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);\nvar customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse("[" + part.body + "]");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === "css" ? "" : p.name + "=";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expressiion");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false, playSafe = false) {\n  return asLocators(lang, selector, isFrameLocator, playSafe)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, playSafe = false, maxOutputSize = 20) {\n  if (playSafe) {\n    try {\n      return innerAsLocators(generators[lang], parseSelector(selector), isFrameLocator, maxOutputSize);\n    } catch (e) {\n      return [selector];\n    }\n  } else {\n    return innerAsLocators(generators[lang], parseSelector(selector), isFrameLocator, maxOutputSize);\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  for (let index = 0; index < parts.length - 1; index++) {\n    if (parts[index].name === "nth" && parts[index + 1].name === "internal:control" && parts[index + 1].body === "enter-frame") {\n      const [nth] = parts.splice(index, 1);\n      parts.splice(index + 1, 0, nth);\n    }\n  }\n  const tokens = [];\n  let nextBase = isFrameLocator ? "frame-locator" : "page";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = "locator";\n    if (part.name === "nth") {\n      if (part.body === "0")\n        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);\n      else if (part.body === "-1")\n        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);\n      else\n        tokens.push([factory.generateLocator(base, "nth", part.body)]);\n      continue;\n    }\n    if (part.name === "internal:text") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "text", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:has-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has-not-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));\n      continue;\n    }\n    if (part.name === "internal:has-not") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));\n      continue;\n    }\n    if (part.name === "internal:and") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));\n      continue;\n    }\n    if (part.name === "internal:or") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));\n      continue;\n    }\n    if (part.name === "internal:label") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "label", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:role") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === "name") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === "level" && typeof attr.value === "string")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === "internal:testid") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, "test-id", value)]);\n      continue;\n    }\n    if (part.name === "internal:attr") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === "placeholder") {\n        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);\n        continue;\n      }\n      if (name === "alt") {\n        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);\n        continue;\n      }\n      if (name === "title") {\n        tokens.push([factory.generateLocator(base, "title", text, { exact })]);\n        continue;\n      }\n    }\n    let locatorType = "default";\n    const nextPart = parts[index + 1];\n    if (nextPart && nextPart.name === "internal:control" && nextPart.body === "enter-frame") {\n      locatorType = "frame";\n      nextBase = "frame-locator";\n      index++;\n    }\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, locatorType, selectorPart);\n    if (locatorType === "default" && nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });\n        const options = {};\n        if (nextPart.name === "internal:has-text")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, "default", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    tokens.push([locatorPart]);\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => "");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return currentTokens.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith(\'"\')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith(\'"s\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith(\'"i\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frameLocator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${options.name}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case "has":\n        return `filter({ has: ${body} })`;\n      case "hasNot":\n        return `filter({ hasNot: ${body} })`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${body})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return String(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return String(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, "\'");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frame_locator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first`;\n      case "last":\n        return `last`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === "string" ? this.quote(value) : value;\n          if (typeof value === "boolean")\n            valueString = value ? "True" : "False";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case "has-not-text":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case "has":\n        return `filter(has=${body})`;\n      case "hasNot":\n        return `filter(has_not=${body})`;\n      case "and":\n        return `and_(${body})`;\n      case "or":\n        return `or_(${body})`;\n      case "test-id":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("get_by_text", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("get_by_alt_text", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("get_by_placeholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("get_by_label", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("get_by_title", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";\n    return `re.compile(r"${body.source.replace(/\\\\\\//, "/").replace(/"/g, \'\\\\"\')}"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case "page":\n        clazz = "Page";\n        break;\n      case "frame-locator":\n        clazz = "FrameLocator";\n        break;\n      case "locator":\n        clazz = "Locator";\n        break;\n    }\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frameLocator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case "has-text":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case "has-not-text":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case "has":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case "hasNot":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact(clazz, "getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case "frame":\n        return `FrameLocator(${this.quote(body)})`;\n      case "nth":\n        return `Nth(${body})`;\n      case "first":\n        return `First`;\n      case "last":\n        return `Last`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case "has-text":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case "has":\n        return `Filter(new() { Has = ${body} })`;\n      case "hasNot":\n        return `Filter(new() { HasNot = ${body} })`;\n      case "and":\n        return `And(${body})`;\n      case "or":\n        return `Or(${body})`;\n      case "test-id":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("GetByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("GetByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("GetByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("GetByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";\n    return `new Regex(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: new JavaScriptLocatorFactory(),\n  python: new PythonLocatorFactory(),\n  java: new JavaLocatorFactory(),\n  csharp: new CSharpLocatorFactory(),\n  jsonl: new JsonlLocatorFactory()\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/playwright-core/src/server/injected/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._highlightEntries = [];\n    this._language = "javascript";\n    this._injectedScript = injectedScript;\n    const document = injectedScript.document;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement("x-pw-glass");\n    this._glassPaneElement.style.position = "fixed";\n    this._glassPaneElement.style.top = "0";\n    this._glassPaneElement.style.right = "0";\n    this._glassPaneElement.style.bottom = "0";\n    this._glassPaneElement.style.left = "0";\n    this._glassPaneElement.style.zIndex = "2147483647";\n    this._glassPaneElement.style.pointerEvents = "none";\n    this._glassPaneElement.style.display = "flex";\n    this._glassPaneElement.style.backgroundColor = "transparent";\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: this._isUnderTest ? "open" : "closed" });\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n    const styleElement = document.createElement("style");\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\n                      \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n    this._glassPaneShadow.appendChild(styleElement);\n  }\n  install() {\n    this._injectedScript.document.documentElement.appendChild(this._glassPaneElement);\n  }\n  setLanguage(language) {\n    this._language = language;\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this.updateHighlight(this._injectedScript.querySelectorAll(selector, this._injectedScript.document.documentElement), stringifySelector(selector), false);\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  isInstalled() {\n    return this._glassPaneElement.parentElement === this._injectedScript.document.documentElement && !this._glassPaneElement.nextElementSibling;\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n    if (this._isUnderTest)\n      console.error("Action point for test: " + JSON.stringify({ x, y }));\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._highlightEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._highlightEntries = [];\n  }\n  updateHighlight(elements, selector, isRecording) {\n    let color;\n    if (isRecording)\n      color = "#dc6f6f7f";\n    else\n      color = elements.length > 1 ? "#f6b26b7f" : "#6fa8dc7f";\n    this._innerUpdateHighlight(elements, { color, tooltipText: selector ? asLocator(this._language, selector) : "" });\n  }\n  maskElements(elements, color) {\n    this._innerUpdateHighlight(elements, { color: color ? color : "#F0F" });\n  }\n  _innerUpdateHighlight(elements, options) {\n    if (this._highlightIsUpToDate(elements, options.tooltipText))\n      return;\n    this.clearHighlight();\n    for (let i = 0; i < elements.length; ++i) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (options.tooltipText) {\n        tooltipElement = this._injectedScript.document.createElement("x-pw-tooltip");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        const suffix = elements.length > 1 ? ` [${i + 1} of ${elements.length}]` : "";\n        tooltipElement.textContent = options.tooltipText + suffix;\n        tooltipElement.style.top = "0";\n        tooltipElement.style.left = "0";\n        tooltipElement.style.display = "flex";\n      }\n      this._highlightEntries.push({ targetElement: elements[i], tooltipElement, highlightElement, tooltipText: options.tooltipText });\n    }\n    for (const entry of this._highlightEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const tooltipWidth = entry.tooltipElement.offsetWidth;\n      const tooltipHeight = entry.tooltipElement.offsetHeight;\n      const totalWidth = this._glassPaneElement.offsetWidth;\n      const totalHeight = this._glassPaneElement.offsetHeight;\n      let anchorLeft = entry.box.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\n        anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = entry.box.bottom + 5;\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        if (entry.box.top > tooltipHeight + 5) {\n          anchorTop = entry.box.top - tooltipHeight - 5;\n        } else {\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._highlightEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + "px";\n        entry.tooltipElement.style.left = entry.tooltipLeft + "px";\n      }\n      const box = entry.box;\n      entry.highlightElement.style.backgroundColor = options.color;\n      entry.highlightElement.style.left = box.x + "px";\n      entry.highlightElement.style.top = box.y + "px";\n      entry.highlightElement.style.width = box.width + "px";\n      entry.highlightElement.style.height = box.height + "px";\n      entry.highlightElement.style.display = "block";\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n  }\n  _highlightIsUpToDate(elements, tooltipText) {\n    if (elements.length !== this._highlightEntries.length)\n      return false;\n    for (let i = 0; i < this._highlightEntries.length; ++i) {\n      if (tooltipText !== this._highlightEntries[i].tooltipText)\n        return false;\n      if (elements[i] !== this._highlightEntries[i].targetElement)\n        return false;\n      const oldBox = this._highlightEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box = elements[i].getBoundingClientRect();\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    const highlightElement = this._injectedScript.document.createElement("x-pw-highlight");\n    highlightElement.style.position = "absolute";\n    highlightElement.style.top = "0";\n    highlightElement.style.left = "0";\n    highlightElement.style.width = "0";\n    highlightElement.style.height = "0";\n    highlightElement.style.boxSizing = "border-box";\n    return highlightElement;\n  }\n};\n\n// packages/playwright-core/src/server/injected/recorder.ts\nvar Recorder = class {\n  constructor(injectedScript, delegate) {\n    this._performingAction = false;\n    this._listeners = [];\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n    this._mode = "none";\n    this._testIdAttributeName = "data-testid";\n    this.document = injectedScript.document;\n    this._injectedScript = injectedScript;\n    this._delegate = delegate;\n    this._highlight = new Highlight(injectedScript);\n    this.refreshListenersIfNeeded();\n    if (injectedScript.isUnderTest)\n      console.error("Recorder script ready for test");\n  }\n  refreshListenersIfNeeded() {\n    if (this._highlight.isInstalled())\n      return;\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(this.document, "click", (event) => this._onClick(event), true),\n      addEventListener(this.document, "auxclick", (event) => this._onClick(event), true),\n      addEventListener(this.document, "input", (event) => this._onInput(event), true),\n      addEventListener(this.document, "keydown", (event) => this._onKeyDown(event), true),\n      addEventListener(this.document, "keyup", (event) => this._onKeyUp(event), true),\n      addEventListener(this.document, "mousedown", (event) => this._onMouseDown(event), true),\n      addEventListener(this.document, "mouseup", (event) => this._onMouseUp(event), true),\n      addEventListener(this.document, "mousemove", (event) => this._onMouseMove(event), true),\n      addEventListener(this.document, "mouseleave", (event) => this._onMouseLeave(event), true),\n      addEventListener(this.document, "focus", (event) => event.isTrusted && this._onFocus(true), true),\n      addEventListener(this.document, "scroll", (event) => {\n        if (!event.isTrusted)\n          return;\n        this._hoveredModel = null;\n        this._highlight.hideActionPoint();\n        this._updateHighlight();\n      }, true)\n    ];\n    this._highlight.install();\n  }\n  setUIState(state) {\n    var _a;\n    const { mode, actionPoint, actionSelector, language, testIdAttributeName } = state;\n    this._testIdAttributeName = testIdAttributeName;\n    this._highlight.setLanguage(language);\n    if (mode !== this._mode) {\n      this._mode = mode;\n      this._clearHighlight();\n    }\n    if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {\n    } else if (!actionPoint && !this._actionPoint) {\n    } else {\n      if (actionPoint)\n        this._highlight.showActionPoint(actionPoint.x, actionPoint.y);\n      else\n        this._highlight.hideActionPoint();\n      this._actionPoint = actionPoint;\n    }\n    if (this._actionSelector && !((_a = this._hoveredModel) == null ? void 0 : _a.elements.length))\n      this._actionSelector = void 0;\n    if (actionSelector !== this._actionSelector) {\n      this._hoveredModel = actionSelector ? querySelector(this._injectedScript, actionSelector, this.document) : null;\n      this._updateHighlight();\n      this._actionSelector = actionSelector;\n    }\n  }\n  _clearHighlight() {\n    this._hoveredModel = null;\n    this._activeModel = null;\n    this._updateHighlight();\n  }\n  _actionInProgress(event) {\n    if (this._performingAction)\n      return true;\n    consumeEvent(event);\n    return false;\n  }\n  _consumedDueToNoModel(event, model) {\n    if (model)\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _consumedDueWrongTarget(event) {\n    if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _onClick(event) {\n    var _a, _b;\n    if (!event.isTrusted)\n      return;\n    if (this._mode === "inspecting")\n      (_b = (_a = this._delegate).setSelector) == null ? void 0 : _b.call(_a, this._hoveredModel ? this._hoveredModel.selector : "");\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    const checkbox = asCheckbox(this._deepEventTarget(event));\n    if (checkbox) {\n      this._performAction({\n        name: checkbox.checked ? "check" : "uncheck",\n        selector: this._hoveredModel.selector,\n        signals: []\n      });\n      return;\n    }\n    this._performAction({\n      name: "click",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._deepEventTarget(event);\n    if (this._mode === "none")\n      return true;\n    if (this._mode === "inspecting") {\n      consumeEvent(event);\n      return true;\n    }\n    const nodeName = target.nodeName;\n    if (nodeName === "SELECT" || nodeName === "OPTION")\n      return true;\n    if (nodeName === "INPUT" && ["date"].includes(target.type))\n      return true;\n    return false;\n  }\n  _onMouseDown(event) {\n    if (!event.isTrusted)\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingAction)\n      consumeEvent(event);\n    this._activeModel = this._hoveredModel;\n  }\n  _onMouseUp(event) {\n    if (!event.isTrusted)\n      return;\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingAction)\n      consumeEvent(event);\n  }\n  _onMouseMove(event) {\n    if (!event.isTrusted)\n      return;\n    if (this._mode === "none")\n      return;\n    const target = this._deepEventTarget(event);\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    this._updateModelForHoveredElement();\n  }\n  _onMouseLeave(event) {\n    if (!event.isTrusted)\n      return;\n    if (this._injectedScript.window.top !== this._injectedScript.window && this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n      this._hoveredElement = null;\n      this._updateModelForHoveredElement();\n    }\n  }\n  _onFocus(userGesture) {\n    if (this._mode === "none")\n      return;\n    const activeElement = this._deepActiveElement(this.document);\n    if (userGesture && activeElement === this.document.body)\n      return;\n    const result = activeElement ? generateSelector(this._injectedScript, activeElement, { testIdAttributeName: this._testIdAttributeName }) : null;\n    this._activeModel = result && result.selector ? result : null;\n    if (userGesture)\n      this._hoveredElement = activeElement;\n    this._updateModelForHoveredElement();\n  }\n  _updateModelForHoveredElement() {\n    if (!this._hoveredElement || !this._hoveredElement.isConnected) {\n      this._hoveredModel = null;\n      this._hoveredElement = null;\n      this._updateHighlight();\n      return;\n    }\n    const hoveredElement = this._hoveredElement;\n    const { selector, elements } = generateSelector(this._injectedScript, hoveredElement, { testIdAttributeName: this._testIdAttributeName });\n    if (this._hoveredModel && this._hoveredModel.selector === selector)\n      return;\n    this._hoveredModel = selector ? { selector, elements } : null;\n    this._updateHighlight();\n  }\n  _updateHighlight() {\n    const elements = this._hoveredModel ? this._hoveredModel.elements : [];\n    const selector = this._hoveredModel ? this._hoveredModel.selector : "";\n    this._highlight.updateHighlight(elements, selector, this._mode === "recording");\n  }\n  _onInput(event) {\n    var _a, _b, _c, _d;\n    if (this._mode !== "recording")\n      return true;\n    const target = this._deepEventTarget(event);\n    if (target.nodeName === "INPUT" && target.type.toLowerCase() === "file") {\n      (_b = (_a = this._delegate).recordAction) == null ? void 0 : _b.call(_a, {\n        name: "setInputFiles",\n        selector: this._activeModel.selector,\n        signals: [],\n        files: [...target.files || []].map((file) => file.name)\n      });\n      return;\n    }\n    if (["INPUT", "TEXTAREA"].includes(target.nodeName) || target.isContentEditable) {\n      if (target.nodeName === "INPUT" && ["checkbox", "radio"].includes(target.type.toLowerCase())) {\n        return;\n      }\n      if (this._consumedDueWrongTarget(event))\n        return;\n      (_d = (_c = this._delegate).recordAction) == null ? void 0 : _d.call(_c, {\n        name: "fill",\n        selector: this._activeModel.selector,\n        signals: [],\n        text: target.isContentEditable ? target.innerText : target.value\n      });\n    }\n    if (target.nodeName === "SELECT") {\n      const selectElement = target;\n      if (this._actionInProgress(event))\n        return;\n      this._performAction({\n        name: "select",\n        selector: this._hoveredModel.selector,\n        options: [...selectElement.selectedOptions].map((option) => option.value),\n        signals: []\n      });\n    }\n  }\n  _shouldGenerateKeyPressFor(event) {\n    if (event.key === "Enter" && (this._deepEventTarget(event).nodeName === "TEXTAREA" || this._deepEventTarget(event).isContentEditable))\n      return false;\n    if (["Backspace", "Delete", "AltGraph"].includes(event.key))\n      return false;\n    if (event.key === "@" && event.code === "KeyL")\n      return false;\n    if (navigator.platform.includes("Mac")) {\n      if (event.key === "v" && event.metaKey)\n        return false;\n    } else {\n      if (event.key === "v" && event.ctrlKey)\n        return false;\n      if (event.key === "Insert" && event.shiftKey)\n        return false;\n    }\n    if (["Shift", "Control", "Meta", "Alt", "Process"].includes(event.key))\n      return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier)\n      return !!asCheckbox(this._deepEventTarget(event));\n    return true;\n  }\n  _onKeyDown(event) {\n    if (!event.isTrusted)\n      return;\n    if (this._mode === "inspecting") {\n      consumeEvent(event);\n      return;\n    }\n    if (this._mode !== "recording")\n      return;\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (this._actionInProgress(event)) {\n      this._expectProgrammaticKeyUp = true;\n      return;\n    }\n    if (this._consumedDueWrongTarget(event))\n      return;\n    if (event.key === " ") {\n      const checkbox = asCheckbox(this._deepEventTarget(event));\n      if (checkbox) {\n        this._performAction({\n          name: checkbox.checked ? "uncheck" : "check",\n          selector: this._activeModel.selector,\n          signals: []\n        });\n        return;\n      }\n    }\n    this._performAction({\n      name: "press",\n      selector: this._activeModel.selector,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n  _onKeyUp(event) {\n    if (!event.isTrusted)\n      return;\n    if (this._mode === "none")\n      return;\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (!this._expectProgrammaticKeyUp) {\n      consumeEvent(event);\n      return;\n    }\n    this._expectProgrammaticKeyUp = false;\n  }\n  async _performAction(action) {\n    var _a, _b;\n    this._clearHighlight();\n    this._performingAction = true;\n    await ((_b = (_a = this._delegate).performAction) == null ? void 0 : _b.call(_a, action).catch(() => {\n    }));\n    this._performingAction = false;\n    this._onFocus(false);\n    if (this._injectedScript.isUnderTest) {\n      console.error("Action performed for test: " + JSON.stringify({\n        hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n        active: this._activeModel ? this._activeModel.selector : null\n      }));\n    }\n  }\n  _deepEventTarget(event) {\n    return event.composedPath()[0];\n  }\n  _deepActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      activeElement = activeElement.shadowRoot.activeElement;\n    return activeElement;\n  }\n};\nfunction modifiersForEvent(event) {\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n  switch (event.which) {\n    case 1:\n      return "left";\n    case 2:\n      return "middle";\n    case 3:\n      return "right";\n  }\n  return "left";\n}\nfunction positionForEvent(event) {\n  const targetElement = event.target;\n  if (targetElement.nodeName !== "CANVAS")\n    return;\n  return {\n    x: event.offsetX,\n    y: event.offsetY\n  };\n}\nfunction consumeEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n  if (!node || node.nodeName !== "INPUT")\n    return null;\n  const inputElement = node;\n  return ["checkbox", "radio"].includes(inputElement.type) ? inputElement : null;\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n  target.addEventListener(eventName, listener, useCapture);\n  const remove = () => {\n    target.removeEventListener(eventName, listener, useCapture);\n  };\n  return remove;\n}\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners)\n    listener();\n  listeners.splice(0, listeners.length);\n}\nfunction querySelector(injectedScript, selector, ownerDocument) {\n  try {\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n    };\n  } catch (e) {\n    return {\n      selector,\n      elements: []\n    };\n  }\n}\nvar PollingRecorder = class {\n  constructor(injectedScript) {\n    this._recorder = new Recorder(injectedScript, this);\n    this._embedder = injectedScript.window;\n    injectedScript.onGlobalListenersRemoved.add(() => this._recorder.refreshListenersIfNeeded());\n    const refreshOverlay = () => {\n      this._pollRecorderMode().catch((e) => console.log(e));\n    };\n    this._embedder.__pw_refreshOverlay = refreshOverlay;\n    refreshOverlay();\n  }\n  async _pollRecorderMode() {\n    const pollPeriod = 1e3;\n    if (this._pollRecorderModeTimer)\n      clearTimeout(this._pollRecorderModeTimer);\n    const state = await this._embedder.__pw_recorderState().catch(() => {\n    });\n    if (!state) {\n      this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n      return;\n    }\n    this._recorder.setUIState(state);\n    this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n  }\n  async performAction(action) {\n    await this._embedder.__pw_recorderPerformAction(action);\n  }\n  async recordAction(action) {\n    await this._embedder.__pw_recorderRecordAction(action);\n  }\n  async __pw_recorderState() {\n    return await this._embedder.__pw_recorderState();\n  }\n  async setSelector(selector) {\n    await this._embedder.__pw_recorderSetSelector(selector);\n  }\n};\nvar recorder_default = PollingRecorder;\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/generated/consoleApiSource.js
var require_consoleApiSource = __commonJS({
  "node_modules/playwright-core/lib/generated/consoleApiSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = '\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n// packages/playwright-core/src/server/injected/consoleApi.ts\nvar consoleApi_exports = {};\n__export(consoleApi_exports, {\n  default: () => consoleApi_default\n});\nmodule.exports = __toCommonJS(consoleApi_exports);\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "`") + char;\n  throw new Error("Invalid escape char");\n}\nfunction isString(obj) {\n  return typeof obj === "string" || obj instanceof String;\n}\nfunction toTitleCase(name) {\n  return name.charAt(0).toUpperCase() + name.substring(1);\n}\nfunction toSnakeCase(name) {\n  return name.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/([A-Z])([A-Z][a-z])/g, "$1_$2").toLowerCase();\n}\nfunction escapeForTextSelector(text, exact) {\n  if (typeof text !== "string")\n    return String(text).replace(/>>/g, "\\\\>\\\\>");\n  return `${JSON.stringify(text)}${exact ? "s" : "i"}`;\n}\nfunction escapeForAttributeSelector(value, exact) {\n  if (typeof value !== "string")\n    return String(value).replace(/>>/g, "\\\\>\\\\>");\n  return `"${value.replace(/\\\\/g, "\\\\\\\\").replace(/["]/g, \'\\\\"\')}"${exact ? "s" : "i"}`;\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorUtils.ts\nfunction getByAttributeTextSelector(attrName, text, options) {\n  return `internal:attr=[${attrName}=${escapeForAttributeSelector(text, (options == null ? void 0 : options.exact) || false)}]`;\n}\nfunction getByTestIdSelector(testIdAttributeName, testId) {\n  return `internal:testid=[${testIdAttributeName}=${escapeForAttributeSelector(testId, true)}]`;\n}\nfunction getByLabelSelector(text, options) {\n  return "internal:label=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByAltTextSelector(text, options) {\n  return getByAttributeTextSelector("alt", text, options);\n}\nfunction getByTitleSelector(text, options) {\n  return getByAttributeTextSelector("title", text, options);\n}\nfunction getByPlaceholderSelector(text, options) {\n  return getByAttributeTextSelector("placeholder", text, options);\n}\nfunction getByTextSelector(text, options) {\n  return "internal:text=" + escapeForTextSelector(text, !!(options == null ? void 0 : options.exact));\n}\nfunction getByRoleSelector(role, options = {}) {\n  const props = [];\n  if (options.checked !== void 0)\n    props.push(["checked", String(options.checked)]);\n  if (options.disabled !== void 0)\n    props.push(["disabled", String(options.disabled)]);\n  if (options.selected !== void 0)\n    props.push(["selected", String(options.selected)]);\n  if (options.expanded !== void 0)\n    props.push(["expanded", String(options.expanded)]);\n  if (options.includeHidden !== void 0)\n    props.push(["include-hidden", String(options.includeHidden)]);\n  if (options.level !== void 0)\n    props.push(["level", String(options.level)]);\n  if (options.name !== void 0)\n    props.push(["name", isString(options.name) ? escapeForAttributeSelector(options.name, !!options.exact) : String(options.name)]);\n  if (options.pressed !== void 0)\n    props.push(["pressed", String(options.pressed)]);\n  return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssTokenizer.ts\nvar between = function(num, first, last) {\n  return num >= first && num <= last;\n};\nfunction digit(code) {\n  return between(code, 48, 57);\n}\nfunction hexdigit(code) {\n  return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n}\nfunction uppercaseletter(code) {\n  return between(code, 65, 90);\n}\nfunction lowercaseletter(code) {\n  return between(code, 97, 122);\n}\nfunction letter(code) {\n  return uppercaseletter(code) || lowercaseletter(code);\n}\nfunction nonascii(code) {\n  return code >= 128;\n}\nfunction namestartchar(code) {\n  return letter(code) || nonascii(code) || code === 95;\n}\nfunction namechar(code) {\n  return namestartchar(code) || digit(code) || code === 45;\n}\nfunction nonprintable(code) {\n  return between(code, 0, 8) || code === 11 || between(code, 14, 31) || code === 127;\n}\nfunction newline(code) {\n  return code === 10;\n}\nfunction whitespace(code) {\n  return newline(code) || code === 9 || code === 32;\n}\nvar maximumallowedcodepoint = 1114111;\nvar InvalidCharacterError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = "InvalidCharacterError";\n  }\n};\nfunction preprocess(str) {\n  const codepoints = [];\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === 13 && str.charCodeAt(i + 1) === 10) {\n      code = 10;\n      i++;\n    }\n    if (code === 13 || code === 12)\n      code = 10;\n    if (code === 0)\n      code = 65533;\n    if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n      const lead = code - 55296;\n      const trail = str.charCodeAt(i + 1) - 56320;\n      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n      i++;\n    }\n    codepoints.push(code);\n  }\n  return codepoints;\n}\nfunction stringFromCode(code) {\n  if (code <= 65535)\n    return String.fromCharCode(code);\n  code -= Math.pow(2, 16);\n  const lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n  const trail = code % Math.pow(2, 10) + 56320;\n  return String.fromCharCode(lead) + String.fromCharCode(trail);\n}\nfunction tokenize(str1) {\n  const str = preprocess(str1);\n  let i = -1;\n  const tokens = [];\n  let code;\n  let line = 0;\n  let column = 0;\n  let lastLineLength = 0;\n  const incrLineno = function() {\n    line += 1;\n    lastLineLength = column;\n    column = 0;\n  };\n  const locStart = { line, column };\n  const codepoint = function(i2) {\n    if (i2 >= str.length)\n      return -1;\n    return str[i2];\n  };\n  const next = function(num) {\n    if (num === void 0)\n      num = 1;\n    if (num > 3)\n      throw "Spec Error: no more than three codepoints of lookahead.";\n    return codepoint(i + num);\n  };\n  const consume = function(num) {\n    if (num === void 0)\n      num = 1;\n    i += num;\n    code = codepoint(i);\n    if (newline(code))\n      incrLineno();\n    else\n      column += num;\n    return true;\n  };\n  const reconsume = function() {\n    i -= 1;\n    if (newline(code)) {\n      line -= 1;\n      column = lastLineLength;\n    } else {\n      column -= 1;\n    }\n    locStart.line = line;\n    locStart.column = column;\n    return true;\n  };\n  const eof = function(codepoint2) {\n    if (codepoint2 === void 0)\n      codepoint2 = code;\n    return codepoint2 === -1;\n  };\n  const donothing = function() {\n  };\n  const parseerror = function() {\n  };\n  const consumeAToken = function() {\n    consumeComments();\n    consume();\n    if (whitespace(code)) {\n      while (whitespace(next()))\n        consume();\n      return new WhitespaceToken();\n    } else if (code === 34) {\n      return consumeAStringToken();\n    } else if (code === 35) {\n      if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n        const token = new HashToken("");\n        if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n          token.type = "id";\n        token.value = consumeAName();\n        return token;\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 36) {\n      if (next() === 61) {\n        consume();\n        return new SuffixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 39) {\n      return consumeAStringToken();\n    } else if (code === 40) {\n      return new OpenParenToken();\n    } else if (code === 41) {\n      return new CloseParenToken();\n    } else if (code === 42) {\n      if (next() === 61) {\n        consume();\n        return new SubstringMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 43) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 44) {\n      return new CommaToken();\n    } else if (code === 45) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else if (next(1) === 45 && next(2) === 62) {\n        consume(2);\n        return new CDCToken();\n      } else if (startsWithAnIdentifier()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 46) {\n      if (startsWithANumber()) {\n        reconsume();\n        return consumeANumericToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 58) {\n      return new ColonToken();\n    } else if (code === 59) {\n      return new SemicolonToken();\n    } else if (code === 60) {\n      if (next(1) === 33 && next(2) === 45 && next(3) === 45) {\n        consume(3);\n        return new CDOToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 64) {\n      if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n        return new AtKeywordToken(consumeAName());\n      else\n        return new DelimToken(code);\n    } else if (code === 91) {\n      return new OpenSquareToken();\n    } else if (code === 92) {\n      if (startsWithAValidEscape()) {\n        reconsume();\n        return consumeAnIdentlikeToken();\n      } else {\n        parseerror();\n        return new DelimToken(code);\n      }\n    } else if (code === 93) {\n      return new CloseSquareToken();\n    } else if (code === 94) {\n      if (next() === 61) {\n        consume();\n        return new PrefixMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 123) {\n      return new OpenCurlyToken();\n    } else if (code === 124) {\n      if (next() === 61) {\n        consume();\n        return new DashMatchToken();\n      } else if (next() === 124) {\n        consume();\n        return new ColumnToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (code === 125) {\n      return new CloseCurlyToken();\n    } else if (code === 126) {\n      if (next() === 61) {\n        consume();\n        return new IncludeMatchToken();\n      } else {\n        return new DelimToken(code);\n      }\n    } else if (digit(code)) {\n      reconsume();\n      return consumeANumericToken();\n    } else if (namestartchar(code)) {\n      reconsume();\n      return consumeAnIdentlikeToken();\n    } else if (eof()) {\n      return new EOFToken();\n    } else {\n      return new DelimToken(code);\n    }\n  };\n  const consumeComments = function() {\n    while (next(1) === 47 && next(2) === 42) {\n      consume(2);\n      while (true) {\n        consume();\n        if (code === 42 && next() === 47) {\n          consume();\n          break;\n        } else if (eof()) {\n          parseerror();\n          return;\n        }\n      }\n    }\n  };\n  const consumeANumericToken = function() {\n    const num = consumeANumber();\n    if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n      const token = new DimensionToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      token.unit = consumeAName();\n      return token;\n    } else if (next() === 37) {\n      consume();\n      const token = new PercentageToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      return token;\n    } else {\n      const token = new NumberToken();\n      token.value = num.value;\n      token.repr = num.repr;\n      token.type = num.type;\n      return token;\n    }\n  };\n  const consumeAnIdentlikeToken = function() {\n    const str2 = consumeAName();\n    if (str2.toLowerCase() === "url" && next() === 40) {\n      consume();\n      while (whitespace(next(1)) && whitespace(next(2)))\n        consume();\n      if (next() === 34 || next() === 39)\n        return new FunctionToken(str2);\n      else if (whitespace(next()) && (next(2) === 34 || next(2) === 39))\n        return new FunctionToken(str2);\n      else\n        return consumeAURLToken();\n    } else if (next() === 40) {\n      consume();\n      return new FunctionToken(str2);\n    } else {\n      return new IdentToken(str2);\n    }\n  };\n  const consumeAStringToken = function(endingCodePoint) {\n    if (endingCodePoint === void 0)\n      endingCodePoint = code;\n    let string = "";\n    while (consume()) {\n      if (code === endingCodePoint || eof()) {\n        return new StringToken(string);\n      } else if (newline(code)) {\n        parseerror();\n        reconsume();\n        return new BadStringToken();\n      } else if (code === 92) {\n        if (eof(next()))\n          donothing();\n        else if (newline(next()))\n          consume();\n        else\n          string += stringFromCode(consumeEscape());\n      } else {\n        string += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeAURLToken = function() {\n    const token = new URLToken("");\n    while (whitespace(next()))\n      consume();\n    if (eof(next()))\n      return token;\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return token;\n      } else if (whitespace(code)) {\n        while (whitespace(next()))\n          consume();\n        if (next() === 41 || eof(next())) {\n          consume();\n          return token;\n        } else {\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else if (code === 34 || code === 39 || code === 40 || nonprintable(code)) {\n        parseerror();\n        consumeTheRemnantsOfABadURL();\n        return new BadURLToken();\n      } else if (code === 92) {\n        if (startsWithAValidEscape()) {\n          token.value += stringFromCode(consumeEscape());\n        } else {\n          parseerror();\n          consumeTheRemnantsOfABadURL();\n          return new BadURLToken();\n        }\n      } else {\n        token.value += stringFromCode(code);\n      }\n    }\n    throw new Error("Internal error");\n  };\n  const consumeEscape = function() {\n    consume();\n    if (hexdigit(code)) {\n      const digits = [code];\n      for (let total = 0; total < 5; total++) {\n        if (hexdigit(next())) {\n          consume();\n          digits.push(code);\n        } else {\n          break;\n        }\n      }\n      if (whitespace(next()))\n        consume();\n      let value = parseInt(digits.map(function(x) {\n        return String.fromCharCode(x);\n      }).join(""), 16);\n      if (value > maximumallowedcodepoint)\n        value = 65533;\n      return value;\n    } else if (eof()) {\n      return 65533;\n    } else {\n      return code;\n    }\n  };\n  const areAValidEscape = function(c1, c2) {\n    if (c1 !== 92)\n      return false;\n    if (newline(c2))\n      return false;\n    return true;\n  };\n  const startsWithAValidEscape = function() {\n    return areAValidEscape(code, next());\n  };\n  const wouldStartAnIdentifier = function(c1, c2, c3) {\n    if (c1 === 45)\n      return namestartchar(c2) || c2 === 45 || areAValidEscape(c2, c3);\n    else if (namestartchar(c1))\n      return true;\n    else if (c1 === 92)\n      return areAValidEscape(c1, c2);\n    else\n      return false;\n  };\n  const startsWithAnIdentifier = function() {\n    return wouldStartAnIdentifier(code, next(1), next(2));\n  };\n  const wouldStartANumber = function(c1, c2, c3) {\n    if (c1 === 43 || c1 === 45) {\n      if (digit(c2))\n        return true;\n      if (c2 === 46 && digit(c3))\n        return true;\n      return false;\n    } else if (c1 === 46) {\n      if (digit(c2))\n        return true;\n      return false;\n    } else if (digit(c1)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  const startsWithANumber = function() {\n    return wouldStartANumber(code, next(1), next(2));\n  };\n  const consumeAName = function() {\n    let result = "";\n    while (consume()) {\n      if (namechar(code)) {\n        result += stringFromCode(code);\n      } else if (startsWithAValidEscape()) {\n        result += stringFromCode(consumeEscape());\n      } else {\n        reconsume();\n        return result;\n      }\n    }\n    throw new Error("Internal parse error");\n  };\n  const consumeANumber = function() {\n    let repr = "";\n    let type = "integer";\n    if (next() === 43 || next() === 45) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    while (digit(next())) {\n      consume();\n      repr += stringFromCode(code);\n    }\n    if (next(1) === 46 && digit(next(2))) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const c1 = next(1), c2 = next(2), c3 = next(3);\n    if ((c1 === 69 || c1 === 101) && digit(c2)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    } else if ((c1 === 69 || c1 === 101) && (c2 === 43 || c2 === 45) && digit(c3)) {\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      consume();\n      repr += stringFromCode(code);\n      type = "number";\n      while (digit(next())) {\n        consume();\n        repr += stringFromCode(code);\n      }\n    }\n    const value = convertAStringToANumber(repr);\n    return { type, value, repr };\n  };\n  const convertAStringToANumber = function(string) {\n    return +string;\n  };\n  const consumeTheRemnantsOfABadURL = function() {\n    while (consume()) {\n      if (code === 41 || eof()) {\n        return;\n      } else if (startsWithAValidEscape()) {\n        consumeEscape();\n        donothing();\n      } else {\n        donothing();\n      }\n    }\n  };\n  let iterationCount = 0;\n  while (!eof(next())) {\n    tokens.push(consumeAToken());\n    iterationCount++;\n    if (iterationCount > str.length * 2)\n      throw new Error("I\'m infinite-looping!");\n  }\n  return tokens;\n}\nvar CSSParserToken = class {\n  constructor() {\n    this.tokenType = "";\n  }\n  toJSON() {\n    return { token: this.tokenType };\n  }\n  toString() {\n    return this.tokenType;\n  }\n  toSource() {\n    return "" + this;\n  }\n};\nvar BadStringToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADSTRING";\n  }\n};\nvar BadURLToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "BADURL";\n  }\n};\nvar WhitespaceToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "WHITESPACE";\n  }\n  toString() {\n    return "WS";\n  }\n  toSource() {\n    return " ";\n  }\n};\nvar CDOToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDO";\n  }\n  toSource() {\n    return "<!--";\n  }\n};\nvar CDCToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "CDC";\n  }\n  toSource() {\n    return "-->";\n  }\n};\nvar ColonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ":";\n  }\n};\nvar SemicolonToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ";";\n  }\n};\nvar CommaToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = ",";\n  }\n};\nvar GroupingToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n    this.mirror = "";\n  }\n};\nvar OpenCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "{";\n    this.value = "{";\n    this.mirror = "}";\n  }\n};\nvar CloseCurlyToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "}";\n    this.value = "}";\n    this.mirror = "{";\n  }\n};\nvar OpenSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "[";\n    this.value = "[";\n    this.mirror = "]";\n  }\n};\nvar CloseSquareToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "]";\n    this.value = "]";\n    this.mirror = "[";\n  }\n};\nvar OpenParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = "(";\n    this.value = "(";\n    this.mirror = ")";\n  }\n};\nvar CloseParenToken = class extends GroupingToken {\n  constructor() {\n    super();\n    this.tokenType = ")";\n    this.value = ")";\n    this.mirror = "(";\n  }\n};\nvar IncludeMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "~=";\n  }\n};\nvar DashMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "|=";\n  }\n};\nvar PrefixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "^=";\n  }\n};\nvar SuffixMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "$=";\n  }\n};\nvar SubstringMatchToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "*=";\n  }\n};\nvar ColumnToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "||";\n  }\n};\nvar EOFToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.tokenType = "EOF";\n  }\n  toSource() {\n    return "";\n  }\n};\nvar DelimToken = class extends CSSParserToken {\n  constructor(code) {\n    super();\n    this.tokenType = "DELIM";\n    this.value = "";\n    this.value = stringFromCode(code);\n  }\n  toString() {\n    return "DELIM(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n  toSource() {\n    if (this.value === "\\\\")\n      return "\\\\\\n";\n    else\n      return this.value;\n  }\n};\nvar StringValuedToken = class extends CSSParserToken {\n  constructor() {\n    super(...arguments);\n    this.value = "";\n  }\n  ASCIIMatch(str) {\n    return this.value.toLowerCase() === str.toLowerCase();\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    return json;\n  }\n};\nvar IdentToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "IDENT";\n    this.value = val;\n  }\n  toString() {\n    return "IDENT(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value);\n  }\n};\nvar FunctionToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "FUNCTION";\n    this.value = val;\n    this.mirror = ")";\n  }\n  toString() {\n    return "FUNCTION(" + this.value + ")";\n  }\n  toSource() {\n    return escapeIdent(this.value) + "(";\n  }\n};\nvar AtKeywordToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "AT-KEYWORD";\n    this.value = val;\n  }\n  toString() {\n    return "AT(" + this.value + ")";\n  }\n  toSource() {\n    return "@" + escapeIdent(this.value);\n  }\n};\nvar HashToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "HASH";\n    this.value = val;\n    this.type = "unrestricted";\n  }\n  toString() {\n    return "HASH(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    return json;\n  }\n  toSource() {\n    if (this.type === "id")\n      return "#" + escapeIdent(this.value);\n    else\n      return "#" + escapeHash(this.value);\n  }\n};\nvar StringToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "STRING";\n    this.value = val;\n  }\n  toString() {\n    return \'"\' + escapeString(this.value) + \'"\';\n  }\n};\nvar URLToken = class extends StringValuedToken {\n  constructor(val) {\n    super();\n    this.tokenType = "URL";\n    this.value = val;\n  }\n  toString() {\n    return "URL(" + this.value + ")";\n  }\n  toSource() {\n    return \'url("\' + escapeString(this.value) + \'")\';\n  }\n};\nvar NumberToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "NUMBER";\n    this.type = "integer";\n    this.repr = "";\n  }\n  toString() {\n    if (this.type === "integer")\n      return "INT(" + this.value + ")";\n    return "NUMBER(" + this.value + ")";\n  }\n  toJSON() {\n    const json = super.toJSON();\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr;\n  }\n};\nvar PercentageToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "PERCENTAGE";\n    this.repr = "";\n  }\n  toString() {\n    return "PERCENTAGE(" + this.value + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.repr = this.repr;\n    return json;\n  }\n  toSource() {\n    return this.repr + "%";\n  }\n};\nvar DimensionToken = class extends CSSParserToken {\n  constructor() {\n    super();\n    this.tokenType = "DIMENSION";\n    this.type = "integer";\n    this.repr = "";\n    this.unit = "";\n  }\n  toString() {\n    return "DIM(" + this.value + "," + this.unit + ")";\n  }\n  toJSON() {\n    const json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n    json.value = this.value;\n    json.type = this.type;\n    json.repr = this.repr;\n    json.unit = this.unit;\n    return json;\n  }\n  toSource() {\n    const source = this.repr;\n    let unit = escapeIdent(this.unit);\n    if (unit[0].toLowerCase() === "e" && (unit[1] === "-" || between(unit.charCodeAt(1), 48, 57))) {\n      unit = "\\\\65 " + unit.slice(1, unit.length);\n    }\n    return source + unit;\n  }\n};\nfunction escapeIdent(string) {\n  string = "" + string;\n  let result = "";\n  const firstcode = string.charCodeAt(0);\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127 || i === 0 && between(code, 48, 57) || i === 1 && between(code, 48, 57) && firstcode === 45)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + string[i];\n  }\n  return result;\n}\nfunction escapeHash(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (code >= 128 || code === 45 || code === 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122))\n      result += string[i];\n    else\n      result += "\\\\" + code.toString(16) + " ";\n  }\n  return result;\n}\nfunction escapeString(string) {\n  string = "" + string;\n  let result = "";\n  for (let i = 0; i < string.length; i++) {\n    const code = string.charCodeAt(i);\n    if (code === 0)\n      throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n    if (between(code, 1, 31) || code === 127)\n      result += "\\\\" + code.toString(16) + " ";\n    else if (code === 34 || code === 92)\n      result += "\\\\" + string[i];\n    else\n      result += string[i];\n  }\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/cssParser.ts\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof EOFToken))\n      tokens.push(new EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector "${selector}"`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof AtKeywordToken || token instanceof BadStringToken || token instanceof BadURLToken || token instanceof ColumnToken || token instanceof CDOToken || token instanceof CDCToken || token instanceof SemicolonToken || token instanceof OpenCurlyToken || token instanceof CloseCurlyToken || token instanceof URLToken || token instanceof PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof IdentToken;\n  }\n  function isString2(p = pos) {\n    return tokens[p] instanceof StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof CommaToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof CloseParenToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString2())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    while (!isCloseParen() && !isEOF())\n      s += tokens[pos++].toSource();\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/utils/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = /* @__PURE__ */ new Set(["internal:has", "internal:has-not", "internal:and", "internal:or", "left-of", "right-of", "above", "below", "near"]);\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set(["left-of", "right-of", "above", "below", "near"]);\nvar customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nfunction parseSelector(selector) {\n  const parsedStrings = parseSelectorString(selector);\n  const parts = [];\n  for (const part of parsedStrings.parts) {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      parts.push({\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      });\n      continue;\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse("[" + part.body + "]");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== "string")\n          throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== "number" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new InvalidSelectorError(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const nested = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      const lastFrame = [...nested.body.parsed.parts].reverse().find((part2) => part2.name === "internal:control" && part2.body === "enter-frame");\n      const lastFrameIndex = lastFrame ? nested.body.parsed.parts.indexOf(lastFrame) : -1;\n      if (lastFrameIndex !== -1 && selectorPartsEqual(nested.body.parsed.parts.slice(0, lastFrameIndex + 1), parts.slice(0, lastFrameIndex + 1)))\n        nested.body.parsed.parts.splice(0, lastFrameIndex + 1);\n      parts.push(nested);\n      continue;\n    }\n    parts.push({ ...part, source: part.body });\n  }\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new InvalidSelectorError(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: parsedStrings.capture,\n    parts\n  };\n}\nfunction selectorPartsEqual(list1, list2) {\n  return stringifySelector({ parts: list1 }) === stringifySelector({ parts: list2 });\n}\nfunction stringifySelector(selector) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === "css" ? "" : p.name + "=";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new InvalidSelectorError(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expressiion");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new InvalidSelectorError(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/utils/isomorphic/locatorGenerators.ts\nfunction asLocator(lang, selector, isFrameLocator = false, playSafe = false) {\n  return asLocators(lang, selector, isFrameLocator, playSafe)[0];\n}\nfunction asLocators(lang, selector, isFrameLocator = false, playSafe = false, maxOutputSize = 20) {\n  if (playSafe) {\n    try {\n      return innerAsLocators(generators[lang], parseSelector(selector), isFrameLocator, maxOutputSize);\n    } catch (e) {\n      return [selector];\n    }\n  } else {\n    return innerAsLocators(generators[lang], parseSelector(selector), isFrameLocator, maxOutputSize);\n  }\n}\nfunction innerAsLocators(factory, parsed, isFrameLocator = false, maxOutputSize = 20) {\n  const parts = [...parsed.parts];\n  for (let index = 0; index < parts.length - 1; index++) {\n    if (parts[index].name === "nth" && parts[index + 1].name === "internal:control" && parts[index + 1].body === "enter-frame") {\n      const [nth] = parts.splice(index, 1);\n      parts.splice(index + 1, 0, nth);\n    }\n  }\n  const tokens = [];\n  let nextBase = isFrameLocator ? "frame-locator" : "page";\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const base = nextBase;\n    nextBase = "locator";\n    if (part.name === "nth") {\n      if (part.body === "0")\n        tokens.push([factory.generateLocator(base, "first", ""), factory.generateLocator(base, "nth", "0")]);\n      else if (part.body === "-1")\n        tokens.push([factory.generateLocator(base, "last", ""), factory.generateLocator(base, "nth", "-1")]);\n      else\n        tokens.push([factory.generateLocator(base, "nth", part.body)]);\n      continue;\n    }\n    if (part.name === "internal:text") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "text", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:has-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has-not-text") {\n      const { exact, text } = detectExact(part.body);\n      if (!exact) {\n        tokens.push([factory.generateLocator(base, "has-not-text", text, { exact })]);\n        continue;\n      }\n    }\n    if (part.name === "internal:has") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "has", inner)));\n      continue;\n    }\n    if (part.name === "internal:has-not") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "hasNot", inner)));\n      continue;\n    }\n    if (part.name === "internal:and") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "and", inner)));\n      continue;\n    }\n    if (part.name === "internal:or") {\n      const inners = innerAsLocators(factory, part.body.parsed, false, maxOutputSize);\n      tokens.push(inners.map((inner) => factory.generateLocator(base, "or", inner)));\n      continue;\n    }\n    if (part.name === "internal:label") {\n      const { exact, text } = detectExact(part.body);\n      tokens.push([factory.generateLocator(base, "label", text, { exact })]);\n      continue;\n    }\n    if (part.name === "internal:role") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const options = { attrs: [] };\n      for (const attr of attrSelector.attributes) {\n        if (attr.name === "name") {\n          options.exact = attr.caseSensitive;\n          options.name = attr.value;\n        } else {\n          if (attr.name === "level" && typeof attr.value === "string")\n            attr.value = +attr.value;\n          options.attrs.push({ name: attr.name === "include-hidden" ? "includeHidden" : attr.name, value: attr.value });\n        }\n      }\n      tokens.push([factory.generateLocator(base, "role", attrSelector.name, options)]);\n      continue;\n    }\n    if (part.name === "internal:testid") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { value } = attrSelector.attributes[0];\n      tokens.push([factory.generateLocator(base, "test-id", value)]);\n      continue;\n    }\n    if (part.name === "internal:attr") {\n      const attrSelector = parseAttributeSelector(part.body, true);\n      const { name, value, caseSensitive } = attrSelector.attributes[0];\n      const text = value;\n      const exact = !!caseSensitive;\n      if (name === "placeholder") {\n        tokens.push([factory.generateLocator(base, "placeholder", text, { exact })]);\n        continue;\n      }\n      if (name === "alt") {\n        tokens.push([factory.generateLocator(base, "alt", text, { exact })]);\n        continue;\n      }\n      if (name === "title") {\n        tokens.push([factory.generateLocator(base, "title", text, { exact })]);\n        continue;\n      }\n    }\n    let locatorType = "default";\n    const nextPart = parts[index + 1];\n    if (nextPart && nextPart.name === "internal:control" && nextPart.body === "enter-frame") {\n      locatorType = "frame";\n      nextBase = "frame-locator";\n      index++;\n    }\n    const selectorPart = stringifySelector({ parts: [part] });\n    const locatorPart = factory.generateLocator(base, locatorType, selectorPart);\n    if (locatorType === "default" && nextPart && ["internal:has-text", "internal:has-not-text"].includes(nextPart.name)) {\n      const { exact, text } = detectExact(nextPart.body);\n      if (!exact) {\n        const nextLocatorPart = factory.generateLocator("locator", nextPart.name === "internal:has-text" ? "has-text" : "has-not-text", text, { exact });\n        const options = {};\n        if (nextPart.name === "internal:has-text")\n          options.hasText = text;\n        else\n          options.hasNotText = text;\n        const combinedPart = factory.generateLocator(base, "default", selectorPart, options);\n        tokens.push([factory.chainLocators([locatorPart, nextLocatorPart]), combinedPart]);\n        index++;\n        continue;\n      }\n    }\n    tokens.push([locatorPart]);\n  }\n  return combineTokens(factory, tokens, maxOutputSize);\n}\nfunction combineTokens(factory, tokens, maxOutputSize) {\n  const currentTokens = tokens.map(() => "");\n  const result = [];\n  const visit = (index) => {\n    if (index === tokens.length) {\n      result.push(factory.chainLocators(currentTokens));\n      return currentTokens.length < maxOutputSize;\n    }\n    for (const taken of tokens[index]) {\n      currentTokens[index] = taken;\n      if (!visit(index + 1))\n        return false;\n    }\n    return true;\n  };\n  visit(0);\n  return result;\n}\nfunction detectExact(text) {\n  let exact = false;\n  const match = text.match(/^\\/(.*)\\/([igm]*)$/);\n  if (match)\n    return { text: new RegExp(match[1], match[2]) };\n  if (text.endsWith(\'"\')) {\n    text = JSON.parse(text);\n    exact = true;\n  } else if (text.endsWith(\'"s\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = true;\n  } else if (text.endsWith(\'"i\')) {\n    text = JSON.parse(text.substring(0, text.length - 1));\n    exact = false;\n  }\n  return { exact, text };\n}\nvar JavaScriptLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, { hasText: ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, { hasNotText: ${this.toHasText(options.hasNotText)} })`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frameLocator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name: ${options.name}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name: ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact: true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${name}: ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, { ${attrs.join(", ")} }` : "";\n        return `getByRole(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter({ hasText: ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `filter({ hasNotText: ${this.toHasText(body)} })`;\n      case "has":\n        return `filter({ has: ${body} })`;\n      case "hasNot":\n        return `filter({ hasNot: ${body} })`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${body})`;\n    return exact ? `${method}(${this.quote(body)}, { exact: true })` : `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return String(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return String(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, "\'");\n  }\n};\nvar PythonLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, has_text=${this.toHasText(options.hasText)})`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, has_not_text=${this.toHasText(options.hasNotText)})`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frame_locator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first`;\n      case "last":\n        return `last`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`name=${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`name=${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`exact=True`);\n        }\n        for (const { name, value } of options.attrs) {\n          let valueString = typeof value === "string" ? this.quote(value) : value;\n          if (typeof value === "boolean")\n            valueString = value ? "True" : "False";\n          attrs.push(`${toSnakeCase(name)}=${valueString}`);\n        }\n        const attrString = attrs.length ? `, ${attrs.join(", ")}` : "";\n        return `get_by_role(${this.quote(body)}${attrString})`;\n      case "has-text":\n        return `filter(has_text=${this.toHasText(body)})`;\n      case "has-not-text":\n        return `filter(has_not_text=${this.toHasText(body)})`;\n      case "has":\n        return `filter(has=${body})`;\n      case "hasNot":\n        return `filter(has_not=${body})`;\n      case "and":\n        return `and_(${body})`;\n      case "or":\n        return `or_(${body})`;\n      case "test-id":\n        return `get_by_test_id(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("get_by_text", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("get_by_alt_text", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("get_by_placeholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("get_by_label", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("get_by_title", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", re.IGNORECASE" : "";\n    return `re.compile(r"${body.source.replace(/\\\\\\//, "/").replace(/"/g, \'\\\\"\')}"${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, exact=True)`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return `${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JavaLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    let clazz;\n    switch (base) {\n      case "page":\n        clazz = "Page";\n        break;\n      case "frame-locator":\n        clazz = "FrameLocator";\n        break;\n      case "locator":\n        clazz = "Locator";\n        break;\n    }\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasText(${this.toHasText(options.hasText)}))`;\n        if (options.hasNotText !== void 0)\n          return `locator(${this.quote(body)}, new ${clazz}.LocatorOptions().setHasNotText(${this.toHasText(options.hasNotText)}))`;\n        return `locator(${this.quote(body)})`;\n      case "frame":\n        return `frameLocator(${this.quote(body)})`;\n      case "nth":\n        return `nth(${body})`;\n      case "first":\n        return `first()`;\n      case "last":\n        return `last()`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`.setName(${this.regexToString(options.name)})`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`.setName(${this.quote(options.name)})`);\n          if (options.exact)\n            attrs.push(`.setExact(true)`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`.set${toTitleCase(name)}(${typeof value === "string" ? this.quote(value) : value})`);\n        const attrString = attrs.length ? `, new ${clazz}.GetByRoleOptions()${attrs.join("")}` : "";\n        return `getByRole(AriaRole.${toSnakeCase(body).toUpperCase()}${attrString})`;\n      case "has-text":\n        return `filter(new ${clazz}.FilterOptions().setHasText(${this.toHasText(body)}))`;\n      case "has-not-text":\n        return `filter(new ${clazz}.FilterOptions().setHasNotText(${this.toHasText(body)}))`;\n      case "has":\n        return `filter(new ${clazz}.FilterOptions().setHas(${body}))`;\n      case "hasNot":\n        return `filter(new ${clazz}.FilterOptions().setHasNot(${body}))`;\n      case "and":\n        return `and(${body})`;\n      case "or":\n        return `or(${body})`;\n      case "test-id":\n        return `getByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact(clazz, "getByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact(clazz, "getByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact(clazz, "getByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact(clazz, "getByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact(clazz, "getByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", Pattern.CASE_INSENSITIVE" : "";\n    return `Pattern.compile(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(clazz, method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new ${clazz}.${toTitleCase(method)}Options().setExact(true))`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return this.regexToString(body);\n    return this.quote(body);\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar CSharpLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    switch (kind) {\n      case "default":\n        if (options.hasText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasText(options.hasText)} })`;\n        if (options.hasNotText !== void 0)\n          return `Locator(${this.quote(body)}, new() { ${this.toHasNotText(options.hasNotText)} })`;\n        return `Locator(${this.quote(body)})`;\n      case "frame":\n        return `FrameLocator(${this.quote(body)})`;\n      case "nth":\n        return `Nth(${body})`;\n      case "first":\n        return `First`;\n      case "last":\n        return `Last`;\n      case "role":\n        const attrs = [];\n        if (isRegExp(options.name)) {\n          attrs.push(`NameRegex = ${this.regexToString(options.name)}`);\n        } else if (typeof options.name === "string") {\n          attrs.push(`Name = ${this.quote(options.name)}`);\n          if (options.exact)\n            attrs.push(`Exact = true`);\n        }\n        for (const { name, value } of options.attrs)\n          attrs.push(`${toTitleCase(name)} = ${typeof value === "string" ? this.quote(value) : value}`);\n        const attrString = attrs.length ? `, new() { ${attrs.join(", ")} }` : "";\n        return `GetByRole(AriaRole.${toTitleCase(body)}${attrString})`;\n      case "has-text":\n        return `Filter(new() { ${this.toHasText(body)} })`;\n      case "has-not-text":\n        return `Filter(new() { ${this.toHasNotText(body)} })`;\n      case "has":\n        return `Filter(new() { Has = ${body} })`;\n      case "hasNot":\n        return `Filter(new() { HasNot = ${body} })`;\n      case "and":\n        return `And(${body})`;\n      case "or":\n        return `Or(${body})`;\n      case "test-id":\n        return `GetByTestId(${this.toTestIdValue(body)})`;\n      case "text":\n        return this.toCallWithExact("GetByText", body, !!options.exact);\n      case "alt":\n        return this.toCallWithExact("GetByAltText", body, !!options.exact);\n      case "placeholder":\n        return this.toCallWithExact("GetByPlaceholder", body, !!options.exact);\n      case "label":\n        return this.toCallWithExact("GetByLabel", body, !!options.exact);\n      case "title":\n        return this.toCallWithExact("GetByTitle", body, !!options.exact);\n      default:\n        throw new Error("Unknown selector kind " + kind);\n    }\n  }\n  chainLocators(locators) {\n    return locators.join(".");\n  }\n  regexToString(body) {\n    const suffix = body.flags.includes("i") ? ", RegexOptions.IgnoreCase" : "";\n    return `new Regex(${this.quote(body.source)}${suffix})`;\n  }\n  toCallWithExact(method, body, exact) {\n    if (isRegExp(body))\n      return `${method}(${this.regexToString(body)})`;\n    if (exact)\n      return `${method}(${this.quote(body)}, new() { Exact = true })`;\n    return `${method}(${this.quote(body)})`;\n  }\n  toHasText(body) {\n    if (isRegExp(body))\n      return `HasTextRegex = ${this.regexToString(body)}`;\n    return `HasText = ${this.quote(body)}`;\n  }\n  toTestIdValue(value) {\n    if (isRegExp(value))\n      return this.regexToString(value);\n    return this.quote(value);\n  }\n  toHasNotText(body) {\n    if (isRegExp(body))\n      return `HasNotTextRegex = ${this.regexToString(body)}`;\n    return `HasNotText = ${this.quote(body)}`;\n  }\n  quote(text) {\n    return escapeWithQuotes(text, \'"\');\n  }\n};\nvar JsonlLocatorFactory = class {\n  generateLocator(base, kind, body, options = {}) {\n    return JSON.stringify({\n      kind,\n      body,\n      options\n    });\n  }\n  chainLocators(locators) {\n    const objects = locators.map((l) => JSON.parse(l));\n    for (let i = 0; i < objects.length - 1; ++i)\n      objects[i].next = objects[i + 1];\n    return JSON.stringify(objects[0]);\n  }\n};\nvar generators = {\n  javascript: new JavaScriptLocatorFactory(),\n  python: new PythonLocatorFactory(),\n  java: new JavaLocatorFactory(),\n  csharp: new CSharpLocatorFactory(),\n  jsonl: new JsonlLocatorFactory()\n};\nfunction isRegExp(obj) {\n  return obj instanceof RegExp;\n}\n\n// packages/playwright-core/src/server/injected/consoleApi.ts\nvar selectorSymbol = Symbol("selector");\nvar injectedScriptSymbol = Symbol("injectedScript");\nvar Locator = class {\n  constructor(injectedScript, selector, options) {\n    this[selectorSymbol] = selector;\n    this[injectedScriptSymbol] = injectedScript;\n    if (options == null ? void 0 : options.hasText)\n      selector += ` >> internal:has-text=${escapeForTextSelector(options.hasText, false)}`;\n    if (options == null ? void 0 : options.hasNotText)\n      selector += ` >> internal:has-not-text=${escapeForTextSelector(options.hasNotText, false)}`;\n    if (options == null ? void 0 : options.has)\n      selector += ` >> internal:has=` + JSON.stringify(options.has[selectorSymbol]);\n    if (options == null ? void 0 : options.hasNot)\n      selector += ` >> internal:has-not=` + JSON.stringify(options.hasNot[selectorSymbol]);\n    if (selector) {\n      const parsed = injectedScript.parseSelector(selector);\n      this.element = injectedScript.querySelector(parsed, injectedScript.document, false);\n      this.elements = injectedScript.querySelectorAll(parsed, injectedScript.document);\n    }\n    const selectorBase = selector;\n    const self = this;\n    self.locator = (selector2, options2) => {\n      return new Locator(injectedScript, selectorBase ? selectorBase + " >> " + selector2 : selector2, options2);\n    };\n    self.getByTestId = (testId) => self.locator(getByTestIdSelector(injectedScript.testIdAttributeNameForStrictErrorAndConsoleCodegen(), testId));\n    self.getByAltText = (text, options2) => self.locator(getByAltTextSelector(text, options2));\n    self.getByLabel = (text, options2) => self.locator(getByLabelSelector(text, options2));\n    self.getByPlaceholder = (text, options2) => self.locator(getByPlaceholderSelector(text, options2));\n    self.getByText = (text, options2) => self.locator(getByTextSelector(text, options2));\n    self.getByTitle = (text, options2) => self.locator(getByTitleSelector(text, options2));\n    self.getByRole = (role, options2 = {}) => self.locator(getByRoleSelector(role, options2));\n    self.filter = (options2) => new Locator(injectedScript, selector, options2);\n    self.first = () => self.locator("nth=0");\n    self.last = () => self.locator("nth=-1");\n    self.nth = (index) => self.locator(`nth=${index}`);\n    self.and = (locator) => new Locator(injectedScript, selectorBase + ` >> internal:and=` + JSON.stringify(locator[selectorSymbol]));\n    self.or = (locator) => new Locator(injectedScript, selectorBase + ` >> internal:or=` + JSON.stringify(locator[selectorSymbol]));\n  }\n};\nvar ConsoleAPI = class {\n  constructor(injectedScript) {\n    this._injectedScript = injectedScript;\n    if (this._injectedScript.window.playwright)\n      return;\n    this._injectedScript.window.playwright = {\n      $: (selector, strict) => this._querySelector(selector, !!strict),\n      $$: (selector) => this._querySelectorAll(selector),\n      inspect: (selector) => this._inspect(selector),\n      selector: (element) => this._selector(element),\n      generateLocator: (element, language) => this._generateLocator(element, language),\n      resume: () => this._resume(),\n      ...new Locator(injectedScript, "")\n    };\n    delete this._injectedScript.window.playwright.filter;\n    delete this._injectedScript.window.playwright.first;\n    delete this._injectedScript.window.playwright.last;\n    delete this._injectedScript.window.playwright.nth;\n    delete this._injectedScript.window.playwright.and;\n    delete this._injectedScript.window.playwright.or;\n  }\n  _querySelector(selector, strict) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.query(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelector(parsed, this._injectedScript.document, strict);\n  }\n  _querySelectorAll(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.$$(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelectorAll(parsed, this._injectedScript.document);\n  }\n  _inspect(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.inspect(\'Playwright >> selector\').`);\n    this._injectedScript.window.inspect(this._querySelector(selector, false));\n  }\n  _selector(element) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.selector(element).`);\n    return this._injectedScript.generateSelector(element);\n  }\n  _generateLocator(element, language) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.locator(element).`);\n    const selector = this._injectedScript.generateSelector(element);\n    return asLocator(language || "javascript", selector);\n  }\n  _resume() {\n    this._injectedScript.window.__pw_resume().catch(() => {\n    });\n  }\n};\nvar consoleApi_default = ConsoleAPI;\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/chromium/crApp.js
var require_crApp = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crApp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.installAppIcon = installAppIcon;
    exports2.syncLocalStorageWithSettings = syncLocalStorageWithSettings;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _utils = require_utils();
    var _registry = require_registry();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function installAppIcon(page) {
      return __async(this, null, function* () {
        const icon = yield _fs.default.promises.readFile(require.resolve("./appIcon.png"));
        const crPage = page._delegate;
        yield crPage._mainFrameSession._client.send("Browser.setDockTile", {
          image: icon.toString("base64")
        });
      });
    }
    function syncLocalStorageWithSettings(page, appName) {
      return __async(this, null, function* () {
        if ((0, _utils.isUnderTest)())
          return;
        const settingsFile = _path.default.join(_registry.registryDirectory, ".settings", `${appName}.json`);
        yield page.exposeBinding("_saveSerializedSettings", false, (_, settings2) => {
          _fs.default.mkdirSync(_path.default.dirname(settingsFile), {
            recursive: true
          });
          _fs.default.writeFileSync(settingsFile, settings2);
        });
        const settings = yield _fs.default.promises.readFile(settingsFile, "utf-8").catch(() => "{}");
        yield page.addInitScript(`(${String((settings2) => {
          if (location && location.protocol === "data:")
            return;
          Object.entries(settings2).map(([k, v]) => localStorage[k] = v);
          window.saveSettings = () => {
            window._saveSerializedSettings(JSON.stringify(__spreadValues({}, localStorage)));
          };
        })})(${settings});
  `);
      });
    }
  }
});

// node_modules/playwright-core/lib/server/download.js
var require_download = __commonJS({
  "node_modules/playwright-core/lib/server/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Download = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _page = require_page();
    var _utils = require_utils();
    var _artifact = require_artifact();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Download = class {
      constructor(page, downloadsPath, uuid, url, suggestedFilename) {
        this.artifact = void 0;
        this.url = void 0;
        this._page = void 0;
        this._suggestedFilename = void 0;
        const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
        this.artifact = new _artifact.Artifact(page, _path.default.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
          return this._page._browserContext.cancelDownload(uuid);
        });
        this._page = page;
        this.url = url;
        this._suggestedFilename = suggestedFilename;
        page._browserContext._downloads.add(this);
        if (suggestedFilename !== void 0)
          this._page.emit(_page.Page.Events.Download, this);
      }
      _filenameSuggested(suggestedFilename) {
        (0, _utils.assert)(this._suggestedFilename === void 0);
        this._suggestedFilename = suggestedFilename;
        this._page.emit(_page.Page.Events.Download, this);
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright-core/lib/server/browser.js
var require_browser = __commonJS({
  "node_modules/playwright-core/lib/server/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Browser = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _download = require_download();
    var _instrumentation = require_instrumentation();
    var _artifact = require_artifact();
    var Browser = class extends _instrumentation.SdkObject {
      constructor(parent, options) {
        super(parent, "browser");
        this.options = void 0;
        this._downloads = /* @__PURE__ */ new Map();
        this._defaultContext = null;
        this._startedClosing = false;
        this._idToVideo = /* @__PURE__ */ new Map();
        this._contextForReuse = void 0;
        this.attribution.browser = this;
        this.options = options;
        this.instrumentation.onBrowserOpen(this);
      }
      newContext(metadata, options) {
        return __async(this, null, function* () {
          (0, _browserContext.validateBrowserContextOptions)(options, this.options);
          const context = yield this.doCreateNewContext(options);
          if (options.storageState)
            yield context.setStorageState(metadata, options.storageState);
          return context;
        });
      }
      newContextForReuse(params, metadata) {
        return __async(this, null, function* () {
          const hash = _browserContext.BrowserContext.reusableContextHash(params);
          if (!this._contextForReuse || hash !== this._contextForReuse.hash || !this._contextForReuse.context.canResetForReuse()) {
            if (this._contextForReuse)
              yield this._contextForReuse.context.close(metadata);
            this._contextForReuse = {
              context: yield this.newContext(metadata, params),
              hash
            };
            return {
              context: this._contextForReuse.context,
              needsReset: false
            };
          }
          yield this._contextForReuse.context.stopPendingOperations();
          return {
            context: this._contextForReuse.context,
            needsReset: true
          };
        });
      }
      _downloadCreated(page, uuid, url, suggestedFilename) {
        const download = new _download.Download(page, this.options.downloadsPath || "", uuid, url, suggestedFilename);
        this._downloads.set(uuid, download);
      }
      _downloadFilenameSuggested(uuid, suggestedFilename) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download._filenameSuggested(suggestedFilename);
      }
      _downloadFinished(uuid, error) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download.artifact.reportFinished(error);
        this._downloads.delete(uuid);
      }
      _videoStarted(context, videoId, path, pageOrError) {
        const artifact = new _artifact.Artifact(context, path);
        this._idToVideo.set(videoId, {
          context,
          artifact
        });
        pageOrError.then((page) => {
          if (page instanceof _page.Page) {
            page._video = artifact;
            page.emitOnContext(_browserContext.BrowserContext.Events.VideoStarted, artifact);
            page.emit(_page.Page.Events.Video, artifact);
          }
        });
      }
      _takeVideo(videoId) {
        const video = this._idToVideo.get(videoId);
        this._idToVideo.delete(videoId);
        return video === null || video === void 0 ? void 0 : video.artifact;
      }
      _didClose() {
        for (const context of this.contexts())
          context._browserClosed();
        if (this._defaultContext)
          this._defaultContext._browserClosed();
        this.emit(Browser.Events.Disconnected);
        this.instrumentation.onBrowserClose(this);
      }
      close() {
        return __async(this, null, function* () {
          if (!this._startedClosing) {
            this._startedClosing = true;
            yield this.options.browserProcess.close();
          }
          if (this.isConnected())
            yield new Promise((x) => this.once(Browser.Events.Disconnected, x));
        });
      }
      killForTests() {
        return __async(this, null, function* () {
          yield this.options.browserProcess.kill();
        });
      }
    };
    exports2.Browser = Browser;
    Browser.Events = {
      Disconnected: "disconnected"
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crConnection.js
var require_crConnection = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kBrowserCloseMessageId = exports2.ConnectionEvents = exports2.CRSessionEvents = exports2.CRSession = exports2.CRConnection = void 0;
    var _utils = require_utils();
    var _events = require("events");
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("ConnectionEvents.Disconnected")
    };
    exports2.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var CRConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = 0;
        this._transport = void 0;
        this._sessions = /* @__PURE__ */ new Map();
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this.rootSession = void 0;
        this._closed = false;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.rootSession = new CRSession(this, "", "browser", "");
        this._sessions.set("", this.rootSession);
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      _rawSend(sessionId, method, params) {
        const id = ++this._lastId;
        const message = {
          id,
          method,
          params
        };
        if (sessionId)
          message.sessionId = sessionId;
        this._protocolLogger("send", message);
        this._transport.send(message);
        return id;
      }
      _onMessage(message) {
        return __async(this, null, function* () {
          this._protocolLogger("receive", message);
          if (message.id === kBrowserCloseMessageId)
            return;
          if (message.method === "Target.attachedToTarget") {
            const sessionId = message.params.sessionId;
            const rootSessionId = message.sessionId || "";
            const session2 = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session2);
          } else if (message.method === "Target.detachedFromTarget") {
            const session2 = this._sessions.get(message.params.sessionId);
            if (session2) {
              session2._onClosed(void 0);
              this._sessions.delete(message.params.sessionId);
            }
          }
          const session = this._sessions.get(message.sessionId || "");
          if (session)
            session._onMessage(message);
        });
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const browserDisconnectedLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session._onClosed(browserDisconnectedLogs);
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(targetInfo) {
        return __async(this, null, function* () {
          const {
            sessionId
          } = yield this.rootSession.send("Target.attachToTarget", {
            targetId: targetInfo.targetId,
            flatten: true
          });
          return this._sessions.get(sessionId);
        });
      }
      createBrowserSession() {
        return __async(this, null, function* () {
          const {
            sessionId
          } = yield this.rootSession.send("Target.attachToBrowserTarget");
          return this._sessions.get(sessionId);
        });
      }
    };
    exports2.CRConnection = CRConnection;
    var CRSessionEvents = {
      Disconnected: Symbol("Events.CDPSession.Disconnected")
    };
    exports2.CRSessionEvents = CRSessionEvents;
    var CRSession = class extends _events.EventEmitter {
      constructor(connection, rootSessionId, targetType, sessionId) {
        super();
        this._connection = void 0;
        this._eventListener = void 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._targetType = void 0;
        this._sessionId = void 0;
        this._rootSessionId = void 0;
        this._crashed = false;
        this._browserDisconnectedLogs = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.guid = void 0;
        this.guid = `cdp-session@${sessionId}`;
        this.setMaxListeners(0);
        this._connection = connection;
        this._rootSessionId = rootSessionId;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      _markAsCrashed() {
        this._crashed = true;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          if (this._browserDisconnectedLogs !== void 0)
            throw new _protocolError.ProtocolError(true, `Browser closed.` + this._browserDisconnectedLogs);
          if (!this._connection)
            throw new _protocolError.ProtocolError(true, `Target closed`);
          const id = this._connection._rawSend(this._sessionId, method, params);
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      _sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      _onMessage(object) {
        var _object$error;
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else if (object.id && ((_object$error = object.error) === null || _object$error === void 0 ? void 0 : _object$error.code) === -32001) {
        } else {
          var _object$error2;
          (0, _utils.assert)(!object.id, (object === null || object === void 0 ? void 0 : (_object$error2 = object.error) === null || _object$error2 === void 0 ? void 0 : _object$error2.message) || void 0);
          Promise.resolve().then(() => {
            if (this._eventListener)
              this._eventListener(object.method, object.params);
            this.emit(object.method, object.params);
          });
        }
      }
      detach() {
        return __async(this, null, function* () {
          if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
          const rootSession = this._connection.session(this._rootSessionId);
          if (!rootSession)
            throw new Error("Root session has been closed");
          yield rootSession.send("Target.detachFromTarget", {
            sessionId: this._sessionId
          });
        });
      }
      _onClosed(browserDisconnectedLogs) {
        this._browserDisconnectedLogs = browserDisconnectedLogs;
        const errorMessage = browserDisconnectedLogs !== void 0 ? "Browser closed." + browserDisconnectedLogs : "Target closed";
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, errorMessage));
        }
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(CRSessionEvents.Disconnected));
      }
    };
    exports2.CRSession = CRSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/dialog.js
var require_dialog = __commonJS({
  "node_modules/playwright-core/lib/server/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Dialog = void 0;
    var _utils = require_utils();
    var _instrumentation = require_instrumentation();
    var Dialog = class extends _instrumentation.SdkObject {
      constructor(page, type, message, onHandle, defaultValue) {
        super(page, "dialog");
        this._page = void 0;
        this._type = void 0;
        this._message = void 0;
        this._onHandle = void 0;
        this._handled = false;
        this._defaultValue = void 0;
        this._page = page;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || "";
        this._page._frameManager.dialogDidOpen(this);
      }
      page() {
        return this._page;
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      accept(promptText) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._handled, "Cannot accept dialog which is already handled!");
          this._handled = true;
          this._page._frameManager.dialogWillClose(this);
          yield this._onHandle(true, promptText);
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._handled, "Cannot dismiss dialog which is already handled!");
          this._handled = true;
          this._page._frameManager.dialogWillClose(this);
          yield this._onHandle(false);
        });
      }
      close() {
        return __async(this, null, function* () {
          if (this._type === "beforeunload")
            yield this.accept();
          else
            yield this.dismiss();
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/server/chromium/crAccessibility.js
var require_crAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(client, needle) {
      return __async(this, null, function* () {
        const {
          nodes
        } = yield client.send("Accessibility.getFullAXTree");
        const tree = CRAXNode.createTree(client, nodes);
        return {
          tree,
          needle: needle ? yield tree._findElement(needle) : null
        };
      });
    }
    var CRAXNode = class {
      constructor(client, payload) {
        this._payload = void 0;
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._client = void 0;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
          if (property.name === "hidden")
            this._hidden = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findElement(element) {
        return __async(this, null, function* () {
          const objectId = element._objectId;
          const {
            node: {
              backendNodeId
            }
          } = yield this._client.send("DOM.describeNode", {
            objectId
          });
          const needle = this.find((node) => node._payload.backendDOMNodeId === backendNodeId);
          return needle || null;
        });
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored" || this._hidden)
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      normalizedRole() {
        switch (this._role) {
          case "RootWebArea":
            return "WebArea";
          case "StaticText":
            return "text";
          default:
            return this._role;
        }
      }
      serialize() {
        const properties = /* @__PURE__ */ new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this.normalizedRole(),
          name: this._payload.name ? this._payload.name.value || "" : ""
        };
        const userStringProperties = ["description", "keyshortcuts", "roledescription", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        if (this._payload.value) {
          if (typeof this._payload.value.value === "string")
            axNode.valueString = this._payload.value.value;
          if (typeof this._payload.value.value === "number")
            axNode.valueNumber = this._payload.value.value;
        }
        if (properties.has("checked"))
          axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
        if (properties.has("pressed"))
          axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
        return axNode;
      }
      static createTree(client, payloads) {
        const nodeById = /* @__PURE__ */ new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crCoverage.js
var require_crCoverage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crCoverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRCoverage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var CRCoverage = class {
      constructor(client) {
        this._jsCoverage = void 0;
        this._cssCoverage = void 0;
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      startJSCoverage(options) {
        return __async(this, null, function* () {
          return yield this._jsCoverage.start(options);
        });
      }
      stopJSCoverage() {
        return __async(this, null, function* () {
          return yield this._jsCoverage.stop();
        });
      }
      startCSSCoverage(options) {
        return __async(this, null, function* () {
          return yield this._cssCoverage.start(options);
        });
      }
      stopCSSCoverage() {
        return __async(this, null, function* () {
          return yield this._cssCoverage.stop();
        });
      }
    };
    exports2.CRCoverage = CRCoverage;
    var JSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._scriptIds = void 0;
        this._scriptSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = /* @__PURE__ */ new Set();
        this._scriptSources = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start(options) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._enabled, "JSCoverage is already enabled");
          const {
            resetOnNavigation = true,
            reportAnonymousScripts = false
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._reportAnonymousScripts = reportAnonymousScripts;
          this._enabled = true;
          this._scriptIds.clear();
          this._scriptSources.clear();
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))];
          yield Promise.all([this._client.send("Profiler.enable"), this._client.send("Profiler.startPreciseCoverage", {
            callCount: true,
            detailed: true
          }), this._client.send("Debugger.enable"), this._client.send("Debugger.setSkipAllPauses", {
            skip: true
          })]);
        });
      }
      _onDebuggerPaused() {
        this._client.send("Debugger.resume");
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptIds.clear();
        this._scriptSources.clear();
      }
      _onScriptParsed(event) {
        return __async(this, null, function* () {
          this._scriptIds.add(event.scriptId);
          if (!event.url && !this._reportAnonymousScripts)
            return;
          const response = yield this._client._sendMayFail("Debugger.getScriptSource", {
            scriptId: event.scriptId
          });
          if (response)
            this._scriptSources.set(event.scriptId, response.scriptSource);
        });
      }
      stop() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._enabled, "JSCoverage is not enabled");
          this._enabled = false;
          const [profileResponse] = yield Promise.all([this._client.send("Profiler.takePreciseCoverage"), this._client.send("Profiler.stopPreciseCoverage"), this._client.send("Profiler.disable"), this._client.send("Debugger.disable")]);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          const coverage = {
            entries: []
          };
          for (const entry of profileResponse.result) {
            if (!this._scriptIds.has(entry.scriptId))
              continue;
            if (!entry.url && !this._reportAnonymousScripts)
              continue;
            const source = this._scriptSources.get(entry.scriptId);
            if (source)
              coverage.entries.push(__spreadProps(__spreadValues({}, entry), {
                source
              }));
            else
              coverage.entries.push(entry);
          }
          return coverage;
        });
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._stylesheetURLs = void 0;
        this._stylesheetSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = /* @__PURE__ */ new Map();
        this._stylesheetSources = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start(options) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._enabled, "CSSCoverage is already enabled");
          const {
            resetOnNavigation = true
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._enabled = true;
          this._stylesheetURLs.clear();
          this._stylesheetSources.clear();
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))];
          yield Promise.all([this._client.send("DOM.enable"), this._client.send("CSS.enable"), this._client.send("CSS.startRuleUsageTracking")]);
        });
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      _onStyleSheet(event) {
        return __async(this, null, function* () {
          const header = event.header;
          if (!header.sourceURL)
            return;
          const response = yield this._client._sendMayFail("CSS.getStyleSheetText", {
            styleSheetId: header.styleSheetId
          });
          if (response) {
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
          }
        });
      }
      stop() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._enabled, "CSSCoverage is not enabled");
          this._enabled = false;
          const ruleTrackingResponse = yield this._client.send("CSS.stopRuleUsageTracking");
          yield Promise.all([this._client.send("CSS.disable"), this._client.send("DOM.disable")]);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
          for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
              ranges = [];
              styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
              startOffset: entry.startOffset,
              endOffset: entry.endOffset,
              count: entry.used ? 1 : 0
            });
          }
          const coverage = {
            entries: []
          };
          for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.entries.push({
              url,
              ranges,
              text
            });
          }
          return coverage;
        });
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({
          offset: range.startOffset,
          type: 0,
          range
        });
        points.push({
          offset: range.endOffset,
          type: 1,
          range
        });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({
              start: lastOffset,
              end: point.offset
            });
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js
var require_crProtocolHelper = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.exceptionToError = exceptionToError;
    exports2.getExceptionMessage = getExceptionMessage;
    exports2.readProtocolStream = readProtocolStream;
    exports2.releaseObject = releaseObject;
    exports2.toButtonsMask = toButtonsMask;
    exports2.toConsoleMessageLocation = toConsoleMessageLocation;
    exports2.toModifiersMask = toModifiersMask;
    var _fs = _interopRequireDefault(require("fs"));
    var _fileUtils = require_fileUtils();
    var _stackTrace = require_stackTrace();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getExceptionMessage(exceptionDetails) {
      if (exceptionDetails.exception)
        return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
      let message = exceptionDetails.text;
      if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
          const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
          const functionName = callframe.functionName || "<anonymous>";
          message += `
    at ${functionName} (${location2})`;
        }
      }
      return message;
    }
    function releaseObject(client, objectId) {
      return __async(this, null, function* () {
        yield client.send("Runtime.releaseObject", {
          objectId
        }).catch((error) => {
        });
      });
    }
    function readProtocolStream(client, handle, path) {
      return __async(this, null, function* () {
        let eof = false;
        let fd;
        if (path) {
          yield (0, _fileUtils.mkdirIfNeeded)(path);
          fd = yield _fs.default.promises.open(path, "w");
        }
        const bufs = [];
        while (!eof) {
          const response = yield client.send("IO.read", {
            handle
          });
          eof = response.eof;
          const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
          bufs.push(buf);
          if (fd)
            yield fd.write(buf);
        }
        if (fd)
          yield fd.close();
        yield client.send("IO.close", {
          handle
        });
        return Buffer.concat(bufs);
      });
    }
    function toConsoleMessageLocation(stackTrace) {
      return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber
      } : {
        url: "",
        lineNumber: 0,
        columnNumber: 0
      };
    }
    function exceptionToError(exceptionDetails) {
      const messageWithStack = getExceptionMessage(exceptionDetails);
      const lines = messageWithStack.split("\n");
      const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
      let messageWithName = "";
      let stack = "";
      if (firstStackTraceLine === -1) {
        messageWithName = messageWithStack;
      } else {
        messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
        stack = messageWithStack;
      }
      const {
        name,
        message
      } = (0, _stackTrace.splitErrorMessage)(messageWithName);
      const err = new Error(message);
      err.stack = stack;
      err.name = name;
      return err;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Meta"))
        mask |= 4;
      if (modifiers.has("Shift"))
        mask |= 8;
      return mask;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crDragDrop.js
var require_crDragDrop = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDragDrop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DragManager = void 0;
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var DragManager = class {
      constructor(page) {
        this._crPage = void 0;
        this._dragState = null;
        this._lastPosition = {
          x: 0,
          y: 0
        };
        this._crPage = page;
      }
      cancelDrag() {
        return __async(this, null, function* () {
          if (!this._dragState)
            return false;
          yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "dragCancel",
            x: this._lastPosition.x,
            y: this._lastPosition.y,
            data: {
              items: [],
              dragOperationsMask: 65535
            }
          });
          this._dragState = null;
          return true;
        });
      }
      interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
        return __async(this, null, function* () {
          this._lastPosition = {
            x,
            y
          };
          if (this._dragState) {
            yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
              type: "dragOver",
              x,
              y,
              data: this._dragState,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
            return;
          }
          if (button !== "left")
            return moveCallback();
          const client = this._crPage._mainFrameSession._client;
          let onDragIntercepted;
          const dragInterceptedPromise = new Promise((x2) => onDragIntercepted = x2);
          yield Promise.all(this._crPage._page.frames().map((frame) => __async(this, null, function* () {
            yield frame.nonStallingEvaluateInExistingContext(function() {
              let didStartDrag = Promise.resolve(false);
              let dragEvent = null;
              const dragListener = (event) => dragEvent = event;
              const mouseListener = () => {
                didStartDrag = new Promise((callback) => {
                  window.addEventListener("dragstart", dragListener, {
                    once: true,
                    capture: true
                  });
                  setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
                });
              };
              window.addEventListener("mousemove", mouseListener, {
                once: true,
                capture: true
              });
              window.__cleanupDrag = () => __async(this, null, function* () {
                const val = yield didStartDrag;
                window.removeEventListener("mousemove", mouseListener, {
                  capture: true
                });
                window.removeEventListener("dragstart", dragListener, {
                  capture: true
                });
                delete window.__cleanupDrag;
                return val;
              });
            }.toString(), true, "utility").catch(() => {
            });
          })));
          client.on("Input.dragIntercepted", onDragIntercepted);
          try {
            yield client.send("Input.setInterceptDrags", {
              enabled: true
            });
          } catch (e) {
            client.off("Input.dragIntercepted", onDragIntercepted);
            return moveCallback();
          }
          yield moveCallback();
          const expectingDrag = (yield Promise.all(this._crPage._page.frames().map((frame) => __async(this, null, function* () {
            return frame.nonStallingEvaluateInExistingContext("window.__cleanupDrag && window.__cleanupDrag()", false, "utility").catch(() => false);
          })))).some((x2) => x2);
          this._dragState = expectingDrag ? (yield dragInterceptedPromise).data : null;
          client.off("Input.dragIntercepted", onDragIntercepted);
          yield client.send("Input.setInterceptDrags", {
            enabled: false
          });
          if (this._dragState) {
            yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
              type: "dragEnter",
              x,
              y,
              data: this._dragState,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
          }
        });
      }
      isDragging() {
        return !!this._dragState;
      }
      drop(x, y, modifiers) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._dragState, "missing drag state");
          yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "drop",
            x,
            y,
            data: this._dragState,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
          });
          this._dragState = null;
        });
      }
    };
    exports2.DragManager = DragManager;
  }
});

// node_modules/playwright-core/lib/server/chromium/crExecutionContext.js
var require_crExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRExecutionContext = void 0;
    var _crProtocolHelper = require_crProtocolHelper();
    var js = _interopRequireWildcard(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRExecutionContext = class {
      constructor(client, contextPayload) {
        this._client = void 0;
        this._contextId = void 0;
        this._client = client;
        this._contextId = contextPayload.id;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: true
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return remoteObject.value;
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return remoteObject.objectId;
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._contextId,
          userGesture: true
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.callFunctionOn", {
            functionDeclaration: expression,
            objectId: utilityScript._objectId,
            arguments: [{
              objectId: utilityScript._objectId
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId
            }))],
            returnByValue,
            awaitPromise: true,
            userGesture: true
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return returnByValue ? (0, _utilityScriptSerializers.parseEvaluationResultValue)(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._client.send("Runtime.getProperties", {
            objectId,
            ownProperties: true
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.result) {
            if (!property.enumerable || !property.value)
              continue;
            result.set(property.name, context.createHandle(property.value));
          }
          return result;
        });
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield (0, _crProtocolHelper.releaseObject)(this._client, objectId);
        });
      }
      objectCount(objectId) {
        return __async(this, null, function* () {
          const result = yield this._client.send("Runtime.queryObjects", {
            prototypeObjectId: objectId
          });
          const match = result.objects.description.match(/Array\((\d+)\)/);
          return +match[1];
        });
      }
    };
    exports2.CRExecutionContext = CRExecutionContext;
    function rewriteError(error) {
      if (error.message.includes("Object reference chain is too long"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error.message.includes("Object couldn't be returned by value"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error, error.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview)
        return js.sparseArrayToString(object.preview.properties);
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/macEditingCommands.js
var require_macEditingCommands = __commonJS({
  "node_modules/playwright-core/lib/server/macEditingCommands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.macEditingCommands = void 0;
    var macEditingCommands = {
      "Backspace": "deleteBackward:",
      "Enter": "insertNewline:",
      "NumpadEnter": "insertNewline:",
      "Escape": "cancelOperation:",
      "ArrowUp": "moveUp:",
      "ArrowDown": "moveDown:",
      "ArrowLeft": "moveLeft:",
      "ArrowRight": "moveRight:",
      "F5": "complete:",
      "Delete": "deleteForward:",
      "Home": "scrollToBeginningOfDocument:",
      "End": "scrollToEndOfDocument:",
      "PageUp": "scrollPageUp:",
      "PageDown": "scrollPageDown:",
      "Shift+Backspace": "deleteBackward:",
      "Shift+Enter": "insertNewline:",
      "Shift+NumpadEnter": "insertNewline:",
      "Shift+Escape": "cancelOperation:",
      "Shift+ArrowUp": "moveUpAndModifySelection:",
      "Shift+ArrowDown": "moveDownAndModifySelection:",
      "Shift+ArrowLeft": "moveLeftAndModifySelection:",
      "Shift+ArrowRight": "moveRightAndModifySelection:",
      "Shift+F5": "complete:",
      "Shift+Delete": "deleteForward:",
      "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+End": "moveToEndOfDocumentAndModifySelection:",
      "Shift+PageUp": "pageUpAndModifySelection:",
      "Shift+PageDown": "pageDownAndModifySelection:",
      "Shift+Numpad5": "delete:",
      "Control+Tab": "selectNextKeyView:",
      "Control+Enter": "insertLineBreak:",
      "Control+NumpadEnter": "insertLineBreak:",
      "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
      "Control+KeyA": "moveToBeginningOfParagraph:",
      "Control+KeyB": "moveBackward:",
      "Control+KeyD": "deleteForward:",
      "Control+KeyE": "moveToEndOfParagraph:",
      "Control+KeyF": "moveForward:",
      "Control+KeyH": "deleteBackward:",
      "Control+KeyK": "deleteToEndOfParagraph:",
      "Control+KeyL": "centerSelectionInVisibleArea:",
      "Control+KeyN": "moveDown:",
      "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
      "Control+KeyP": "moveUp:",
      "Control+KeyT": "transpose:",
      "Control+KeyV": "pageDown:",
      "Control+KeyY": "yank:",
      "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Control+ArrowUp": "scrollPageUp:",
      "Control+ArrowDown": "scrollPageDown:",
      "Control+ArrowLeft": "moveToLeftEndOfLine:",
      "Control+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Control+Enter": "insertLineBreak:",
      "Shift+Control+NumpadEnter": "insertLineBreak:",
      "Shift+Control+Tab": "selectPreviousKeyView:",
      "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
      "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
      "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
      "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
      "Shift+Control+KeyF": "moveForwardAndModifySelection:",
      "Shift+Control+KeyN": "moveDownAndModifySelection:",
      "Shift+Control+KeyP": "moveUpAndModifySelection:",
      "Shift+Control+KeyV": "pageDownAndModifySelection:",
      "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Shift+Control+ArrowUp": "scrollPageUp:",
      "Shift+Control+ArrowDown": "scrollPageDown:",
      "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Alt+Backspace": "deleteWordBackward:",
      "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Alt+Escape": "complete:",
      "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
      "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
      "Alt+ArrowLeft": "moveWordLeft:",
      "Alt+ArrowRight": "moveWordRight:",
      "Alt+Delete": "deleteWordForward:",
      "Alt+PageUp": "pageUp:",
      "Alt+PageDown": "pageDown:",
      "Shift+Alt+Backspace": "deleteWordBackward:",
      "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+Escape": "complete:",
      "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
      "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
      "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
      "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
      "Shift+Alt+Delete": "deleteWordForward:",
      "Shift+Alt+PageUp": "pageUp:",
      "Shift+Alt+PageDown": "pageDown:",
      "Control+Alt+KeyB": "moveWordBackward:",
      "Control+Alt+KeyF": "moveWordForward:",
      "Control+Alt+Backspace": "deleteWordBackward:",
      "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
      "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
      "Shift+Control+Alt+Backspace": "deleteWordBackward:",
      "Meta+NumpadSubtract": "cancel:",
      "Meta+Backspace": "deleteToBeginningOfLine:",
      "Meta+ArrowUp": "moveToBeginningOfDocument:",
      "Meta+ArrowDown": "moveToEndOfDocument:",
      "Meta+ArrowLeft": "moveToLeftEndOfLine:",
      "Meta+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Meta+NumpadSubtract": "cancel:",
      "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
      "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Meta+KeyA": "selectAll:",
      "Meta+KeyC": "copy:",
      "Meta+KeyX": "cut:",
      "Meta+KeyV": "paste:",
      "Meta+KeyZ": "undo:",
      "Shift+Meta+KeyZ": "redo:"
    };
    exports2.macEditingCommands = macEditingCommands;
  }
});

// node_modules/playwright-core/lib/server/chromium/crInput.js
var require_crInput = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var RawKeyboardImpl = class {
      constructor(_client, _isMac, _dragManger) {
        this._client = _client;
        this._isMac = _isMac;
        this._dragManger = _dragManger;
      }
      _commandsForCode(code, modifiers) {
        if (!this._isMac)
          return [];
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = _macEditingCommands.macEditingCommands[shortcut] || [];
        if ((0, _utils.isString)(commands))
          commands = [commands];
        commands = commands.filter((x) => !x.startsWith("insert"));
        return commands.map((c) => c.substring(0, c.length - 1));
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          if (code === "Escape" && (yield this._dragManger.cancelDrag()))
            return;
          const commands = this._commandsForCode(code, modifiers);
          yield this._client.send("Input.dispatchKeyEvent", {
            type: text ? "keyDown" : "rawKeyDown",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            commands,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            location: location2,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          yield this._client.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            key,
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            location: location2
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._client.send("Input.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(page, client, dragManager) {
        this._client = void 0;
        this._page = void 0;
        this._dragManager = void 0;
        this._page = page;
        this._client = client;
        this._dragManager = dragManager;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          const actualMove = () => __async(this, null, function* () {
            yield this._client.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              button,
              buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
              x,
              y,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
          });
          if (forClick) {
            return actualMove();
          }
          yield this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, actualMove);
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          if (this._dragManager.isDragging())
            return;
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mousePressed",
            button,
            buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          if (this._dragManager.isDragging()) {
            yield this._dragManager.drop(x, y, modifiers);
            return;
          }
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            button,
            buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            deltaX,
            deltaY
          });
        });
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield Promise.all([this._client.send("Input.dispatchTouchEvent", {
            type: "touchStart",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            touchPoints: [{
              x,
              y
            }]
          }), this._client.send("Input.dispatchTouchEvent", {
            type: "touchEnd",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            touchPoints: []
          })]);
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/chromium/crNetworkManager.js
var require_crNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crNetworkManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRNetworkManager = void 0;
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network2());
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRNetworkManager = class {
      constructor(session, page, serviceWorker, parentManager) {
        this._session = void 0;
        this._page = void 0;
        this._serviceWorker = void 0;
        this._parentManager = void 0;
        this._requestIdToRequest = /* @__PURE__ */ new Map();
        this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
        this._credentials = null;
        this._attemptedAuthentications = /* @__PURE__ */ new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._requestIdToRequestPausedEvent = /* @__PURE__ */ new Map();
        this._eventListeners = void 0;
        this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
        this._session = session;
        this._page = page;
        this._serviceWorker = serviceWorker;
        this._parentManager = parentManager;
        this._eventListeners = this.instrumentNetworkEvents({
          session
        });
      }
      instrumentNetworkEvents(sessionInfo) {
        const listeners = [_eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Fetch.requestPaused", this._onRequestPaused.bind(this, sessionInfo)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Fetch.authRequired", this._onAuthRequired.bind(this)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, sessionInfo)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.requestServedFromCache", this._onRequestServedFromCache.bind(this)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.responseReceived", this._onResponseReceived.bind(this, sessionInfo)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.responseReceivedExtraInfo", this._onResponseReceivedExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.loadingFinished", this._onLoadingFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.loadingFailed", this._onLoadingFailed.bind(this, sessionInfo))];
        if (this._page) {
          listeners.push(...[_eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(sessionInfo.session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))]);
        }
        return listeners;
      }
      initialize() {
        return __async(this, null, function* () {
          yield this._session.send("Network.enable");
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      authenticate(credentials) {
        return __async(this, null, function* () {
          this._credentials = credentials;
          yield this._updateProtocolRequestInterception();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          yield this._session.send("Network.emulateNetworkConditions", {
            offline,
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1
          });
        });
      }
      setRequestInterception(value) {
        return __async(this, null, function* () {
          this._userRequestInterceptionEnabled = value;
          yield this._updateProtocolRequestInterception();
        });
      }
      _updateProtocolRequestInterception() {
        return __async(this, null, function* () {
          const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
          if (enabled === this._protocolRequestInterceptionEnabled)
            return;
          this._protocolRequestInterceptionEnabled = enabled;
          if (enabled) {
            yield Promise.all([this._session.send("Network.setCacheDisabled", {
              cacheDisabled: true
            }), this._session.send("Fetch.enable", {
              handleAuthRequests: true,
              patterns: [{
                urlPattern: "*",
                requestStage: "Request"
              }]
            })]);
          } else {
            yield Promise.all([this._session.send("Network.setCacheDisabled", {
              cacheDisabled: false
            }), this._session.send("Fetch.disable")]);
          }
        });
      }
      clearCache() {
        return __async(this, null, function* () {
          yield this._session.send("Network.setCacheDisabled", {
            cacheDisabled: true
          });
          if (!this._protocolRequestInterceptionEnabled)
            yield this._session.send("Network.setCacheDisabled", {
              cacheDisabled: false
            });
          yield this._session.send("Network.clearBrowserCache");
        });
      }
      _onRequestWillBeSent(sessionInfo, event) {
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
          if (requestPausedEvent) {
            this._onRequest(sessionInfo, event, requestPausedEvent);
            this._requestIdToRequestPausedEvent.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
        } else {
          this._onRequest(sessionInfo, event, null);
        }
      }
      _onRequestServedFromCache(event) {
        this._responseExtraInfoTracker.requestServedFromCache(event);
      }
      _onRequestWillBeSentExtraInfo(event) {
        this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
      }
      _onAuthRequired(event) {
        let response = "Default";
        const shouldProvideCredentials = this._shouldProvideCredentials(event.request.url);
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (shouldProvideCredentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const {
          username,
          password
        } = shouldProvideCredentials && this._credentials ? this._credentials : {
          username: void 0,
          password: void 0
        };
        this._session._sendMayFail("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: {
            response,
            username,
            password
          }
        });
      }
      _shouldProvideCredentials(url) {
        if (!this._credentials)
          return false;
        return !this._credentials.origin || new URL(url).origin.toLowerCase() === this._credentials.origin.toLowerCase();
      }
      _onRequestPaused(sessionInfo, event) {
        if (!event.networkId) {
          this._session._sendMayFail("Fetch.failRequest", {
            requestId: event.requestId,
            errorReason: "Aborted"
          });
          return;
        }
        if (event.request.url.startsWith("data:"))
          return;
        const requestId = event.networkId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
          this._onRequest(sessionInfo, requestWillBeSentEvent, event);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToRequestPausedEvent.set(requestId, event);
        }
      }
      _onRequest(sessionInfo, requestWillBeSentEvent, requestPausedEvent) {
        var _this$_page, _this$_page2, _this$_page3;
        if (requestWillBeSentEvent.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (requestWillBeSentEvent.redirectResponse) {
          const request2 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp, requestWillBeSentEvent.redirectHasExtraInfo);
            redirectedFrom = request2;
          }
        }
        let frame = requestWillBeSentEvent.frameId ? (_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page._frameManager.frame(requestWillBeSentEvent.frameId) : sessionInfo.workerFrame;
        if (!frame && this._page && requestPausedEvent && requestPausedEvent.frameId)
          frame = this._page._frameManager.frame(requestPausedEvent.frameId);
        if (!frame && this._page && requestWillBeSentEvent.frameId === ((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2._delegate)._targetId) {
          frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
        }
        const isInterceptedOptionsPreflight = !!requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && requestWillBeSentEvent.initiator.type === "preflight";
        if (isInterceptedOptionsPreflight && (this._page || this._serviceWorker).needsRequestInterception()) {
          const requestHeaders = requestPausedEvent.request.headers;
          const responseHeaders = [{
            name: "Access-Control-Allow-Origin",
            value: requestHeaders["Origin"] || "*"
          }, {
            name: "Access-Control-Allow-Methods",
            value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE"
          }, {
            name: "Access-Control-Allow-Credentials",
            value: "true"
          }];
          if (requestHeaders["Access-Control-Request-Headers"])
            responseHeaders.push({
              name: "Access-Control-Allow-Headers",
              value: requestHeaders["Access-Control-Request-Headers"]
            });
          this._session._sendMayFail("Fetch.fulfillRequest", {
            requestId: requestPausedEvent.requestId,
            responseCode: 204,
            responsePhrase: network.STATUS_TEXTS["204"],
            responseHeaders,
            body: ""
          });
          return;
        }
        if (!frame && !this._serviceWorker) {
          if (requestPausedEvent)
            this._session._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          return;
        }
        let route = null;
        if (requestPausedEvent) {
          if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled)
            this._session._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          else
            route = new RouteImpl(this._session, requestPausedEvent.requestId);
        }
        const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
        const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
        const request = new InterceptableRequest({
          session: sessionInfo.session,
          context: (this._page || this._serviceWorker)._browserContext,
          frame: frame || null,
          serviceWorker: this._serviceWorker || null,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        });
        this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);
        if (requestPausedEvent && !requestPausedEvent.responseStatusCode && !requestPausedEvent.responseErrorReason) {
          request.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(requestPausedEvent.request.headers, "\n"));
        }
        (((_this$_page3 = this._page) === null || _this$_page3 === void 0 ? void 0 : _this$_page3._frameManager) || this._serviceWorker).requestStarted(request.request, route || void 0);
      }
      _createResponse(request, responsePayload, hasExtraInfo) {
        var _responsePayload$secu, _responsePayload$secu2, _responsePayload$secu3, _responsePayload$secu4, _responsePayload$secu5;
        const getResponseBody = () => __async(this, null, function* () {
          const contentLengthHeader = Object.entries(responsePayload.headers).find((header) => header[0].toLowerCase() === "content-length");
          const expectedLength = contentLengthHeader ? +contentLengthHeader[1] : void 0;
          const session = request.session;
          const response2 = yield session.send("Network.getResponseBody", {
            requestId: request._requestId
          });
          if (response2.body || !expectedLength)
            return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
          const resource = yield session.send("Network.loadNetworkResource", {
            url: request.request.url(),
            frameId: this._serviceWorker ? void 0 : request.request.frame()._id,
            options: {
              disableCache: false,
              includeCredentials: true
            }
          });
          const chunks = [];
          while (resource.resource.stream) {
            const chunk = yield session.send("IO.read", {
              handle: resource.resource.stream
            });
            chunks.push(Buffer.from(chunk.data, chunk.base64Encoded ? "base64" : "utf-8"));
            if (chunk.eof) {
              yield session.send("IO.close", {
                handle: resource.resource.stream
              });
              break;
            }
          }
          return Buffer.concat(chunks);
        });
        const timingPayload = responsePayload.timing;
        let timing;
        if (timingPayload && !this._responseExtraInfoTracker.servedFromCache(request._requestId)) {
          timing = {
            startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1e3,
            domainLookupStart: timingPayload.dnsStart,
            domainLookupEnd: timingPayload.dnsEnd,
            connectStart: timingPayload.connectStart,
            secureConnectionStart: timingPayload.sslStart,
            connectEnd: timingPayload.connectEnd,
            requestStart: timingPayload.sendStart,
            responseStart: timingPayload.receiveHeadersEnd
          };
        } else {
          timing = {
            startTime: request._wallTime * 1e3,
            domainLookupStart: -1,
            domainLookupEnd: -1,
            connectStart: -1,
            secureConnectionStart: -1,
            connectEnd: -1,
            requestStart: -1,
            responseStart: -1
          };
        }
        const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers), timing, getResponseBody, !!responsePayload.fromServiceWorker, responsePayload.protocol);
        if (responsePayload !== null && responsePayload !== void 0 && responsePayload.remoteIPAddress && typeof (responsePayload === null || responsePayload === void 0 ? void 0 : responsePayload.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu = responsePayload.securityDetails) === null || _responsePayload$secu === void 0 ? void 0 : _responsePayload$secu.protocol,
          subjectName: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu2 = responsePayload.securityDetails) === null || _responsePayload$secu2 === void 0 ? void 0 : _responsePayload$secu2.subjectName,
          issuer: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu3 = responsePayload.securityDetails) === null || _responsePayload$secu3 === void 0 ? void 0 : _responsePayload$secu3.issuer,
          validFrom: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu4 = responsePayload.securityDetails) === null || _responsePayload$secu4 === void 0 ? void 0 : _responsePayload$secu4.validFrom,
          validTo: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu5 = responsePayload.securityDetails) === null || _responsePayload$secu5 === void 0 ? void 0 : _responsePayload$secu5.validTo
        });
        this._responseExtraInfoTracker.processResponse(request._requestId, response, hasExtraInfo);
        return response;
      }
      _handleRequestRedirect(request, responsePayload, timestamp, hasExtraInfo) {
        var _this$_page4, _this$_page5;
        const response = this._createResponse(request, responsePayload, hasExtraInfo);
        response.setTransferSize(null);
        response.setEncodedBodySize(null);
        response._requestFinished((timestamp - request._timestamp) * 1e3);
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        (((_this$_page4 = this._page) === null || _this$_page4 === void 0 ? void 0 : _this$_page4._frameManager) || this._serviceWorker).requestReceivedResponse(response);
        (((_this$_page5 = this._page) === null || _this$_page5 === void 0 ? void 0 : _this$_page5._frameManager) || this._serviceWorker).reportRequestFinished(request.request, response);
      }
      _onResponseReceivedExtraInfo(event) {
        this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
      }
      _onResponseReceived(sessionInfo, event) {
        var _this$_page6;
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request && event.response.fromServiceWorker) {
          const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
          if (requestWillBeSentEvent) {
            this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
            this._onRequest(sessionInfo, requestWillBeSentEvent, null);
            request = this._requestIdToRequest.get(event.requestId);
          }
        }
        if (!request)
          return;
        const response = this._createResponse(request, event.response, event.hasExtraInfo);
        (((_this$_page6 = this._page) === null || _this$_page6 === void 0 ? void 0 : _this$_page6._frameManager) || this._serviceWorker).requestReceivedResponse(response);
      }
      _onLoadingFinished(event) {
        var _this$_page7;
        this._responseExtraInfoTracker.loadingFinished(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          response.setTransferSize(event.encodedDataLength);
          response.responseHeadersSize().then((size) => response.setEncodedBodySize(event.encodedDataLength - size));
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        (((_this$_page7 = this._page) === null || _this$_page7 === void 0 ? void 0 : _this$_page7._frameManager) || this._serviceWorker).reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(sessionInfo, event) {
        var _this$_page8;
        this._responseExtraInfoTracker.loadingFailed(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request) {
          const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
          if (requestWillBeSentEvent) {
            this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
            this._onRequest(sessionInfo, requestWillBeSentEvent, null);
            request = this._requestIdToRequest.get(event.requestId);
          }
        }
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          response.setTransferSize(null);
          response.setEncodedBodySize(null);
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        (((_this$_page8 = this._page) === null || _this$_page8 === void 0 ? void 0 : _this$_page8._frameManager) || this._serviceWorker).requestFailed(request.request, !!event.canceled);
      }
      _maybeAdoptMainRequest(requestId) {
        if (!this._parentManager)
          return;
        const request = this._parentManager._requestIdToRequest.get(requestId);
        if (!request || request._documentId !== requestId)
          return;
        this._requestIdToRequest.set(requestId, request);
        request.session = this._session;
        this._parentManager._requestIdToRequest.delete(requestId);
        if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
          this._parentManager._attemptedAuthentications.delete(request._interceptionId);
          this._attemptedAuthentications.add(request._interceptionId);
        }
        return request;
      }
    };
    exports2.CRNetworkManager = CRNetworkManager;
    var InterceptableRequest = class {
      constructor(options) {
        this.request = void 0;
        this._requestId = void 0;
        this._interceptionId = void 0;
        this._documentId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        this.session = void 0;
        const {
          session,
          context,
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom,
          serviceWorker
        } = options;
        this.session = session;
        this._timestamp = requestWillBeSentEvent.timestamp;
        this._wallTime = requestWillBeSentEvent.wallTime;
        this._requestId = requestWillBeSentEvent.requestId;
        this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
        this._documentId = documentId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const {
          headers,
          method,
          url,
          postDataEntries = null
        } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
        const type = (requestWillBeSentEvent.type || "").toLowerCase();
        let postDataBuffer = null;
        if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes)
          postDataBuffer = Buffer.from(postDataEntries[0].bytes, "base64");
        this.request = new network.Request(context, frame, serviceWorker, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, url, type, method, postDataBuffer, (0, _utils.headersObjectToArray)(headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
    };
    var RouteImpl = class {
      constructor(session, interceptionId) {
        this._session = void 0;
        this._interceptionId = void 0;
        this._session = session;
        this._interceptionId = interceptionId;
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._session._sendMayFail("Fetch.continueRequest", {
            requestId: this._interceptionId,
            url: overrides.url,
            headers: overrides.headers,
            method: overrides.method,
            postData: overrides.postData ? overrides.postData.toString("base64") : void 0
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
          const responseHeaders = splitSetCookieHeader(response.headers);
          yield this._session._sendMayFail("Fetch.fulfillRequest", {
            requestId: this._interceptionId,
            responseCode: response.status,
            responsePhrase: network.STATUS_TEXTS[String(response.status)],
            responseHeaders,
            body
          });
        });
      }
      abort(errorCode = "failed") {
        return __async(this, null, function* () {
          const errorReason = errorReasons[errorCode];
          (0, _utils.assert)(errorReason, "Unknown error code: " + errorCode);
          yield this._session._sendMayFail("Fetch.failRequest", {
            requestId: this._interceptionId,
            errorReason
          });
        });
      }
    };
    function splitSetCookieHeader(headers) {
      const index = headers.findIndex(({
        name
      }) => name.toLowerCase() === "set-cookie");
      if (index === -1)
        return headers;
      const header = headers[index];
      const values = header.value.split("\n");
      if (values.length === 1)
        return headers;
      const result = headers.slice();
      result.splice(index, 1, ...values.map((value) => ({
        name: header.name,
        value
      })));
      return result;
    }
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
    var ResponseExtraInfoTracker = class {
      constructor() {
        this._requests = /* @__PURE__ */ new Map();
      }
      requestWillBeSentExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.requestWillBeSentExtraInfo.push(event);
        this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);
        this._checkFinished(info);
      }
      requestServedFromCache(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.servedFromCache = true;
      }
      servedFromCache(requestId) {
        const info = this._requests.get(requestId);
        return !!(info !== null && info !== void 0 && info.servedFromCache);
      }
      responseReceivedExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.responseReceivedExtraInfo.push(event);
        this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);
        this._checkFinished(info);
      }
      processResponse(requestId, response, hasExtraInfo) {
        var _info;
        let info = this._requests.get(requestId);
        if (!hasExtraInfo || (_info = info) !== null && _info !== void 0 && _info.servedFromCache) {
          response.request().setRawRequestHeaders(null);
          response.setResponseHeadersSize(null);
          response.setRawResponseHeaders(null);
          return;
        }
        info = this._getOrCreateEntry(requestId);
        info.responses.push(response);
        this._patchHeaders(info, info.responses.length - 1);
      }
      loadingFinished(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFinished = event;
        this._checkFinished(info);
      }
      loadingFailed(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFailed = event;
        this._checkFinished(info);
      }
      _getOrCreateEntry(requestId) {
        let info = this._requests.get(requestId);
        if (!info) {
          info = {
            requestId,
            requestWillBeSentExtraInfo: [],
            responseReceivedExtraInfo: [],
            responses: []
          };
          this._requests.set(requestId, info);
        }
        return info;
      }
      _patchHeaders(info, index) {
        const response = info.responses[index];
        const requestExtraInfo = info.requestWillBeSentExtraInfo[index];
        if (response && requestExtraInfo) {
          response.request().setRawRequestHeaders((0, _utils.headersObjectToArray)(requestExtraInfo.headers, "\n"));
          info.requestWillBeSentExtraInfo[index] = void 0;
        }
        const responseExtraInfo = info.responseReceivedExtraInfo[index];
        if (response && responseExtraInfo) {
          var _responseExtraInfo$he;
          response.setResponseHeadersSize(((_responseExtraInfo$he = responseExtraInfo.headersText) === null || _responseExtraInfo$he === void 0 ? void 0 : _responseExtraInfo$he.length) || 0);
          response.setRawResponseHeaders((0, _utils.headersObjectToArray)(responseExtraInfo.headers, "\n"));
          info.responseReceivedExtraInfo[index] = void 0;
        }
      }
      _checkFinished(info) {
        if (!info.loadingFinished && !info.loadingFailed)
          return;
        if (info.responses.length <= info.responseReceivedExtraInfo.length) {
          this._stopTracking(info.requestId);
          return;
        }
      }
      _stopTracking(requestId) {
        this._requests.delete(requestId);
      }
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crPdf.js
var require_crPdf = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPdf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRPDF = void 0;
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var PagePaperFormats = {
      letter: {
        width: 8.5,
        height: 11
      },
      legal: {
        width: 8.5,
        height: 14
      },
      tabloid: {
        width: 11,
        height: 17
      },
      ledger: {
        width: 17,
        height: 11
      },
      a0: {
        width: 33.1,
        height: 46.8
      },
      a1: {
        width: 23.4,
        height: 33.1
      },
      a2: {
        width: 16.54,
        height: 23.4
      },
      a3: {
        width: 11.7,
        height: 16.54
      },
      a4: {
        width: 8.27,
        height: 11.7
      },
      a5: {
        width: 5.83,
        height: 8.27
      },
      a6: {
        width: 4.13,
        height: 5.83
      }
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(text) {
      if (text === void 0)
        return void 0;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unitToPixels.hasOwnProperty(unit)) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      (0, _utils.assert)(!isNaN(value), "Failed to parse parameter value: " + text);
      const pixels = value * unitToPixels[unit];
      return pixels / 96;
    }
    var CRPDF = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      generate(options) {
        return __async(this, null, function* () {
          const {
            scale = 1,
            displayHeaderFooter = false,
            headerTemplate = "",
            footerTemplate = "",
            printBackground = false,
            landscape = false,
            pageRanges = "",
            preferCSSPageSize = false,
            margin = {}
          } = options;
          let paperWidth = 8.5;
          let paperHeight = 11;
          if (options.format) {
            const format = PagePaperFormats[options.format.toLowerCase()];
            (0, _utils.assert)(format, "Unknown paper format: " + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
          } else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
          }
          const marginTop = convertPrintParameterToInches(margin.top) || 0;
          const marginLeft = convertPrintParameterToInches(margin.left) || 0;
          const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
          const marginRight = convertPrintParameterToInches(margin.right) || 0;
          const result = yield this._client.send("Page.printToPDF", {
            transferMode: "ReturnAsStream",
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize
          });
          return yield (0, _crProtocolHelper.readProtocolStream)(this._client, result.stream, null);
        });
      }
    };
    exports2.CRPDF = CRPDF;
  }
});

// node_modules/playwright-core/lib/server/chromium/defaultFontFamilies.js
var require_defaultFontFamilies = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/defaultFontFamilies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.platformToFontFamilies = void 0;
    var platformToFontFamilies = {
      "linux": {
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Monospace",
          "serif": "Times New Roman",
          "sansSerif": "Arial",
          "cursive": "Comic Sans MS",
          "fantasy": "Impact"
        }
      },
      "mac": {
        "fontFamilies": {
          "standard": "Times",
          "fixed": "Courier",
          "serif": "Times",
          "sansSerif": "Helvetica",
          "cursive": "Apple Chancery",
          "fantasy": "Papyrus"
        },
        "forScripts": [{
          "script": "jpan",
          "fontFamilies": {
            "standard": "Hiragino Kaku Gothic ProN",
            "fixed": "Osaka-Mono",
            "serif": "Hiragino Mincho ProN",
            "sansSerif": "Hiragino Kaku Gothic ProN"
          }
        }, {
          "script": "hang",
          "fontFamilies": {
            "standard": "Apple SD Gothic Neo",
            "serif": "AppleMyungjo",
            "sansSerif": "Apple SD Gothic Neo"
          }
        }, {
          "script": "hans",
          "fontFamilies": {
            "standard": ",PingFang SC,STHeiti",
            "serif": "Songti SC",
            "sansSerif": ",PingFang SC,STHeiti",
            "cursive": "Kaiti SC"
          }
        }, {
          "script": "hant",
          "fontFamilies": {
            "standard": ",PingFang TC,Heiti TC",
            "serif": "Songti TC",
            "sansSerif": ",PingFang TC,Heiti TC",
            "cursive": "Kaiti TC"
          }
        }]
      },
      "win": {
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Consolas",
          "serif": "Times New Roman",
          "sansSerif": "Arial",
          "cursive": "Comic Sans MS",
          "fantasy": "Impact"
        },
        "forScripts": [{
          "script": "cyrl",
          "fontFamilies": {
            "standard": "Times New Roman",
            "fixed": "Courier New",
            "serif": "Times New Roman",
            "sansSerif": "Arial"
          }
        }, {
          "script": "arab",
          "fontFamilies": {
            "fixed": "Courier New",
            "sansSerif": "Segoe UI"
          }
        }, {
          "script": "grek",
          "fontFamilies": {
            "standard": "Times New Roman",
            "fixed": "Courier New",
            "serif": "Times New Roman",
            "sansSerif": "Arial"
          }
        }, {
          "script": "jpan",
          "fontFamilies": {
            "standard": ",Meiryo,Yu Gothic",
            "fixed": "MS Gothic",
            "serif": ",Yu Mincho,MS PMincho",
            "sansSerif": ",Meiryo,Yu Gothic"
          }
        }, {
          "script": "hang",
          "fontFamilies": {
            "standard": "Malgun Gothic",
            "fixed": "Gulimche",
            "serif": "Batang",
            "sansSerif": "Malgun Gothic",
            "cursive": "Gungsuh"
          }
        }, {
          "script": "hans",
          "fontFamilies": {
            "standard": "Microsoft YaHei",
            "fixed": "NSimsun",
            "serif": "Simsun",
            "sansSerif": "Microsoft YaHei",
            "cursive": "KaiTi"
          }
        }, {
          "script": "hant",
          "fontFamilies": {
            "standard": "Microsoft JhengHei",
            "fixed": "MingLiU",
            "serif": "PMingLiU",
            "sansSerif": "Microsoft JhengHei",
            "cursive": "DFKai-SB"
          }
        }]
      }
    };
    exports2.platformToFontFamilies = platformToFontFamilies;
  }
});

// node_modules/playwright-core/lib/server/chromium/videoRecorder.js
var require_videoRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/videoRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VideoRecorder = void 0;
    var _utils = require_utils();
    var _page = require_page();
    var _processLauncher = require_processLauncher();
    var _progress = require_progress();
    var _instrumentation = require_instrumentation();
    var fps = 25;
    var VideoRecorder = class {
      static launch(page, ffmpegPath, options) {
        return __async(this, null, function* () {
          if (!options.outputFile.endsWith(".webm"))
            throw new Error("File must have .webm extension");
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), page);
          controller.setLogName("browser");
          return yield controller.run((progress2) => __async(this, null, function* () {
            const recorder = new VideoRecorder(page, ffmpegPath, progress2);
            yield recorder._launch(options);
            return recorder;
          }));
        });
      }
      constructor(page, ffmpegPath, progress2) {
        this._process = null;
        this._gracefullyClose = null;
        this._lastWritePromise = Promise.resolve();
        this._lastFrameTimestamp = 0;
        this._lastFrameBuffer = null;
        this._lastWriteTimestamp = 0;
        this._progress = void 0;
        this._frameQueue = [];
        this._isStopped = false;
        this._ffmpegPath = void 0;
        this._progress = progress2;
        this._ffmpegPath = ffmpegPath;
        page.on(_page.Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.timestamp));
      }
      _launch(options) {
        return __async(this, null, function* () {
          const w = options.width;
          const h = options.height;
          const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
          args.push(options.outputFile);
          const progress2 = this._progress;
          const {
            launchedProcess,
            gracefullyClose
          } = yield (0, _processLauncher.launchProcess)({
            command: this._ffmpegPath,
            args,
            stdio: "stdin",
            log: (message) => progress2.log(message),
            tempDirectories: [],
            attemptToGracefullyClose: () => __async(this, null, function* () {
              progress2.log("Closing stdin...");
              launchedProcess.stdin.end();
            }),
            onExit: (exitCode, signal) => {
              progress2.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
            }
          });
          launchedProcess.stdin.on("finish", () => {
            progress2.log("ffmpeg finished input.");
          });
          launchedProcess.stdin.on("error", () => {
            progress2.log("ffmpeg error.");
          });
          this._process = launchedProcess;
          this._gracefullyClose = gracefullyClose;
        });
      }
      writeFrame(frame, timestamp) {
        (0, _utils.assert)(this._process);
        if (this._isStopped)
          return;
        if (this._lastFrameBuffer) {
          const durationSec = timestamp - this._lastFrameTimestamp;
          const repeatCount = Math.max(1, Math.round(fps * durationSec));
          for (let i = 0; i < repeatCount; ++i)
            this._frameQueue.push(this._lastFrameBuffer);
          this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
        }
        this._lastFrameBuffer = frame;
        this._lastFrameTimestamp = timestamp;
        this._lastWriteTimestamp = (0, _utils.monotonicTime)();
      }
      _sendFrames() {
        return __async(this, null, function* () {
          while (this._frameQueue.length)
            yield this._sendFrame(this._frameQueue.shift());
        });
      }
      _sendFrame(frame) {
        return __async(this, null, function* () {
          return new Promise((f) => this._process.stdin.write(frame, f)).then((error) => {
            if (error)
              this._progress.log(`ffmpeg failed to write: ${String(error)}`);
          });
        });
      }
      stop() {
        return __async(this, null, function* () {
          if (this._isStopped)
            return;
          this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + ((0, _utils.monotonicTime)() - this._lastWriteTimestamp) / 1e3);
          this._isStopped = true;
          yield this._lastWritePromise;
          yield this._gracefullyClose();
        });
      }
    };
    exports2.VideoRecorder = VideoRecorder;
  }
});

// node_modules/playwright-core/lib/server/chromium/crPage.js
var require_crPage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRPage = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _eventsHelper = require_eventsHelper();
    var _registry = require_registry();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var frames = _interopRequireWildcard(require_frames());
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network2());
    var _page = require_page();
    var _crAccessibility = require_crAccessibility();
    var _crBrowser = require_crBrowser();
    var _crConnection = require_crConnection();
    var _crCoverage = require_crCoverage();
    var _crDragDrop = require_crDragDrop();
    var _crExecutionContext = require_crExecutionContext();
    var _crInput = require_crInput();
    var _crNetworkManager = require_crNetworkManager();
    var _crPdf = require_crPdf();
    var _crProtocolHelper = require_crProtocolHelper();
    var _defaultFontFamilies = require_defaultFontFamilies();
    var _videoRecorder = require_videoRecorder();
    var _browserContext = require_browserContext();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var CRPage = class {
      static mainFrameSession(page) {
        const crPage = page._delegate;
        return crPage._mainFrameSession;
      }
      constructor(client, targetId, browserContext, opener, bits) {
        this._mainFrameSession = void 0;
        this._sessions = /* @__PURE__ */ new Map();
        this._page = void 0;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._targetId = void 0;
        this._opener = void 0;
        this._pdf = void 0;
        this._coverage = void 0;
        this._browserContext = void 0;
        this._pagePromise = void 0;
        this._initializedPage = null;
        this._isBackgroundPage = void 0;
        this._nextWindowOpenPopupFeatures = [];
        this._targetId = targetId;
        this._opener = opener;
        this._isBackgroundPage = bits.isBackgroundPage;
        const dragManager = new _crDragDrop.DragManager(this);
        this.rawKeyboard = new _crInput.RawKeyboardImpl(client, browserContext._browser._platform() === "mac", dragManager);
        this.rawMouse = new _crInput.RawMouseImpl(this, client, dragManager);
        this.rawTouchscreen = new _crInput.RawTouchscreenImpl(client);
        this._pdf = new _crPdf.CRPDF(client);
        this._coverage = new _crCoverage.CRCoverage(client);
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this._mainFrameSession = new FrameSession(this, client, targetId, null);
        this._sessions.set(targetId, this._mainFrameSession);
        client.once(_crConnection.CRSessionEvents.Disconnected, () => this._page._didDisconnect());
        if (opener && !browserContext._options.noDefaultViewport) {
          const features = opener._nextWindowOpenPopupFeatures.shift() || [];
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(features);
          if (viewportSize)
            this._page._emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
        this._pagePromise = this._mainFrameSession._initialize(bits.hasUIWindow).then((r) => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          return r;
        })).catch((e) => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          throw e;
        })).then(() => {
          this._initializedPage = this._page;
          this._reportAsNew();
          return this._page;
        }).catch((e) => {
          this._reportAsNew(e);
          return e;
        });
      }
      potentiallyUninitializedPage() {
        return this._page;
      }
      _reportAsNew(error) {
        this._page.reportAsNew(error, this._isBackgroundPage ? _crBrowser.CRBrowserContext.CREvents.BackgroundPage : _browserContext.BrowserContext.Events.Page);
      }
      _forAllFrameSessions(cb) {
        return __async(this, null, function* () {
          const frameSessions = Array.from(this._sessions.values());
          yield Promise.all(frameSessions.map((frameSession) => {
            if (frameSession._isMainFrame())
              return cb(frameSession);
            return cb(frameSession).catch((e) => {
              if (e.message && e.message.includes("Target closed"))
                return;
              throw e;
            });
          }));
        });
      }
      _sessionForFrame(frame) {
        while (!this._sessions.has(frame._id)) {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error(`Frame has been detached.`);
          frame = parent;
        }
        return this._sessions.get(frame._id);
      }
      _sessionForHandle(handle) {
        const frame = handle._context.frame;
        return this._sessionForFrame(frame);
      }
      willBeginDownload() {
        this._mainFrameSession._willBeginDownload();
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      didClose() {
        for (const session of this._sessions.values())
          session.dispose();
        this._page._didClose();
      }
      navigateFrame(frame, url, referrer) {
        return __async(this, null, function* () {
          return this._sessionForFrame(frame)._navigate(frame, url, referrer);
        });
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._initBinding(binding));
          yield Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(binding.source).catch((e) => {
          })));
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._removeExposedBindings());
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateExtraHTTPHeaders(false));
        });
      }
      updateGeolocation() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
        });
      }
      updateOffline() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateOffline(false));
        });
      }
      updateHttpCredentials() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateHttpCredentials(false));
        });
      }
      updateEmulatedViewportSize(preserveWindowBoundaries) {
        return __async(this, null, function* () {
          yield this._mainFrameSession._updateViewport(preserveWindowBoundaries);
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.bringToFront");
        });
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateEmulateMedia());
        });
      }
      updateUserAgent() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateUserAgent());
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateRequestInterception());
        });
      }
      updateFileChooserInterception() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateFileChooserInterception(false));
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.reload");
        });
      }
      _go(delta) {
        return __async(this, null, function* () {
          const history = yield this._mainFrameSession._client.send("Page.getNavigationHistory");
          const entry = history.entries[history.currentIndex + delta];
          if (!entry)
            return false;
          yield this._mainFrameSession._client.send("Page.navigateToHistoryEntry", {
            entryId: entry.id
          });
          return true;
        });
      }
      goBack() {
        return this._go(-1);
      }
      goForward() {
        return this._go(1);
      }
      addInitScript(source, world = "main") {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(source, world));
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._removeEvaluatesOnNewDocument());
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          if (runBeforeUnload)
            yield this._mainFrameSession._client.send("Page.close");
          else
            yield this._browserContext._browser._closePage(this);
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", {
            color
          });
        });
      }
      takeScreenshot(progress2, format, documentRect, viewportRect, quality, fitsViewport, scale) {
        return __async(this, null, function* () {
          const {
            visualViewport
          } = yield this._mainFrameSession._client.send("Page.getLayoutMetrics");
          if (!documentRect) {
            documentRect = __spreadValues({
              x: visualViewport.pageX + viewportRect.x,
              y: visualViewport.pageY + viewportRect.y
            }, _helper.helper.enclosingIntSize({
              width: viewportRect.width / visualViewport.scale,
              height: viewportRect.height / visualViewport.scale
            }));
          }
          const clip = __spreadProps(__spreadValues({}, documentRect), {
            scale: viewportRect ? visualViewport.scale : 1
          });
          if (scale === "css") {
            const deviceScaleFactor = this._browserContext._options.deviceScaleFactor || 1;
            clip.scale /= deviceScaleFactor;
          }
          progress2.throwIfAborted();
          const result = yield this._mainFrameSession._client.send("Page.captureScreenshot", {
            format,
            quality,
            clip,
            captureBeyondViewport: !fitsViewport
          });
          return Buffer.from(result.data, "base64");
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getContentFrame(handle);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getOwnerFrame(handle);
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getBoundingBox(handle);
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            yield this._mainFrameSession._startScreencast(this, {
              format: "jpeg",
              quality: options.quality,
              maxWidth: options.width,
              maxHeight: options.height
            });
          } else {
            yield this._mainFrameSession._stopScreencast(this);
          }
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getContentQuads(handle);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          yield handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
        });
      }
      setInputFilePaths(progress2, handle, files) {
        return __async(this, null, function* () {
          const frame = yield handle.ownerFrame();
          if (!frame)
            throw new Error("Cannot set input files to detached input element");
          const parentSession = this._sessionForFrame(frame);
          yield parentSession._client.send("DOM.setFileInputFiles", {
            objectId: handle._objectId,
            files
          });
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _crAccessibility.getAccessibilityTree)(this._mainFrameSession._client, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.enable").catch((e) => {
          });
        });
      }
      resetForReuse() {
        return __async(this, null, function* () {
        });
      }
      pdf(options) {
        return __async(this, null, function* () {
          return this._pdf.generate(options);
        });
      }
      coverage() {
        return this._coverage;
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          let parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const parentSession = this._sessionForFrame(parent);
          const {
            backendNodeId
          } = yield parentSession._client.send("DOM.getFrameOwner", {
            frameId: frame._id
          }).catch((e) => {
            if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
              (0, _stackTrace.rewriteErrorMessage)(e, "Frame has been detached.");
            throw e;
          });
          parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          return parentSession._adoptBackendNodeId(backendNodeId, yield parent._mainContext());
        });
      }
    };
    exports2.CRPage = CRPage;
    var FrameSession = class {
      constructor(crPage, client, targetId, parentSession) {
        this._client = void 0;
        this._crPage = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._parentSession = void 0;
        this._childSessions = /* @__PURE__ */ new Set();
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._targetId = void 0;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._windowId = void 0;
        this._swappedIn = false;
        this._videoRecorder = null;
        this._screencastId = null;
        this._screencastClients = /* @__PURE__ */ new Set();
        this._evaluateOnNewDocumentIdentifiers = [];
        this._exposedBindingNames = [];
        this._metricsOverride = void 0;
        this._client = client;
        this._crPage = crPage;
        this._page = crPage._page;
        this._targetId = targetId;
        this._networkManager = new _crNetworkManager.CRNetworkManager(client, this._page, null, parentSession ? parentSession._networkManager : null);
        this._parentSession = parentSession;
        if (parentSession)
          parentSession._childSessions.add(this);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        client.once(_crConnection.CRSessionEvents.Disconnected, () => {
          this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
        });
      }
      _isMainFrame() {
        return this._targetId === this._crPage._targetId;
      }
      _addRendererListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))]);
      }
      _addBrowserListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))]);
      }
      _initialize(hasUIWindow) {
        return __async(this, null, function* () {
          const isSettingStorageState = this._page._browserContext.isSettingStorageState();
          if (!isSettingStorageState && hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
            const {
              windowId
            } = yield this._client.send("Browser.getWindowForTarget");
            this._windowId = windowId;
          }
          let screencastOptions;
          if (!isSettingStorageState && this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
            const screencastId = (0, _utils.createGuid)();
            const outputFile = _path.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
            screencastOptions = __spreadProps(__spreadValues({}, this._crPage._browserContext._options.recordVideo.size), {
              outputFile
            });
            yield this._crPage._browserContext._ensureVideosPath();
            yield this._createVideoRecorder(screencastId, screencastOptions);
            this._crPage.pageOrError().then((p) => {
              if (p instanceof Error)
                this._stopVideoRecording().catch(() => {
                });
            });
          }
          let lifecycleEventsEnabled;
          if (!this._isMainFrame())
            this._addRendererListeners();
          this._addBrowserListeners();
          const promises = [this._client.send("Page.enable"), this._client.send("Page.getFrameTree").then(({
            frameTree
          }) => {
            if (this._isMainFrame()) {
              this._handleFrameTree(frameTree);
              this._addRendererListeners();
            }
            const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
            for (const frame of localFrames) {
              this._client._sendMayFail("Page.createIsolatedWorld", {
                frameId: frame._id,
                grantUniveralAccess: true,
                worldName: UTILITY_WORLD_NAME
              });
              for (const binding of this._crPage._browserContext._pageBindings.values())
                frame.evaluateExpression(binding.source).catch((e) => {
                });
              for (const source of this._crPage._browserContext.initScripts)
                frame.evaluateExpression(source).catch((e) => {
                });
            }
            const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
            if (isInitialEmptyPage) {
              lifecycleEventsEnabled.catch((e) => {
              }).then(() => {
                this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
              });
            } else {
              this._firstNonInitialNavigationCommittedFulfill();
              this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
            }
          }), this._client.send("Log.enable", {}), lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", {
            enabled: true
          }), this._client.send("Runtime.enable", {}), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: "",
            worldName: UTILITY_WORLD_NAME
          }), this._networkManager.initialize(), this._client.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          })];
          if (!isSettingStorageState) {
            if (this._isMainFrame())
              promises.push(this._client.send("Emulation.setFocusEmulationEnabled", {
                enabled: true
              }));
            const options = this._crPage._browserContext._options;
            if (options.bypassCSP)
              promises.push(this._client.send("Page.setBypassCSP", {
                enabled: true
              }));
            if (options.ignoreHTTPSErrors)
              promises.push(this._client.send("Security.setIgnoreCertificateErrors", {
                ignore: true
              }));
            if (this._isMainFrame())
              promises.push(this._updateViewport());
            if (options.hasTouch)
              promises.push(this._client.send("Emulation.setTouchEmulationEnabled", {
                enabled: true
              }));
            if (options.javaScriptEnabled === false)
              promises.push(this._client.send("Emulation.setScriptExecutionDisabled", {
                value: true
              }));
            if (options.userAgent || options.locale)
              promises.push(this._updateUserAgent());
            if (options.locale)
              promises.push(emulateLocale(this._client, options.locale));
            if (options.timezoneId)
              promises.push(emulateTimezone(this._client, options.timezoneId));
            if (!this._crPage._browserContext._browser.options.headful)
              promises.push(this._setDefaultFontFamilies(this._client));
            promises.push(this._updateGeolocation(true));
            promises.push(this._updateExtraHTTPHeaders(true));
            promises.push(this._updateRequestInterception());
            promises.push(this._updateOffline(true));
            promises.push(this._updateHttpCredentials(true));
            promises.push(this._updateEmulateMedia());
            promises.push(this._updateFileChooserInterception(true));
            for (const binding of this._crPage._page.allBindings())
              promises.push(this._initBinding(binding));
            for (const source of this._crPage._browserContext.initScripts)
              promises.push(this._evaluateOnNewDocument(source, "main"));
            for (const source of this._crPage._page.initScripts)
              promises.push(this._evaluateOnNewDocument(source, "main"));
            if (screencastOptions)
              promises.push(this._startVideoRecording(screencastOptions));
          }
          promises.push(this._client.send("Runtime.runIfWaitingForDebugger"));
          promises.push(this._firstNonInitialNavigationCommittedPromise);
          yield Promise.all(promises);
        });
      }
      dispose() {
        for (const childSession of this._childSessions)
          childSession.dispose();
        if (this._parentSession)
          this._parentSession._childSessions.delete(this);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._crPage._sessions.delete(this._targetId);
      }
      _navigate(frame, url, referrer) {
        return __async(this, null, function* () {
          const response = yield this._client.send("Page.navigate", {
            url,
            referrer,
            frameId: frame._id
          });
          if (response.errorText)
            throw new frames.NavigationAbortedError(response.loaderId, `${response.errorText} at ${url}`);
          return {
            newDocumentId: response.loaderId
          };
        });
      }
      _onLifecycleEvent(event) {
        if (this._eventBelongsToStaleFrame(event.frameId))
          return;
        if (event.name === "load")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "load");
        else if (event.name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _eventBelongsToStaleFrame(frameId) {
        const frame = this._page._frameManager.frame(frameId);
        if (!frame)
          return true;
        const session = this._crPage._sessionForFrame(frame);
        return session && session !== this && !session._swappedIn;
      }
      _onFrameAttached(frameId, parentFrameId) {
        const frameSession = this._crPage._sessions.get(frameId);
        if (frameSession && frameId !== this._targetId) {
          frameSession._swappedIn = true;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
          return;
        }
        this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        if (this._eventBelongsToStaleFrame(framePayload.id))
          return;
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameRequestedNavigation(payload) {
        if (this._eventBelongsToStaleFrame(payload.frameId))
          return;
        if (payload.disposition === "currentTab")
          this._page._frameManager.frameRequestedNavigation(payload.frameId);
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId, reason) {
        if (this._crPage._sessions.has(frameId)) {
          return;
        }
        if (reason === "swap") {
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        this._page._frameManager.frameDetached(frameId);
      }
      _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame || this._eventBelongsToStaleFrame(frame._id))
          return;
        const delegate = new _crExecutionContext.CRExecutionContext(this._client, contextPayload);
        let worldName = null;
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
          worldName = "main";
        else if (contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
          this._onExecutionContextDestroyed(contextId);
      }
      _onAttachedToTarget(event) {
        var _this$_page$_frameMan;
        const session = _crConnection.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type === "iframe") {
          const targetId = event.targetInfo.targetId;
          const frame = this._page._frameManager.frame(targetId);
          if (!frame)
            return;
          this._page._frameManager.removeChildFramesRecursively(frame);
          const frameSession = new FrameSession(this._crPage, session, targetId, this);
          this._crPage._sessions.set(targetId, frameSession);
          frameSession._initialize(false).catch((e) => e);
          return;
        }
        if (event.targetInfo.type !== "worker") {
          session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
            this._client._sendMayFail("Target.detachFromTarget", {
              sessionId: event.sessionId
            });
          });
          return;
        }
        const url = event.targetInfo.url;
        const worker = new _page.Worker(this._page, url);
        this._page._addWorker(event.sessionId, worker);
        session.once("Runtime.executionContextCreated", (event2) => __async(this, null, function* () {
          worker._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event2.context));
        }));
        session._sendMayFail("Runtime.enable");
        session._sendMayFail("Network.enable");
        session._sendMayFail("Runtime.runIfWaitingForDebugger");
        session.on("Runtime.consoleAPICalled", (event2) => {
          const args = event2.args.map((o) => worker._existingExecutionContext.createHandle(o));
          this._page._addConsoleMessage(event2.type, args, (0, _crProtocolHelper.toConsoleMessageLocation)(event2.stackTrace));
        });
        session.on("Runtime.exceptionThrown", (exception) => this._page.emit(_page.Page.Events.PageError, (0, _crProtocolHelper.exceptionToError)(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents({
          session,
          workerFrame: (_this$_page$_frameMan = this._page._frameManager.frame(this._targetId)) !== null && _this$_page$_frameMan !== void 0 ? _this$_page$_frameMan : void 0
        });
      }
      _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
        const childFrameSession = this._crPage._sessions.get(event.targetId);
        if (!childFrameSession)
          return;
        if (childFrameSession._swappedIn) {
          childFrameSession.dispose();
          return;
        }
        this._client.send("Page.enable").catch((e) => null).then(() => {
          if (!childFrameSession._swappedIn)
            this._page._frameManager.frameDetached(event.targetId);
          childFrameSession.dispose();
        });
      }
      _onWindowOpen(event) {
        this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
      }
      _onConsoleAPI(event) {
        return __async(this, null, function* () {
          if (event.executionContextId === 0) {
            return;
          }
          const context = this._contextIdToContext.get(event.executionContextId);
          if (!context)
            return;
          const values = event.args.map((arg) => context.createHandle(arg));
          this._page._addConsoleMessage(event.type, values, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));
        });
      }
      _initBinding(binding) {
        return __async(this, null, function* () {
          const [, response] = yield Promise.all([this._client.send("Runtime.addBinding", {
            name: binding.name
          }), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: binding.source
          })]);
          this._exposedBindingNames.push(binding.name);
          if (!binding.name.startsWith("__pw"))
            this._evaluateOnNewDocumentIdentifiers.push(response.identifier);
        });
      }
      _removeExposedBindings() {
        return __async(this, null, function* () {
          const toRetain = [];
          const toRemove = [];
          for (const name of this._exposedBindingNames)
            (name.startsWith("__pw_") ? toRetain : toRemove).push(name);
          this._exposedBindingNames = toRetain;
          yield Promise.all(toRemove.map((name) => this._client.send("Runtime.removeBinding", {
            name
          })));
        });
      }
      _onBindingCalled(event) {
        return __async(this, null, function* () {
          const pageOrError = yield this._crPage.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(event.executionContextId);
            if (context)
              yield this._page._onBindingCalled(event.payload, context);
          }
        });
      }
      _onDialog(event) {
        if (!this._page._frameManager.frame(this._targetId))
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, (accept, promptText) => __async(this, null, function* () {
          yield this._client.send("Page.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }), event.defaultPrompt));
      }
      _handleException(exceptionDetails) {
        this._page.firePageError((0, _crProtocolHelper.exceptionToError)(exceptionDetails));
      }
      _onTargetCrashed() {
        return __async(this, null, function* () {
          this._client._markAsCrashed();
          this._page._didCrash();
        });
      }
      _onLogEntryAdded(event) {
        const {
          level,
          text,
          args,
          source,
          url,
          lineNumber
        } = event.entry;
        if (args)
          args.map((arg) => (0, _crProtocolHelper.releaseObject)(this._client, arg.objectId));
        if (source !== "worker") {
          const location2 = {
            url: url || "",
            lineNumber: lineNumber || 0,
            columnNumber: 0
          };
          this._page._addConsoleMessage(level, [], location2, text);
        }
      }
      _onFileChooserOpened(event) {
        return __async(this, null, function* () {
          if (!event.backendNodeId)
            return;
          const frame = this._page._frameManager.frame(event.frameId);
          if (!frame)
            return;
          let handle;
          try {
            const utilityContext = yield frame._utilityContext();
            handle = yield this._adoptBackendNodeId(event.backendNodeId, utilityContext);
          } catch (e) {
            return;
          }
          yield this._page._onFileChooserOpened(handle);
        });
      }
      _willBeginDownload() {
        const originPage = this._crPage._initializedPage;
        if (!originPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
        }
      }
      _onScreencastFrame(payload) {
        this._page.throttleScreencastFrameAck(() => {
          this._client.send("Page.screencastFrameAck", {
            sessionId: payload.sessionId
          }).catch(() => {
          });
        });
        const buffer = Buffer.from(payload.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          timestamp: payload.metadata.timestamp,
          width: payload.metadata.deviceWidth,
          height: payload.metadata.deviceHeight
        });
      }
      _createVideoRecorder(screencastId, options) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._screencastId);
          const ffmpegPath = _registry.registry.findExecutable("ffmpeg").executablePathOrDie(this._page.attribution.playwright.options.sdkLanguage);
          this._videoRecorder = yield _videoRecorder.VideoRecorder.launch(this._crPage._page, ffmpegPath, options);
          this._screencastId = screencastId;
        });
      }
      _startVideoRecording(options) {
        return __async(this, null, function* () {
          const screencastId = this._screencastId;
          (0, _utils.assert)(screencastId);
          this._page.once(_page.Page.Events.Close, () => this._stopVideoRecording().catch(() => {
          }));
          const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
          yield this._startScreencast(this._videoRecorder, {
            format: "jpeg",
            quality: 90,
            maxWidth: options.width,
            maxHeight: options.height
          });
          gotFirstFrame.then(() => {
            this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options.outputFile, this._crPage.pageOrError());
          });
        });
      }
      _stopVideoRecording() {
        return __async(this, null, function* () {
          if (!this._screencastId)
            return;
          const screencastId = this._screencastId;
          this._screencastId = null;
          const recorder = this._videoRecorder;
          this._videoRecorder = null;
          yield this._stopScreencast(recorder);
          yield recorder.stop().catch(() => {
          });
          const video = this._crPage._browserContext._browser._takeVideo(screencastId);
          video === null || video === void 0 ? void 0 : video.reportFinished();
        });
      }
      _startScreencast(_0) {
        return __async(this, arguments, function* (client, options = {}) {
          this._screencastClients.add(client);
          if (this._screencastClients.size === 1)
            yield this._client.send("Page.startScreencast", options);
        });
      }
      _stopScreencast(client) {
        return __async(this, null, function* () {
          this._screencastClients.delete(client);
          if (!this._screencastClients.size)
            yield this._client._sendMayFail("Page.stopScreencast");
        });
      }
      _updateExtraHTTPHeaders(initial) {
        return __async(this, null, function* () {
          const headers = network.mergeHeaders([this._crPage._browserContext._options.extraHTTPHeaders, this._page.extraHTTPHeaders()]);
          if (!initial || headers.length)
            yield this._client.send("Network.setExtraHTTPHeaders", {
              headers: (0, _utils.headersArrayToObject)(headers, false)
            });
        });
      }
      _updateGeolocation(initial) {
        return __async(this, null, function* () {
          const geolocation = this._crPage._browserContext._options.geolocation;
          if (!initial || geolocation)
            yield this._client.send("Emulation.setGeolocationOverride", geolocation || {});
        });
      }
      _updateOffline(initial) {
        return __async(this, null, function* () {
          const offline = !!this._crPage._browserContext._options.offline;
          if (!initial || offline)
            yield this._networkManager.setOffline(offline);
        });
      }
      _updateHttpCredentials(initial) {
        return __async(this, null, function* () {
          const credentials = this._crPage._browserContext._options.httpCredentials || null;
          if (!initial || credentials)
            yield this._networkManager.authenticate(credentials);
        });
      }
      _updateViewport(preserveWindowBoundaries) {
        return __async(this, null, function* () {
          if (this._crPage._browserContext._browser.isClank())
            return;
          (0, _utils.assert)(this._isMainFrame());
          const options = this._crPage._browserContext._options;
          const emulatedSize = this._page.emulatedSize();
          if (emulatedSize === null)
            return;
          const viewportSize = emulatedSize.viewport;
          const screenSize = emulatedSize.screen;
          const isLandscape = screenSize.width > screenSize.height;
          const metricsOverride = {
            mobile: !!options.isMobile,
            width: viewportSize.width,
            height: viewportSize.height,
            screenWidth: screenSize.width,
            screenHeight: screenSize.height,
            deviceScaleFactor: options.deviceScaleFactor || 1,
            screenOrientation: !!options.isMobile ? isLandscape ? {
              angle: 90,
              type: "landscapePrimary"
            } : {
              angle: 0,
              type: "portraitPrimary"
            } : {
              angle: 0,
              type: "landscapePrimary"
            },
            dontSetVisibleSize: preserveWindowBoundaries
          };
          if (JSON.stringify(this._metricsOverride) === JSON.stringify(metricsOverride))
            return;
          const promises = [this._client.send("Emulation.setDeviceMetricsOverride", metricsOverride)];
          if (!preserveWindowBoundaries && this._windowId) {
            let insets = {
              width: 0,
              height: 0
            };
            if (this._crPage._browserContext._browser.options.headful) {
              insets = {
                width: 24,
                height: 88
              };
              if (process.platform === "win32")
                insets = {
                  width: 16,
                  height: 88
                };
              else if (process.platform === "linux")
                insets = {
                  width: 8,
                  height: 85
                };
              else if (process.platform === "darwin")
                insets = {
                  width: 2,
                  height: 80
                };
              if (this._crPage._browserContext.isPersistentContext()) {
                insets.height += 46;
              }
            }
            promises.push(this.setWindowBounds({
              width: viewportSize.width + insets.width,
              height: viewportSize.height + insets.height
            }));
          }
          yield Promise.all(promises);
          this._metricsOverride = metricsOverride;
        });
      }
      windowBounds() {
        return __async(this, null, function* () {
          const {
            bounds
          } = yield this._client.send("Browser.getWindowBounds", {
            windowId: this._windowId
          });
          return bounds;
        });
      }
      setWindowBounds(bounds) {
        return __async(this, null, function* () {
          return yield this._client.send("Browser.setWindowBounds", {
            windowId: this._windowId,
            bounds
          });
        });
      }
      _updateEmulateMedia() {
        return __async(this, null, function* () {
          const emulatedMedia = this._page.emulatedMedia();
          const media = emulatedMedia.media === "no-override" ? "" : emulatedMedia.media;
          const colorScheme = emulatedMedia.colorScheme === "no-override" ? "" : emulatedMedia.colorScheme;
          const reducedMotion = emulatedMedia.reducedMotion === "no-override" ? "" : emulatedMedia.reducedMotion;
          const forcedColors = emulatedMedia.forcedColors === "no-override" ? "" : emulatedMedia.forcedColors;
          const features = [{
            name: "prefers-color-scheme",
            value: colorScheme
          }, {
            name: "prefers-reduced-motion",
            value: reducedMotion
          }, {
            name: "forced-colors",
            value: forcedColors
          }];
          yield this._client.send("Emulation.setEmulatedMedia", {
            media,
            features
          });
        });
      }
      _updateUserAgent() {
        return __async(this, null, function* () {
          const options = this._crPage._browserContext._options;
          yield this._client.send("Emulation.setUserAgentOverride", {
            userAgent: options.userAgent || "",
            acceptLanguage: options.locale
          });
        });
      }
      _setDefaultFontFamilies(session) {
        return __async(this, null, function* () {
          const fontFamilies = _defaultFontFamilies.platformToFontFamilies[this._crPage._browserContext._browser._platform()];
          yield session.send("Page.setFontFamilies", fontFamilies);
        });
      }
      _updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._networkManager.setRequestInterception(this._page.needsRequestInterception());
        });
      }
      _updateFileChooserInterception(initial) {
        return __async(this, null, function* () {
          const enabled = this._page.fileChooserIntercepted();
          if (initial && !enabled)
            return;
          yield this._client.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch(() => {
          });
        });
      }
      _evaluateOnNewDocument(source, world) {
        return __async(this, null, function* () {
          const worldName = world === "utility" ? UTILITY_WORLD_NAME : void 0;
          const {
            identifier
          } = yield this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source,
            worldName
          });
          this._evaluateOnNewDocumentIdentifiers.push(identifier);
        });
      }
      _removeEvaluatesOnNewDocument() {
        return __async(this, null, function* () {
          const identifiers = this._evaluateOnNewDocumentIdentifiers;
          this._evaluateOnNewDocumentIdentifiers = [];
          yield Promise.all(identifiers.map((identifier) => this._client.send("Page.removeScriptToEvaluateOnNewDocument", {
            identifier
          })));
        });
      }
      _getContentFrame(handle) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
            return null;
          return this._page._frameManager.frame(nodeInfo.node.frameId);
        });
      }
      _getOwnerFrame(handle) {
        return __async(this, null, function* () {
          const documentElement = yield handle.evaluateHandle((node) => {
            const doc = node;
            if (doc.documentElement && doc.documentElement.ownerDocument === doc)
              return doc.documentElement;
            return node.ownerDocument ? node.ownerDocument.documentElement : null;
          });
          if (!documentElement)
            return null;
          if (!documentElement._objectId)
            return null;
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: documentElement._objectId
          });
          const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
          documentElement.dispose();
          return frameId;
        });
      }
      _getBoundingBox(handle) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.getBoxModel", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          const quad = result.model.border;
          const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
          const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
          const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
          const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
          const position = yield this._framePosition();
          if (!position)
            return null;
          return {
            x: x + position.x,
            y: y + position.y,
            width,
            height
          };
        });
      }
      _framePosition() {
        return __async(this, null, function* () {
          const frame = this._page._frameManager.frame(this._targetId);
          if (!frame)
            return null;
          if (frame === this._page.mainFrame())
            return {
              x: 0,
              y: 0
            };
          const element = yield frame.frameElement();
          const box = yield element.boundingBox();
          return box;
        });
      }
      _scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            throw e;
          });
        });
      }
      _getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.getContentQuads", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          const position = yield this._framePosition();
          if (!position)
            return null;
          return result.quads.map((quad) => [{
            x: quad[0] + position.x,
            y: quad[1] + position.y
          }, {
            x: quad[2] + position.x,
            y: quad[3] + position.y
          }, {
            x: quad[4] + position.x,
            y: quad[5] + position.y
          }, {
            x: quad[6] + position.x,
            y: quad[7] + position.y
          }]);
        });
      }
      _adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
        });
      }
      _adoptBackendNodeId(backendNodeId, to) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.resolveNode", {
            backendNodeId,
            executionContextId: to[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.object).asElement();
        });
      }
    };
    function emulateLocale(session, locale) {
      return __async(this, null, function* () {
        try {
          yield session.send("Emulation.setLocaleOverride", {
            locale
          });
        } catch (exception) {
          if (exception.message.includes("Another locale override is already in effect"))
            return;
          throw exception;
        }
      });
    }
    function emulateTimezone(session, timezoneId) {
      return __async(this, null, function* () {
        try {
          yield session.send("Emulation.setTimezoneOverride", {
            timezoneId
          });
        } catch (exception) {
          if (exception.message.includes("Timezone override is already in effect"))
            return;
          if (exception.message.includes("Invalid timezone"))
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
          throw exception;
        }
      });
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/chromium/crServiceWorker.js
var require_crServiceWorker = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crServiceWorker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRServiceWorker = void 0;
    var _page = require_page();
    var _crExecutionContext = require_crExecutionContext();
    var _crNetworkManager = require_crNetworkManager();
    var network = _interopRequireWildcard(require_network2());
    var _browserContext = require_browserContext();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRServiceWorker = class extends _page.Worker {
      constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = void 0;
        this._networkManager = void 0;
        this._session = void 0;
        this._extraHTTPHeaders = null;
        this._session = session;
        this._browserContext = browserContext;
        if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS)
          this._networkManager = new _crNetworkManager.CRNetworkManager(session, null, this, null);
        session.once("Runtime.executionContextCreated", (event) => {
          this._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));
        });
        if (this._networkManager && this._isNetworkInspectionEnabled()) {
          this._networkManager.initialize().catch(() => {
          });
          this.updateRequestInterception();
          this.updateExtraHTTPHeaders(true);
          this.updateHttpCredentials(true);
          this.updateOffline(true);
        }
        session.send("Runtime.enable", {}).catch((e) => {
        });
        session.send("Runtime.runIfWaitingForDebugger").catch((e) => {
        });
        session.on("Inspector.targetReloadedAfterCrash", () => {
          session._sendMayFail("Runtime.runIfWaitingForDebugger", {});
        });
      }
      updateOffline(initial) {
        return __async(this, null, function* () {
          var _this$_networkManager;
          if (!this._isNetworkInspectionEnabled())
            return;
          const offline = !!this._browserContext._options.offline;
          if (!initial || offline)
            yield (_this$_networkManager = this._networkManager) === null || _this$_networkManager === void 0 ? void 0 : _this$_networkManager.setOffline(offline);
        });
      }
      updateHttpCredentials(initial) {
        return __async(this, null, function* () {
          var _this$_networkManager2;
          if (!this._isNetworkInspectionEnabled())
            return;
          const credentials = this._browserContext._options.httpCredentials || null;
          if (!initial || credentials)
            yield (_this$_networkManager2 = this._networkManager) === null || _this$_networkManager2 === void 0 ? void 0 : _this$_networkManager2.authenticate(credentials);
        });
      }
      updateExtraHTTPHeaders(initial) {
        return __async(this, null, function* () {
          if (!this._isNetworkInspectionEnabled())
            return;
          const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._extraHTTPHeaders]);
          if (!initial || headers.length)
            yield this._session.send("Network.setExtraHTTPHeaders", {
              headers: (0, _utils.headersArrayToObject)(headers, false)
            });
        });
      }
      updateRequestInterception() {
        if (!this._networkManager || !this._isNetworkInspectionEnabled())
          return Promise.resolve();
        return this._networkManager.setRequestInterception(this.needsRequestInterception()).catch((e) => {
        });
      }
      needsRequestInterception() {
        return this._isNetworkInspectionEnabled() && !!this._browserContext._requestInterceptor;
      }
      reportRequestFinished(request, response) {
        this._browserContext.emit(_browserContext.BrowserContext.Events.RequestFinished, {
          request,
          response
        });
      }
      requestFailed(request, _canceled) {
        this._browserContext.emit(_browserContext.BrowserContext.Events.RequestFailed, request);
      }
      requestReceivedResponse(response) {
        this._browserContext.emit(_browserContext.BrowserContext.Events.Response, response);
      }
      requestStarted(request, route) {
        this._browserContext.emit(_browserContext.BrowserContext.Events.Request, request);
        if (route) {
          var _this$_browserContext, _this$_browserContext2;
          const r = new network.Route(request, route);
          if ((_this$_browserContext = (_this$_browserContext2 = this._browserContext)._requestInterceptor) !== null && _this$_browserContext !== void 0 && _this$_browserContext.call(_this$_browserContext2, r, request))
            return;
          r.continue({
            isFallback: true
          });
        }
      }
      _isNetworkInspectionEnabled() {
        return this._browserContext._options.serviceWorkers !== "block";
      }
    };
    exports2.CRServiceWorker = CRServiceWorker;
  }
});

// node_modules/playwright-core/lib/server/chromium/crBrowser.js
var require_crBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRBrowserContext = exports2.CRBrowser = void 0;
    var _browser = require_browser();
    var _browserContext = require_browserContext();
    var _utils = require_utils();
    var network = _interopRequireWildcard(require_network2());
    var _page = require_page();
    var _frames = require_frames();
    var _crConnection = require_crConnection();
    var _crPage = require_crPage();
    var _crProtocolHelper = require_crProtocolHelper();
    var _crServiceWorker = require_crServiceWorker();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRBrowser = class extends _browser.Browser {
      static connect(parent, transport, options, devtools) {
        return __async(this, null, function* () {
          options = __spreadValues({}, options);
          const connection = new _crConnection.CRConnection(transport, options.protocolLogger, options.browserLogsCollector);
          const browser = new CRBrowser(parent, connection, options);
          browser._devtools = devtools;
          const session = connection.rootSession;
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const version = yield session.send("Browser.getVersion");
          browser._version = version.product.substring(version.product.indexOf("/") + 1);
          browser._userAgent = version.userAgent;
          browser.options.headful = !version.userAgent.includes("Headless");
          if (!options.persistent) {
            yield session.send("Target.setAutoAttach", {
              autoAttach: true,
              waitForDebuggerOnStart: true,
              flatten: true
            });
            return browser;
          }
          browser._defaultContext = new CRBrowserContext(browser, void 0, options.persistent);
          yield Promise.all([session.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          }).then(() => __async(this, null, function* () {
            yield session.send("Target.getTargetInfo");
          })), browser._defaultContext._initialize()]);
          yield browser._waitForAllPagesToBeInitialized();
          return browser;
        });
      }
      constructor(parent, connection, options) {
        super(parent, options);
        this._connection = void 0;
        this._session = void 0;
        this._clientRootSessionPromise = null;
        this._contexts = /* @__PURE__ */ new Map();
        this._crPages = /* @__PURE__ */ new Map();
        this._backgroundPages = /* @__PURE__ */ new Map();
        this._serviceWorkers = /* @__PURE__ */ new Map();
        this._devtools = void 0;
        this._version = "";
        this._tracingRecording = false;
        this._tracingPath = "";
        this._tracingClient = void 0;
        this._userAgent = "";
        this._connection = connection;
        this._session = this._connection.rootSession;
        this._connection.on(_crConnection.ConnectionEvents.Disconnected, () => this._didClose());
        this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._session.on("Browser.downloadWillBegin", this._onDownloadWillBegin.bind(this));
        this._session.on("Browser.downloadProgress", this._onDownloadProgress.bind(this));
      }
      doCreateNewContext(options) {
        return __async(this, null, function* () {
          let proxyBypassList = void 0;
          if (options.proxy) {
            if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK)
              proxyBypassList = options.proxy.bypass;
            else
              proxyBypassList = "<-loopback>" + (options.proxy.bypass ? `,${options.proxy.bypass}` : "");
          }
          const {
            browserContextId
          } = yield this._session.send("Target.createBrowserContext", {
            disposeOnDetach: true,
            proxyServer: options.proxy ? options.proxy.server : void 0,
            proxyBypassList
          });
          const context = new CRBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      _platform() {
        if (this._userAgent.includes("Windows"))
          return "win";
        if (this._userAgent.includes("Macintosh"))
          return "mac";
        return "linux";
      }
      isClank() {
        return this.options.name === "clank";
      }
      _waitForAllPagesToBeInitialized() {
        return __async(this, null, function* () {
          yield Promise.all([...this._crPages.values()].map((page) => page.pageOrError()));
        });
      }
      _onAttachedToTarget({
        targetInfo,
        sessionId,
        waitingForDebugger
      }) {
        if (targetInfo.type === "browser")
          return;
        const session = this._connection.session(sessionId);
        (0, _utils.assert)(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
          context = this._defaultContext;
        }
        if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
          this._devtools.install(session);
          return;
        }
        const treatOtherAsPage = targetInfo.type === "other" && process.env.PW_CHROMIUM_ATTACH_TO_OTHER;
        if (!context || targetInfo.type === "other" && !treatOtherAsPage) {
          if (waitingForDebugger) {
            session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
              this._session._sendMayFail("Target.detachFromTarget", {
                sessionId
              });
            });
          }
          return;
        }
        (0, _utils.assert)(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils.assert)(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils.assert)(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        if (targetInfo.type === "background_page") {
          const backgroundPage = new _crPage.CRPage(session, targetInfo.targetId, context, null, {
            hasUIWindow: false,
            isBackgroundPage: true
          });
          this._backgroundPages.set(targetInfo.targetId, backgroundPage);
          return;
        }
        if (targetInfo.type === "page" || treatOtherAsPage) {
          const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
          const crPage = new _crPage.CRPage(session, targetInfo.targetId, context, opener, {
            hasUIWindow: targetInfo.type === "page",
            isBackgroundPage: false
          });
          this._crPages.set(targetInfo.targetId, crPage);
          return;
        }
        if (targetInfo.type === "service_worker") {
          const serviceWorker = new _crServiceWorker.CRServiceWorker(context, session, targetInfo.url);
          this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
          context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
          return;
        }
        session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
          this._session._sendMayFail("Target.detachFromTarget", {
            sessionId
          });
        });
      }
      _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
          this._crPages.delete(targetId);
          crPage.didClose();
          return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
          this._backgroundPages.delete(targetId);
          backgroundPage.didClose();
          return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
          this._serviceWorkers.delete(targetId);
          serviceWorker.didClose();
          return;
        }
      }
      _findOwningPage(frameId) {
        for (const crPage of this._crPages.values()) {
          const frame = crPage._page._frameManager.frame(frameId);
          if (frame)
            return crPage;
        }
        return null;
      }
      _onDownloadWillBegin(payload) {
        const page = this._findOwningPage(payload.frameId);
        if (!page) {
          return;
        }
        page.willBeginDownload();
        let originPage = page._initializedPage;
        if (!originPage && page._opener)
          originPage = page._opener._initializedPage;
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
      }
      _onDownloadProgress(payload) {
        if (payload.state === "completed")
          this._downloadFinished(payload.guid, "");
        if (payload.state === "canceled")
          this._downloadFinished(payload.guid, "canceled");
      }
      _closePage(crPage) {
        return __async(this, null, function* () {
          yield this._session.send("Target.closeTarget", {
            targetId: crPage._targetId
          });
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          return yield this._connection.createBrowserSession();
        });
      }
      startTracing(_0) {
        return __async(this, arguments, function* (page, options = {}) {
          (0, _utils.assert)(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
          this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
          const defaultCategories = ["-*", "devtools.timeline", "v8.execute", "disabled-by-default-devtools.timeline", "disabled-by-default-devtools.timeline.frame", "toplevel", "blink.console", "blink.user_timing", "latencyInfo", "disabled-by-default-devtools.timeline.stack", "disabled-by-default-v8.cpu_profiler", "disabled-by-default-v8.cpu_profiler.hires"];
          const {
            path = null,
            screenshots = false,
            categories = defaultCategories
          } = options;
          if (screenshots)
            categories.push("disabled-by-default-devtools.screenshot");
          this._tracingPath = path;
          this._tracingRecording = true;
          yield this._tracingClient.send("Tracing.start", {
            transferMode: "ReturnAsStream",
            categories: categories.join(",")
          });
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._tracingClient, "Tracing was not started.");
          const [event] = yield Promise.all([new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)), this._tracingClient.send("Tracing.end")]);
          const result = yield (0, _crProtocolHelper.readProtocolStream)(this._tracingClient, event.stream, this._tracingPath);
          this._tracingRecording = false;
          return result;
        });
      }
      isConnected() {
        return !this._connection._closed;
      }
      _clientRootSession() {
        return __async(this, null, function* () {
          if (!this._clientRootSessionPromise)
            this._clientRootSessionPromise = this._connection.createBrowserSession();
          return this._clientRootSessionPromise;
        });
      }
    };
    exports2.CRBrowser = CRBrowser;
    var CRBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._authenticateProxyViaCredentials();
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils.assert)(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
          const promises = [__superGet("_initialize").call(this)];
          if (this._browser.options.name !== "electron" && this._browser.options.name !== "clank") {
            promises.push(this._browser._session.send("Browser.setDownloadBehavior", {
              behavior: this._options.acceptDownloads ? "allowAndName" : "deny",
              browserContextId: this._browserContextId,
              downloadPath: this._browser.options.downloadsPath,
              eventsEnabled: true
            }));
          }
          yield Promise.all(promises);
        });
      }
      _crPages() {
        return [...this._browser._crPages.values()].filter((crPage) => crPage._browserContext === this);
      }
      pages() {
        return this._crPages().map((crPage) => crPage._initializedPage).filter(Boolean);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : void 0;
          let {
            targetId
          } = yield this._browser._session.send("Target.createTarget", {
            url: "about:blank",
            browserContextId: this._browserContextId
          });
          if (oldKeys) {
            const newKeys = new Set(this._browser._crPages.keys());
            for (const key of oldKeys)
              newKeys.delete(key);
            for (const key of newKeys) {
              const page = this._browser._crPages.get(key);
              if (page._opener)
                newKeys.delete(key);
            }
            (0, _utils.assert)(newKeys.size === 1);
            [targetId] = [...newKeys];
          }
          return this._browser._crPages.get(targetId);
        });
      }
      doGetCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._session.send("Storage.getCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({
              sameSite: "Lax"
            }, c);
            delete copy.size;
            delete copy.priority;
            delete copy.session;
            delete copy.sameParty;
            delete copy.sourceScheme;
            delete copy.sourcePort;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._browser._session.send("Storage.setCookies", {
            cookies: network.rewriteCookies(cookies),
            browserContextId: this._browserContextId
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._session.send("Storage.clearCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([
            ["geolocation", "geolocation"],
            ["midi", "midi"],
            ["notifications", "notifications"],
            ["camera", "videoCapture"],
            ["microphone", "audioCapture"],
            ["background-sync", "backgroundSync"],
            ["ambient-light-sensor", "sensors"],
            ["accelerometer", "sensors"],
            ["gyroscope", "sensors"],
            ["magnetometer", "sensors"],
            ["accessibility-events", "accessibilityEvents"],
            ["clipboard-read", "clipboardReadWrite"],
            ["clipboard-write", "clipboardSanitizedWrite"],
            ["payment-handler", "paymentHandler"],
            ["midi-sysex", "midiSysex"]
          ]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._browser._session.send("Browser.grantPermissions", {
            origin: origin === "*" ? void 0 : origin,
            browserContextId: this._browserContextId,
            permissions: filtered
          });
        });
      }
      doClearPermissions() {
        return __async(this, null, function* () {
          yield this._browser._session.send("Browser.resetPermissions", {
            browserContextId: this._browserContextId
          });
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          for (const page of this.pages())
            yield page._delegate.updateGeolocation();
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          for (const page of this.pages())
            yield page._delegate.updateExtraHTTPHeaders();
          for (const sw of this.serviceWorkers())
            yield sw.updateExtraHTTPHeaders(false);
        });
      }
      setUserAgent(userAgent) {
        return __async(this, null, function* () {
          this._options.userAgent = userAgent;
          for (const page of this.pages())
            yield page._delegate.updateUserAgent();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          for (const page of this.pages())
            yield page._delegate.updateOffline();
          for (const sw of this.serviceWorkers())
            yield sw.updateOffline(false);
        });
      }
      doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          for (const page of this.pages())
            yield page._delegate.updateHttpCredentials();
          for (const sw of this.serviceWorkers())
            yield sw.updateHttpCredentials(false);
        });
      }
      doAddInitScript(source) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.addInitScript(source);
        });
      }
      doRemoveInitScripts() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.removeInitScripts();
        });
      }
      doExposeBinding(binding) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.exposeBinding(binding);
        });
      }
      doRemoveExposedBindings() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.removeExposedBindings();
        });
      }
      doUpdateRequestInterception() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.updateRequestInterception();
          for (const sw of this.serviceWorkers())
            yield sw.updateRequestInterception();
        });
      }
      doClose() {
        return __async(this, null, function* () {
          const openedBeforeUnloadDialogs = [];
          for (const crPage of this._crPages()) {
            const dialogs = [...crPage._page._frameManager._openedDialogs].filter((dialog) => dialog.type() === "beforeunload");
            openedBeforeUnloadDialogs.push(...dialogs);
          }
          yield Promise.all(openedBeforeUnloadDialogs.map((dialog) => dialog.dismiss()));
          if (!this._browserContextId) {
            yield Promise.all(this._crPages().map((crPage) => crPage._mainFrameSession._stopVideoRecording()));
            yield this._browser.close();
            return;
          }
          yield this._browser._session.send("Target.disposeBrowserContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
          for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
            if (serviceWorker._browserContext !== this)
              continue;
            serviceWorker.didClose();
            this._browser._serviceWorkers.delete(targetId);
          }
        });
      }
      onClosePersistent() {
        for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {
            backgroundPage.didClose();
            this._browser._backgroundPages.delete(targetId);
          }
        }
      }
      clearCache() {
        return __async(this, null, function* () {
          for (const page of this._crPages())
            yield page._mainFrameSession._networkManager.clearCache();
        });
      }
      cancelDownload(guid) {
        return __async(this, null, function* () {
          yield this._browser._session.send("Browser.cancelDownload", {
            guid,
            browserContextId: this._browserContextId
          });
        });
      }
      backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
            result.push(backgroundPage._initializedPage);
        }
        return result;
      }
      serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker._browserContext === this);
      }
      newCDPSession(page) {
        return __async(this, null, function* () {
          let targetId = null;
          if (page instanceof _page.Page) {
            targetId = page._delegate._targetId;
          } else if (page instanceof _frames.Frame) {
            const session = page._page._delegate._sessions.get(page._id);
            if (!session)
              throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
            targetId = session._targetId;
          } else {
            throw new Error("page: expected Page or Frame");
          }
          const rootSession = yield this._browser._clientRootSession();
          const {
            sessionId
          } = yield rootSession.send("Target.attachToTarget", {
            targetId,
            flatten: true
          });
          return this._browser._connection.session(sessionId);
        });
      }
    };
    exports2.CRBrowserContext = CRBrowserContext;
    CRBrowserContext.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
});

// node_modules/playwright-core/lib/protocol/transport.js
var require_transport = __commonJS({
  "node_modules/playwright-core/lib/protocol/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PipeTransport = void 0;
    var _utils = require_utils();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead, closeable, endian = "le") {
        this._pipeWrite = void 0;
        this._data = Buffer.from([]);
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this._closed = false;
        this._bytesLeft = 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._endian = void 0;
        this._closeableStream = void 0;
        this._pipeWrite = pipeWrite;
        this._endian = endian;
        this._closeableStream = closeable;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose();
        });
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        const data = Buffer.from(message, "utf-8");
        const dataLength = Buffer.alloc(4);
        if (this._endian === "be")
          dataLength.writeUInt32BE(data.length, 0);
        else
          dataLength.writeUInt32LE(data.length, 0);
        this._pipeWrite.write(dataLength);
        this._pipeWrite.write(data);
      }
      close() {
        this._closeableStream.close();
      }
      _dispatch(buffer) {
        this._data = Buffer.concat([this._data, buffer]);
        while (true) {
          if (!this._bytesLeft && this._data.length < 4) {
            break;
          }
          if (!this._bytesLeft) {
            this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
            this._data = this._data.slice(4);
          }
          if (!this._bytesLeft || this._data.length < this._bytesLeft) {
            break;
          }
          const message = this._data.slice(0, this._bytesLeft);
          this._data = this._data.slice(this._bytesLeft);
          this._bytesLeft = 0;
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(message.toString("utf-8"));
          });
        }
      }
    };
    exports2.PipeTransport = PipeTransport;
  }
});

// node_modules/playwright-core/lib/server/chromium/chromiumSwitches.js
var require_chromiumSwitches = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/chromiumSwitches.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.chromiumSwitches = void 0;
    var chromiumSwitches = [
      "--disable-field-trial-config",
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-back-forward-cache",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-component-update",
      "--no-default-browser-check",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate",
      "--allow-pre-commit-input",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain",
      "--no-service-autorun",
      "--export-tagged-pdf"
    ];
    exports2.chromiumSwitches = chromiumSwitches;
  }
});

// node_modules/playwright-core/lib/server/android/android.js
var require_android = __commonJS({
  "node_modules/playwright-core/lib/server/android/android.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidDevice = exports2.Android = void 0;
    var _utilsBundle = require_utilsBundle();
    var _events = require("events");
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _browserContext = require_browserContext();
    var _progress = require_progress();
    var _crBrowser = require_crBrowser();
    var _helper = require_helper();
    var _transport = require_transport();
    var _debugLogger = require_debugLogger();
    var _processLauncher = require_processLauncher();
    var _timeoutSettings = require_timeoutSettings();
    var _instrumentation = require_instrumentation();
    var _chromiumSwitches = require_chromiumSwitches();
    var _registry = require_registry();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var Android = class extends _instrumentation.SdkObject {
      constructor(parent, backend) {
        super(parent, "android");
        this._backend = void 0;
        this._devices = /* @__PURE__ */ new Map();
        this._timeoutSettings = void 0;
        this._backend = backend;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      devices(options) {
        return __async(this, null, function* () {
          const devices = (yield this._backend.devices(options)).filter((d) => d.status === "device");
          const newSerials = /* @__PURE__ */ new Set();
          for (const d of devices) {
            newSerials.add(d.serial);
            if (this._devices.has(d.serial))
              continue;
            const device = yield AndroidDevice.create(this, d, options);
            this._devices.set(d.serial, device);
          }
          for (const d of this._devices.keys()) {
            if (!newSerials.has(d))
              this._devices.delete(d);
          }
          return [...this._devices.values()];
        });
      }
      _deviceClosed(device) {
        this._devices.delete(device.serial);
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends _instrumentation.SdkObject {
      constructor(android, backend, model, options) {
        super(android, "android-device");
        this._backend = void 0;
        this.model = void 0;
        this.serial = void 0;
        this._options = void 0;
        this._driverPromise = void 0;
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._pollingWebViews = void 0;
        this._timeoutSettings = void 0;
        this._webViews = /* @__PURE__ */ new Map();
        this._browserConnections = /* @__PURE__ */ new Set();
        this._android = void 0;
        this._isClosed = false;
        this._android = android;
        this._backend = backend;
        this.model = model;
        this.serial = backend.serial;
        this._options = options;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(android._timeoutSettings);
      }
      static create(android, backend, options) {
        return __async(this, null, function* () {
          yield backend.init();
          const model = yield backend.runCommand("shell:getprop ro.product.model");
          const device = new AndroidDevice(android, backend, model.toString().trim(), options);
          yield device._init();
          return device;
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield this._refreshWebViews();
          const poll = () => {
            this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
              this.close().catch(() => {
              });
            }), 500);
          };
          poll();
        });
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      shell(command) {
        return __async(this, null, function* () {
          const result = yield this._backend.runCommand(`shell:${command}`);
          yield this._refreshWebViews();
          return result;
        });
      }
      open(command) {
        return __async(this, null, function* () {
          return yield this._backend.open(`${command}`);
        });
      }
      screenshot() {
        return __async(this, null, function* () {
          return yield this._backend.runCommand(`shell:screencap -p`);
        });
      }
      _driver() {
        return __async(this, null, function* () {
          if (this._isClosed)
            return;
          if (!this._driverPromise)
            this._driverPromise = this._installDriver();
          return this._driverPromise;
        });
      }
      _installDriver() {
        return __async(this, null, function* () {
          (0, _utilsBundle.debug)("pw:android")("Stopping the old driver");
          yield this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
          if (!this._options.omitDriverInstall) {
            (0, _utilsBundle.debug)("pw:android")("Uninstalling the old driver");
            yield this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
            yield this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
            (0, _utilsBundle.debug)("pw:android")("Installing the new driver");
            const executable = _registry.registry.findExecutable("android");
            for (const file of ["android-driver.apk", "android-driver-target.apk"]) {
              const fullName = _path.default.join(executable.directory, file);
              if (!_fs.default.existsSync(fullName))
                throw new Error("Please install Android driver apk using `npx playwright install android`");
              yield this.installApk(yield _fs.default.promises.readFile(fullName));
            }
          } else {
            (0, _utilsBundle.debug)("pw:android")("Skipping the driver installation");
          }
          (0, _utilsBundle.debug)("pw:android")("Starting the new driver");
          this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => (0, _utilsBundle.debug)("pw:android")(e));
          const socket = yield this._waitForLocalAbstract("playwright_android_driver_socket");
          const transport = new _transport.PipeTransport(socket, socket, socket, "be");
          transport.onmessage = (message) => {
            const response = JSON.parse(message);
            const {
              id,
              result,
              error
            } = response;
            const callback = this._callbacks.get(id);
            if (!callback)
              return;
            if (error)
              callback.reject(new Error(error));
            else
              callback.fulfill(result);
            this._callbacks.delete(id);
          };
          return transport;
        });
      }
      _waitForLocalAbstract(socketName) {
        return __async(this, null, function* () {
          let socket;
          (0, _utilsBundle.debug)("pw:android")(`Polling the socket localabstract:${socketName}`);
          while (!socket) {
            try {
              socket = yield this._backend.open(`localabstract:${socketName}`);
            } catch (e) {
              yield new Promise((f) => setTimeout(f, 250));
            }
          }
          (0, _utilsBundle.debug)("pw:android")(`Connected to localabstract:${socketName}`);
          return socket;
        });
      }
      send(_0) {
        return __async(this, arguments, function* (method, params = {}) {
          params.timeout = this._timeoutSettings.timeout(params);
          const driver = yield this._driver();
          if (!driver)
            throw new Error("Device is closed");
          const id = ++this._lastId;
          const result = new Promise((fulfill, reject) => this._callbacks.set(id, {
            fulfill,
            reject
          }));
          driver.send(JSON.stringify({
            id,
            method,
            params
          }));
          return result;
        });
      }
      close() {
        return __async(this, null, function* () {
          if (this._isClosed)
            return;
          this._isClosed = true;
          if (this._pollingWebViews)
            clearTimeout(this._pollingWebViews);
          for (const connection of this._browserConnections)
            yield connection.close();
          if (this._driverPromise) {
            const driver = yield this._driver();
            driver === null || driver === void 0 ? void 0 : driver.close();
          }
          yield this._backend.close();
          this._android._deviceClosed(this);
          this.emit(AndroidDevice.Events.Close);
        });
      }
      launchBrowser(pkg = "com.android.chrome", options) {
        return __async(this, null, function* () {
          (0, _utilsBundle.debug)("pw:android")("Force-stopping", pkg);
          yield this._backend.runCommand(`shell:am force-stop ${pkg}`);
          const socketName = (0, _utils.isUnderTest)() ? "webview_devtools_remote_playwright_test" : "playwright-" + (0, _utils.createGuid)();
          const commandLine = this._defaultArgs(options, socketName).join(" ");
          (0, _utilsBundle.debug)("pw:android")("Starting", pkg, commandLine);
          yield this._backend.runCommand(`shell:echo "${Buffer.from(commandLine).toString("base64")}" | base64 -d > /data/local/tmp/chrome-command-line`);
          yield this._backend.runCommand(`shell:am start -a android.intent.action.VIEW -d about:blank ${pkg}`);
          return yield this._connectToBrowser(socketName, options);
        });
      }
      _defaultArgs(options, socketName) {
        const chromeArguments = ["_", "--disable-fre", "--no-default-browser-check", `--remote-debugging-socket-name=${socketName}`, ..._chromiumSwitches.chromiumSwitches, ...this._innerDefaultArgs(options)];
        return chromeArguments;
      }
      _innerDefaultArgs(options) {
        const {
          args = [],
          proxy
        } = options;
        const chromeArguments = [];
        if (proxy) {
          chromeArguments.push(`--proxy-server=${proxy.server}`);
          const proxyBypassRules = [];
          if (proxy.bypass)
            proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
          if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
            proxyBypassRules.push("<-loopback>");
          if (proxyBypassRules.length > 0)
            chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
        }
        chromeArguments.push(...args);
        return chromeArguments;
      }
      connectToWebView(socketName) {
        return __async(this, null, function* () {
          const webView = this._webViews.get(socketName);
          if (!webView)
            throw new Error("WebView has been closed");
          return yield this._connectToBrowser(socketName);
        });
      }
      _connectToBrowser(_0) {
        return __async(this, arguments, function* (socketName, options = {}) {
          const socket = yield this._waitForLocalAbstract(socketName);
          const androidBrowser = new AndroidBrowser(this, socket);
          yield androidBrowser._init();
          this._browserConnections.add(androidBrowser);
          const artifactsDir = yield _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          const cleanupArtifactsDir = () => __async(this, null, function* () {
            const errors = yield (0, _fileUtils.removeFolders)([artifactsDir]);
            for (let i = 0; i < (errors || []).length; ++i)
              (0, _utilsBundle.debug)("pw:android")(`exception while removing ${artifactsDir}: ${errors[i]}`);
          });
          _processLauncher.gracefullyCloseSet.add(cleanupArtifactsDir);
          socket.on("close", () => __async(this, null, function* () {
            _processLauncher.gracefullyCloseSet.delete(cleanupArtifactsDir);
            cleanupArtifactsDir().catch((e) => (0, _utilsBundle.debug)("pw:android")(`could not cleanup artifacts dir: ${e}`));
          }));
          const browserOptions = {
            name: "clank",
            isChromium: true,
            slowMo: 0,
            persistent: __spreadProps(__spreadValues({}, options), {
              noDefaultViewport: true
            }),
            artifactsDir,
            downloadsPath: artifactsDir,
            tracesDir: artifactsDir,
            browserProcess: new ClankBrowserProcess(androidBrowser),
            proxy: options.proxy,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector: new _debugLogger.RecentLogsCollector(),
            originalLaunchOptions: {}
          };
          (0, _browserContext.validateBrowserContextOptions)(options, browserOptions);
          const browser = yield _crBrowser.CRBrowser.connect(this.attribution.playwright, androidBrowser, browserOptions);
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
          const defaultContext = browser._defaultContext;
          yield controller.run((progress2) => __async(this, null, function* () {
            yield defaultContext._loadDefaultContextAsIs(progress2);
          }));
          return defaultContext;
        });
      }
      webViews() {
        return [...this._webViews.values()];
      }
      installApk(content, options) {
        return __async(this, null, function* () {
          const args = options && options.args ? options.args : ["-r", "-t", "-S"];
          (0, _utilsBundle.debug)("pw:android")("Opening install socket");
          const installSocket = yield this._backend.open(`shell:cmd package install ${args.join(" ")} ${content.length}`);
          (0, _utilsBundle.debug)("pw:android")("Writing driver bytes: " + content.length);
          yield installSocket.write(content);
          const success = yield new Promise((f) => installSocket.on("data", f));
          (0, _utilsBundle.debug)("pw:android")("Written driver bytes: " + success);
          installSocket.close();
        });
      }
      push(content, path, mode = 420) {
        return __async(this, null, function* () {
          const socket = yield this._backend.open(`sync:`);
          const sendHeader = (command, length) => __async(this, null, function* () {
            const buffer = Buffer.alloc(command.length + 4);
            buffer.write(command, 0);
            buffer.writeUInt32LE(length, command.length);
            yield socket.write(buffer);
          });
          const send = (command, data) => __async(this, null, function* () {
            yield sendHeader(command, data.length);
            yield socket.write(data);
          });
          yield send("SEND", Buffer.from(`${path},${mode}`));
          const maxChunk = 65535;
          for (let i = 0; i < content.length; i += maxChunk)
            yield send("DATA", content.slice(i, i + maxChunk));
          yield sendHeader("DONE", Date.now() / 1e3 | 0);
          const result = yield new Promise((f) => socket.once("data", f));
          const code = result.slice(0, 4).toString();
          if (code !== "OKAY")
            throw new Error("Could not push: " + code);
          socket.close();
        });
      }
      _refreshWebViews() {
        return __async(this, null, function* () {
          const sockets = (yield this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
          if (this._isClosed)
            return;
          const socketNames = /* @__PURE__ */ new Set();
          for (const line of sockets) {
            const matchSocketName = line.match(/[^@]+@(.*?webview_devtools_remote_?.*)/);
            if (!matchSocketName)
              continue;
            const socketName = matchSocketName[1];
            socketNames.add(socketName);
            if (this._webViews.has(socketName))
              continue;
            const match = line.match(/[^@]+@.*?webview_devtools_remote_?(\d*)/);
            let pid = -1;
            if (match && match[1])
              pid = +match[1];
            const pkg = yield this._extractPkg(pid);
            if (this._isClosed)
              return;
            const webView = {
              pid,
              pkg,
              socketName
            };
            this._webViews.set(socketName, webView);
            this.emit(AndroidDevice.Events.WebViewAdded, webView);
          }
          for (const p of this._webViews.keys()) {
            if (!socketNames.has(p)) {
              this._webViews.delete(p);
              this.emit(AndroidDevice.Events.WebViewRemoved, p);
            }
          }
        });
      }
      _extractPkg(pid) {
        return __async(this, null, function* () {
          let pkg = "";
          if (pid === -1)
            return pkg;
          const procs = (yield this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split("\n");
          for (const proc of procs) {
            const match = proc.match(/[^\s]+\s+(\d+).*$/);
            if (!match)
              continue;
            pkg = proc.substring(proc.lastIndexOf(" ") + 1);
          }
          return pkg;
        });
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    AndroidDevice.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Close: "close"
    };
    var AndroidBrowser = class extends _events.EventEmitter {
      constructor(device, socket) {
        super();
        this.device = void 0;
        this._socket = void 0;
        this._receiver = void 0;
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this.onmessage = void 0;
        this.onclose = void 0;
        this.setMaxListeners(0);
        this.device = device;
        this._socket = socket;
        this._socket.on("close", () => {
          this._waitForNextTask(() => {
            if (this.onclose)
              this.onclose();
          });
        });
        this._receiver = new _utilsBundle.wsReceiver();
        this._receiver.on("message", (message) => {
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(JSON.parse(message));
          });
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
          yield new Promise((f) => this._socket.once("data", f));
          this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
          }));
        });
      }
      send(s) {
        return __async(this, null, function* () {
          yield this._socket.write(encodeWebFrame(JSON.stringify(s)));
        });
      }
      close() {
        return __async(this, null, function* () {
          this._socket.close();
        });
      }
    };
    function encodeWebFrame(data) {
      return _utilsBundle.wsSender.frame(Buffer.from(data), {
        opcode: 1,
        mask: true,
        fin: true,
        readOnly: true
      })[0];
    }
    var ClankBrowserProcess = class {
      constructor(browser) {
        this._browser = void 0;
        this.onclose = void 0;
        this._browser = browser;
      }
      kill() {
        return __async(this, null, function* () {
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._browser.close();
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/server/android/backendAdb.js
var require_backendAdb = __commonJS({
  "node_modules/playwright-core/lib/server/android/backendAdb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AdbBackend = void 0;
    var _utilsBundle = require_utilsBundle();
    var net = _interopRequireWildcard(require("net"));
    var _events = require("events");
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var AdbBackend = class {
      devices() {
        return __async(this, arguments, function* (options = {}) {
          const result = yield runCommand("host:devices", options.host, options.port);
          const lines = result.toString().trim().split("\n");
          return lines.map((line) => {
            const [serial, status] = line.trim().split("	");
            return new AdbDevice(serial, status, options.host, options.port);
          });
        });
      }
    };
    exports2.AdbBackend = AdbBackend;
    var AdbDevice = class {
      constructor(serial, status, host, port) {
        this.serial = void 0;
        this.status = void 0;
        this.host = void 0;
        this.port = void 0;
        this._closed = false;
        this.serial = serial;
        this.status = status;
        this.host = host;
        this.port = port;
      }
      init() {
        return __async(this, null, function* () {
        });
      }
      close() {
        return __async(this, null, function* () {
          this._closed = true;
        });
      }
      runCommand(command) {
        if (this._closed)
          throw new Error("Device is closed");
        return runCommand(command, this.host, this.port, this.serial);
      }
      open(command) {
        return __async(this, null, function* () {
          if (this._closed)
            throw new Error("Device is closed");
          const result = yield open2(command, this.host, this.port, this.serial);
          result.becomeSocket();
          return result;
        });
      }
    };
    function runCommand(command, host = "127.0.0.1", port = 5037, serial) {
      return __async(this, null, function* () {
        (0, _utilsBundle.debug)("pw:adb:runCommand")(command, serial);
        const socket = new BufferedSocketWrapper(command, net.createConnection({
          host,
          port
        }));
        try {
          if (serial) {
            yield socket.write(encodeMessage(`host:transport:${serial}`));
            const status2 = yield socket.read(4);
            (0, _utils.assert)(status2.toString() === "OKAY", status2.toString());
          }
          yield socket.write(encodeMessage(command));
          const status = yield socket.read(4);
          (0, _utils.assert)(status.toString() === "OKAY", status.toString());
          let commandOutput;
          if (!command.startsWith("shell:")) {
            const remainingLength = parseInt((yield socket.read(4)).toString(), 16);
            commandOutput = yield socket.read(remainingLength);
          } else {
            commandOutput = yield socket.readAll();
          }
          return commandOutput;
        } finally {
          socket.close();
        }
      });
    }
    function open2(command, host = "127.0.0.1", port = 5037, serial) {
      return __async(this, null, function* () {
        const socket = new BufferedSocketWrapper(command, net.createConnection({
          host,
          port
        }));
        if (serial) {
          yield socket.write(encodeMessage(`host:transport:${serial}`));
          const status2 = yield socket.read(4);
          (0, _utils.assert)(status2.toString() === "OKAY", status2.toString());
        }
        yield socket.write(encodeMessage(command));
        const status = yield socket.read(4);
        (0, _utils.assert)(status.toString() === "OKAY", status.toString());
        return socket;
      });
    }
    function encodeMessage(message) {
      let lenHex = message.length.toString(16);
      lenHex = "0".repeat(4 - lenHex.length) + lenHex;
      return Buffer.from(lenHex + message);
    }
    var BufferedSocketWrapper = class extends _events.EventEmitter {
      constructor(command, socket) {
        super();
        this.guid = (0, _utils.createGuid)();
        this._socket = void 0;
        this._buffer = Buffer.from([]);
        this._isSocket = false;
        this._notifyReader = void 0;
        this._connectPromise = void 0;
        this._isClosed = false;
        this._command = void 0;
        this._command = command;
        this._socket = socket;
        this._connectPromise = new Promise((f) => this._socket.on("connect", f));
        this._socket.on("data", (data) => {
          (0, _utilsBundle.debug)("pw:adb:data")(data.toString());
          if (this._isSocket) {
            this.emit("data", data);
            return;
          }
          this._buffer = Buffer.concat([this._buffer, data]);
          if (this._notifyReader)
            this._notifyReader();
        });
        this._socket.on("close", () => {
          this._isClosed = true;
          if (this._notifyReader)
            this._notifyReader();
          this.close();
          this.emit("close");
        });
        this._socket.on("error", (error) => this.emit("error", error));
      }
      write(data) {
        return __async(this, null, function* () {
          (0, _utilsBundle.debug)("pw:adb:send")(data.toString().substring(0, 100) + "...");
          yield this._connectPromise;
          yield new Promise((f) => this._socket.write(data, f));
        });
      }
      close() {
        if (this._isClosed)
          return;
        (0, _utilsBundle.debug)("pw:adb")("Close " + this._command);
        this._socket.destroy();
      }
      read(length) {
        return __async(this, null, function* () {
          yield this._connectPromise;
          (0, _utils.assert)(!this._isSocket, "Can not read by length in socket mode");
          while (this._buffer.length < length)
            yield new Promise((f) => this._notifyReader = f);
          const result = this._buffer.slice(0, length);
          this._buffer = this._buffer.slice(length);
          (0, _utilsBundle.debug)("pw:adb:recv")(result.toString().substring(0, 100) + "...");
          return result;
        });
      }
      readAll() {
        return __async(this, null, function* () {
          while (!this._isClosed)
            yield new Promise((f) => this._notifyReader = f);
          return this._buffer;
        });
      }
      becomeSocket() {
        (0, _utils.assert)(!this._buffer.length);
        this._isSocket = true;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/transport.js
var require_transport2 = __commonJS({
  "node_modules/playwright-core/lib/server/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocketTransport = void 0;
    var _utilsBundle = require_utilsBundle();
    var _utils = require_utils();
    var _happyEyeballs = require_happy_eyeballs();
    var WebSocketTransport = class {
      static connect(progress2, url, headers, followRedirects, debugLogHeader) {
        return __async(this, null, function* () {
          const logUrl = stripQueryParams(url);
          progress2 === null || progress2 === void 0 ? void 0 : progress2.log(`<ws connecting> ${logUrl}`);
          const transport = new WebSocketTransport(progress2, url, logUrl, headers, followRedirects, debugLogHeader);
          let success = false;
          progress2 === null || progress2 === void 0 ? void 0 : progress2.cleanupWhenAborted(() => __async(this, null, function* () {
            if (!success)
              yield transport.closeAndWait().catch((e) => null);
          }));
          yield new Promise((fulfill, reject) => {
            transport._ws.on("open", () => __async(this, null, function* () {
              progress2 === null || progress2 === void 0 ? void 0 : progress2.log(`<ws connected> ${logUrl}`);
              fulfill(transport);
            }));
            transport._ws.on("error", (event) => {
              progress2 === null || progress2 === void 0 ? void 0 : progress2.log(`<ws connect error> ${logUrl} ${event.message}`);
              reject(new Error("WebSocket error: " + event.message));
              transport._ws.close();
            });
            transport._ws.on("unexpected-response", (request, response) => {
              for (let i = 0; i < response.rawHeaders.length; i += 2) {
                if (debugLogHeader && response.rawHeaders[i] === debugLogHeader)
                  progress2 === null || progress2 === void 0 ? void 0 : progress2.log(response.rawHeaders[i + 1]);
              }
              const chunks = [];
              const errorPrefix = `${logUrl} ${response.statusCode} ${response.statusMessage}`;
              response.on("data", (chunk) => chunks.push(chunk));
              response.on("close", () => {
                const error = chunks.length ? `${errorPrefix}
${Buffer.concat(chunks)}` : errorPrefix;
                progress2 === null || progress2 === void 0 ? void 0 : progress2.log(`<ws unexpected response> ${error}`);
                reject(new Error("WebSocket error: " + error));
                transport._ws.close();
              });
            });
          });
          success = true;
          return transport;
        });
      }
      constructor(progress2, url, logUrl, headers, followRedirects, debugLogHeader) {
        var _progress$timeUntilDe;
        this._ws = void 0;
        this._progress = void 0;
        this._logUrl = void 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this.wsEndpoint = void 0;
        this.headers = [];
        this.wsEndpoint = url;
        this._logUrl = logUrl;
        this._ws = new _utilsBundle.ws(url, [], {
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          handshakeTimeout: Math.max((_progress$timeUntilDe = progress2 === null || progress2 === void 0 ? void 0 : progress2.timeUntilDeadline()) !== null && _progress$timeUntilDe !== void 0 ? _progress$timeUntilDe : 3e4, 1),
          headers,
          followRedirects,
          agent: /^(https|wss):\/\//.test(url) ? _happyEyeballs.httpsHappyEyeballsAgent : _happyEyeballs.httpHappyEyeballsAgent
        });
        this._ws.on("upgrade", (response) => {
          for (let i = 0; i < response.rawHeaders.length; i += 2) {
            this.headers.push({
              name: response.rawHeaders[i],
              value: response.rawHeaders[i + 1]
            });
            if (debugLogHeader && response.rawHeaders[i] === debugLogHeader)
              progress2 === null || progress2 === void 0 ? void 0 : progress2.log(response.rawHeaders[i + 1]);
          }
        });
        this._progress = progress2;
        const messageWrap = (0, _utils.makeWaitForNextTask)();
        this._ws.addEventListener("message", (event) => {
          messageWrap(() => {
            const eventData = event.data;
            let parsedJson;
            try {
              parsedJson = JSON.parse(eventData);
            } catch (e) {
              var _this$_progress;
              (_this$_progress = this._progress) === null || _this$_progress === void 0 ? void 0 : _this$_progress.log(`<closing ws> Closing websocket due to malformed JSON. eventData=${eventData} e=${e === null || e === void 0 ? void 0 : e.message}`);
              this._ws.close();
              return;
            }
            try {
              if (this.onmessage)
                this.onmessage.call(null, parsedJson);
            } catch (e) {
              var _this$_progress2;
              (_this$_progress2 = this._progress) === null || _this$_progress2 === void 0 ? void 0 : _this$_progress2.log(`<closing ws> Closing websocket due to failed onmessage callback. eventData=${eventData} e=${e === null || e === void 0 ? void 0 : e.message}`);
              this._ws.close();
            }
          });
        });
        this._ws.addEventListener("close", (event) => {
          var _this$_progress3;
          (_this$_progress3 = this._progress) === null || _this$_progress3 === void 0 ? void 0 : _this$_progress3.log(`<ws disconnected> ${logUrl} code=${event.code} reason=${event.reason}`);
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", (error) => {
          var _this$_progress4;
          return (_this$_progress4 = this._progress) === null || _this$_progress4 === void 0 ? void 0 : _this$_progress4.log(`<ws error> ${logUrl} ${error.type} ${error.message}`);
        });
      }
      send(message) {
        this._ws.send(JSON.stringify(message));
      }
      close() {
        var _this$_progress5;
        (_this$_progress5 = this._progress) === null || _this$_progress5 === void 0 ? void 0 : _this$_progress5.log(`<ws disconnecting> ${this._logUrl}`);
        this._ws.close();
      }
      closeAndWait() {
        return __async(this, null, function* () {
          if (this._ws.readyState === _utilsBundle.ws.CLOSED)
            return;
          const promise = new Promise((f) => this._ws.once("close", f));
          this.close();
          yield promise;
        });
      }
    };
    exports2.WebSocketTransport = WebSocketTransport;
    function stripQueryParams(url) {
      try {
        const u = new URL(url);
        u.search = "";
        u.hash = "";
        return u.toString();
      } catch (e) {
        return url;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/pipeTransport.js
var require_pipeTransport = __commonJS({
  "node_modules/playwright-core/lib/server/pipeTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PipeTransport = void 0;
    var _utils = require_utils();
    var _debugLogger = require_debugLogger();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pipeRead = void 0;
        this._pipeWrite = void 0;
        this._pendingBuffers = [];
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this._closed = false;
        this._onclose = void 0;
        this.onmessage = void 0;
        this._pipeRead = pipeRead;
        this._pipeWrite = pipeWrite;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this._onclose)
            this._onclose.call(null);
        });
        pipeRead.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        pipeWrite.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        this.onmessage = void 0;
      }
      get onclose() {
        return this._onclose;
      }
      set onclose(onclose) {
        this._onclose = onclose;
        if (onclose && !this._pipeRead.readable)
          onclose();
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        this._pipeWrite.write(JSON.stringify(message));
        this._pipeWrite.write("\0");
      }
      close() {
        throw new Error("unimplemented");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingBuffers.push(buffer);
          return;
        }
        this._pendingBuffers.push(buffer.slice(0, end));
        const message = Buffer.concat(this._pendingBuffers).toString();
        this._waitForNextTask(() => {
          if (this.onmessage)
            this.onmessage.call(null, JSON.parse(message));
        });
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          const message2 = buffer.toString(void 0, start, end);
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage.call(null, JSON.parse(message2));
          });
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingBuffers = [buffer.slice(start)];
      }
    };
    exports2.PipeTransport = PipeTransport;
  }
});

// node_modules/playwright-core/lib/server/browserType.js
var require_browserType = __commonJS({
  "node_modules/playwright-core/lib/server/browserType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kNoXServerRunningError = exports2.BrowserType = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var os = _interopRequireWildcard(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _browserContext = require_browserContext();
    var _registry = require_registry();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _pipeTransport = require_pipeTransport();
    var _progress = require_progress();
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _helper = require_helper();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kNoXServerRunningError = "Looks like you launched a headed browser without having a XServer running.\nSet either 'headless: true' or use 'xvfb-run <your-playwright-app>' before running Playwright.\n\n<3 Playwright Team";
    exports2.kNoXServerRunningError = kNoXServerRunningError;
    var BrowserType = class extends _instrumentation.SdkObject {
      constructor(parent, browserName) {
        super(parent, "browser-type");
        this._name = void 0;
        this.attribution.browserType = this;
        this._name = browserName;
      }
      executablePath() {
        return _registry.registry.findExecutable(this._name).executablePath(this.attribution.playwright.options.sdkLanguage) || "";
      }
      name() {
        return this._name;
      }
      launch(metadata, options, protocolLogger) {
        return __async(this, null, function* () {
          options = this._validateLaunchOptions(options);
          const controller = new _progress.ProgressController(metadata, this);
          controller.setLogName("browser");
          const browser = yield controller.run((progress2) => {
            const seleniumHubUrl = options.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
            if (seleniumHubUrl)
              return this._launchWithSeleniumHub(progress2, seleniumHubUrl, options);
            return this._innerLaunchWithRetries(progress2, options, void 0, _helper.helper.debugProtocolLogger(protocolLogger)).catch((e) => {
              throw this._rewriteStartupError(e);
            });
          }, _timeoutSettings.TimeoutSettings.launchTimeout(options));
          return browser;
        });
      }
      launchPersistentContext(metadata, userDataDir, options) {
        return __async(this, null, function* () {
          options = this._validateLaunchOptions(options);
          const controller = new _progress.ProgressController(metadata, this);
          const persistent = options;
          controller.setLogName("browser");
          const browser = yield controller.run((progress2) => {
            return this._innerLaunchWithRetries(progress2, options, persistent, _helper.helper.debugProtocolLogger(), userDataDir).catch((e) => {
              throw this._rewriteStartupError(e);
            });
          }, _timeoutSettings.TimeoutSettings.launchTimeout(options));
          return browser._defaultContext;
        });
      }
      _innerLaunchWithRetries(progress2, options, persistent, protocolLogger, userDataDir) {
        return __async(this, null, function* () {
          try {
            return yield this._innerLaunch(progress2, options, persistent, protocolLogger, userDataDir);
          } catch (error) {
            const errorMessage = typeof error === "object" && typeof error.message === "string" ? error.message : "";
            if (errorMessage.includes("Inconsistency detected by ld.so")) {
              progress2.log(`<restarting browser due to hitting race condition in glibc>`);
              return this._innerLaunch(progress2, options, persistent, protocolLogger, userDataDir);
            }
            throw error;
          }
        });
      }
      _innerLaunch(progress2, options, persistent, protocolLogger, maybeUserDataDir) {
        return __async(this, null, function* () {
          options.proxy = options.proxy ? (0, _browserContext.normalizeProxySettings)(options.proxy) : void 0;
          const browserLogsCollector = new _debugLogger.RecentLogsCollector();
          const {
            browserProcess,
            userDataDir,
            artifactsDir,
            transport
          } = yield this._launchProcess(progress2, options, !!persistent, browserLogsCollector, maybeUserDataDir);
          if (options.__testHookBeforeCreateBrowser)
            yield options.__testHookBeforeCreateBrowser();
          const browserOptions = {
            name: this._name,
            isChromium: this._name === "chromium",
            channel: options.channel,
            slowMo: options.slowMo,
            persistent,
            headful: !options.headless,
            artifactsDir,
            downloadsPath: options.downloadsPath || artifactsDir,
            tracesDir: options.tracesDir || artifactsDir,
            browserProcess,
            customExecutablePath: options.executablePath,
            proxy: options.proxy,
            protocolLogger,
            browserLogsCollector,
            wsEndpoint: options.useWebSocket ? transport.wsEndpoint : void 0,
            originalLaunchOptions: options
          };
          if (persistent)
            (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
          copyTestHooks(options, browserOptions);
          const browser = yield this._connectToTransport(transport, browserOptions);
          browser._userDataDirForTest = userDataDir;
          if (persistent && !options.ignoreAllDefaultArgs)
            yield browser._defaultContext._loadDefaultContext(progress2);
          return browser;
        });
      }
      _launchProcess(progress2, options, isPersistent, browserLogsCollector, userDataDir) {
        return __async(this, null, function* () {
          var _options$args;
          const {
            ignoreDefaultArgs,
            ignoreAllDefaultArgs,
            args = [],
            executablePath = null,
            handleSIGINT = true,
            handleSIGTERM = true,
            handleSIGHUP = true
          } = options;
          const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
          yield this._createArtifactDirs(options);
          const tempDirectories = [];
          const artifactsDir = yield _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), "playwright-artifacts-"));
          tempDirectories.push(artifactsDir);
          if (userDataDir) {
            if (!(yield (0, _fileUtils.existsAsync)(userDataDir)))
              yield _fs.default.promises.mkdir(userDataDir, {
                recursive: true,
                mode: 448
              });
          } else {
            userDataDir = yield _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
            tempDirectories.push(userDataDir);
          }
          const browserArguments = [];
          if (ignoreAllDefaultArgs)
            browserArguments.push(...args);
          else if (ignoreDefaultArgs)
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
          else
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));
          let executable;
          if (executablePath) {
            if (!(yield (0, _fileUtils.existsAsync)(executablePath)))
              throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
            executable = executablePath;
          } else {
            const registryExecutable = _registry.registry.findExecutable(options.channel || this._name);
            if (!registryExecutable || registryExecutable.browserName !== this._name)
              throw new Error(`Unsupported ${this._name} channel "${options.channel}"`);
            executable = registryExecutable.executablePathOrDie(this.attribution.playwright.options.sdkLanguage);
            yield registryExecutable.validateHostRequirements(this.attribution.playwright.options.sdkLanguage);
          }
          const waitForWSEndpoint = options.useWebSocket || (_options$args = options.args) !== null && _options$args !== void 0 && _options$args.some((a) => a.startsWith("--remote-debugging-port")) ? new _manualPromise.ManualPromise() : void 0;
          const waitForJuggler = this._name === "firefox" ? new _manualPromise.ManualPromise() : void 0;
          let transport = void 0;
          let browserProcess = void 0;
          const {
            launchedProcess,
            gracefullyClose,
            kill
          } = yield (0, _processLauncher.launchProcess)({
            command: executable,
            args: browserArguments,
            env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
            handleSIGINT,
            handleSIGTERM,
            handleSIGHUP,
            log: (message) => {
              if (waitForWSEndpoint) {
                const match = message.match(/DevTools listening on (.*)/);
                if (match)
                  waitForWSEndpoint.resolve(match[1]);
              }
              if (waitForJuggler && message.includes("Juggler listening to the pipe"))
                waitForJuggler.resolve();
              progress2.log(message);
              browserLogsCollector.log(message);
            },
            stdio: "pipe",
            tempDirectories,
            attemptToGracefullyClose: () => __async(this, null, function* () {
              if (options.__testHookGracefullyClose)
                yield options.__testHookGracefullyClose();
              this._attemptToGracefullyCloseBrowser(transport);
            }),
            onExit: (exitCode, signal) => {
              waitForJuggler === null || waitForJuggler === void 0 ? void 0 : waitForJuggler.resolve();
              if (browserProcess && browserProcess.onclose)
                browserProcess.onclose(exitCode, signal);
            }
          });
          function closeOrKill(timeout) {
            return __async(this, null, function* () {
              let timer;
              try {
                yield Promise.race([gracefullyClose(), new Promise((resolve, reject) => timer = setTimeout(reject, timeout))]);
              } catch (ignored) {
                yield kill().catch((ignored2) => {
                });
              } finally {
                clearTimeout(timer);
              }
            });
          }
          browserProcess = {
            onclose: void 0,
            process: launchedProcess,
            close: () => closeOrKill(options.__testHookBrowserCloseTimeout || _timeoutSettings.DEFAULT_TIMEOUT),
            kill
          };
          progress2.cleanupWhenAborted(() => closeOrKill(progress2.timeUntilDeadline()));
          const wsEndpoint = yield waitForWSEndpoint;
          yield waitForJuggler;
          if (options.useWebSocket) {
            transport = yield _transport.WebSocketTransport.connect(progress2, wsEndpoint);
          } else {
            const stdio = launchedProcess.stdio;
            transport = new _pipeTransport.PipeTransport(stdio[3], stdio[4]);
          }
          return {
            browserProcess,
            artifactsDir,
            userDataDir,
            transport
          };
        });
      }
      _createArtifactDirs(options) {
        return __async(this, null, function* () {
          if (options.downloadsPath)
            yield _fs.default.promises.mkdir(options.downloadsPath, {
              recursive: true
            });
          if (options.tracesDir)
            yield _fs.default.promises.mkdir(options.tracesDir, {
              recursive: true
            });
        });
      }
      connectOverCDP(metadata, endpointURL, options, timeout) {
        return __async(this, null, function* () {
          throw new Error("CDP connections are only supported by Chromium");
        });
      }
      _launchWithSeleniumHub(progress2, hubUrl, options) {
        return __async(this, null, function* () {
          throw new Error("Connecting to SELENIUM_REMOTE_URL is only supported by Chromium");
        });
      }
      _validateLaunchOptions(options) {
        const {
          devtools = false
        } = options;
        let {
          headless = !devtools,
          downloadsPath,
          proxy
        } = options;
        if ((0, _utils.debugMode)())
          headless = false;
        if (downloadsPath && !_path.default.isAbsolute(downloadsPath))
          downloadsPath = _path.default.join(process.cwd(), downloadsPath);
        if (this.attribution.playwright.options.socksProxyPort)
          proxy = {
            server: `socks5://127.0.0.1:${this.attribution.playwright.options.socksProxyPort}`
          };
        return __spreadProps(__spreadValues({}, options), {
          devtools,
          headless,
          downloadsPath,
          proxy
        });
      }
    };
    exports2.BrowserType = BrowserType;
    function copyTestHooks(from, to) {
      for (const [key, value] of Object.entries(from)) {
        if (key.startsWith("__testHook"))
          to[key] = value;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crDevTools.js
var require_crDevTools = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDevTools.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRDevTools = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kBindingName = "__pw_devtools__";
    var CRDevTools = class {
      constructor(preferencesPath) {
        this._preferencesPath = void 0;
        this._prefs = void 0;
        this._savePromise = void 0;
        this.__testHookOnBinding = void 0;
        this._preferencesPath = preferencesPath;
        this._savePromise = Promise.resolve();
      }
      install(session) {
        session.on("Runtime.bindingCalled", (event) => __async(this, null, function* () {
          if (event.name !== kBindingName)
            return;
          const parsed = JSON.parse(event.payload);
          let result = void 0;
          if (this.__testHookOnBinding)
            this.__testHookOnBinding(parsed);
          if (parsed.method === "getPreferences") {
            if (this._prefs === void 0) {
              try {
                const json = yield _fs.default.promises.readFile(this._preferencesPath, "utf8");
                this._prefs = JSON.parse(json);
              } catch (e) {
                this._prefs = {};
              }
            }
            result = this._prefs;
          } else if (parsed.method === "setPreference") {
            this._prefs[parsed.params[0]] = parsed.params[1];
            this._save();
          } else if (parsed.method === "removePreference") {
            delete this._prefs[parsed.params[0]];
            this._save();
          } else if (parsed.method === "clearPreferences") {
            this._prefs = {};
            this._save();
          }
          session.send("Runtime.evaluate", {
            expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
            contextId: event.executionContextId
          }).catch((e) => null);
        }));
        Promise.all([session.send("Runtime.enable"), session.send("Runtime.addBinding", {
          name: kBindingName
        }), session.send("Page.enable"), session.send("Page.addScriptToEvaluateOnNewDocument", {
          source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      `
        }), session.send("Runtime.runIfWaitingForDebugger")]).catch((e) => null);
      }
      _save() {
        this._savePromise = this._savePromise.then(() => __async(this, null, function* () {
          yield _fs.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
        }));
      }
    };
    exports2.CRDevTools = CRDevTools;
  }
});

// node_modules/playwright-core/lib/server/chromium/chromium.js
var require_chromium = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/chromium.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Chromium = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _crBrowser = require_crBrowser();
    var _processLauncher = require_processLauncher();
    var _crConnection = require_crConnection();
    var _stackTrace = require_stackTrace();
    var _browserType = require_browserType();
    var _transport = require_transport2();
    var _crDevTools = require_crDevTools();
    var _browser = require_browser();
    var _network = require_network();
    var _userAgent = require_userAgent();
    var _ascii = require_ascii();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _debugLogger = require_debugLogger();
    var _progress = require_progress();
    var _timeoutSettings = require_timeoutSettings();
    var _helper = require_helper();
    var _registry = require_registry();
    var _manualPromise = require_manualPromise();
    var _browserContext = require_browserContext();
    var _chromiumSwitches = require_chromiumSwitches();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var Chromium = class extends _browserType.BrowserType {
      constructor(parent) {
        super(parent, "chromium");
        this._devtools = void 0;
        if ((0, _utils.debugMode)())
          this._devtools = this._createDevTools();
      }
      connectOverCDP(metadata, endpointURL, options, timeout) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          controller.setLogName("browser");
          return controller.run((progress2) => __async(this, null, function* () {
            return yield this._connectOverCDPInternal(progress2, endpointURL, options);
          }), _timeoutSettings.TimeoutSettings.timeout({
            timeout
          }));
        });
      }
      _connectOverCDPInternal(progress2, endpointURL, options, onClose) {
        return __async(this, null, function* () {
          let headersMap;
          if (options.headers)
            headersMap = (0, _utils.headersArrayToObject)(options.headers, false);
          if (!headersMap)
            headersMap = {
              "User-Agent": (0, _userAgent.getUserAgent)()
            };
          else if (headersMap && !Object.keys(headersMap).some((key) => key.toLowerCase() === "user-agent"))
            headersMap["User-Agent"] = (0, _userAgent.getUserAgent)();
          const artifactsDir = yield _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          const wsEndpoint = yield urlToWSEndpoint(progress2, endpointURL);
          progress2.throwIfAborted();
          const chromeTransport = yield _transport.WebSocketTransport.connect(progress2, wsEndpoint, headersMap);
          const cleanedUp = new _manualPromise.ManualPromise();
          const doCleanup = () => __async(this, null, function* () {
            yield (0, _fileUtils.removeFolders)([artifactsDir]);
            yield onClose === null || onClose === void 0 ? void 0 : onClose();
            cleanedUp.resolve();
          });
          const doClose = () => __async(this, null, function* () {
            yield chromeTransport.closeAndWait();
            yield cleanedUp;
          });
          const browserProcess = {
            close: doClose,
            kill: doClose
          };
          const persistent = {
            noDefaultViewport: true
          };
          const browserOptions = {
            slowMo: options.slowMo,
            name: "chromium",
            isChromium: true,
            persistent,
            browserProcess,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector: new _debugLogger.RecentLogsCollector(),
            artifactsDir,
            downloadsPath: options.downloadsPath || artifactsDir,
            tracesDir: options.tracesDir || artifactsDir,
            proxy: {
              server: "per-context"
            },
            originalLaunchOptions: {}
          };
          (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
          progress2.throwIfAborted();
          const browser = yield _crBrowser.CRBrowser.connect(this.attribution.playwright, chromeTransport, browserOptions);
          browser.on(_browser.Browser.Events.Disconnected, doCleanup);
          return browser;
        });
      }
      _createDevTools() {
        const directory = _registry.registry.findExecutable("chromium").directory;
        return directory ? new _crDevTools.CRDevTools(_path.default.join(directory, "devtools-preferences.json")) : void 0;
      }
      _connectToTransport(transport, options) {
        return __async(this, null, function* () {
          let devtools = this._devtools;
          if (options.__testHookForDevTools) {
            devtools = this._createDevTools();
            yield options.__testHookForDevTools(devtools);
          }
          return _crBrowser.CRBrowser.connect(this.attribution.playwright, transport, options, devtools);
        });
      }
      _rewriteStartupError(error) {
        if (error.message.includes("Missing X server"))
          return (0, _stackTrace.rewriteErrorMessage)(error, "\n" + (0, _ascii.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
        if (!error.message.includes("crbug.com/357670") && !error.message.includes("No usable sandbox!") && !error.message.includes("crbug.com/638180"))
          return error;
        return (0, _stackTrace.rewriteErrorMessage)(error, [`Chromium sandboxing failed!`, `================================`, `To workaround sandboxing issues, do either of the following:`, `  - (preferred): Configure environment to support sandboxing: https://playwright.dev/docs/troubleshooting`, `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`, `================================`, ``].join("\n"));
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          id: _crConnection.kBrowserCloseMessageId,
          params: {}
        };
        transport.send(message);
      }
      _launchWithSeleniumHub(progress2, hubUrl, options) {
        return __async(this, null, function* () {
          yield this._createArtifactDirs(options);
          if (!hubUrl.endsWith("/"))
            hubUrl = hubUrl + "/";
          const args = this._innerDefaultArgs(options);
          args.push("--remote-debugging-port=0");
          const isEdge = options.channel && options.channel.startsWith("msedge");
          let desiredCapabilities = {
            "browserName": isEdge ? "MicrosoftEdge" : "chrome",
            [isEdge ? "ms:edgeOptions" : "goog:chromeOptions"]: {
              args
            }
          };
          if (process.env.SELENIUM_REMOTE_CAPABILITIES) {
            const remoteCapabilities = parseSeleniumRemoteParams({
              name: "capabilities",
              value: process.env.SELENIUM_REMOTE_CAPABILITIES
            }, progress2);
            if (remoteCapabilities)
              desiredCapabilities = __spreadValues(__spreadValues({}, desiredCapabilities), remoteCapabilities);
          }
          let headers = {};
          if (process.env.SELENIUM_REMOTE_HEADERS) {
            const remoteHeaders = parseSeleniumRemoteParams({
              name: "headers",
              value: process.env.SELENIUM_REMOTE_HEADERS
            }, progress2);
            if (remoteHeaders)
              headers = remoteHeaders;
          }
          progress2.log(`<selenium> connecting to ${hubUrl}`);
          const response = yield (0, _network.fetchData)({
            url: hubUrl + "session",
            method: "POST",
            headers: __spreadValues({
              "Content-Type": "application/json; charset=utf-8"
            }, headers),
            data: JSON.stringify({
              desiredCapabilities,
              capabilities: {
                alwaysMatch: desiredCapabilities
              }
            }),
            timeout: progress2.timeUntilDeadline()
          }, seleniumErrorHandler);
          const value = JSON.parse(response).value;
          const sessionId = value.sessionId;
          progress2.log(`<selenium> connected to sessionId=${sessionId}`);
          const disconnectFromSelenium = () => __async(this, null, function* () {
            progress2.log(`<selenium> disconnecting from sessionId=${sessionId}`);
            yield (0, _network.fetchData)({
              url: hubUrl + "session/" + sessionId,
              method: "DELETE",
              headers
            }).catch((error) => progress2.log(`<error disconnecting from selenium>: ${error}`));
            progress2.log(`<selenium> disconnected from sessionId=${sessionId}`);
            _processLauncher.gracefullyCloseSet.delete(disconnectFromSelenium);
          });
          _processLauncher.gracefullyCloseSet.add(disconnectFromSelenium);
          try {
            const capabilities = value.capabilities;
            let endpointURL;
            if (capabilities["se:cdp"]) {
              progress2.log(`<selenium> using selenium v4`);
              const endpointURLString = addProtocol(capabilities["se:cdp"]);
              endpointURL = new URL(endpointURLString);
              if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1")
                endpointURL.hostname = new URL(hubUrl).hostname;
              progress2.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
            } else {
              progress2.log(`<selenium> using selenium v3`);
              const maybeChromeOptions = capabilities["goog:chromeOptions"];
              const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === "object" ? maybeChromeOptions : void 0;
              const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === "string" ? chromeOptions.debuggerAddress : void 0;
              const chromeOptionsURL = typeof maybeChromeOptions === "string" ? maybeChromeOptions : void 0;
              const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL).replace("localhost", "127.0.0.1");
              progress2.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);
              endpointURL = new URL(endpointURLString);
              if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1") {
                const sessionInfoUrl = new URL(hubUrl).origin + "/grid/api/testsession?session=" + sessionId;
                try {
                  const sessionResponse = yield (0, _network.fetchData)({
                    url: sessionInfoUrl,
                    method: "GET",
                    timeout: progress2.timeUntilDeadline(),
                    headers
                  }, seleniumErrorHandler);
                  const proxyId = JSON.parse(sessionResponse).proxyId;
                  endpointURL.hostname = new URL(proxyId).hostname;
                  progress2.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
                } catch (e) {
                  progress2.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
                }
              }
            }
            return yield this._connectOverCDPInternal(progress2, endpointURL.toString(), __spreadProps(__spreadValues({}, options), {
              headers: (0, _utils.headersObjectToArray)(headers)
            }), disconnectFromSelenium);
          } catch (e) {
            yield disconnectFromSelenium();
            throw e;
          }
        });
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const chromeArguments = this._innerDefaultArgs(options);
        chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (options.useWebSocket)
          chromeArguments.push("--remote-debugging-port=0");
        else
          chromeArguments.push("--remote-debugging-pipe");
        if (isPersistent)
          chromeArguments.push("about:blank");
        else
          chromeArguments.push("--no-startup-window");
        return chromeArguments;
      }
      _innerDefaultArgs(options) {
        const {
          args = [],
          proxy
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
          throw new Error("Playwright manages remote debugging connection itself.");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const chromeArguments = [..._chromiumSwitches.chromiumSwitches];
        if (_os.default.platform() === "darwin") {
          chromeArguments.push("--enable-use-zoom-for-dsf=false");
          if (options.headless)
            chromeArguments.push("--use-angle");
        }
        if (options.devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (options.headless) {
          if (process.env.PLAYWRIGHT_CHROMIUM_USE_HEADLESS_NEW)
            chromeArguments.push("--headless=new");
          else
            chromeArguments.push("--headless");
          chromeArguments.push("--hide-scrollbars", "--mute-audio", "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4");
        }
        if (options.chromiumSandbox !== true)
          chromeArguments.push("--no-sandbox");
        if (proxy) {
          const proxyURL = new URL(proxy.server);
          const isSocks = proxyURL.protocol === "socks5:";
          if (isSocks && !this.attribution.playwright.options.socksProxyPort) {
            chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
          }
          chromeArguments.push(`--proxy-server=${proxy.server}`);
          const proxyBypassRules = [];
          if (this.attribution.playwright.options.socksProxyPort)
            proxyBypassRules.push("<-loopback>");
          if (proxy.bypass)
            proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
          if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
            proxyBypassRules.push("<-loopback>");
          if (proxyBypassRules.length > 0)
            chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
        }
        chromeArguments.push(...args);
        return chromeArguments;
      }
    };
    exports2.Chromium = Chromium;
    function urlToWSEndpoint(progress2, endpointURL) {
      return __async(this, null, function* () {
        if (endpointURL.startsWith("ws"))
          return endpointURL;
        progress2.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
        const httpURL = endpointURL.endsWith("/") ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
        const json = yield (0, _network.fetchData)({
          url: httpURL
        }, (_, resp) => __async(this, null, function* () {
          return new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.
This does not look like a DevTools server, try connecting via ws://.`);
        }));
        return JSON.parse(json).webSocketDebuggerUrl;
      });
    }
    function seleniumErrorHandler(params, response) {
      return __async(this, null, function* () {
        const body = yield streamToString(response);
        let message = body;
        try {
          const json = JSON.parse(body);
          message = json.value.localizedMessage || json.value.message;
        } catch (e) {
        }
        return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
      });
    }
    function addProtocol(url) {
      if (!["ws://", "wss://", "http://", "https://"].some((protocol) => url.startsWith(protocol)))
        return "http://" + url;
      return url;
    }
    function streamToString(stream) {
      return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on("error", reject);
        stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
      });
    }
    function parseSeleniumRemoteParams(env, progress2) {
      try {
        const parsed = JSON.parse(env.value);
        progress2.log(`<selenium> using additional ${env.name} "${env.value}"`);
        return parsed;
      } catch (e) {
        progress2.log(`<selenium> ignoring additional ${env.name} "${env.value}": ${e}`);
      }
    }
  }
});

// node_modules/electron/index.js
var require_electron = __commonJS({
  "node_modules/electron/index.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var pathFile = path.join(__dirname, "path.txt");
    function getElectronPath() {
      let executablePath;
      if (fs.existsSync(pathFile)) {
        executablePath = fs.readFileSync(pathFile, "utf-8");
      }
      if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {
        return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || "electron");
      }
      if (executablePath) {
        return path.join(__dirname, "dist", executablePath);
      } else {
        throw new Error("Electron failed to install correctly, please delete node_modules/electron and try installing again");
      }
    }
    module2.exports = getElectronPath();
  }
});

// node_modules/playwright-core/lib/server/electron/electron.js
var require_electron2 = __commonJS({
  "node_modules/playwright-core/lib/server/electron/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronApplication = exports2.Electron = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _crBrowser = require_crBrowser();
    var _crConnection = require_crConnection();
    var _crExecutionContext = require_crExecutionContext();
    var js = _interopRequireWildcard(require_javascript());
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _browserContext = require_browserContext();
    var _progress = require_progress();
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var readline = _interopRequireWildcard(require("readline"));
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var ElectronApplication = class extends _instrumentation.SdkObject {
      constructor(parent, browser, nodeConnection, process2) {
        super(parent, "electron-app");
        this._browserContext = void 0;
        this._nodeConnection = void 0;
        this._nodeSession = void 0;
        this._nodeExecutionContext = void 0;
        this._nodeElectronHandlePromise = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._process = void 0;
        this._process = process2;
        this._browserContext = browser._defaultContext;
        this._browserContext.on(_browserContext.BrowserContext.Events.Close, () => {
          Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
        });
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
        this._nodeElectronHandlePromise = new Promise((f) => {
          this._nodeSession.on("Runtime.executionContextCreated", (event) => __async(this, null, function* () {
            if (event.context.auxData && event.context.auxData.isDefault) {
              this._nodeExecutionContext = new js.ExecutionContext(this, new _crExecutionContext.CRExecutionContext(this._nodeSession, event.context), "electron");
              const source = `process.mainModule.require('electron')`;
              f(yield this._nodeExecutionContext.rawEvaluateHandle(source).then((objectId) => new js.JSHandle(this._nodeExecutionContext, "object", "ElectronModule", objectId)));
            }
          }));
        });
        this._browserContext.setCustomCloseHandler(() => __async(this, null, function* () {
          const electronHandle = yield this._nodeElectronHandlePromise;
          yield electronHandle.evaluate(({
            app
          }) => app.quit()).catch(() => {
          });
        }));
      }
      initialize() {
        return __async(this, null, function* () {
          yield this._nodeSession.send("Runtime.enable", {});
          yield this._nodeSession.send("Runtime.evaluate", {
            expression: "__playwright_run()"
          });
        });
      }
      process() {
        return this._process;
      }
      context() {
        return this._browserContext;
      }
      close() {
        return __async(this, null, function* () {
          const progressController = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
          const closed = progressController.run((progress2) => _helper.helper.waitForEvent(progress2, this, ElectronApplication.Events.Close).promise);
          yield this._browserContext.close((0, _instrumentation.serverSideCallMetadata)());
          this._nodeConnection.close();
          yield closed;
        });
      }
      browserWindow(page) {
        return __async(this, null, function* () {
          const targetId = page._delegate._targetId;
          const electronHandle = yield this._nodeElectronHandlePromise;
          return yield electronHandle.evaluateHandle(({
            BrowserWindow,
            webContents
          }, targetId2) => {
            const wc = webContents.fromDevToolsTargetId(targetId2);
            return BrowserWindow.fromWebContents(wc);
          }, targetId);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
    ElectronApplication.Events = {
      Close: "close"
    };
    var Electron = class extends _instrumentation.SdkObject {
      constructor(playwright) {
        super(playwright, "electron");
      }
      launch(options) {
        return __async(this, null, function* () {
          const {
            args = []
          } = options;
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
          controller.setLogName("browser");
          return controller.run((progress2) => __async(this, null, function* () {
            let app = void 0;
            const electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...args];
            if (_os.default.platform() === "linux") {
              const runningAsRoot = process.geteuid && process.geteuid() === 0;
              if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
                electronArguments.push("--no-sandbox");
            }
            const artifactsDir = yield _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
            const browserLogsCollector = new _debugLogger.RecentLogsCollector();
            const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
            let command;
            if (options.executablePath) {
              command = options.executablePath;
            } else {
              try {
                command = require_electron();
              } catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.code) === "MODULE_NOT_FOUND") {
                  throw new Error("\n" + (0, _utils.wrapInASCIIBox)(["Electron executablePath not found!", "Please install it using `npm install -D electron` or set the executablePath to your Electron executable."].join("\n"), 1));
                }
                throw error;
              }
              electronArguments.unshift("-r", require.resolve("./loader"));
            }
            delete env.NODE_OPTIONS;
            const {
              launchedProcess,
              gracefullyClose,
              kill
            } = yield (0, _processLauncher.launchProcess)({
              command,
              args: electronArguments,
              env,
              log: (message) => {
                progress2.log(message);
                browserLogsCollector.log(message);
              },
              stdio: "pipe",
              cwd: options.cwd,
              tempDirectories: [artifactsDir],
              attemptToGracefullyClose: () => app.close(),
              handleSIGINT: true,
              handleSIGTERM: true,
              handleSIGHUP: true,
              onExit: () => {
              }
            });
            const waitForXserverError = new Promise((resolve, reject) => __async(this, null, function* () {
              waitForLine(progress2, launchedProcess, /Unable to open X display/).then(() => reject(new Error(["Unable to open X display!", `================================`, "Most likely this is because there is no X server available.", "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.", "For example: 'xvfb-run npm run test:e2e'", `================================`, progress2.metadata.log].join("\n")))).catch(() => {
              });
            }));
            const nodeMatch = yield waitForLine(progress2, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
            const nodeTransport = yield _transport.WebSocketTransport.connect(progress2, nodeMatch[1]);
            const nodeConnection = new _crConnection.CRConnection(nodeTransport, _helper.helper.debugProtocolLogger(), browserLogsCollector);
            waitForLine(progress2, launchedProcess, /Waiting for the debugger to disconnect\.\.\./).then(() => {
              nodeTransport.close();
            }).catch(() => {
            });
            const chromeMatch = yield Promise.race([waitForLine(progress2, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/), waitForXserverError]);
            const chromeTransport = yield _transport.WebSocketTransport.connect(progress2, chromeMatch[1]);
            const browserProcess = {
              onclose: void 0,
              process: launchedProcess,
              close: gracefullyClose,
              kill
            };
            const contextOptions = __spreadProps(__spreadValues({}, options), {
              noDefaultViewport: true
            });
            const browserOptions = {
              name: "electron",
              isChromium: true,
              headful: true,
              persistent: contextOptions,
              browserProcess,
              protocolLogger: _helper.helper.debugProtocolLogger(),
              browserLogsCollector,
              artifactsDir,
              downloadsPath: artifactsDir,
              tracesDir: options.tracesDir || artifactsDir,
              originalLaunchOptions: {}
            };
            (0, _browserContext.validateBrowserContextOptions)(contextOptions, browserOptions);
            const browser = yield _crBrowser.CRBrowser.connect(this.attribution.playwright, chromeTransport, browserOptions);
            app = new ElectronApplication(this, browser, nodeConnection, launchedProcess);
            yield app.initialize();
            return app;
          }), _timeoutSettings.TimeoutSettings.timeout(options));
        });
      }
    };
    exports2.Electron = Electron;
    function waitForLine(progress2, process2, regex) {
      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process2.stderr
        });
        const failError = new Error("Process failed to launch!");
        const listeners = [
          _eventsHelper.eventsHelper.addEventListener(rl, "line", onLine),
          _eventsHelper.eventsHelper.addEventListener(rl, "close", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "exit", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "error", reject.bind(null, failError))
        ];
        progress2.cleanupWhenAborted(cleanup);
        function onLine(line) {
          const match = line.match(regex);
          if (!match)
            return;
          cleanup();
          resolve(match);
        }
        function cleanup() {
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffConnection.js
var require_ffConnection = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kBrowserCloseMessageId = exports2.FFSessionEvents = exports2.FFSession = exports2.FFConnection = exports2.ConnectionEvents = void 0;
    var _events = require("events");
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var FFConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = void 0;
        this._callbacks = void 0;
        this._transport = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._sessions = void 0;
        this._closed = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._sessions = /* @__PURE__ */ new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
      }
      send(method, params) {
        return __async(this, null, function* () {
          this._checkClosed(method);
          const id = this.nextMessageId();
          this._rawSend({
            id,
            method,
            params
          });
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      _checkClosed(method) {
        if (this._closed)
          throw new _protocolError.ProtocolError(true, `${method}): Browser closed.` + _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
      }
      _rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _onMessage(message) {
        return __async(this, null, function* () {
          this._protocolLogger("receive", message);
          if (message.id === kBrowserCloseMessageId)
            return;
          if (message.sessionId) {
            const session = this._sessions.get(message.sessionId);
            if (session)
              session.dispatchMessage(message);
          } else if (message.id) {
            const callback = this._callbacks.get(message.id);
            if (callback) {
              this._callbacks.delete(message.id);
              if (message.error)
                callback.reject(createProtocolError(callback.error, callback.method, message.error));
              else
                callback.resolve(message.result);
            }
          } else {
            Promise.resolve().then(() => this.emit(message.method, message.params));
          }
        });
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const formattedBrowserLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session.dispose();
        this._sessions.clear();
        for (const callback of this._callbacks.values()) {
          const error = (0, _stackTrace.rewriteErrorMessage)(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs);
          error.sessionClosed = true;
          callback.reject(error);
        }
        this._callbacks.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(sessionId) {
        const session = new FFSession(this, sessionId, (message) => this._rawSend(__spreadProps(__spreadValues({}, message), {
          sessionId
        })));
        this._sessions.set(sessionId, session);
        return session;
      }
    };
    exports2.FFConnection = FFConnection;
    var FFSessionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.FFSessionEvents = FFSessionEvents;
    var FFSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, rawSend) {
        super();
        this._connection = void 0;
        this._disposed = false;
        this._callbacks = void 0;
        this._sessionId = void 0;
        this._rawSend = void 0;
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._callbacks = /* @__PURE__ */ new Map();
        this._connection = connection;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      markAsCrashed() {
        this._crashed = true;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          this._connection._checkClosed(method);
          if (this._disposed)
            throw new _protocolError.ProtocolError(true, "Target closed");
          const id = this._connection.nextMessageId();
          this._rawSend({
            method,
            params,
            id
          });
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils.assert)(!object.id);
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
      dispose() {
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, "Target closed"));
        }
        this._callbacks.clear();
        this._disposed = true;
        this._connection._sessions.delete(this._sessionId);
        Promise.resolve().then(() => this.emit(FFSessionEvents.Disconnected));
      }
    };
    exports2.FFSession = FFSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffAccessibility.js
var require_ffAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(session, needle) {
      return __async(this, null, function* () {
        const objectId = needle ? needle._objectId : void 0;
        const {
          tree
        } = yield session.send("Accessibility.getFullAXTree", {
          objectId
        });
        const axNode = new FFAXNode(tree);
        return {
          tree: axNode,
          needle: needle ? axNode._findNeedle() : null
        };
      });
    }
    var FFRoleToARIARole = new Map(Object.entries({
      "pushbutton": "button",
      "checkbutton": "checkbox",
      "editcombobox": "combobox",
      "content deletion": "deletion",
      "footnote": "doc-footnote",
      "non-native document": "document",
      "grouping": "group",
      "graphic": "img",
      "content insertion": "insertion",
      "animation": "marquee",
      "flat equation": "math",
      "menupopup": "menu",
      "check menu item": "menuitemcheckbox",
      "radio menu item": "menuitemradio",
      "listbox option": "option",
      "radiobutton": "radio",
      "statusbar": "status",
      "pagetab": "tab",
      "pagetablist": "tablist",
      "propertypage": "tabpanel",
      "entry": "textbox",
      "outline": "tree",
      "tree table": "treegrid",
      "outlineitem": "treeitem"
    }));
    var FFAXNode = class {
      constructor(payload) {
        this._children = void 0;
        this._payload = void 0;
        this._editable = void 0;
        this._richlyEditable = void 0;
        this._focusable = void 0;
        this._expanded = void 0;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._payload = payload;
        this._children = (payload.children || []).map((x) => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && payload.tag !== "textarea" && payload.tag !== "input";
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "entry";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "text leaf" || role === "text" || role === "statictext";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.foundObject)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "graphic":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "document" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "checkbutton":
          case "check menu item":
          case "check rich option":
          case "combobox":
          case "combobox option":
          case "color chooser":
          case "listbox":
          case "listbox option":
          case "listbox rich option":
          case "popup menu":
          case "menupopup":
          case "menuitem":
          case "menubar":
          case "button":
          case "pushbutton":
          case "radiobutton":
          case "radio menuitem":
          case "scrollbar":
          case "slider":
          case "spinbutton":
          case "switch":
          case "pagetab":
          case "entry":
          case "tree table":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name.trim();
      }
      serialize() {
        const node = {
          role: FFRoleToARIARole.get(this._role) || this._role,
          name: this._name || ""
        };
        const userStringProperties = ["name", "description", "roledescription", "valuetext", "keyshortcuts"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (this._role === "document" && booleanProperty === "focused")
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        axNode.valueString = this._payload.value;
        if ("checked" in this._payload)
          axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
        if ("pressed" in this._payload)
          axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
        return axNode;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js
var require_ffExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFExecutionContext = void 0;
    var js = _interopRequireWildcard(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFExecutionContext = class {
      constructor(session, executionContextId) {
        this._session = void 0;
        this._executionContextId = void 0;
        this._session = session;
        this._executionContextId = executionContextId;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.evaluate", {
            expression,
            returnByValue: true,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          return payload.result.value;
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.evaluate", {
            expression,
            returnByValue: false,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          return payload.result.objectId;
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunction", {
          functionDeclaration: func.toString(),
          args: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.callFunction", {
            functionDeclaration: expression,
            args: [{
              objectId: utilityScript._objectId,
              value: void 0
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId,
              value: void 0
            }))],
            returnByValue,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          if (returnByValue)
            return (0, _utilityScriptSerializers.parseEvaluationResultValue)(payload.result.value);
          return utilityScript._context.createHandle(payload.result);
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Runtime.getObjectProperties", {
            executionContextId: this._executionContextId,
            objectId
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.properties)
            result.set(property.name, context.createHandle(property.value));
          return result;
        });
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || "", renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield this._session.send("Runtime.disposeObject", {
            executionContextId: this._executionContextId,
            objectId
          });
        });
      }
      objectCount(objectId) {
        throw new Error("Method not implemented in Firefox.");
      }
    };
    exports2.FFExecutionContext = FFExecutionContext;
    function checkException(exceptionDetails) {
      if (!exceptionDetails)
        return;
      if (exceptionDetails.value)
        throw new js.JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));
      else
        throw new js.JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? "\n" + exceptionDetails.stack : ""));
    }
    function rewriteError(error) {
      if (error.message.includes("cyclic object value") || error.message.includes("Object is not serializable"))
        return {
          result: {
            type: "undefined",
            value: void 0
          }
        };
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error, error.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.type === "symbol")
        return "Symbol()";
      if (object.subtype === "regexp")
        return "RegExp";
      if (object.subtype === "weakmap")
        return "WeakMap";
      if (object.subtype === "weakset")
        return "WeakSet";
      if (object.subtype)
        return object.subtype[0].toUpperCase() + object.subtype.slice(1);
      if ("value" in object)
        return String(object.value);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffInput.js
var require_ffInput = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Shift"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonNumber(button) {
      if (button === "left")
        return 0;
      if (button === "middle")
        return 1;
      if (button === "right")
        return 2;
      return 0;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          if (code === "MetaLeft")
            code = "OSLeft";
          if (code === "MetaRight")
            code = "OSRight";
          if (text === "\r")
            text = "";
          yield this._client.send("Page.dispatchKeyEvent", {
            type: "keydown",
            keyCode: keyCodeWithoutLocation,
            code,
            key,
            repeat: autoRepeat,
            location: location2,
            text
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          if (code === "MetaLeft")
            code = "OSLeft";
          if (code === "MetaRight")
            code = "OSRight";
          yield this._client.send("Page.dispatchKeyEvent", {
            type: "keyup",
            key,
            keyCode: keyCodeWithoutLocation,
            code,
            location: location2,
            repeat: false
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._client.send("Page.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(client) {
        this._client = void 0;
        this._page = void 0;
        this._client = client;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mousemove",
            button: 0,
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mousedown",
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mouseup",
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, {
            world: "utility"
          });
          yield this._client.send("Page.dispatchWheelEvent", {
            deltaX,
            deltaY,
            x: Math.floor(x),
            y: Math.floor(y),
            deltaZ: 0,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchTapEvent", {
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js
var require_ffNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFNetworkManager = void 0;
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network2());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFNetworkManager = class {
      constructor(session, page) {
        this._session = void 0;
        this._requests = void 0;
        this._page = void 0;
        this._eventListeners = void 0;
        this._session = session;
        this._requests = /* @__PURE__ */ new Map();
        this._page = page;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFinished", this._onRequestFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFailed", this._onRequestFailed.bind(this))];
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      setRequestInterception(enabled) {
        return __async(this, null, function* () {
          yield this._session.send("Network.setRequestInterception", {
            enabled
          });
        });
      }
      _onRequestWillBeSent(event) {
        const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
        const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
        if (!frame)
          return;
        if (redirectedFrom)
          this._requests.delete(redirectedFrom._id);
        const request = new InterceptableRequest(frame, redirectedFrom, event);
        let route;
        if (event.isIntercepted)
          route = new FFRouteImpl(this._session, request);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request, route);
      }
      _onResponseReceived(event) {
        var _event$securityDetail, _event$securityDetail2, _event$securityDetail3, _event$securityDetail4, _event$securityDetail5;
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const getResponseBody = () => __async(this, null, function* () {
          const response2 = yield this._session.send("Network.getResponseBody", {
            requestId: request._id
          });
          if (response2.evicted)
            throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
          return Buffer.from(response2.base64body, "base64");
        });
        const startTime = event.timing.startTime;
        function relativeToStart(time) {
          if (!time)
            return -1;
          return (time - startTime) / 1e3;
        }
        const timing = {
          startTime: startTime / 1e3,
          domainLookupStart: relativeToStart(event.timing.domainLookupStart),
          domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
          connectStart: relativeToStart(event.timing.connectStart),
          secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
          connectEnd: relativeToStart(event.timing.connectEnd),
          requestStart: relativeToStart(event.timing.requestStart),
          responseStart: relativeToStart(event.timing.responseStart)
        };
        const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody, event.fromServiceWorker);
        if (event !== null && event !== void 0 && event.remoteIPAddress && typeof (event === null || event === void 0 ? void 0 : event.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: event.remoteIPAddress,
            port: event.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: event === null || event === void 0 ? void 0 : (_event$securityDetail = event.securityDetails) === null || _event$securityDetail === void 0 ? void 0 : _event$securityDetail.protocol,
          subjectName: event === null || event === void 0 ? void 0 : (_event$securityDetail2 = event.securityDetails) === null || _event$securityDetail2 === void 0 ? void 0 : _event$securityDetail2.subjectName,
          issuer: event === null || event === void 0 ? void 0 : (_event$securityDetail3 = event.securityDetails) === null || _event$securityDetail3 === void 0 ? void 0 : _event$securityDetail3.issuer,
          validFrom: event === null || event === void 0 ? void 0 : (_event$securityDetail4 = event.securityDetails) === null || _event$securityDetail4 === void 0 ? void 0 : _event$securityDetail4.validFrom,
          validTo: event === null || event === void 0 ? void 0 : (_event$securityDetail5 = event.securityDetails) === null || _event$securityDetail5 === void 0 ? void 0 : _event$securityDetail5.validTo
        });
        response.setRawResponseHeaders(null);
        response.setResponseHeadersSize(null);
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        response.setTransferSize(event.transferSize);
        response.setEncodedBodySize(event.encodedBodySize);
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        const responseEndTime = event.responseEndTime ? event.responseEndTime / 1e3 - response.timing().startTime : -1;
        if (isRedirected) {
          response._requestFinished(responseEndTime);
        } else {
          this._requests.delete(request._id);
          response._requestFinished(responseEndTime);
        }
        if (event.protocolVersion)
          response._setHttpVersion(event.protocolVersion);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        this._requests.delete(request._id);
        const response = request.request._existingResponse();
        if (response) {
          response.setTransferSize(null);
          response.setEncodedBodySize(null);
          response._requestFinished(-1);
        }
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === "NS_BINDING_ABORTED");
      }
    };
    exports2.FFNetworkManager = FFNetworkManager;
    var causeToResourceType = {
      TYPE_INVALID: "other",
      TYPE_OTHER: "other",
      TYPE_SCRIPT: "script",
      TYPE_IMAGE: "image",
      TYPE_STYLESHEET: "stylesheet",
      TYPE_OBJECT: "other",
      TYPE_DOCUMENT: "document",
      TYPE_SUBDOCUMENT: "document",
      TYPE_REFRESH: "document",
      TYPE_XBL: "other",
      TYPE_PING: "other",
      TYPE_XMLHTTPREQUEST: "xhr",
      TYPE_OBJECT_SUBREQUEST: "other",
      TYPE_DTD: "other",
      TYPE_FONT: "font",
      TYPE_MEDIA: "media",
      TYPE_WEBSOCKET: "websocket",
      TYPE_CSP_REPORT: "other",
      TYPE_XSLT: "other",
      TYPE_BEACON: "other",
      TYPE_FETCH: "fetch",
      TYPE_IMAGESET: "images",
      TYPE_WEB_MANIFEST: "manifest"
    };
    var internalCauseToResourceType = {
      TYPE_INTERNAL_EVENTSOURCE: "eventsource"
    };
    var InterceptableRequest = class {
      constructor(frame, redirectedFrom, payload) {
        this.request = void 0;
        this._id = void 0;
        this._redirectedTo = void 0;
        this._id = payload.requestId;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        let postDataBuffer = null;
        if (payload.postData)
          postDataBuffer = Buffer.from(payload.postData, "base64");
        this.request = new network.Request(frame._page._browserContext, frame, null, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other", payload.method, postDataBuffer, payload.headers);
        this.request.setRawRequestHeaders(null);
      }
      _finalRequest() {
        let request = this;
        while (request._redirectedTo)
          request = request._redirectedTo;
        return request;
      }
    };
    var FFRouteImpl = class {
      constructor(session, request) {
        this._request = void 0;
        this._session = void 0;
        this._session = session;
        this._request = request;
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._session.sendMayFail("Network.resumeInterceptedRequest", {
            requestId: this._request._id,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
          yield this._session.sendMayFail("Network.fulfillInterceptedRequest", {
            requestId: this._request._id,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)] || "",
            headers: response.headers,
            base64body
          });
        });
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          yield this._session.sendMayFail("Network.abortInterceptedRequest", {
            requestId: this._request._id,
            errorCode
          });
        });
      }
    };
    function parseMultivalueHeaders(headers) {
      const result = [];
      for (const header of headers) {
        const separator = header.name.toLowerCase() === "set-cookie" ? "\n" : ",";
        const tokens = header.value.split(separator).map((s) => s.trim());
        for (const token of tokens)
          result.push({
            name: header.name,
            value: token
          });
      }
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffPage.js
var require_ffPage = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UTILITY_WORLD_NAME = exports2.FFPage = void 0;
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _page = require_page();
    var _ffAccessibility = require_ffAccessibility();
    var _ffConnection = require_ffConnection();
    var _ffExecutionContext = require_ffExecutionContext();
    var _ffInput = require_ffInput();
    var _ffNetworkManager = require_ffNetworkManager();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _manualPromise = require_manualPromise();
    var _browserContext = require_browserContext();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    exports2.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;
    var FFPage = class {
      constructor(session, browserContext, opener) {
        this.cspErrorsAsynchronousForInlineScipts = true;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._browserContext = void 0;
        this._pagePromise = new _manualPromise.ManualPromise();
        this._initializedPage = null;
        this._initializationFailed = false;
        this._opener = void 0;
        this._contextIdToContext = void 0;
        this._eventListeners = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this._screencastId = void 0;
        this._initScripts = [];
        this._session = session;
        this._opener = opener;
        this.rawKeyboard = new _ffInput.RawKeyboardImpl(session);
        this.rawMouse = new _ffInput.RawMouseImpl(session);
        this.rawTouchscreen = new _ffInput.RawTouchscreenImpl(session);
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._networkManager = new _ffNetworkManager.FFNetworkManager(session, this._page);
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.videoRecordingStarted", this._onVideoRecordingStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.screencastFrame", this._onScreencastFrame.bind(this))];
        session.once(_ffConnection.FFSessionEvents.Disconnected, () => {
          this._markAsError(new Error("Page closed"));
          this._page._didDisconnect();
        });
        this._session.once("Page.ready", () => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          if (this._initializationFailed)
            return;
          this._initializedPage = this._page;
          this._page.reportAsNew();
          this._pagePromise.resolve(this._page);
        }));
        this.addInitScript("", UTILITY_WORLD_NAME).catch((e) => this._markAsError(e));
      }
      potentiallyUninitializedPage() {
        return this._page;
      }
      _markAsError(error) {
        return __async(this, null, function* () {
          if (this._initializationFailed)
            return;
          this._initializationFailed = true;
          if (!this._initializedPage) {
            yield this._page.initOpener(this._opener);
            this._page.reportAsNew(error);
            this._pagePromise.resolve(error);
          }
        });
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      _onWebSocketCreated(event) {
        this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
        this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketClosed(event) {
        if (event.error)
          this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
        this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketFrameReceived(event) {
        this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onWebSocketFrameSent(event) {
        this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onExecutionContextCreated(payload) {
        const {
          executionContextId,
          auxData
        } = payload;
        const frame = this._page._frameManager.frame(auxData.frameId);
        if (!frame)
          return;
        const delegate = new _ffExecutionContext.FFExecutionContext(this._session, executionContextId);
        let worldName = null;
        if (auxData.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        else if (!auxData.name)
          worldName = "main";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(executionContextId, context);
      }
      _onExecutionContextDestroyed(payload) {
        const {
          executionContextId
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _onExecutionContextsCleared() {
        for (const executionContextId of Array.from(this._contextIdToContext.keys()))
          this._onExecutionContextDestroyed({
            executionContextId
          });
      }
      _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame)
            this._contextIdToContext.delete(contextId);
        }
      }
      _onLinkClicked(phase) {
        if (phase === "before")
          this._page._frameManager.frameWillPotentiallyRequestNavigation();
        else
          this._page._frameManager.frameDidPotentiallyRequestNavigation();
      }
      _onNavigationStarted(params) {
        this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
      }
      _onNavigationAborted(params) {
        this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
      }
      _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
          if (worker.frameId === params.frameId)
            this._onWorkerDestroyed({
              workerId
            });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
      }
      _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
      }
      _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
      }
      _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
      }
      _onEventFired(payload) {
        const {
          frameId,
          name
        } = payload;
        if (name === "load")
          this._page._frameManager.frameLifecycleEvent(frameId, "load");
        if (name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
      }
      _onUncaughtError(params) {
        const {
          name,
          message
        } = (0, _stackTrace.splitErrorMessage)(params.message);
        const error = new Error(message);
        error.stack = params.message + "\n" + params.stack.split("\n").filter(Boolean).map((a) => a.replace(/([^@]*)@(.*)/, "    at $1 ($2)")).join("\n");
        error.name = name;
        this._page.firePageError(error);
      }
      _onConsole(payload) {
        const {
          type,
          args,
          executionContextId,
          location: location2
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
      }
      _onDialogOpened(params) {
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, (accept, promptText) => __async(this, null, function* () {
          yield this._session.sendMayFail("Page.handleDialog", {
            dialogId: params.dialogId,
            accept,
            promptText
          });
        }), params.defaultValue));
      }
      _onBindingCalled(event) {
        return __async(this, null, function* () {
          const pageOrError = yield this.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(event.executionContextId);
            if (context)
              yield this._page._onBindingCalled(event.payload, context);
          }
        });
      }
      _onFileChooserOpened(payload) {
        return __async(this, null, function* () {
          const {
            executionContextId,
            element
          } = payload;
          const context = this._contextIdToContext.get(executionContextId);
          if (!context)
            return;
          const handle = context.createHandle(element).asElement();
          yield this._page._onFileChooserOpened(handle);
        });
      }
      _onWorkerCreated(event) {
        return __async(this, null, function* () {
          const workerId = event.workerId;
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _ffConnection.FFSession(this._session._connection, workerId, (message) => {
            this._session.send("Page.sendMessageToWorker", {
              frameId: event.frameId,
              workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                method: "",
                params: {},
                error: {
                  message: e.message,
                  data: void 0
                }
              });
            });
          });
          this._workers.set(workerId, {
            session: workerSession,
            frameId: event.frameId
          });
          this._page._addWorker(workerId, worker);
          workerSession.once("Runtime.executionContextCreated", (event2) => {
            worker._createExecutionContext(new _ffExecutionContext.FFExecutionContext(workerSession, event2.executionContextId));
          });
          workerSession.on("Runtime.console", (event2) => {
            const {
              type,
              args,
              location: location2
            } = event2;
            const context = worker._existingExecutionContext;
            this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
          });
        });
      }
      _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.session.dispose();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
      }
      _onDispatchMessageFromWorker(event) {
        return __async(this, null, function* () {
          const worker = this._workers.get(event.workerId);
          if (!worker)
            return;
          worker.session.dispatchMessage(JSON.parse(event.message));
        });
      }
      _onCrashed(event) {
        return __async(this, null, function* () {
          this._session.markAsCrashed();
          this._page._didCrash();
        });
      }
      _onVideoRecordingStarted(event) {
        this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._session.send("Page.addBinding", {
            name: binding.name,
            script: binding.source
          });
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
        });
      }
      didClose() {
        this._session.dispose();
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
      }
      navigateFrame(frame, url, referer) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Page.navigate", {
            url,
            referer,
            frameId: frame._id
          });
          return {
            newDocumentId: response.navigationId || void 0
          };
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._session.send("Network.setExtraHTTPHeaders", {
            headers: this._page.extraHTTPHeaders() || []
          });
        });
      }
      updateEmulatedViewportSize() {
        return __async(this, null, function* () {
          const viewportSize = this._page.viewportSize();
          yield this._session.send("Page.setViewportSize", {
            viewportSize
          });
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._session.send("Page.bringToFront", {});
        });
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          const emulatedMedia = this._page.emulatedMedia();
          const colorScheme = emulatedMedia.colorScheme === "no-override" ? void 0 : emulatedMedia.colorScheme;
          const reducedMotion = emulatedMedia.reducedMotion === "no-override" ? void 0 : emulatedMedia.reducedMotion;
          const forcedColors = emulatedMedia.forcedColors === "no-override" ? void 0 : emulatedMedia.forcedColors;
          yield this._session.send("Page.setEmulatedMedia", {
            type: emulatedMedia.media === "no-override" ? "" : emulatedMedia.media,
            colorScheme,
            reducedMotion,
            forcedColors
          });
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._networkManager.setRequestInterception(this._page.needsRequestInterception());
        });
      }
      updateFileChooserInterception() {
        return __async(this, null, function* () {
          const enabled = this._page.fileChooserIntercepted();
          yield this._session.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch(() => {
          });
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._session.send("Page.reload");
        });
      }
      goBack() {
        return __async(this, null, function* () {
          const {
            success
          } = yield this._session.send("Page.goBack", {
            frameId: this._page.mainFrame()._id
          });
          return success;
        });
      }
      goForward() {
        return __async(this, null, function* () {
          const {
            success
          } = yield this._session.send("Page.goForward", {
            frameId: this._page.mainFrame()._id
          });
          return success;
        });
      }
      addInitScript(script, worldName) {
        return __async(this, null, function* () {
          this._initScripts.push({
            script,
            worldName
          });
          yield this._session.send("Page.setInitScripts", {
            scripts: this._initScripts
          });
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          this._initScripts = [];
          yield this._session.send("Page.setInitScripts", {
            scripts: []
          });
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          yield this._session.send("Page.close", {
            runBeforeUnload
          });
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          if (color)
            throw new Error("Not implemented");
        });
      }
      takeScreenshot(progress2, format, documentRect, viewportRect, quality, fitsViewport, scale) {
        return __async(this, null, function* () {
          if (!documentRect) {
            const scrollOffset = yield this._page.mainFrame().waitForFunctionValueInUtility(progress2, () => ({
              x: window.scrollX,
              y: window.scrollY
            }));
            documentRect = {
              x: viewportRect.x + scrollOffset.x,
              y: viewportRect.y + scrollOffset.y,
              width: viewportRect.width,
              height: viewportRect.height
            };
          }
          progress2.throwIfAborted();
          const {
            data
          } = yield this._session.send("Page.screenshot", {
            mimeType: "image/" + format,
            clip: documentRect,
            quality,
            omitDeviceScaleFactor: scale === "css"
          });
          return Buffer.from(data, "base64");
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          const {
            contentFrameId
          } = yield this._session.send("Page.describeNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          if (!contentFrameId)
            return null;
          return this._page._frameManager.frame(contentFrameId);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          const {
            ownerFrameId
          } = yield this._session.send("Page.describeNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          return ownerFrameId || null;
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          const quads = yield this.getContentQuads(handle);
          if (!quads || !quads.length)
            return null;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (const quad of quads) {
            for (const point of quad) {
              minX = Math.min(minX, point.x);
              maxX = Math.max(maxX, point.x);
              minY = Math.min(minY, point.y);
              maxY = Math.max(maxY, point.y);
            }
          }
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._session.send("Page.scrollIntoViewIfNeeded", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            throw e;
          });
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            const {
              screencastId
            } = yield this._session.send("Page.startScreencast", options);
            this._screencastId = screencastId;
          } else {
            yield this._session.send("Page.stopScreencast");
          }
        });
      }
      _onScreencastFrame(event) {
        if (!this._screencastId)
          return;
        const screencastId = this._screencastId;
        this._page.throttleScreencastFrameAck(() => {
          this._session.send("Page.screencastFrameAck", {
            screencastId
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("Page.getContentQuads", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          if (!result)
            return null;
          return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          yield handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
        });
      }
      setInputFilePaths(progress2, handle, files) {
        return __async(this, null, function* () {
          yield Promise.all([this._session.send("Page.setFileInputFiles", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            files
          }), handle.dispatchEvent(progress2.metadata, "input"), handle.dispatchEvent(progress2.metadata, "change")]);
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const result = yield this._session.send("Page.adoptNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            executionContextId: to[contextDelegateSymbol]._executionContextId
          });
          if (!result.remoteObject)
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.remoteObject);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _ffAccessibility.getAccessibilityTree)(this._session, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
        });
      }
      resetForReuse() {
        return __async(this, null, function* () {
          yield this.rawMouse.move(-1, -1, "none", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), false);
        });
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const context = yield parent._mainContext();
          const result = yield this._session.send("Page.adoptNode", {
            frameId: frame._id,
            executionContextId: context[contextDelegateSymbol]._executionContextId
          });
          if (!result.remoteObject)
            throw new Error("Frame has been detached.");
          return context.createHandle(result.remoteObject);
        });
      }
    };
    exports2.FFPage = FFPage;
    function webSocketId(frameId, wsid) {
      return `${frameId}---${wsid}`;
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/firefox/ffBrowser.js
var require_ffBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFBrowserContext = exports2.FFBrowser = void 0;
    var _errors = require_errors();
    var _utils = require_utils();
    var _browser = require_browser();
    var _browserContext = require_browserContext();
    var network = _interopRequireWildcard(require_network2());
    var _ffConnection = require_ffConnection();
    var _ffPage = require_ffPage();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFBrowser = class extends _browser.Browser {
      static connect(parent, transport, options) {
        return __async(this, null, function* () {
          var _options$originalLaun;
          const connection = new _ffConnection.FFConnection(transport, options.protocolLogger, options.browserLogsCollector);
          const browser = new FFBrowser(parent, connection, options);
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          let firefoxUserPrefs = options.persistent ? {} : (_options$originalLaun = options.originalLaunchOptions.firefoxUserPrefs) !== null && _options$originalLaun !== void 0 ? _options$originalLaun : {};
          if (Object.keys(kBandaidFirefoxUserPrefs).length)
            firefoxUserPrefs = __spreadValues(__spreadValues({}, kBandaidFirefoxUserPrefs), firefoxUserPrefs);
          const promises = [connection.send("Browser.enable", {
            attachToDefaultContext: !!options.persistent,
            userPrefs: Object.entries(firefoxUserPrefs).map(([name, value]) => ({
              name,
              value
            }))
          }), browser._initVersion()];
          if (options.persistent) {
            browser._defaultContext = new FFBrowserContext(browser, void 0, options.persistent);
            promises.push(browser._defaultContext._initialize());
          }
          if (options.proxy)
            promises.push(browser._connection.send("Browser.setBrowserProxy", toJugglerProxyOptions(options.proxy)));
          yield Promise.all(promises);
          return browser;
        });
      }
      constructor(parent, connection, options) {
        super(parent, options);
        this._connection = void 0;
        this._ffPages = void 0;
        this._contexts = void 0;
        this._version = "";
        this._userAgent = "";
        this._connection = connection;
        this._ffPages = /* @__PURE__ */ new Map();
        this._contexts = /* @__PURE__ */ new Map();
        this._connection.on(_ffConnection.ConnectionEvents.Disconnected, () => this._onDisconnect());
        this._connection.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._connection.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._connection.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
        this._connection.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
        this._connection.on("Browser.videoRecordingFinished", this._onVideoRecordingFinished.bind(this));
      }
      _initVersion() {
        return __async(this, null, function* () {
          const result = yield this._connection.send("Browser.getInfo");
          this._version = result.version.substring(result.version.indexOf("/") + 1);
          this._userAgent = result.userAgent;
        });
      }
      isConnected() {
        return !this._connection._closed;
      }
      doCreateNewContext(options) {
        return __async(this, null, function* () {
          if (options.isMobile)
            throw new Error("options.isMobile is not supported in Firefox");
          const {
            browserContextId
          } = yield this._connection.send("Browser.createBrowserContext", {
            removeOnDetach: true
          });
          const context = new FFBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
      }
      _onAttachedToTarget(payload) {
        const {
          targetId,
          browserContextId,
          openerId,
          type
        } = payload.targetInfo;
        (0, _utils.assert)(type === "page");
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        (0, _utils.assert)(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new _ffPage.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
      }
      _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        if (!ffPage)
          return;
        ffPage._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
        let originPage = ffPage._initializedPage;
        if (!originPage) {
          ffPage._markAsError(new Error("Starting new page download"));
          if (ffPage._opener)
            originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
      }
      _onDownloadFinished(payload) {
        const error = payload.canceled ? "canceled" : payload.error;
        this._downloadFinished(payload.uuid, error);
      }
      _onVideoRecordingFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onDisconnect() {
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
    };
    exports2.FFBrowser = FFBrowser;
    var FFBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._ffPages().length);
          const browserContextId = this._browserContextId;
          const promises = [__superGet("_initialize").call(this)];
          promises.push(this._browser._connection.send("Browser.setDownloadOptions", {
            browserContextId,
            downloadOptions: {
              behavior: this._options.acceptDownloads ? "saveToDisk" : "cancel",
              downloadsDir: this._browser.options.downloadsPath
            }
          }));
          if (this._options.viewport) {
            const viewport = {
              viewportSize: {
                width: this._options.viewport.width,
                height: this._options.viewport.height
              },
              deviceScaleFactor: this._options.deviceScaleFactor || 1
            };
            promises.push(this._browser._connection.send("Browser.setDefaultViewport", {
              browserContextId,
              viewport
            }));
          }
          if (this._options.hasTouch)
            promises.push(this._browser._connection.send("Browser.setTouchOverride", {
              browserContextId,
              hasTouch: true
            }));
          if (this._options.userAgent)
            promises.push(this._browser._connection.send("Browser.setUserAgentOverride", {
              browserContextId,
              userAgent: this._options.userAgent
            }));
          if (this._options.bypassCSP)
            promises.push(this._browser._connection.send("Browser.setBypassCSP", {
              browserContextId,
              bypassCSP: true
            }));
          if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._connection.send("Browser.setIgnoreHTTPSErrors", {
              browserContextId,
              ignoreHTTPSErrors: true
            }));
          if (this._options.javaScriptEnabled === false)
            promises.push(this._browser._connection.send("Browser.setJavaScriptDisabled", {
              browserContextId,
              javaScriptDisabled: true
            }));
          if (this._options.locale)
            promises.push(this._browser._connection.send("Browser.setLocaleOverride", {
              browserContextId,
              locale: this._options.locale
            }));
          if (this._options.timezoneId)
            promises.push(this._browser._connection.send("Browser.setTimezoneOverride", {
              browserContextId,
              timezoneId: this._options.timezoneId
            }));
          if (this._options.extraHTTPHeaders || this._options.locale)
            promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
          if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
          if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
          if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
          if (this._options.colorScheme !== "no-override") {
            promises.push(this._browser._connection.send("Browser.setColorScheme", {
              browserContextId,
              colorScheme: this._options.colorScheme !== void 0 ? this._options.colorScheme : "light"
            }));
          }
          if (this._options.reducedMotion !== "no-override") {
            promises.push(this._browser._connection.send("Browser.setReducedMotion", {
              browserContextId,
              reducedMotion: this._options.reducedMotion !== void 0 ? this._options.reducedMotion : "no-preference"
            }));
          }
          if (this._options.forcedColors !== "no-override") {
            promises.push(this._browser._connection.send("Browser.setForcedColors", {
              browserContextId,
              forcedColors: this._options.forcedColors !== void 0 ? this._options.forcedColors : "none"
            }));
          }
          if (this._options.recordVideo) {
            promises.push(this._ensureVideosPath().then(() => {
              return this._browser._connection.send("Browser.setVideoRecordingOptions", {
                options: __spreadProps(__spreadValues({}, this._options.recordVideo.size), {
                  dir: this._options.recordVideo.dir
                }),
                browserContextId: this._browserContextId
              });
            }));
          }
          if (this._options.proxy) {
            promises.push(this._browser._connection.send("Browser.setContextProxy", __spreadValues({
              browserContextId: this._browserContextId
            }, toJugglerProxyOptions(this._options.proxy))));
          }
          yield Promise.all(promises);
        });
      }
      _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
      }
      pages() {
        return this._ffPages().map((ffPage) => ffPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const {
            targetId
          } = yield this._browser._connection.send("Browser.newPage", {
            browserContextId: this._browserContextId
          }).catch((e) => {
            if (e.message.includes("Failed to override timezone"))
              throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
            throw e;
          });
          return this._browser._ffPages.get(targetId);
        });
      }
      doGetCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._connection.send("Browser.getCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({}, c);
            delete copy.size;
            delete copy.session;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
            expires: c.expires && c.expires !== -1 ? c.expires : void 0
          }));
          yield this._browser._connection.send("Browser.setCookies", {
            browserContextId: this._browserContextId,
            cookies: cc
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.clearCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([["geolocation", "geo"], ["persistent-storage", "persistent-storage"], ["push", "push"], ["notifications", "desktop-notification"]]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._browser._connection.send("Browser.grantPermissions", {
            origin,
            browserContextId: this._browserContextId,
            permissions: filtered
          });
        });
      }
      doClearPermissions() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.resetPermissions", {
            browserContextId: this._browserContextId
          });
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          yield this._browser._connection.send("Browser.setGeolocationOverride", {
            browserContextId: this._browserContextId,
            geolocation: geolocation || null
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          let allHeaders = this._options.extraHTTPHeaders;
          if (this._options.locale)
            allHeaders = network.mergeHeaders([allHeaders, network.singleHeader("Accept-Language", this._options.locale)]);
          yield this._browser._connection.send("Browser.setExtraHTTPHeaders", {
            browserContextId: this._browserContextId,
            headers: allHeaders
          });
        });
      }
      setUserAgent(userAgent) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setUserAgentOverride", {
            browserContextId: this._browserContextId,
            userAgent: userAgent || null
          });
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          yield this._browser._connection.send("Browser.setOnlineOverride", {
            browserContextId: this._browserContextId,
            override: offline ? "offline" : "online"
          });
        });
      }
      doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          yield this._browser._connection.send("Browser.setHTTPCredentials", {
            browserContextId: this._browserContextId,
            credentials: httpCredentials || null
          });
        });
      }
      doAddInitScript(source) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setInitScripts", {
            browserContextId: this._browserContextId,
            scripts: this.initScripts.map((script) => ({
              script
            }))
          });
        });
      }
      doRemoveInitScripts() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setInitScripts", {
            browserContextId: this._browserContextId,
            scripts: []
          });
        });
      }
      doExposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.addBinding", {
            browserContextId: this._browserContextId,
            name: binding.name,
            script: binding.source
          });
        });
      }
      doRemoveExposedBindings() {
        return __async(this, null, function* () {
        });
      }
      doUpdateRequestInterception() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setRequestInterception", {
            browserContextId: this._browserContextId,
            enabled: !!this._requestInterceptor
          });
        });
      }
      onClosePersistent() {
      }
      clearCache() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.clearCache");
        });
      }
      doClose() {
        return __async(this, null, function* () {
          if (!this._browserContextId) {
            if (this._options.recordVideo) {
              yield this._browser._connection.send("Browser.setVideoRecordingOptions", {
                options: void 0,
                browserContextId: this._browserContextId
              });
            }
            yield this._browser.close();
          } else {
            yield this._browser._connection.send("Browser.removeBrowserContext", {
              browserContextId: this._browserContextId
            });
            this._browser._contexts.delete(this._browserContextId);
          }
        });
      }
      cancelDownload(uuid) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.cancelDownload", {
            uuid
          });
        });
      }
    };
    exports2.FFBrowserContext = FFBrowserContext;
    function toJugglerProxyOptions(proxy) {
      const proxyServer = new URL(proxy.server);
      let port = parseInt(proxyServer.port, 10);
      let type = "http";
      if (proxyServer.protocol === "socks5:")
        type = "socks";
      else if (proxyServer.protocol === "socks4:")
        type = "socks4";
      else if (proxyServer.protocol === "https:")
        type = "https";
      if (proxyServer.port === "") {
        if (proxyServer.protocol === "http:")
          port = 80;
        else if (proxyServer.protocol === "https:")
          port = 443;
      }
      return {
        type,
        bypass: proxy.bypass ? proxy.bypass.split(",").map((domain) => domain.trim()) : [],
        host: proxyServer.hostname,
        port,
        username: proxy.username,
        password: proxy.password
      };
    }
    var kBandaidFirefoxUserPrefs = {};
  }
});

// node_modules/playwright-core/lib/server/firefox/firefox.js
var require_firefox = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/firefox.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Firefox = void 0;
    var os = _interopRequireWildcard(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _ffBrowser = require_ffBrowser();
    var _ffConnection = require_ffConnection();
    var _browserType = require_browserType();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Firefox = class extends _browserType.BrowserType {
      constructor(parent) {
        super(parent, "firefox");
      }
      _connectToTransport(transport, options) {
        return _ffBrowser.FFBrowser.connect(this.attribution.playwright, transport, options);
      }
      _rewriteStartupError(error) {
        if (error.message.includes("no DISPLAY environment variable specified"))
          return (0, _stackTrace.rewriteErrorMessage)(error, "\n" + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
        return error;
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        if (!_path.default.isAbsolute(os.homedir()))
          throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
        if (os.platform() === "linux") {
          return __spreadProps(__spreadValues({}, env), {
            SNAP_NAME: void 0,
            SNAP_INSTANCE_NAME: void 0
          });
        }
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          params: {},
          id: _ffConnection.kBrowserCloseMessageId
        };
        transport.send(message);
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const {
          args = [],
          headless
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument");
        if (args.find((arg) => arg.startsWith("-juggler")))
          throw new Error("Use the port parameter instead of -juggler argument");
        const firefoxArguments = ["-no-remote"];
        if (headless) {
          firefoxArguments.push("-headless");
        } else {
          firefoxArguments.push("-wait-for-browser");
          firefoxArguments.push("-foreground");
        }
        firefoxArguments.push(`-profile`, userDataDir);
        firefoxArguments.push("-juggler-pipe");
        firefoxArguments.push(...args);
        if (isPersistent)
          firefoxArguments.push("about:blank");
        else
          firefoxArguments.push("-silent");
        return firefoxArguments;
      }
    };
    exports2.Firefox = Firefox;
  }
});

// node_modules/playwright-core/lib/server/selectors.js
var require_selectors = __commonJS({
  "node_modules/playwright-core/lib/server/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Selectors = void 0;
    var _selectorParser = require_selectorParser();
    var _utils = require_utils();
    var Selectors = class {
      constructor() {
        this._builtinEngines = void 0;
        this._builtinEnginesInMainWorld = void 0;
        this._engines = void 0;
        this.guid = `selectors@${(0, _utils.createGuid)()}`;
        this._testIdAttributeName = "data-testid";
        this._builtinEngines = /* @__PURE__ */ new Set(["css", "css:light", "xpath", "xpath:light", "_react", "_vue", "text", "text:light", "id", "id:light", "data-testid", "data-testid:light", "data-test-id", "data-test-id:light", "data-test", "data-test:light", "nth", "visible", "internal:control", "internal:has", "internal:has-not", "internal:has-text", "internal:has-not-text", "internal:and", "internal:or", "role", "internal:attr", "internal:label", "internal:text", "internal:role", "internal:testid"]);
        this._builtinEnginesInMainWorld = /* @__PURE__ */ new Set(["_react", "_vue"]);
        this._engines = /* @__PURE__ */ new Map();
      }
      register(name, source, contentScript = false) {
        return __async(this, null, function* () {
          if (!name.match(/^[a-zA-Z_0-9-]+$/))
            throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
          if (this._builtinEngines.has(name) || name === "zs" || name === "zs:light")
            throw new Error(`"${name}" is a predefined selector engine`);
          if (this._engines.has(name))
            throw new Error(`"${name}" selector engine has been already registered`);
          this._engines.set(name, {
            source,
            contentScript
          });
        });
      }
      testIdAttributeName() {
        return this._testIdAttributeName;
      }
      setTestIdAttributeName(testIdAttributeName) {
        this._testIdAttributeName = testIdAttributeName;
      }
      unregisterAll() {
        this._engines.clear();
      }
      parseSelector(selector, strict) {
        const parsed = typeof selector === "string" ? (0, _selectorParser.parseSelector)(selector) : selector;
        let needsMainWorld = false;
        (0, _selectorParser.visitAllSelectorParts)(parsed, (part) => {
          const name = part.name;
          const custom = this._engines.get(name);
          if (!custom && !this._builtinEngines.has(name))
            throw new _selectorParser.InvalidSelectorError(`Unknown engine "${name}" while parsing selector ${(0, _selectorParser.stringifySelector)(parsed)}`);
          if (custom && !custom.contentScript)
            needsMainWorld = true;
          if (this._builtinEnginesInMainWorld.has(name))
            needsMainWorld = true;
        });
        return {
          parsed,
          world: needsMainWorld ? "main" : "utility",
          strict
        };
      }
    };
    exports2.Selectors = Selectors;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkConnection.js
var require_wkConnection = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKSession = exports2.WKConnection = void 0;
    exports2.createProtocolError = createProtocolError;
    exports2.kPageProxyMessageReceived = exports2.kBrowserCloseMessageId = void 0;
    var _events = require("events");
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _errors = require_errors();
    var _protocolError = require_protocolError();
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var kPageProxyMessageReceived = "kPageProxyMessageReceived";
    exports2.kPageProxyMessageReceived = kPageProxyMessageReceived;
    var WKConnection = class {
      constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
        this._transport = void 0;
        this._onDisconnect = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._lastId = 0;
        this._closed = false;
        this.browserSession = void 0;
        this._transport = transport;
        this._onDisconnect = onDisconnect;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.browserSession = new WKSession(this, "", _errors.kBrowserClosedError, (message) => {
          this.rawSend(message);
        });
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
      }
      nextMessageId() {
        return ++this._lastId;
      }
      rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _dispatchMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === kBrowserCloseMessageId)
          return;
        if (message.pageProxyId) {
          const payload = {
            message,
            pageProxyId: message.pageProxyId
          };
          this.browserSession.dispatchMessage({
            method: kPageProxyMessageReceived,
            params: payload
          });
          return;
        }
        this.browserSession.dispatchMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        this.browserSession.dispose(true);
        this._onDisconnect();
      }
      isClosed() {
        return this._closed;
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
    };
    exports2.WKConnection = WKConnection;
    var WKSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, errorText, rawSend) {
        super();
        this.connection = void 0;
        this.errorText = void 0;
        this.sessionId = void 0;
        this._disposed = false;
        this._rawSend = void 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          if (this._disposed)
            throw new _protocolError.ProtocolError(true, `Target closed`);
          const id = this.connection.nextMessageId();
          const messageObj = {
            id,
            method,
            params
          };
          this._rawSend(messageObj);
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      markAsCrashed() {
        this._crashed = true;
      }
      isDisposed() {
        return this._disposed;
      }
      dispose(disconnected) {
        if (disconnected)
          this.errorText = "Browser closed." + _helper.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, this.errorText));
        }
        this._callbacks.clear();
        this._disposed = true;
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else if (object.id && !object.error) {
          (0, _utils.assert)(this.isDisposed());
        } else {
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
    };
    exports2.WKSession = WKSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${JSON.stringify(protocolError.data)}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkAccessibility.js
var require_wkAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(session, needle) {
      return __async(this, null, function* () {
        const objectId = needle ? needle._objectId : void 0;
        const {
          axNode
        } = yield session.send("Page.accessibilitySnapshot", {
          objectId
        });
        const tree = new WKAXNode(axNode);
        return {
          tree,
          needle: needle ? tree._findNeedle() : null
        };
      });
    }
    var WKRoleToARIARole = new Map(Object.entries({
      "TextField": "textbox"
    }));
    var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
      "WebArea": "HTML content",
      "Summary": "summary",
      "DescriptionList": "description list",
      "ImageMap": "image map",
      "ListMarker": "list marker",
      "Video": "video playback",
      "Mark": "highlighted",
      "contentinfo": "content information",
      "Details": "details",
      "DescriptionListDetail": "description",
      "DescriptionListTerm": "term",
      "alertdialog": "web alert dialog",
      "dialog": "web dialog",
      "status": "application status",
      "tabpanel": "tab panel",
      "application": "web application"
    }));
    var WKAXNode = class {
      constructor(payload) {
        this._payload = void 0;
        this._children = void 0;
        this._payload = payload;
        this._children = [];
        for (const payload2 of this._payload.children || [])
          this._children.push(new WKAXNode(payload2));
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.found)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isControl() {
        switch (this._payload.role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "TextField":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      _isTextControl() {
        switch (this._payload.role) {
          case "combobox":
          case "searchfield":
          case "textbox":
          case "TextField":
            return true;
        }
        return false;
      }
      _name() {
        if (this._payload.role === "text")
          return this._payload.value || "";
        return this._payload.name || "";
      }
      isInteresting(insideControl) {
        const {
          role,
          focusable
        } = this._payload;
        const name = this._name();
        if (role === "ScrollArea")
          return false;
        if (role === "WebArea")
          return true;
        if (focusable || role === "MenuListOption")
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!name;
      }
      _hasRendundantTextChild() {
        if (this._children.length !== 1)
          return false;
        const child = this._children[0];
        return child._payload.role === "text" && this._payload.name === child._payload.value;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isTextControl())
          return true;
        if (this._hasRendundantTextChild())
          return true;
        return false;
      }
      serialize() {
        const node = {
          role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
          name: this._name()
        };
        if ("description" in this._payload && this._payload.description !== node.name)
          node.description = this._payload.description;
        if ("roledescription" in this._payload) {
          const roledescription = this._payload.roledescription;
          if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
            node.roledescription = roledescription;
        }
        if ("value" in this._payload && this._payload.role !== "text") {
          if (typeof this._payload.value === "string")
            node.valueString = this._payload.value;
          else if (typeof this._payload.value === "number")
            node.valueNumber = this._payload.value;
        }
        if ("checked" in this._payload)
          node.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
        if ("pressed" in this._payload)
          node.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
        const userStringProperties = ["keyshortcuts", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const orientationIsApplicable = /* @__PURE__ */ new Set(["ScrollArea", "scrollbar", "listbox", "combobox", "menu", "tree", "separator", "slider", "tablist", "toolbar"]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
          node.orientation = this._payload.orientation;
        return node;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js
var require_wkExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKExecutionContext = void 0;
    var js = _interopRequireWildcard(require_javascript());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var WKExecutionContext = class {
      constructor(session, contextId) {
        this._session = void 0;
        this._contextId = void 0;
        this._session = session;
        this._contextId = contextId;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.evaluate", {
              expression,
              contextId: this._contextId,
              returnByValue: true
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            return response.result.value;
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.evaluate", {
              expression,
              contextId: this._contextId,
              returnByValue: false
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            return response.result.objectId;
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          objectId: args.find((a) => a instanceof js.JSHandle)._objectId,
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          emulateUserGesture: true
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.callFunctionOn", {
              functionDeclaration: expression,
              objectId: utilityScript._objectId,
              arguments: [{
                objectId: utilityScript._objectId
              }, ...values.map((value) => ({
                value
              })), ...objectIds.map((objectId) => ({
                objectId
              }))],
              returnByValue,
              emulateUserGesture: true,
              awaitPromise: true
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            if (returnByValue)
              return (0, _utilityScriptSerializers.parseEvaluationResultValue)(response.result.value);
            return utilityScript._context.createHandle(response.result);
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Runtime.getProperties", {
            objectId,
            ownProperties: true
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.properties) {
            if (!property.enumerable || !property.value)
              continue;
            result.set(property.name, context.createHandle(property.value));
          }
          return result;
        });
      }
      createHandle(context, remoteObject) {
        const isPromise = remoteObject.className === "Promise";
        return new js.JSHandle(context, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield this._session.send("Runtime.releaseObject", {
            objectId
          });
        });
      }
      objectCount(objectId) {
        throw new Error("Method not implemented in WebKit.");
      }
    };
    exports2.WKExecutionContext = WKExecutionContext;
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
      return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
    }
    function rewriteError(error) {
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        return new Error("Execution context was destroyed, most likely because of a navigation.");
      return error;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview)
        return js.sparseArrayToString(object.preview.properties);
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInput.js
var require_wkInput = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Shift"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Alt"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          const parts = [];
          for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
            if (modifiers.has(modifier))
              parts.push(modifier);
          }
          parts.push(code);
          const shortcut = parts.join("+");
          let commands = _macEditingCommands.macEditingCommands[shortcut];
          if ((0, _utils.isString)(commands))
            commands = [commands];
          yield this._pageProxySession.send("Input.dispatchKeyEvent", {
            type: "keyDown",
            modifiers: toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCode,
            code,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            macCommands: commands,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCode,
            code,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._session.send("Page.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._page = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "move",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "down",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "up",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          var _this$_page;
          if ((_this$_page = this._page) !== null && _this$_page !== void 0 && _this$_page._browserContext._options.isMobile)
            throw new Error("Mouse wheel is not supported in mobile WebKit");
          yield this._session.send("Page.updateScrollingState");
          yield this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, {
            world: "utility"
          });
          yield this._pageProxySession.send("Input.dispatchWheelEvent", {
            x,
            y,
            deltaX,
            deltaY,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._pageProxySession = session;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchTapEvent", {
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js
var require_wkInterceptableRequest = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKRouteImpl = exports2.WKInterceptableRequest = void 0;
    var network = _interopRequireWildcard(require_network2());
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var errorReasons = {
      "aborted": "Cancellation",
      "accessdenied": "AccessControl",
      "addressunreachable": "General",
      "blockedbyclient": "Cancellation",
      "blockedbyresponse": "General",
      "connectionaborted": "General",
      "connectionclosed": "General",
      "connectionfailed": "General",
      "connectionrefused": "General",
      "connectionreset": "General",
      "internetdisconnected": "General",
      "namenotresolved": "General",
      "timedout": "Timeout",
      "failed": "General"
    };
    var WKInterceptableRequest = class {
      constructor(session, route, frame, event, redirectedFrom, documentId) {
        this._session = void 0;
        this.request = void 0;
        this._requestId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        this._session = session;
        this._requestId = event.requestId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : "other";
        let postDataBuffer = null;
        this._timestamp = event.timestamp;
        this._wallTime = event.walltime * 1e3;
        if (event.request.postData)
          postDataBuffer = Buffer.from(event.request.postData, "base64");
        this.request = new network.Request(frame._page._browserContext, frame, null, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, (0, _utils.headersObjectToArray)(event.request.headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      createResponse(responsePayload) {
        const getResponseBody = () => __async(this, null, function* () {
          const response2 = yield this._session.send("Network.getResponseBody", {
            requestId: this._requestId
          });
          return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
        });
        const timingPayload = responsePayload.timing;
        const timing = {
          startTime: this._wallTime,
          domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
          domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
          connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
          secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
          connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
          requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
          responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
        };
        const setCookieSeparator = process.platform === "darwin" ? "," : "\n";
        const response = new network.Response(this.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers, ",", setCookieSeparator), timing, getResponseBody, responsePayload.source === "service-worker");
        response.setRawResponseHeaders(null);
        response.setTransferSize(null);
        if (responsePayload.requestHeaders && Object.keys(responsePayload.requestHeaders).length) {
          const headers = __spreadValues({}, responsePayload.requestHeaders);
          if (!headers["host"])
            headers["Host"] = new URL(this.request.url()).host;
          this.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(headers));
        } else {
          this.request.setRawRequestHeaders(null);
        }
        return response;
      }
    };
    exports2.WKInterceptableRequest = WKInterceptableRequest;
    var WKRouteImpl = class {
      constructor(session, requestId) {
        this._session = void 0;
        this._requestId = void 0;
        this._requestInterceptedPromise = new _manualPromise.ManualPromise();
        this._session = session;
        this._requestId = requestId;
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          const errorType = errorReasons[errorCode];
          (0, _utils.assert)(errorType, "Unknown error code: " + errorCode);
          yield this._requestInterceptedPromise;
          yield this._session.sendMayFail("Network.interceptRequestWithError", {
            requestId: this._requestId,
            errorType
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          if (300 <= response.status && response.status < 400)
            throw new Error("Cannot fulfill with redirect status: " + response.status);
          yield this._requestInterceptedPromise;
          let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
          const headers = (0, _utils.headersArrayToObject)(response.headers, true);
          const contentType = headers["content-type"];
          if (contentType)
            mimeType = contentType.split(";")[0].trim();
          yield this._session.sendMayFail("Network.interceptRequestWithResponse", {
            requestId: this._requestId,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)],
            mimeType,
            headers,
            base64Encoded: response.isBase64,
            content: response.body
          });
        });
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._requestInterceptedPromise;
          yield this._session.sendMayFail("Network.interceptWithRequest", {
            requestId: this._requestId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers ? (0, _utils.headersArrayToObject)(overrides.headers, false) : void 0,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
          });
        });
      }
    };
    exports2.WKRouteImpl = WKRouteImpl;
    function wkMillisToRoundishMillis(value) {
      if (value === -1e3)
        return -1;
      if (value <= 0) {
        return -1;
      }
      return (value * 1e3 | 0) / 1e3;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js
var require_wkProvisionalPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKProvisionalPage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var WKProvisionalPage = class {
      constructor(session, page) {
        this._session = void 0;
        this._wkPage = void 0;
        this._sessionListeners = [];
        this._mainFrameId = null;
        this.initializationPromise = void 0;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler) => {
          return (payload) => {
            if (payload.frameId)
              payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
            handler(payload);
          };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", overrideFrameId((e) => wkPage._onRequestWillBeSent(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", overrideFrameId((e) => wkPage._onLoadingFinished(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", overrideFrameId((e) => wkPage._onLoadingFailed(e)))];
        this.initializationPromise = this._wkPage._initializeSession(session, true, ({
          frameTree
        }) => this._handleFrameTree(frameTree));
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
      }
      commit() {
        (0, _utils.assert)(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
      }
      _handleFrameTree(frameTree) {
        (0, _utils.assert)(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
      }
    };
    exports2.WKProvisionalPage = WKProvisionalPage;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkWorkers.js
var require_wkWorkers = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkWorkers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKWorkers = void 0;
    var _eventsHelper = require_eventsHelper();
    var _page = require_page();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var WKWorkers = class {
      constructor(page) {
        this._sessionListeners = [];
        this._page = void 0;
        this._workerSessions = /* @__PURE__ */ new Map();
        this._page = page;
      }
      setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Worker.workerCreated", (event) => {
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _wkConnection.WKSession(session.connection, event.workerId, "Most likely the worker has been closed.", (message) => {
            session.send("Worker.sendMessageToWorker", {
              workerId: event.workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          this._workerSessions.set(event.workerId, workerSession);
          worker._createExecutionContext(new _wkExecutionContext.WKExecutionContext(workerSession, void 0));
          this._page._addWorker(event.workerId, worker);
          workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
          Promise.all([workerSession.send("Runtime.enable"), workerSession.send("Console.enable"), session.send("Worker.initialized", {
            workerId: event.workerId
          })]).catch((e) => {
            this._page._removeWorker(event.workerId);
          });
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.dispatchMessageFromWorker", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispatchMessage(JSON.parse(event.message));
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.workerTerminated", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispose(false);
          this._workerSessions.delete(event.workerId);
          this._page._removeWorker(event.workerId);
        })];
      }
      clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
      }
      initializeSession(session) {
        return __async(this, null, function* () {
          yield session.send("Worker.enable");
        });
      }
      _onConsoleMessage(worker, event) {
        return __async(this, null, function* () {
          const {
            type,
            level,
            text,
            parameters,
            url,
            line: lineNumber,
            column: columnNumber
          } = event.message;
          let derivedType = type || "";
          if (type === "log")
            derivedType = level;
          else if (type === "timing")
            derivedType = "timeEnd";
          const handles = (parameters || []).map((p) => {
            return worker._existingExecutionContext.createHandle(p);
          });
          const location2 = {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          };
          this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
        });
      }
    };
    exports2.WKWorkers = WKWorkers;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkPage.js
var require_wkPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKPage = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _utilsBundle = require_utilsBundle();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var _hostPlatform = require_hostPlatform();
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network2());
    var _page = require_page();
    var _wkAccessibility = require_wkAccessibility();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var _wkInput = require_wkInput();
    var _wkInterceptableRequest = require_wkInterceptableRequest();
    var _wkProvisionalPage = require_wkProvisionalPage();
    var _wkWorkers = require_wkWorkers();
    var _debugLogger = require_debugLogger();
    var _manualPromise = require_manualPromise();
    var _browserContext = require_browserContext();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var WKPage = class {
      constructor(browserContext, pageProxySession, opener) {
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._provisionalPage = null;
        this._page = void 0;
        this._pagePromise = new _manualPromise.ManualPromise();
        this._pageProxySession = void 0;
        this._opener = void 0;
        this._requestIdToRequest = /* @__PURE__ */ new Map();
        this._workers = void 0;
        this._contextIdToContext = void 0;
        this._mainFrameContextId = void 0;
        this._sessionListeners = [];
        this._eventListeners = void 0;
        this._browserContext = void 0;
        this._initializedPage = null;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._lastConsoleMessage = null;
        this._requestIdToResponseReceivedPayloadEvent = /* @__PURE__ */ new Map();
        this._nextWindowOpenPopupFeatures = void 0;
        this._recordingVideoFile = null;
        this._screencastGeneration = 0;
        this._pageProxySession = pageProxySession;
        this._opener = opener;
        this.rawKeyboard = new _wkInput.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new _wkInput.RawMouseImpl(pageProxySession);
        this.rawTouchscreen = new _wkInput.RawTouchscreenImpl(pageProxySession);
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._workers = new _wkWorkers.WKWorkers(this._page);
        this._session = void 0;
        this._browserContext = browserContext;
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Screencast.screencastFrame", this._onScreencastFrame.bind(this))];
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
          opener._nextWindowOpenPopupFeatures = void 0;
          if (viewportSize)
            this._page._emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
      }
      potentiallyUninitializedPage() {
        return this._page;
      }
      _initializePageProxySession() {
        return __async(this, null, function* () {
          if (this._page._browserContext.isSettingStorageState())
            return;
          const promises = [this._pageProxySession.send("Dialog.enable"), this._pageProxySession.send("Emulation.setActiveAndFocused", {
            active: true
          })];
          const contextOptions = this._browserContext._options;
          if (contextOptions.javaScriptEnabled === false)
            promises.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", {
              enabled: false
            }));
          promises.push(this._updateViewport());
          promises.push(this.updateHttpCredentials());
          if (this._browserContext._permissions.size) {
            for (const [key, value] of this._browserContext._permissions)
              promises.push(this._grantPermissions(key, value));
          }
          if (this._browserContext._options.recordVideo) {
            const outputFile = _path.default.join(this._browserContext._options.recordVideo.dir, (0, _utils.createGuid)() + ".webm");
            promises.push(this._browserContext._ensureVideosPath().then(() => {
              return this._startVideo(__spreadProps(__spreadValues({}, this._browserContext._options.recordVideo.size), {
                outputFile
              }));
            }));
          }
          yield Promise.all(promises);
        });
      }
      _setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this.rawMouse.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
      }
      _initializeSession(session, provisional, resourceTreeHandler) {
        return __async(this, null, function* () {
          yield this._initializeSessionMayThrow(session, resourceTreeHandler).catch((e) => {
            if (provisional && session.isDisposed())
              return;
            if (this._session === session)
              throw e;
          });
        });
      }
      _initializeSessionMayThrow(session, resourceTreeHandler) {
        return __async(this, null, function* () {
          const [, frameTree] = yield Promise.all([
            session.send("Page.enable"),
            session.send("Page.getResourceTree")
          ]);
          resourceTreeHandler(frameTree);
          const promises = [
            session.send("Runtime.enable"),
            session.send("Page.createUserWorld", {
              name: UTILITY_WORLD_NAME
            }).catch((_) => {
            }),
            session.send("Console.enable"),
            session.send("Network.enable"),
            this._workers.initializeSession(session)
          ];
          if (this._page.needsRequestInterception()) {
            promises.push(session.send("Network.setInterceptionEnabled", {
              enabled: true
            }));
            promises.push(session.send("Network.addInterception", {
              url: ".*",
              stage: "request",
              isRegex: true
            }));
          }
          if (this._page._browserContext.isSettingStorageState()) {
            yield Promise.all(promises);
            return;
          }
          const contextOptions = this._browserContext._options;
          if (contextOptions.userAgent)
            promises.push(this.updateUserAgent());
          const emulatedMedia = this._page.emulatedMedia();
          if (emulatedMedia.media || emulatedMedia.colorScheme || emulatedMedia.reducedMotion || emulatedMedia.forcedColors)
            promises.push(WKPage._setEmulateMedia(session, emulatedMedia.media, emulatedMedia.colorScheme, emulatedMedia.reducedMotion, emulatedMedia.forcedColors));
          for (const binding of this._page.allBindings())
            promises.push(session.send("Runtime.addBinding", {
              name: binding.name
            }));
          const bootstrapScript = this._calculateBootstrapScript();
          if (bootstrapScript.length)
            promises.push(session.send("Page.setBootstrapScript", {
              source: bootstrapScript
            }));
          this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript).catch((e) => {
          }));
          if (contextOptions.bypassCSP)
            promises.push(session.send("Page.setBypassCSP", {
              enabled: true
            }));
          const emulatedSize = this._page.emulatedSize();
          if (emulatedSize) {
            promises.push(session.send("Page.setScreenSizeOverride", {
              width: emulatedSize.screen.width,
              height: emulatedSize.screen.height
            }));
          }
          promises.push(this.updateEmulateMedia());
          promises.push(session.send("Network.setExtraHTTPHeaders", {
            headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
          }));
          if (contextOptions.offline)
            promises.push(session.send("Network.setEmulateOfflineState", {
              offline: true
            }));
          promises.push(session.send("Page.setTouchEmulationEnabled", {
            enabled: !!contextOptions.hasTouch
          }));
          if (contextOptions.timezoneId) {
            promises.push(session.send("Page.setTimeZone", {
              timeZone: contextOptions.timezoneId
            }).catch((e) => {
              throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
            }));
          }
          if (this._page.fileChooserIntercepted())
            promises.push(session.send("Page.setInterceptFileChooserDialog", {
              enabled: true
            }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "DeviceOrientationEventEnabled",
            value: contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "FullScreenEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "NotificationsEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "PointerLockEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "InputTypeMonthEnabled",
            value: contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "InputTypeWeekEnabled",
            value: contextOptions.isMobile
          }));
          yield Promise.all(promises);
        });
      }
      _onDidCommitProvisionalTarget(event) {
        const {
          oldTargetId,
          newTargetId
        } = event;
        (0, _utils.assert)(this._provisionalPage);
        (0, _utils.assert)(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
        (0, _utils.assert)(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
        const newSession = this._provisionalPage._session;
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(newSession);
      }
      _onTargetDestroyed(event) {
        const {
          targetId,
          crashed
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
          this._provisionalPage._session.dispose(false);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        } else if (this._session.sessionId === targetId) {
          this._session.dispose(false);
          _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
          if (crashed) {
            this._session.markAsCrashed();
            this._page._didCrash();
          }
        }
      }
      didClose() {
        this._page._didClose();
      }
      dispose(disconnected) {
        this._pageProxySession.dispose(disconnected);
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        if (this._session)
          this._session.dispose(disconnected);
        if (this._provisionalPage) {
          this._provisionalPage._session.dispose(disconnected);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        }
        this._page._didDisconnect();
        this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
      }
      dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
      }
      handleProvisionalLoadFailed(event) {
        if (!this._initializedPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
          return;
        }
        if (!this._provisionalPage)
          return;
        let errorText = event.error;
        if (errorText.includes("cancelled"))
          errorText += "; maybe frame was detached?";
        this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
      }
      handleWindowOpen(event) {
        (0, _utils.debugAssert)(!this._nextWindowOpenPopupFeatures);
        this._nextWindowOpenPopupFeatures = event.windowFeatures;
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      _onTargetCreated(event) {
        return __async(this, null, function* () {
          const {
            targetInfo
          } = event;
          const session = new _wkConnection.WKSession(this._pageProxySession.connection, targetInfo.targetId, `Target closed`, (message) => {
            this._pageProxySession.send("Target.sendMessageToTarget", {
              message: JSON.stringify(message),
              targetId: targetInfo.targetId
            }).catch((e) => {
              session.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          (0, _utils.assert)(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
          if (!targetInfo.isProvisional) {
            (0, _utils.assert)(!this._initializedPage);
            let pageOrError;
            try {
              this._setSession(session);
              yield Promise.all([this._initializePageProxySession(), this._initializeSession(session, false, ({
                frameTree
              }) => this._handleFrameTree(frameTree))]);
              pageOrError = this._page;
            } catch (e) {
              pageOrError = e;
            }
            if (targetInfo.isPaused)
              this._pageProxySession.sendMayFail("Target.resume", {
                targetId: targetInfo.targetId
              });
            if (pageOrError instanceof _page.Page && this._page.mainFrame().url() === "") {
              try {
                yield this._firstNonInitialNavigationCommittedPromise;
              } catch (e) {
                pageOrError = e;
              }
            } else {
              this._firstNonInitialNavigationCommittedPromise.catch(() => {
              });
            }
            yield this._page.initOpener(this._opener);
            this._initializedPage = pageOrError instanceof _page.Page ? pageOrError : null;
            this._page.reportAsNew(pageOrError instanceof _page.Page ? void 0 : pageOrError);
            this._pagePromise.resolve(pageOrError);
          } else {
            (0, _utils.assert)(targetInfo.isProvisional);
            (0, _utils.assert)(!this._provisionalPage);
            this._provisionalPage = new _wkProvisionalPage.WKProvisionalPage(session, this);
            if (targetInfo.isPaused) {
              this._provisionalPage.initializationPromise.then(() => {
                this._pageProxySession.sendMayFail("Target.resume", {
                  targetId: targetInfo.targetId
                });
              });
            }
          }
        });
      }
      _onDispatchMessageFromTarget(event) {
        const {
          targetId,
          message
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
          this._provisionalPage._session.dispatchMessage(JSON.parse(message));
        else if (this._session.sessionId === targetId)
          this._session.dispatchMessage(JSON.parse(message));
        else
          throw new Error("Unknown target: " + targetId);
      }
      _addSessionListeners() {
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.willCheckNavigationPolicy", (event) => this._onWillCheckNavigationPolicy(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.didCheckNavigationPolicy", (event) => this._onDidCheckNavigationPolicy(event.frameId, event.cancel)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId, event.delay, event.targetIsCurrentFrame)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.loadEventFired", (event) => this._page._frameManager.frameLifecycleEvent(event.frameId, "load")), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded")), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.bindingCalled", (event) => this._onBindingCalled(event.contextId, event.argument)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      _updateState(method, params) {
        return __async(this, null, function* () {
          yield this._forAllSessions((session) => session.send(method, params).then());
        });
      }
      _forAllSessions(callback) {
        return __async(this, null, function* () {
          const sessions = [this._session];
          if (this._provisionalPage)
            sessions.push(this._provisionalPage._session);
          yield Promise.all(sessions.map((session) => callback(session).catch((e) => {
          })));
        });
      }
      _onWillCheckNavigationPolicy(frameId) {
        if (this._provisionalPage)
          return;
        this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _onDidCheckNavigationPolicy(frameId, cancel) {
        if (!cancel)
          return;
        if (this._provisionalPage)
          return;
        this._page._frameManager.frameAbortedNavigation(frameId, "Navigation canceled by policy check");
      }
      _onFrameScheduledNavigation(frameId, delay, targetIsCurrentFrame) {
        if (targetIsCurrentFrame)
          this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        (0, _utils.assert)(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
          this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
      }
      _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame) {
            this._contextIdToContext.delete(contextId);
            if (notifyFrame)
              frame._contextDestroyed(context);
          }
        }
      }
      _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
          return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
          return;
        const delegate = new _wkExecutionContext.WKExecutionContext(this._session, contextPayload.id);
        let worldName = null;
        if (contextPayload.type === "normal")
          worldName = "main";
        else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        if (contextPayload.type === "normal" && frame === this._page.mainFrame())
          this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onBindingCalled(contextId, argument) {
        return __async(this, null, function* () {
          const pageOrError = yield this.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(contextId);
            if (context)
              yield this._page._onBindingCalled(argument, context);
          }
        });
      }
      navigateFrame(frame, url, referrer) {
        return __async(this, null, function* () {
          if (this._pageProxySession.isDisposed())
            throw new Error("Target closed");
          const pageProxyId = this._pageProxySession.sessionId;
          const result = yield this._pageProxySession.connection.browserSession.send("Playwright.navigate", {
            url,
            pageProxyId,
            frameId: frame._id,
            referrer
          });
          return {
            newDocumentId: result.loaderId
          };
        });
      }
      _onConsoleMessage(event) {
        const {
          type,
          level,
          text,
          parameters,
          url,
          line: lineNumber,
          column: columnNumber,
          source
        } = event.message;
        if (level === "error" && source === "javascript") {
          const {
            name,
            message
          } = (0, _stackTrace.splitErrorMessage)(text);
          let stack;
          if (event.message.stackTrace) {
            stack = text + "\n" + event.message.stackTrace.callFrames.map((callFrame) => {
              return `    at ${callFrame.functionName || "unknown"} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
            }).join("\n");
          } else {
            stack = "";
          }
          this._lastConsoleMessage = null;
          const error = new Error(message);
          error.stack = stack;
          error.name = name;
          this._page.firePageError(error);
          return;
        }
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = [];
        for (const p of parameters || []) {
          let context;
          if (p.objectId) {
            const objectId = JSON.parse(p.objectId);
            context = this._contextIdToContext.get(objectId.injectedScriptId);
          } else {
            context = [...this._contextIdToContext.values()].find((c) => c.frame === this._page.mainFrame());
          }
          if (!context)
            return;
          handles.push(context.createHandle(p));
        }
        this._lastConsoleMessage = {
          derivedType,
          text,
          handles,
          count: 0,
          location: {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          }
        };
        this._onConsoleRepeatCountUpdated({
          count: 1
        });
      }
      _onConsoleRepeatCountUpdated(event) {
        if (this._lastConsoleMessage) {
          const {
            derivedType,
            text,
            handles,
            count,
            location: location2
          } = this._lastConsoleMessage;
          for (let i = count; i < event.count; ++i)
            this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
          this._lastConsoleMessage.count = event.count;
        }
      }
      _onDialog(event) {
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, (accept, promptText) => __async(this, null, function* () {
          yield this._pageProxySession.send("Dialog.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }), event.defaultPrompt));
      }
      _onFileChooserOpened(event) {
        return __async(this, null, function* () {
          let handle;
          try {
            const context = yield this._page._frameManager.frame(event.frameId)._mainContext();
            handle = context.createHandle(event.element).asElement();
          } catch (e) {
            return;
          }
          yield this._page._onFileChooserOpened(handle);
        });
      }
      static _setEmulateMedia(session, mediaType, colorScheme, reducedMotion, forcedColors) {
        return __async(this, null, function* () {
          const promises = [];
          promises.push(session.send("Page.setEmulatedMedia", {
            media: mediaType === "no-override" ? "" : mediaType
          }));
          let appearance = void 0;
          switch (colorScheme) {
            case "light":
              appearance = "Light";
              break;
            case "dark":
              appearance = "Dark";
              break;
            case "no-override":
              appearance = void 0;
              break;
          }
          promises.push(session.send("Page.overrideUserPreference", {
            name: "PrefersColorScheme",
            value: appearance
          }));
          let reducedMotionWk = void 0;
          switch (reducedMotion) {
            case "reduce":
              reducedMotionWk = "Reduce";
              break;
            case "no-preference":
              reducedMotionWk = "NoPreference";
              break;
            case "no-override":
              reducedMotionWk = void 0;
              break;
          }
          promises.push(session.send("Page.overrideUserPreference", {
            name: "PrefersReducedMotion",
            value: reducedMotionWk
          }));
          let forcedColorsWk = void 0;
          switch (forcedColors) {
            case "active":
              forcedColorsWk = "Active";
              break;
            case "none":
              forcedColorsWk = "None";
              break;
            case "no-override":
              forcedColorsWk = void 0;
              break;
          }
          promises.push(session.send("Page.setForcedColors", {
            forcedColors: forcedColorsWk
          }));
          yield Promise.all(promises);
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._updateState("Network.setExtraHTTPHeaders", {
            headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
          });
        });
      }
      _calculateExtraHTTPHeaders() {
        const locale = this._browserContext._options.locale;
        const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._page.extraHTTPHeaders(), locale ? network.singleHeader("Accept-Language", locale) : void 0]);
        return headers;
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          const emulatedMedia = this._page.emulatedMedia();
          const colorScheme = emulatedMedia.colorScheme;
          const reducedMotion = emulatedMedia.reducedMotion;
          const forcedColors = emulatedMedia.forcedColors;
          yield this._forAllSessions((session) => WKPage._setEmulateMedia(session, emulatedMedia.media, colorScheme, reducedMotion, forcedColors));
        });
      }
      updateEmulatedViewportSize() {
        return __async(this, null, function* () {
          this._browserContext._validateEmulatedViewport(this._page.viewportSize());
          yield this._updateViewport();
        });
      }
      updateUserAgent() {
        return __async(this, null, function* () {
          const contextOptions = this._browserContext._options;
          this._updateState("Page.overrideUserAgent", {
            value: contextOptions.userAgent
          });
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          this._pageProxySession.send("Target.activate", {
            targetId: this._session.sessionId
          });
        });
      }
      _updateViewport() {
        return __async(this, null, function* () {
          const options = this._browserContext._options;
          const deviceSize = this._page.emulatedSize();
          if (deviceSize === null)
            return;
          const viewportSize = deviceSize.viewport;
          const screenSize = deviceSize.screen;
          const promises = [this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
            width: viewportSize.width,
            height: viewportSize.height,
            fixedLayout: !!options.isMobile,
            deviceScaleFactor: options.deviceScaleFactor || 1
          }), this._session.send("Page.setScreenSizeOverride", {
            width: screenSize.width,
            height: screenSize.height
          })];
          if (options.isMobile) {
            const angle = viewportSize.width > viewportSize.height ? 90 : 0;
            promises.push(this._session.send("Page.setOrientationOverride", {
              angle
            }));
          }
          yield Promise.all(promises);
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          const enabled = this._page.needsRequestInterception();
          yield Promise.all([this._updateState("Network.setInterceptionEnabled", {
            enabled
          }), this._updateState("Network.addInterception", {
            url: ".*",
            stage: "request",
            isRegex: true
          })]);
        });
      }
      updateOffline() {
        return __async(this, null, function* () {
          yield this._updateState("Network.setEmulateOfflineState", {
            offline: !!this._browserContext._options.offline
          });
        });
      }
      updateHttpCredentials() {
        return __async(this, null, function* () {
          const credentials = this._browserContext._options.httpCredentials || {
            username: "",
            password: "",
            origin: ""
          };
          yield this._pageProxySession.send("Emulation.setAuthCredentials", {
            username: credentials.username,
            password: credentials.password,
            origin: credentials.origin
          });
        });
      }
      updateFileChooserInterception() {
        return __async(this, null, function* () {
          const enabled = this._page.fileChooserIntercepted();
          yield this._session.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch(() => {
          });
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._session.send("Page.reload");
        });
      }
      goBack() {
        return this._session.send("Page.goBack").then(() => true).catch((error) => {
          if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`))
            return false;
          throw error;
        });
      }
      goForward() {
        return this._session.send("Page.goForward").then(() => true).catch((error) => {
          if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`))
            return false;
          throw error;
        });
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          this._session.send("Runtime.addBinding", {
            name: binding.name
          });
          yield this._updateBootstrapScript();
          yield Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(binding.source).catch((e) => {
          })));
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      addInitScript(script) {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      _calculateBootstrapScript() {
        const scripts = [];
        if (!this._page.context()._options.isMobile) {
          scripts.push("delete window.orientation");
          scripts.push("delete window.ondevicemotion");
          scripts.push("delete window.ondeviceorientation");
        }
        scripts.push("if (!window.safari) window.safari = {};");
        scripts.push("if (!window.GestureEvent) window.GestureEvent = function GestureEvent() {};");
        for (const binding of this._page.allBindings())
          scripts.push(binding.source);
        scripts.push(...this._browserContext.initScripts);
        scripts.push(...this._page.initScripts);
        return scripts.join(";\n");
      }
      _updateBootstrapScript() {
        return __async(this, null, function* () {
          yield this._updateState("Page.setBootstrapScript", {
            source: this._calculateBootstrapScript()
          });
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          yield this._stopVideo();
          yield this._pageProxySession.sendMayFail("Target.close", {
            targetId: this._session.sessionId,
            runBeforeUnload
          });
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          yield this._session.send("Page.setDefaultBackgroundColorOverride", {
            color
          });
        });
      }
      _toolbarHeight() {
        var _this$_page$_browserC;
        if ((_this$_page$_browserC = this._page._browserContext._browser) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.options.headful)
          return _hostPlatform.hostPlatform === "mac10.15" ? 55 : 59;
        return 0;
      }
      _startVideo(options) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._recordingVideoFile);
          const {
            screencastId
          } = yield this._pageProxySession.send("Screencast.startVideo", {
            file: options.outputFile,
            width: options.width,
            height: options.height,
            toolbarHeight: this._toolbarHeight()
          });
          this._recordingVideoFile = options.outputFile;
          this._browserContext._browser._videoStarted(this._browserContext, screencastId, options.outputFile, this.pageOrError());
        });
      }
      _stopVideo() {
        return __async(this, null, function* () {
          if (!this._recordingVideoFile)
            return;
          yield this._pageProxySession.sendMayFail("Screencast.stopVideo");
          this._recordingVideoFile = null;
        });
      }
      validateScreenshotDimension(side, omitDeviceScaleFactor) {
        if (process.platform === "darwin")
          return;
        if (!omitDeviceScaleFactor && this._page._browserContext._options.deviceScaleFactor)
          side = Math.ceil(side * this._page._browserContext._options.deviceScaleFactor);
        if (side > 32767)
          throw new Error("Cannot take screenshot larger than 32767 pixels on any dimension");
      }
      takeScreenshot(progress2, format, documentRect, viewportRect, quality, fitsViewport, scale) {
        return __async(this, null, function* () {
          const rect = documentRect || viewportRect;
          const omitDeviceScaleFactor = scale === "css";
          this.validateScreenshotDimension(rect.width, omitDeviceScaleFactor);
          this.validateScreenshotDimension(rect.height, omitDeviceScaleFactor);
          const result = yield this._session.send("Page.snapshotRect", __spreadProps(__spreadValues({}, rect), {
            coordinateSystem: documentRect ? "Page" : "Viewport",
            omitDeviceScaleFactor
          }));
          const prefix = "data:image/png;base64,";
          let buffer = Buffer.from(result.dataURL.substr(prefix.length), "base64");
          if (format === "jpeg")
            buffer = _utilsBundle.jpegjs.encode(_utilsBundle.PNG.sync.read(buffer), quality).data;
          return buffer;
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._session.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          if (!nodeInfo.contentFrameId)
            return null;
          return this._page._frameManager.frame(nodeInfo.contentFrameId);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          if (!handle._objectId)
            return null;
          const nodeInfo = yield this._session.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          return nodeInfo.ownerFrameId || null;
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          const quads = yield this.getContentQuads(handle);
          if (!quads || !quads.length)
            return null;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (const quad of quads) {
            for (const point of quad) {
              minX = Math.min(minX, point.x);
              maxX = Math.max(maxX, point.x);
              minY = Math.min(minY, point.y);
              maxY = Math.max(maxY, point.y);
            }
          }
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._session.send("DOM.scrollIntoViewIfNeeded", {
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            throw e;
          });
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            const so = __spreadProps(__spreadValues({}, options), {
              toolbarHeight: this._toolbarHeight()
            });
            const {
              generation
            } = yield this._pageProxySession.send("Screencast.startScreencast", so);
            this._screencastGeneration = generation;
          } else {
            yield this._pageProxySession.send("Screencast.stopScreencast");
          }
        });
      }
      _onScreencastFrame(event) {
        const generation = this._screencastGeneration;
        this._page.throttleScreencastFrameAck(() => {
          this._pageProxySession.send("Screencast.screencastFrameAck", {
            generation
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return process.platform === "win32" ? 5 : 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("DOM.getContentQuads", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          return result.quads.map((quad) => [{
            x: quad[0],
            y: quad[1]
          }, {
            x: quad[2],
            y: quad[3]
          }, {
            x: quad[4],
            y: quad[5]
          }, {
            x: quad[6],
            y: quad[7]
          }]);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          const objectId = handle._objectId;
          const protocolFiles = files.map((file) => ({
            name: file.name,
            type: file.mimeType,
            data: file.buffer
          }));
          yield this._session.send("DOM.setInputFiles", {
            objectId,
            files: protocolFiles
          });
        });
      }
      setInputFilePaths(progress2, handle, paths) {
        return __async(this, null, function* () {
          const pageProxyId = this._pageProxySession.sessionId;
          const objectId = handle._objectId;
          yield Promise.all([this._pageProxySession.connection.browserSession.send("Playwright.grantFileReadAccess", {
            pageProxyId,
            paths
          }), this._session.send("DOM.setInputFiles", {
            objectId,
            paths
          })]);
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("DOM.resolveNode", {
            objectId: handle._objectId,
            executionContextId: to[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.object);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _wkAccessibility.getAccessibilityTree)(this._session, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
        });
      }
      resetForReuse() {
        return __async(this, null, function* () {
        });
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const context = yield parent._mainContext();
          const result = yield this._session.send("DOM.resolveNode", {
            frameId: frame._id,
            executionContextId: context[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error("Frame has been detached.");
          return context.createHandle(result.object);
        });
      }
      _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse, event.timestamp);
            redirectedFrom = request2;
          }
        }
        const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        const isNavigationRequest = event.type === "Document";
        const documentId = isNavigationRequest ? event.loaderId : void 0;
        let route = null;
        if (this._page.needsRequestInterception() && !redirectedFrom)
          route = new _wkInterceptableRequest.WKRouteImpl(session, event.requestId);
        const request = new _wkInterceptableRequest.WKInterceptableRequest(session, route, frame, event, redirectedFrom, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = request.createResponse(responsePayload);
        response._securityDetailsFinished();
        response._serverAddrFinished();
        response.setResponseHeadersSize(null);
        response.setEncodedBodySize(null);
        response._requestFinished(responsePayload.timing ? _helper.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestIntercepted(session, event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request) {
          session.sendMayFail("Network.interceptRequestWithError", {
            errorType: "Cancellation",
            requestId: event.requestId
          });
          return;
        }
        request.request.setRawRequestHeaders(null);
        if (!request._route) {
          session.sendMayFail("Network.interceptWithRequest", {
            requestId: request._requestId
          });
        } else {
          request._route._requestInterceptedPromise.resolve();
        }
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        this._requestIdToResponseReceivedPayloadEvent.set(request._requestId, event);
        const response = request.createResponse(event.response);
        this._page._frameManager.requestReceivedResponse(response);
        if (response.status() === 204) {
          this._onLoadingFailed({
            requestId: event.requestId,
            errorText: "Aborted: 204 No Content",
            timestamp: event.timestamp
          });
        }
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          var _event$metrics, _event$metrics2, _event$metrics2$secur, _responseReceivedPayl, _responseReceivedPayl2, _responseReceivedPayl3, _responseReceivedPayl4, _responseReceivedPayl5, _responseReceivedPayl6, _event$metrics3, _event$metrics$respon, _event$metrics4, _event$metrics$respon2, _event$metrics5;
          const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(request._requestId);
          response._serverAddrFinished(parseRemoteAddress(event === null || event === void 0 ? void 0 : (_event$metrics = event.metrics) === null || _event$metrics === void 0 ? void 0 : _event$metrics.remoteAddress));
          response._securityDetailsFinished({
            protocol: isLoadedSecurely(response.url(), response.timing()) ? (_event$metrics2 = event.metrics) === null || _event$metrics2 === void 0 ? void 0 : (_event$metrics2$secur = _event$metrics2.securityConnection) === null || _event$metrics2$secur === void 0 ? void 0 : _event$metrics2$secur.protocol : void 0,
            subjectName: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl = responseReceivedPayload.response.security) === null || _responseReceivedPayl === void 0 ? void 0 : (_responseReceivedPayl2 = _responseReceivedPayl.certificate) === null || _responseReceivedPayl2 === void 0 ? void 0 : _responseReceivedPayl2.subject,
            validFrom: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl3 = responseReceivedPayload.response.security) === null || _responseReceivedPayl3 === void 0 ? void 0 : (_responseReceivedPayl4 = _responseReceivedPayl3.certificate) === null || _responseReceivedPayl4 === void 0 ? void 0 : _responseReceivedPayl4.validFrom,
            validTo: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl5 = responseReceivedPayload.response.security) === null || _responseReceivedPayl5 === void 0 ? void 0 : (_responseReceivedPayl6 = _responseReceivedPayl5.certificate) === null || _responseReceivedPayl6 === void 0 ? void 0 : _responseReceivedPayl6.validUntil
          });
          if ((_event$metrics3 = event.metrics) !== null && _event$metrics3 !== void 0 && _event$metrics3.protocol)
            response._setHttpVersion(event.metrics.protocol);
          response.setEncodedBodySize((_event$metrics$respon = (_event$metrics4 = event.metrics) === null || _event$metrics4 === void 0 ? void 0 : _event$metrics4.responseBodyBytesReceived) !== null && _event$metrics$respon !== void 0 ? _event$metrics$respon : null);
          response.setResponseHeadersSize((_event$metrics$respon2 = (_event$metrics5 = event.metrics) === null || _event$metrics5 === void 0 ? void 0 : _event$metrics5.responseHeaderBytesReceived) !== null && _event$metrics$respon2 !== void 0 ? _event$metrics$respon2 : null);
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        } else {
          request.request.setRawRequestHeaders(null);
        }
        this._requestIdToResponseReceivedPayloadEvent.delete(request._requestId);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          response._serverAddrFinished();
          response._securityDetailsFinished();
          response.setResponseHeadersSize(null);
          response.setEncodedBodySize(null);
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        } else {
          request.request.setRawRequestHeaders(null);
        }
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes("cancelled"));
      }
      _grantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([["geolocation", "geolocation"]]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._pageProxySession.send("Emulation.grantPermissions", {
            origin,
            permissions: filtered
          });
        });
      }
      _clearPermissions() {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Emulation.resetPermissions", {});
        });
      }
    };
    exports2.WKPage = WKPage;
    function parseRemoteAddress(value) {
      if (!value)
        return;
      try {
        const colon = value.lastIndexOf(":");
        const dot = value.lastIndexOf(".");
        if (dot < 0) {
          return {
            ipAddress: `[${value.slice(0, colon)}]`,
            port: +value.slice(colon + 1)
          };
        }
        if (colon > dot) {
          const [address, port] = value.split(":");
          return {
            ipAddress: address,
            port: +port
          };
        } else {
          const [address, port] = value.split(".");
          return {
            ipAddress: `[${address}]`,
            port: +port
          };
        }
      } catch (_) {
      }
    }
    function isLoadedSecurely(url, timing) {
      try {
        const u = new URL(url);
        if (u.protocol !== "https:" && u.protocol !== "wss:" && u.protocol !== "sftp:")
          return false;
        if (timing.secureConnectionStart === -1 && timing.connectStart !== -1)
          return false;
        return true;
      } catch (_) {
      }
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/webkit/wkBrowser.js
var require_wkBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKBrowserContext = exports2.WKBrowser = void 0;
    var _browser = require_browser();
    var _browserContext = require_browserContext();
    var _utils = require_utils();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network2());
    var _wkConnection = require_wkConnection();
    var _wkPage = require_wkPage();
    var _errors = require_errors();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15";
    var BROWSER_VERSION = "17.0";
    var WKBrowser = class extends _browser.Browser {
      static connect(parent, transport, options) {
        return __async(this, null, function* () {
          const browser = new WKBrowser(parent, transport, options);
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const promises = [browser._browserSession.send("Playwright.enable")];
          if (options.persistent) {
            var _options$persistent;
            (_options$persistent = options.persistent).userAgent || (_options$persistent.userAgent = DEFAULT_USER_AGENT);
            browser._defaultContext = new WKBrowserContext(browser, void 0, options.persistent);
            promises.push(browser._defaultContext._initialize());
          }
          yield Promise.all(promises);
          return browser;
        });
      }
      constructor(parent, transport, options) {
        super(parent, options);
        this._connection = void 0;
        this._browserSession = void 0;
        this._contexts = /* @__PURE__ */ new Map();
        this._wkPages = /* @__PURE__ */ new Map();
        this._eventListeners = void 0;
        this._connection = new _wkConnection.WKConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
        this._browserSession = this._connection.browserSession;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.windowOpen", (event) => this._onWindowOpen(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadCreated", this._onDownloadCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFinished", this._onDownloadFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.screencastFinished", this._onScreencastFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, _wkConnection.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))];
      }
      _onDisconnect() {
        for (const wkPage of this._wkPages.values())
          wkPage.dispose(true);
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
      doCreateNewContext(options) {
        return __async(this, null, function* () {
          const createOptions = options.proxy ? {
            proxyServer: process.platform === "win32" ? options.proxy.server.replace(/^socks5:\/\//, "socks5h://") : options.proxy.server,
            proxyBypassList: options.proxy.bypass
          } : void 0;
          const {
            browserContextId
          } = yield this._browserSession.send("Playwright.createContext", createOptions);
          options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
          const context = new WKBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return BROWSER_VERSION;
      }
      userAgent() {
        return DEFAULT_USER_AGENT;
      }
      _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
          return;
        page._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
        let originPage = page._initializedPage;
        if (!originPage) {
          page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
          if (page._opener)
            originPage = page._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
      }
      _onDownloadFilenameSuggested(payload) {
        this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
      }
      _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
      }
      _onScreencastFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onPageProxyCreated(event) {
        const pageProxyId = event.pageProxyId;
        let context = null;
        if (event.browserContextId) {
          context = this._contexts.get(event.browserContextId) || null;
        }
        if (!context)
          context = this._defaultContext;
        if (!context)
          return;
        const pageProxySession = new _wkConnection.WKSession(this._connection, pageProxyId, `Target closed`, (message) => {
          this._connection.rawSend(__spreadProps(__spreadValues({}, message), {
            pageProxyId
          }));
        });
        const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
        const wkPage = new _wkPage.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
      }
      _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
          return;
        wkPage.didClose();
        wkPage.dispose(false);
        this._wkPages.delete(pageProxyId);
      }
      _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.dispatchMessageToSession(event.message);
      }
      _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleProvisionalLoadFailed(event);
      }
      _onWindowOpen(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleWindowOpen(event);
      }
      isConnected() {
        return !this._connection.isClosed();
      }
    };
    exports2.WKBrowser = WKBrowser;
    var WKBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._validateEmulatedViewport(options.viewport);
        this._authenticateProxyViaHeader();
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._wkPages().length);
          const browserContextId = this._browserContextId;
          const promises = [__superGet("_initialize").call(this)];
          promises.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
            behavior: this._options.acceptDownloads ? "allow" : "deny",
            downloadPath: this._browser.options.downloadsPath,
            browserContextId
          }));
          if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", {
              browserContextId,
              ignore: true
            }));
          if (this._options.locale)
            promises.push(this._browser._browserSession.send("Playwright.setLanguages", {
              browserContextId,
              languages: [this._options.locale]
            }));
          if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
          if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
          if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
          yield Promise.all(promises);
        });
      }
      _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
      }
      pages() {
        return this._wkPages().map((wkPage) => wkPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const {
            pageProxyId
          } = yield this._browser._browserSession.send("Playwright.createPage", {
            browserContextId: this._browserContextId
          });
          return this._browser._wkPages.get(pageProxyId);
        });
      }
      doGetCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._browserSession.send("Playwright.getAllCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({}, c);
            copy.expires = c.expires === -1 ? -1 : c.expires / 1e3;
            delete copy.session;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
            session: c.expires === -1 || c.expires === void 0,
            expires: c.expires && c.expires !== -1 ? c.expires * 1e3 : c.expires
          }));
          yield this._browser._browserSession.send("Playwright.setCookies", {
            cookies: cc,
            browserContextId: this._browserContextId
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.deleteAllCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          yield Promise.all(this.pages().map((page) => page._delegate._grantPermissions(origin, permissions)));
        });
      }
      doClearPermissions() {
        return __async(this, null, function* () {
          yield Promise.all(this.pages().map((page) => page._delegate._clearPermissions()));
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          const payload = geolocation ? __spreadProps(__spreadValues({}, geolocation), {
            timestamp: Date.now()
          }) : void 0;
          yield this._browser._browserSession.send("Playwright.setGeolocationOverride", {
            browserContextId: this._browserContextId,
            geolocation: payload
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          for (const page of this.pages())
            yield page._delegate.updateExtraHTTPHeaders();
        });
      }
      setUserAgent(userAgent) {
        return __async(this, null, function* () {
          this._options.userAgent = userAgent;
          for (const page of this.pages())
            yield page._delegate.updateUserAgent();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          for (const page of this.pages())
            yield page._delegate.updateOffline();
        });
      }
      doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          for (const page of this.pages())
            yield page._delegate.updateHttpCredentials();
        });
      }
      doAddInitScript(source) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate._updateBootstrapScript();
        });
      }
      doRemoveInitScripts() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate._updateBootstrapScript();
        });
      }
      doExposeBinding(binding) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.exposeBinding(binding);
        });
      }
      doRemoveExposedBindings() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.removeExposedBindings();
        });
      }
      doUpdateRequestInterception() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.updateRequestInterception();
        });
      }
      onClosePersistent() {
      }
      clearCache() {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.clearMemoryCache", {
            browserContextId: this._browserContextId
          });
        });
      }
      doClose() {
        return __async(this, null, function* () {
          if (!this._browserContextId) {
            yield Promise.all(this._wkPages().map((wkPage) => wkPage._stopVideo()));
            yield this._browser.close();
          } else {
            yield this._browser._browserSession.send("Playwright.deleteContext", {
              browserContextId: this._browserContextId
            });
            this._browser._contexts.delete(this._browserContextId);
          }
        });
      }
      cancelDownload(uuid) {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.cancelDownload", {
            uuid
          });
        });
      }
      _validateEmulatedViewport(viewportSize) {
        if (!viewportSize)
          return;
        if (process.platform === "win32" && this._browser.options.headful && (viewportSize.width < 250 || viewportSize.height < 240))
          throw new Error(`WebKit on Windows has a minimal viewport of 250x240.`);
      }
    };
    exports2.WKBrowserContext = WKBrowserContext;
  }
});

// node_modules/playwright-core/lib/server/webkit/webkit.js
var require_webkit = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/webkit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebKit = void 0;
    var _wkBrowser = require_wkBrowser();
    var _path = _interopRequireDefault(require("path"));
    var _wkConnection = require_wkConnection();
    var _browserType = require_browserType();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebKit = class extends _browserType.BrowserType {
      constructor(parent) {
        super(parent, "webkit");
      }
      _connectToTransport(transport, options) {
        return _wkBrowser.WKBrowser.connect(this.attribution.playwright, transport, options);
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return __spreadProps(__spreadValues({}, env), {
          CURL_COOKIE_JAR_PATH: _path.default.join(userDataDir, "cookiejar.db")
        });
      }
      _rewriteStartupError(error) {
        if (error.message.includes("cannot open display"))
          return (0, _stackTrace.rewriteErrorMessage)(error, "\n" + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
        return error;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        transport.send({
          method: "Playwright.close",
          params: {},
          id: _wkConnection.kBrowserCloseMessageId
        });
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const {
          args = [],
          proxy,
          headless
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const webkitArguments = ["--inspector-pipe"];
        if (process.platform === "win32")
          webkitArguments.push("--disable-accelerated-compositing");
        if (headless)
          webkitArguments.push("--headless");
        if (isPersistent)
          webkitArguments.push(`--user-data-dir=${userDataDir}`);
        else
          webkitArguments.push(`--no-startup-window`);
        if (proxy) {
          if (process.platform === "darwin") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
          } else if (process.platform === "linux") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
          } else if (process.platform === "win32") {
            webkitArguments.push(`--curl-proxy=${proxy.server.replace(/^socks5:\/\//, "socks5h://")}`);
            if (proxy.bypass)
              webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
          }
        }
        webkitArguments.push(...args);
        if (isPersistent)
          webkitArguments.push("about:blank");
        return webkitArguments;
      }
    };
    exports2.WebKit = WebKit;
  }
});

// node_modules/playwright-core/lib/server/debugController.js
var require_debugController = __commonJS({
  "node_modules/playwright-core/lib/server/debugController.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DebugController = void 0;
    var _processLauncher = require_processLauncher();
    var _instrumentation = require_instrumentation();
    var _recorder = require_recorder();
    var _recorderApp = require_recorderApp();
    var _locatorGenerators = require_locatorGenerators();
    var internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
    var DebugController = class extends _instrumentation.SdkObject {
      constructor(playwright) {
        super({
          attribution: {
            isInternalPlaywright: true
          },
          instrumentation: (0, _instrumentation.createInstrumentation)()
        }, void 0, "DebugController");
        this._autoCloseTimer = void 0;
        this._autoCloseAllowed = false;
        this._trackHierarchyListener = void 0;
        this._playwright = void 0;
        this._sdkLanguage = "javascript";
        this._codegenId = "playwright-test";
        this._playwright = playwright;
      }
      initialize(codegenId, sdkLanguage) {
        this._codegenId = codegenId;
        this._sdkLanguage = sdkLanguage;
        _recorder.Recorder.setAppFactory(() => __async(this, null, function* () {
          return new InspectingRecorderApp(this);
        }));
      }
      setAutoCloseAllowed(allowed) {
        this._autoCloseAllowed = allowed;
      }
      dispose() {
        this.setReportStateChanged(false);
        this.setAutoCloseAllowed(false);
        _recorder.Recorder.setAppFactory(void 0);
      }
      setReportStateChanged(enabled) {
        if (enabled && !this._trackHierarchyListener) {
          this._trackHierarchyListener = {
            onPageOpen: () => this._emitSnapshot(),
            onPageClose: () => this._emitSnapshot()
          };
          this._playwright.instrumentation.addListener(this._trackHierarchyListener, null);
        } else if (!enabled && this._trackHierarchyListener) {
          this._playwright.instrumentation.removeListener(this._trackHierarchyListener);
          this._trackHierarchyListener = void 0;
        }
      }
      resetForReuse() {
        return __async(this, null, function* () {
          const contexts = /* @__PURE__ */ new Set();
          for (const page of this._playwright.allPages())
            contexts.add(page.context());
          for (const context of contexts)
            yield context.resetForReuse(internalMetadata, null);
        });
      }
      navigate(url) {
        return __async(this, null, function* () {
          for (const p of this._playwright.allPages())
            yield p.mainFrame().goto(internalMetadata, url);
        });
      }
      setRecorderMode(params) {
        return __async(this, null, function* () {
          yield this._closeBrowsersWithoutPages();
          if (params.mode === "none") {
            for (const recorder of yield this._allRecorders()) {
              recorder.hideHighlightedSelecor();
              recorder.setMode("none");
            }
            this.setAutoCloseEnabled(true);
            return;
          }
          if (!this._playwright.allBrowsers().length)
            yield this._playwright.chromium.launch(internalMetadata, {
              headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS
            });
          const pages = this._playwright.allPages();
          if (!pages.length) {
            const [browser] = this._playwright.allBrowsers();
            const {
              context
            } = yield browser.newContextForReuse({}, internalMetadata);
            yield context.newPage(internalMetadata);
          }
          if (params.testIdAttributeName) {
            for (const page of this._playwright.allPages())
              page.context().selectors().setTestIdAttributeName(params.testIdAttributeName);
          }
          for (const recorder of yield this._allRecorders()) {
            recorder.hideHighlightedSelecor();
            if (params.mode === "recording")
              recorder.setOutput(this._codegenId, params.file);
            recorder.setMode(params.mode);
          }
          this.setAutoCloseEnabled(true);
        });
      }
      setAutoCloseEnabled(enabled) {
        return __async(this, null, function* () {
          if (!this._autoCloseAllowed)
            return;
          if (this._autoCloseTimer)
            clearTimeout(this._autoCloseTimer);
          if (!enabled)
            return;
          const heartBeat = () => {
            if (!this._playwright.allPages().length)
              selfDestruct();
            else
              this._autoCloseTimer = setTimeout(heartBeat, 5e3);
          };
          this._autoCloseTimer = setTimeout(heartBeat, 3e4);
        });
      }
      highlight(selector) {
        return __async(this, null, function* () {
          for (const recorder of yield this._allRecorders())
            recorder.setHighlightedSelector(this._sdkLanguage, selector);
        });
      }
      hideHighlight() {
        return __async(this, null, function* () {
          for (const recorder of yield this._allRecorders())
            recorder.hideHighlightedSelecor();
          yield this._playwright.hideHighlight();
        });
      }
      allBrowsers() {
        return [...this._playwright.allBrowsers()];
      }
      resume() {
        return __async(this, null, function* () {
          for (const recorder of yield this._allRecorders())
            recorder.resume();
        });
      }
      kill() {
        return __async(this, null, function* () {
          selfDestruct();
        });
      }
      closeAllBrowsers() {
        return __async(this, null, function* () {
          yield Promise.all(this.allBrowsers().map((browser) => browser.close()));
        });
      }
      _emitSnapshot() {
        const browsers = [];
        let pageCount = 0;
        for (const browser of this._playwright.allBrowsers()) {
          const b = {
            contexts: []
          };
          browsers.push(b);
          for (const context of browser.contexts()) {
            const c = {
              pages: []
            };
            b.contexts.push(c);
            for (const page of context.pages())
              c.pages.push(page.mainFrame().url());
            pageCount += context.pages().length;
          }
        }
        this.emit(DebugController.Events.BrowsersChanged, browsers);
        this.emit(DebugController.Events.StateChanged, {
          pageCount
        });
      }
      _allRecorders() {
        return __async(this, null, function* () {
          const contexts = /* @__PURE__ */ new Set();
          for (const page of this._playwright.allPages())
            contexts.add(page.context());
          const result = yield Promise.all([...contexts].map((c) => _recorder.Recorder.show(c, {
            omitCallTracking: true
          })));
          return result.filter(Boolean);
        });
      }
      _closeBrowsersWithoutPages() {
        return __async(this, null, function* () {
          for (const browser of this._playwright.allBrowsers()) {
            for (const context of browser.contexts()) {
              if (!context.pages().length)
                yield context.close((0, _instrumentation.serverSideCallMetadata)());
            }
            if (!browser.contexts())
              yield browser.close();
          }
        });
      }
    };
    exports2.DebugController = DebugController;
    DebugController.Events = {
      BrowsersChanged: "browsersChanged",
      StateChanged: "stateChanged",
      InspectRequested: "inspectRequested",
      SourceChanged: "sourceChanged",
      Paused: "paused"
    };
    function selfDestruct() {
      setTimeout(() => process.exit(0), 3e4);
      (0, _processLauncher.gracefullyCloseAll)().then(() => {
        process.exit(0);
      });
    }
    var InspectingRecorderApp = class extends _recorderApp.EmptyRecorderApp {
      constructor(debugController) {
        super();
        this._debugController = void 0;
        this._debugController = debugController;
      }
      setSelector(selector) {
        return __async(this, null, function* () {
          const locator = (0, _locatorGenerators.asLocator)(this._debugController._sdkLanguage, selector);
          this._debugController.emit(DebugController.Events.InspectRequested, {
            selector,
            locator
          });
        });
      }
      setSources(sources) {
        return __async(this, null, function* () {
          const source = sources.find((s) => s.id === this._debugController._codegenId);
          const {
            text,
            header,
            footer,
            actions
          } = source || {
            text: ""
          };
          this._debugController.emit(DebugController.Events.SourceChanged, {
            text,
            header,
            footer,
            actions
          });
        });
      }
      setPaused(paused) {
        return __async(this, null, function* () {
          this._debugController.emit(DebugController.Events.Paused, {
            paused
          });
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/server/playwright.js
var require_playwright = __commonJS({
  "node_modules/playwright-core/lib/server/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Playwright = void 0;
    exports2.createPlaywright = createPlaywright;
    var _android = require_android();
    var _backendAdb = require_backendAdb();
    var _chromium = require_chromium();
    var _electron = require_electron2();
    var _firefox = require_firefox();
    var _selectors = require_selectors();
    var _webkit = require_webkit();
    var _instrumentation = require_instrumentation();
    var _debugLogger = require_debugLogger();
    var _debugController = require_debugController();
    var Playwright = class extends _instrumentation.SdkObject {
      constructor(options) {
        super({
          attribution: {},
          instrumentation: (0, _instrumentation.createInstrumentation)()
        }, void 0, "Playwright");
        this.selectors = void 0;
        this.chromium = void 0;
        this.android = void 0;
        this.electron = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.options = void 0;
        this.debugController = void 0;
        this._allPages = /* @__PURE__ */ new Set();
        this._allBrowsers = /* @__PURE__ */ new Set();
        this.options = options;
        this.attribution.playwright = this;
        this.instrumentation.addListener({
          onBrowserOpen: (browser) => this._allBrowsers.add(browser),
          onBrowserClose: (browser) => this._allBrowsers.delete(browser),
          onPageOpen: (page) => this._allPages.add(page),
          onPageClose: (page) => this._allPages.delete(page),
          onCallLog: (sdkObject, metadata, logName, message) => {
            _debugLogger.debugLogger.log(logName, message);
          }
        }, null);
        this.chromium = new _chromium.Chromium(this);
        this.firefox = new _firefox.Firefox(this);
        this.webkit = new _webkit.WebKit(this);
        this.electron = new _electron.Electron(this);
        this.android = new _android.Android(this, new _backendAdb.AdbBackend());
        this.selectors = new _selectors.Selectors();
        this.debugController = new _debugController.DebugController(this);
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield Promise.all([...this._allPages].map((p) => p.hideHighlight().catch(() => {
          })));
        });
      }
      allBrowsers() {
        return [...this._allBrowsers];
      }
      allPages() {
        return [...this._allPages];
      }
    };
    exports2.Playwright = Playwright;
    function createPlaywright(options) {
      return new Playwright(options);
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/recorderApp.js
var require_recorderApp = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/recorderApp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RecorderApp = exports2.EmptyRecorderApp = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _progress = require_progress();
    var _events = require("events");
    var _instrumentation = require_instrumentation();
    var _utils = require_utils();
    var _utilsBundle = require_utilsBundle();
    var _crApp = require_crApp();
    var _registry = require_registry();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EmptyRecorderApp = class extends _events.EventEmitter {
      close() {
        return __async(this, null, function* () {
        });
      }
      setPaused(paused) {
        return __async(this, null, function* () {
        });
      }
      setMode(mode) {
        return __async(this, null, function* () {
        });
      }
      setFileIfNeeded(file) {
        return __async(this, null, function* () {
        });
      }
      setSelector(selector, focus) {
        return __async(this, null, function* () {
        });
      }
      updateCallLogs(callLogs) {
        return __async(this, null, function* () {
        });
      }
      setSources(sources) {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.EmptyRecorderApp = EmptyRecorderApp;
    var RecorderApp = class extends _events.EventEmitter {
      constructor(recorder, page, wsEndpoint) {
        super();
        this._page = void 0;
        this.wsEndpoint = void 0;
        this._recorder = void 0;
        this.setMaxListeners(0);
        this._recorder = recorder;
        this._page = page;
        this.wsEndpoint = wsEndpoint;
      }
      close() {
        return __async(this, null, function* () {
          yield this._page.context().close((0, _instrumentation.serverSideCallMetadata)());
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield (0, _crApp.installAppIcon)(this._page);
          yield (0, _crApp.syncLocalStorageWithSettings)(this._page, "recorder");
          yield this._page._setServerRequestInterceptor((route) => {
            if (!route.request().url().startsWith("https://playwright/"))
              return false;
            const uri = route.request().url().substring("https://playwright/".length);
            const file = require.resolve("../../webpack/recorder/" + uri);
            _fs.default.promises.readFile(file).then((buffer) => {
              route.fulfill({
                requestUrl: route.request().url(),
                status: 200,
                headers: [{
                  name: "Content-Type",
                  value: _utilsBundle.mime.getType(_path.default.extname(file)) || "application/octet-stream"
                }],
                body: buffer.toString("base64"),
                isBase64: true
              });
            });
            return true;
          });
          yield this._page.exposeBinding("dispatch", false, (_, data) => this.emit("event", data));
          this._page.once("close", () => {
            this.emit("close");
            this._page.context().close((0, _instrumentation.serverSideCallMetadata)()).catch(() => {
            });
          });
          const mainFrame = this._page.mainFrame();
          yield mainFrame.goto((0, _instrumentation.serverSideCallMetadata)(), "https://playwright/index.html");
        });
      }
      static open(recorder, inspectedContext, handleSIGINT) {
        return __async(this, null, function* () {
          const sdkLanguage = inspectedContext.attribution.playwright.options.sdkLanguage;
          const headed = !!inspectedContext._browser.options.headful;
          const recorderPlaywright = require_playwright().createPlaywright({
            sdkLanguage: "javascript",
            isInternalPlaywright: true
          });
          const args = ["--app=data:text/html,", "--window-size=600,600", "--window-position=1020,10", "--test-type="];
          if (process.env.PWTEST_RECORDER_PORT)
            args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
          const context = yield recorderPlaywright.chromium.launchPersistentContext((0, _instrumentation.serverSideCallMetadata)(), "", {
            channel: (0, _registry.findChromiumChannel)(sdkLanguage),
            args,
            noDefaultViewport: true,
            ignoreDefaultArgs: ["--enable-automation"],
            colorScheme: "no-override",
            headless: !!process.env.PWTEST_CLI_HEADLESS || (0, _utils.isUnderTest)() && !headed,
            useWebSocket: !!process.env.PWTEST_RECORDER_PORT,
            handleSIGINT
          });
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), context._browser);
          yield controller.run((progress2) => __async(this, null, function* () {
            yield context._browser._defaultContext._loadDefaultContextAsIs(progress2);
          }));
          const [page] = context.pages();
          const result = new RecorderApp(recorder, page, context._browser.options.wsEndpoint);
          yield result._init();
          return result;
        });
      }
      setMode(mode) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((mode2) => {
            window.playwrightSetMode(mode2);
          }).toString(), {
            isFunction: true
          }, mode).catch(() => {
          });
        });
      }
      setFileIfNeeded(file) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((file2) => {
            window.playwrightSetFileIfNeeded(file2);
          }).toString(), {
            isFunction: true
          }, file).catch(() => {
          });
        });
      }
      setPaused(paused) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((paused2) => {
            window.playwrightSetPaused(paused2);
          }).toString(), {
            isFunction: true
          }, paused).catch(() => {
          });
        });
      }
      setSources(sources) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((sources2) => {
            window.playwrightSetSources(sources2);
          }).toString(), {
            isFunction: true
          }, sources).catch(() => {
          });
          if (process.env.PWTEST_CLI_IS_UNDER_TEST && sources.length)
            process._didSetSourcesForTest(sources[0].text);
        });
      }
      setSelector(selector, focus) {
        return __async(this, null, function* () {
          if (focus) {
            this._recorder.setMode("none");
            this._page.bringToFront();
          }
          yield this._page.mainFrame().evaluateExpression(((arg) => {
            window.playwrightSetSelector(arg.selector, arg.focus);
          }).toString(), {
            isFunction: true
          }, {
            selector,
            focus
          }).catch(() => {
          });
        });
      }
      updateCallLogs(callLogs) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((callLogs2) => {
            window.playwrightUpdateLogs(callLogs2);
          }).toString(), {
            isFunction: true
          }, callLogs).catch(() => {
          });
        });
      }
    };
    exports2.RecorderApp = RecorderApp;
  }
});

// node_modules/playwright-core/lib/server/recorder/recorderUtils.js
var require_recorderUtils = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/recorderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.metadataToCallLog = metadataToCallLog;
    function metadataToCallLog(metadata, status) {
      var _metadata$params, _metadata$params2, _metadata$error, _metadata$error$error;
      let title = metadata.apiName || metadata.method;
      if (metadata.method === "waitForEventInfo")
        title += `(${metadata.params.info.event})`;
      title = title.replace("object.expect", "expect");
      if (metadata.error)
        status = "error";
      const params = {
        url: (_metadata$params = metadata.params) === null || _metadata$params === void 0 ? void 0 : _metadata$params.url,
        selector: (_metadata$params2 = metadata.params) === null || _metadata$params2 === void 0 ? void 0 : _metadata$params2.selector
      };
      let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
      if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
        duration -= metadata.pauseEndTime - metadata.pauseStartTime;
        duration = Math.max(duration, 0);
      }
      const callLog = {
        id: metadata.id,
        messages: metadata.log,
        title,
        status,
        error: (_metadata$error = metadata.error) === null || _metadata$error === void 0 ? void 0 : (_metadata$error$error = _metadata$error.error) === null || _metadata$error$error === void 0 ? void 0 : _metadata$error$error.message,
        params,
        duration
      };
      return callLog;
    }
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/locatorParser.js
var require_locatorParser = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/locatorParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.locatorOrSelectorAsSelector = locatorOrSelectorAsSelector;
    var _stringUtils = require_stringUtils();
    var _locatorGenerators = require_locatorGenerators();
    var _selectorParser = require_selectorParser();
    function parseLocator(locator, testIdAttributeName) {
      locator = locator.replace(/AriaRole\s*\.\s*([\w]+)/g, (_, group) => group.toLowerCase()).replace(/(get_by_role|getByRole)\s*\(\s*(?:["'`])([^'"`]+)['"`]/g, (_, group1, group2) => `${group1}(${group2.toLowerCase()}`);
      const params = [];
      let template = "";
      for (let i = 0; i < locator.length; ++i) {
        const quote = locator[i];
        if (quote !== '"' && quote !== "'" && quote !== "`" && quote !== "/") {
          template += quote;
          continue;
        }
        const isRegexEscaping = locator[i - 1] === "r" || locator[i] === "/";
        ++i;
        let text = "";
        while (i < locator.length) {
          if (locator[i] === "\\") {
            if (isRegexEscaping) {
              if (locator[i + 1] !== quote)
                text += locator[i];
              ++i;
              text += locator[i];
            } else {
              ++i;
              if (locator[i] === "n")
                text += "\n";
              else if (locator[i] === "r")
                text += "\r";
              else if (locator[i] === "t")
                text += "	";
              else
                text += locator[i];
            }
            ++i;
            continue;
          }
          if (locator[i] !== quote) {
            text += locator[i++];
            continue;
          }
          break;
        }
        params.push({
          quote,
          text
        });
        template += (quote === "/" ? "r" : "") + "$" + params.length;
      }
      template = template.toLowerCase().replace(/get_by_alt_text/g, "getbyalttext").replace(/get_by_test_id/g, "getbytestid").replace(/get_by_([\w]+)/g, "getby$1").replace(/has_not_text/g, "hasnottext").replace(/has_text/g, "hastext").replace(/has_not/g, "hasnot").replace(/frame_locator/g, "framelocator").replace(/[{}\s]/g, "").replace(/new\(\)/g, "").replace(/new[\w]+\.[\w]+options\(\)/g, "").replace(/\.set/g, ",set").replace(/\.or_\(/g, "or(").replace(/\.and_\(/g, "and(").replace(/:/g, "=").replace(/,re\.ignorecase/g, "i").replace(/,pattern.case_insensitive/g, "i").replace(/,regexoptions.ignorecase/g, "i").replace(/re.compile\(([^)]+)\)/g, "$1").replace(/pattern.compile\(([^)]+)\)/g, "r$1").replace(/newregex\(([^)]+)\)/g, "r$1").replace(/string=/g, "=").replace(/regex=/g, "=").replace(/,,/g, ",");
      return transform(template, params, testIdAttributeName);
    }
    function countParams(template) {
      return [...template.matchAll(/\$\d+/g)].length;
    }
    function shiftParams(template, sub) {
      return template.replace(/\$(\d+)/g, (_, ordinal) => `$${ordinal - sub}`);
    }
    function transform(template, params, testIdAttributeName) {
      while (true) {
        const hasMatch = template.match(/filter\(,?(has=|hasnot=|sethas\(|sethasnot\()/);
        if (!hasMatch)
          break;
        const start = hasMatch.index + hasMatch[0].length;
        let balance = 0;
        let end = start;
        for (; end < template.length; end++) {
          if (template[end] === "(")
            balance++;
          else if (template[end] === ")")
            balance--;
          if (balance < 0)
            break;
        }
        let prefix = template.substring(0, start);
        let extraSymbol = 0;
        if (["sethas(", "sethasnot("].includes(hasMatch[1])) {
          extraSymbol = 1;
          prefix = prefix.replace(/sethas\($/, "has=").replace(/sethasnot\($/, "hasnot=");
        }
        const paramsCountBeforeHas = countParams(template.substring(0, start));
        const hasTemplate = shiftParams(template.substring(start, end), paramsCountBeforeHas);
        const paramsCountInHas = countParams(hasTemplate);
        const hasParams = params.slice(paramsCountBeforeHas, paramsCountBeforeHas + paramsCountInHas);
        const hasSelector = JSON.stringify(transform(hasTemplate, hasParams, testIdAttributeName));
        template = prefix.replace(/=$/, "2=") + `$${paramsCountBeforeHas + 1}` + shiftParams(template.substring(end + extraSymbol), paramsCountInHas - 1);
        const paramsBeforeHas = params.slice(0, paramsCountBeforeHas);
        const paramsAfterHas = params.slice(paramsCountBeforeHas + paramsCountInHas);
        params = paramsBeforeHas.concat([{
          quote: '"',
          text: hasSelector
        }]).concat(paramsAfterHas);
      }
      template = template.replace(/\,set([\w]+)\(([^)]+)\)/g, (_, group1, group2) => "," + group1.toLowerCase() + "=" + group2.toLowerCase()).replace(/framelocator\(([^)]+)\)/g, "$1.internal:control=enter-frame").replace(/locator\(([^)]+),hastext=([^),]+)\)/g, "locator($1).internal:has-text=$2").replace(/locator\(([^)]+),hasnottext=([^),]+)\)/g, "locator($1).internal:has-not-text=$2").replace(/locator\(([^)]+),hastext=([^),]+)\)/g, "locator($1).internal:has-text=$2").replace(/locator\(([^)]+)\)/g, "$1").replace(/getbyrole\(([^)]+)\)/g, "internal:role=$1").replace(/getbytext\(([^)]+)\)/g, "internal:text=$1").replace(/getbylabel\(([^)]+)\)/g, "internal:label=$1").replace(/getbytestid\(([^)]+)\)/g, `internal:testid=[${testIdAttributeName}=$1]`).replace(/getby(placeholder|alt|title)(?:text)?\(([^)]+)\)/g, "internal:attr=[$1=$2]").replace(/first(\(\))?/g, "nth=0").replace(/last(\(\))?/g, "nth=-1").replace(/nth\(([^)]+)\)/g, "nth=$1").replace(/filter\(,?hastext=([^)]+)\)/g, "internal:has-text=$1").replace(/filter\(,?hasnottext=([^)]+)\)/g, "internal:has-not-text=$1").replace(/filter\(,?has2=([^)]+)\)/g, "internal:has=$1").replace(/filter\(,?hasnot2=([^)]+)\)/g, "internal:has-not=$1").replace(/,exact=false/g, "").replace(/,exact=true/g, "s").replace(/\,/g, "][");
      const parts = template.split(".");
      for (let index = 0; index < parts.length - 1; index++) {
        if (parts[index] === "internal:control=enter-frame" && parts[index + 1].startsWith("nth=")) {
          const [nth] = parts.splice(index, 1);
          parts.splice(index + 1, 0, nth);
        }
      }
      return parts.map((t) => {
        if (!t.startsWith("internal:") || t === "internal:control")
          return t.replace(/\$(\d+)/g, (_, ordinal) => {
            const param = params[+ordinal - 1];
            return param.text;
          });
        t = t.includes("[") ? t.replace(/\]/, "") + "]" : t;
        t = t.replace(/(?:r)\$(\d+)(i)?/g, (_, ordinal, suffix) => {
          const param = params[+ordinal - 1];
          if (t.startsWith("internal:attr") || t.startsWith("internal:testid") || t.startsWith("internal:role"))
            return new RegExp(param.text) + (suffix || "");
          return (0, _stringUtils.escapeForTextSelector)(new RegExp(param.text, suffix), false);
        }).replace(/\$(\d+)(i|s)?/g, (_, ordinal, suffix) => {
          const param = params[+ordinal - 1];
          if (t.startsWith("internal:has=") || t.startsWith("internal:has-not="))
            return param.text;
          if (t.startsWith("internal:testid"))
            return (0, _stringUtils.escapeForAttributeSelector)(param.text, true);
          if (t.startsWith("internal:attr") || t.startsWith("internal:role"))
            return (0, _stringUtils.escapeForAttributeSelector)(param.text, suffix === "s");
          return (0, _stringUtils.escapeForTextSelector)(param.text, suffix === "s");
        });
        return t;
      }).join(" >> ");
    }
    function locatorOrSelectorAsSelector(language, locator, testIdAttributeName) {
      try {
        (0, _selectorParser.parseSelector)(locator);
        return locator;
      } catch (e) {
      }
      try {
        const selector = parseLocator(locator, testIdAttributeName);
        const locators = (0, _locatorGenerators.asLocators)(language, selector);
        const digest = digestForComparison(locator);
        if (locators.some((candidate) => digestForComparison(candidate) === digest))
          return selector;
      } catch (e) {
      }
      return "";
    }
    function digestForComparison(locator) {
      return locator.replace(/\s/g, "").replace(/["`]/g, "'");
    }
  }
});

// node_modules/playwright-core/lib/server/recorder.js
var require_recorder = __commonJS({
  "node_modules/playwright-core/lib/server/recorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Recorder = void 0;
    var fs = _interopRequireWildcard(require("fs"));
    var _codeGenerator = require_codeGenerator();
    var _utils = require_utils2();
    var _page = require_page();
    var _frames = require_frames();
    var _browserContext = require_browserContext();
    var _java = require_java();
    var _javascript = require_javascript2();
    var _jsonl = require_jsonl();
    var _csharp = require_csharp();
    var _python = require_python();
    var recorderSource = _interopRequireWildcard(require_recorderSource());
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _recorderApp = require_recorderApp();
    var _utils2 = require_utils();
    var _recorderUtils = require_recorderUtils();
    var _debugger = require_debugger();
    var _events = require("events");
    var _timeoutRunner = require_timeoutRunner();
    var _locatorParser = require_locatorParser();
    var _eventsHelper = require_eventsHelper();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var recorderSymbol = Symbol("recorderSymbol");
    var Recorder = class {
      static setAppFactory(recorderAppFactory) {
        Recorder.recorderAppFactory = recorderAppFactory;
      }
      static showInspector(context) {
        Recorder.show(context, {}).catch(() => {
        });
      }
      static show(context, params = {}) {
        let recorderPromise = context[recorderSymbol];
        if (!recorderPromise) {
          const recorder = new Recorder(context, params);
          recorderPromise = recorder.install().then(() => recorder);
          context[recorderSymbol] = recorderPromise;
        }
        return recorderPromise;
      }
      constructor(context, params) {
        this._context = void 0;
        this._mode = void 0;
        this._highlightedSelector = "";
        this._recorderApp = null;
        this._currentCallsMetadata = /* @__PURE__ */ new Map();
        this._recorderSources = [];
        this._userSources = /* @__PURE__ */ new Map();
        this._debugger = void 0;
        this._contextRecorder = void 0;
        this._handleSIGINT = void 0;
        this._omitCallTracking = false;
        this._currentLanguage = void 0;
        this._mode = params.mode || "none";
        this._contextRecorder = new ContextRecorder(context, params);
        this._context = context;
        this._omitCallTracking = !!params.omitCallTracking;
        this._debugger = context.debugger();
        this._handleSIGINT = params.handleSIGINT;
        context.instrumentation.addListener(this, context);
        this._currentLanguage = this._contextRecorder.languageName();
      }
      static defaultRecorderAppFactory(recorder) {
        return __async(this, null, function* () {
          if (process.env.PW_CODEGEN_NO_INSPECTOR)
            return new _recorderApp.EmptyRecorderApp();
          return yield _recorderApp.RecorderApp.open(recorder, recorder._context, recorder._handleSIGINT);
        });
      }
      install() {
        return __async(this, null, function* () {
          const recorderApp = yield (Recorder.recorderAppFactory || Recorder.defaultRecorderAppFactory)(this);
          this._recorderApp = recorderApp;
          recorderApp.once("close", () => {
            this._debugger.resume(false);
            this._recorderApp = null;
          });
          recorderApp.on("event", (data) => {
            if (data.event === "setMode") {
              this.setMode(data.params.mode);
              return;
            }
            if (data.event === "selectorUpdated") {
              this.setHighlightedSelector(data.params.language, data.params.selector);
              return;
            }
            if (data.event === "step") {
              this._debugger.resume(true);
              return;
            }
            if (data.event === "fileChanged") {
              this._currentLanguage = this._contextRecorder.languageName(data.params.file);
              this._refreshOverlay();
              return;
            }
            if (data.event === "resume") {
              this._debugger.resume(false);
              return;
            }
            if (data.event === "pause") {
              this._debugger.pauseOnNextStatement();
              return;
            }
            if (data.event === "clear") {
              this._contextRecorder.clearScript();
              return;
            }
          });
          yield Promise.all([recorderApp.setMode(this._mode), recorderApp.setPaused(this._debugger.isPaused()), this._pushAllSources()]);
          this._context.once(_browserContext.BrowserContext.Events.Close, () => {
            this._contextRecorder.dispose();
            this._context.instrumentation.removeListener(this);
            recorderApp.close().catch(() => {
            });
          });
          this._contextRecorder.on(ContextRecorder.Events.Change, (data) => {
            var _this$_recorderApp;
            this._recorderSources = data.sources;
            this._pushAllSources();
            (_this$_recorderApp = this._recorderApp) === null || _this$_recorderApp === void 0 ? void 0 : _this$_recorderApp.setFileIfNeeded(data.primaryFileName);
          });
          yield this._context.exposeBinding("__pw_recorderState", false, (source) => {
            let actionSelector = "";
            let actionPoint;
            const hasActiveScreenshotCommand = [...this._currentCallsMetadata.keys()].some(isScreenshotCommand);
            if (!hasActiveScreenshotCommand) {
              actionSelector = this._highlightedSelector;
              for (const [metadata, sdkObject] of this._currentCallsMetadata) {
                if (source.page === sdkObject.attribution.page) {
                  actionPoint = metadata.point || actionPoint;
                  actionSelector = actionSelector || metadata.params.selector;
                }
              }
            }
            const uiState = {
              mode: this._mode,
              actionPoint,
              actionSelector,
              language: this._currentLanguage,
              testIdAttributeName: this._contextRecorder.testIdAttributeName()
            };
            return uiState;
          });
          yield this._context.exposeBinding("__pw_recorderSetSelector", false, (_, selector) => __async(this, null, function* () {
            var _this$_recorderApp2;
            yield (_this$_recorderApp2 = this._recorderApp) === null || _this$_recorderApp2 === void 0 ? void 0 : _this$_recorderApp2.setSelector(selector, true);
          }));
          yield this._context.exposeBinding("__pw_resume", false, () => {
            this._debugger.resume(false);
          });
          yield this._context.extendInjectedScript(consoleApiSource.source);
          yield this._contextRecorder.install();
          if (this._debugger.isPaused())
            this._pausedStateChanged();
          this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
          this._context.recorderAppForTest = recorderApp;
        });
      }
      _pausedStateChanged() {
        var _this$_recorderApp3;
        for (const {
          metadata,
          sdkObject
        } of this._debugger.pausedDetails()) {
          if (!this._currentCallsMetadata.has(metadata))
            this.onBeforeCall(sdkObject, metadata);
        }
        (_this$_recorderApp3 = this._recorderApp) === null || _this$_recorderApp3 === void 0 ? void 0 : _this$_recorderApp3.setPaused(this._debugger.isPaused());
        this._updateUserSources();
        this.updateCallLog([...this._currentCallsMetadata.keys()]);
      }
      setMode(mode) {
        var _this$_recorderApp4;
        if (this._mode === mode)
          return;
        this._highlightedSelector = "";
        this._mode = mode;
        (_this$_recorderApp4 = this._recorderApp) === null || _this$_recorderApp4 === void 0 ? void 0 : _this$_recorderApp4.setMode(this._mode);
        this._contextRecorder.setEnabled(this._mode === "recording");
        this._debugger.setMuted(this._mode === "recording");
        if (this._mode !== "none" && this._context.pages().length === 1)
          this._context.pages()[0].bringToFront().catch(() => {
          });
        this._refreshOverlay();
      }
      resume() {
        this._debugger.resume(false);
      }
      setHighlightedSelector(language, selector) {
        this._highlightedSelector = (0, _locatorParser.locatorOrSelectorAsSelector)(language, selector, this._context.selectors().testIdAttributeName());
        this._refreshOverlay();
      }
      hideHighlightedSelecor() {
        this._highlightedSelector = "";
        this._refreshOverlay();
      }
      setOutput(codegenId, outputFile) {
        this._contextRecorder.setOutput(codegenId, outputFile);
      }
      _refreshOverlay() {
        for (const page of this._context.pages())
          page.mainFrame().evaluateExpression("window.__pw_refreshOverlay()").catch(() => {
          });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._omitCallTracking || this._mode === "recording")
            return;
          this._currentCallsMetadata.set(metadata, sdkObject);
          this._updateUserSources();
          this.updateCallLog([metadata]);
          if (isScreenshotCommand(metadata)) {
            this.hideHighlightedSelecor();
          } else if (metadata.params && metadata.params.selector) {
            var _this$_recorderApp5;
            this._highlightedSelector = metadata.params.selector;
            (_this$_recorderApp5 = this._recorderApp) === null || _this$_recorderApp5 === void 0 ? void 0 : _this$_recorderApp5.setSelector(this._highlightedSelector).catch(() => {
            });
          }
        });
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._omitCallTracking || this._mode === "recording")
            return;
          if (!metadata.error)
            this._currentCallsMetadata.delete(metadata);
          this._updateUserSources();
          this.updateCallLog([metadata]);
        });
      }
      _updateUserSources() {
        var _this$_recorderApp6;
        for (const source of this._userSources.values()) {
          source.highlight = [];
          source.revealLine = void 0;
        }
        let fileToSelect = void 0;
        for (const metadata of this._currentCallsMetadata.keys()) {
          if (!metadata.location)
            continue;
          const {
            file,
            line
          } = metadata.location;
          let source = this._userSources.get(file);
          if (!source) {
            source = {
              isRecorded: false,
              label: file,
              id: file,
              text: this._readSource(file),
              highlight: [],
              language: languageForFile(file)
            };
            this._userSources.set(file, source);
          }
          if (line) {
            const paused = this._debugger.isPaused(metadata);
            source.highlight.push({
              line,
              type: metadata.error ? "error" : paused ? "paused" : "running"
            });
            source.revealLine = line;
            fileToSelect = source.id;
          }
        }
        this._pushAllSources();
        if (fileToSelect)
          (_this$_recorderApp6 = this._recorderApp) === null || _this$_recorderApp6 === void 0 ? void 0 : _this$_recorderApp6.setFileIfNeeded(fileToSelect);
      }
      _pushAllSources() {
        var _this$_recorderApp7;
        (_this$_recorderApp7 = this._recorderApp) === null || _this$_recorderApp7 === void 0 ? void 0 : _this$_recorderApp7.setSources([...this._recorderSources, ...this._userSources.values()]);
      }
      onBeforeInputAction(sdkObject, metadata) {
        return __async(this, null, function* () {
        });
      }
      onCallLog(sdkObject, metadata, logName, message) {
        return __async(this, null, function* () {
          this.updateCallLog([metadata]);
        });
      }
      updateCallLog(metadatas) {
        var _this$_recorderApp8;
        if (this._mode === "recording")
          return;
        const logs = [];
        for (const metadata of metadatas) {
          if (!metadata.method || metadata.internal)
            continue;
          let status = "done";
          if (this._currentCallsMetadata.has(metadata))
            status = "in-progress";
          if (this._debugger.isPaused(metadata))
            status = "paused";
          logs.push((0, _recorderUtils.metadataToCallLog)(metadata, status));
        }
        (_this$_recorderApp8 = this._recorderApp) === null || _this$_recorderApp8 === void 0 ? void 0 : _this$_recorderApp8.updateCallLogs(logs);
      }
      _readSource(fileName) {
        try {
          return fs.readFileSync(fileName, "utf-8");
        } catch (e) {
          return "// No source available";
        }
      }
    };
    exports2.Recorder = Recorder;
    Recorder.recorderAppFactory = void 0;
    var ContextRecorder = class extends _events.EventEmitter {
      constructor(context, params) {
        super();
        this._generator = void 0;
        this._pageAliases = /* @__PURE__ */ new Map();
        this._lastPopupOrdinal = 0;
        this._lastDialogOrdinal = -1;
        this._lastDownloadOrdinal = -1;
        this._timers = /* @__PURE__ */ new Set();
        this._context = void 0;
        this._params = void 0;
        this._recorderSources = void 0;
        this._throttledOutputFile = null;
        this._orderedLanguages = [];
        this._listeners = [];
        this._context = context;
        this._params = params;
        this._recorderSources = [];
        const language = params.language || context.attribution.playwright.options.sdkLanguage;
        this.setOutput(language, params.outputFile);
        const generator = new _codeGenerator.CodeGenerator(context._browser.options.name, params.mode === "recording", params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
        generator.on("change", () => {
          this._recorderSources = [];
          for (const languageGenerator of this._orderedLanguages) {
            var _this$_throttledOutpu;
            const {
              header,
              footer,
              actions,
              text
            } = generator.generateStructure(languageGenerator);
            const source = {
              isRecorded: true,
              label: languageGenerator.name,
              group: languageGenerator.groupName,
              id: languageGenerator.id,
              text,
              header,
              footer,
              actions,
              language: languageGenerator.highlighter,
              highlight: []
            };
            source.revealLine = text.split("\n").length - 1;
            this._recorderSources.push(source);
            if (languageGenerator === this._orderedLanguages[0])
              (_this$_throttledOutpu = this._throttledOutputFile) === null || _this$_throttledOutpu === void 0 ? void 0 : _this$_throttledOutpu.setContent(source.text);
          }
          this.emit(ContextRecorder.Events.Change, {
            sources: this._recorderSources,
            primaryFileName: this._orderedLanguages[0].id
          });
        });
        context.on(_browserContext.BrowserContext.Events.BeforeClose, () => {
          var _this$_throttledOutpu2;
          (_this$_throttledOutpu2 = this._throttledOutputFile) === null || _this$_throttledOutpu2 === void 0 ? void 0 : _this$_throttledOutpu2.flush();
        });
        this._listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "exit", () => {
          var _this$_throttledOutpu3;
          (_this$_throttledOutpu3 = this._throttledOutputFile) === null || _this$_throttledOutpu3 === void 0 ? void 0 : _this$_throttledOutpu3.flush();
        }));
        this._generator = generator;
      }
      setOutput(codegenId, outputFile) {
        var _this$_generator;
        const languages = /* @__PURE__ */ new Set([new _java.JavaLanguageGenerator(), new _javascript.JavaScriptLanguageGenerator(false), new _javascript.JavaScriptLanguageGenerator(true), new _python.PythonLanguageGenerator(false, true), new _python.PythonLanguageGenerator(false, false), new _python.PythonLanguageGenerator(true, false), new _csharp.CSharpLanguageGenerator("mstest"), new _csharp.CSharpLanguageGenerator("nunit"), new _csharp.CSharpLanguageGenerator("library"), new _jsonl.JsonlLanguageGenerator()]);
        const primaryLanguage = [...languages].find((l) => l.id === codegenId);
        if (!primaryLanguage)
          throw new Error(`
===============================
Unsupported language: '${codegenId}'
===============================
`);
        languages.delete(primaryLanguage);
        this._orderedLanguages = [primaryLanguage, ...languages];
        this._throttledOutputFile = outputFile ? new ThrottledFile(outputFile) : null;
        (_this$_generator = this._generator) === null || _this$_generator === void 0 ? void 0 : _this$_generator.restart();
      }
      languageName(id) {
        for (const lang of this._orderedLanguages) {
          if (!id || lang.id === id)
            return lang.highlighter;
        }
        return "javascript";
      }
      install() {
        return __async(this, null, function* () {
          this._context.on(_browserContext.BrowserContext.Events.Page, (page) => this._onPage(page));
          for (const page of this._context.pages())
            this._onPage(page);
          this._context.on(_browserContext.BrowserContext.Events.Dialog, (dialog) => this._onDialog(dialog.page()));
          yield this._context.exposeBinding("__pw_recorderPerformAction", false, (source, action) => this._performAction(source.frame, action));
          yield this._context.exposeBinding("__pw_recorderRecordAction", false, (source, action) => this._recordAction(source.frame, action));
          yield this._context.extendInjectedScript(recorderSource.source);
        });
      }
      setEnabled(enabled) {
        this._generator.setEnabled(enabled);
      }
      dispose() {
        for (const timer of this._timers)
          clearTimeout(timer);
        this._timers.clear();
        _eventsHelper.eventsHelper.removeEventListeners(this._listeners);
      }
      _onPage(page) {
        return __async(this, null, function* () {
          const frame = page.mainFrame();
          page.on("close", () => {
            this._generator.addAction({
              frame: this._describeMainFrame(page),
              committed: true,
              action: {
                name: "closePage",
                signals: []
              }
            });
            this._pageAliases.delete(page);
          });
          frame.on(_frames.Frame.Events.InternalNavigation, (event) => {
            if (event.isPublic)
              this._onFrameNavigated(frame, page);
          });
          page.on(_page.Page.Events.Download, () => this._onDownload(page));
          const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
          const pageAlias = "page" + suffix;
          this._pageAliases.set(page, pageAlias);
          if (page.opener()) {
            this._onPopup(page.opener(), page);
          } else {
            this._generator.addAction({
              frame: this._describeMainFrame(page),
              committed: true,
              action: {
                name: "openPage",
                url: page.mainFrame().url(),
                signals: []
              }
            });
          }
        });
      }
      clearScript() {
        this._generator.restart();
        if (this._params.mode === "recording") {
          for (const page of this._context.pages())
            this._onFrameNavigated(page.mainFrame(), page);
        }
      }
      _describeMainFrame(page) {
        return {
          pageAlias: this._pageAliases.get(page),
          isMainFrame: true,
          url: page.mainFrame().url()
        };
      }
      _describeFrame(frame) {
        return __async(this, null, function* () {
          const page = frame._page;
          const pageAlias = this._pageAliases.get(page);
          const chain = [];
          for (let ancestor = frame; ancestor; ancestor = ancestor.parentFrame())
            chain.push(ancestor);
          chain.reverse();
          if (chain.length === 1)
            return this._describeMainFrame(page);
          const hasUniqueName = page.frames().filter((f) => f.name() === frame.name()).length === 1;
          const fallback = {
            pageAlias,
            isMainFrame: false,
            url: frame.url(),
            name: frame.name() && hasUniqueName ? frame.name() : void 0
          };
          if (chain.length > 3)
            return fallback;
          const selectorPromises = [];
          for (let i = 0; i < chain.length - 1; i++)
            selectorPromises.push(this._findFrameSelector(chain[i + 1], chain[i]));
          const result = yield (0, _timeoutRunner.raceAgainstTimeout)(() => Promise.all(selectorPromises), 2e3);
          if (!result.timedOut && result.result.every((selector) => !!selector)) {
            return __spreadProps(__spreadValues({}, fallback), {
              selectorsChain: result.result
            });
          }
          return fallback;
        });
      }
      testIdAttributeName() {
        return this._params.testIdAttributeName || this._context.selectors().testIdAttributeName() || "data-testid";
      }
      _findFrameSelector(frame, parent) {
        return __async(this, null, function* () {
          try {
            const frameElement = yield frame.frameElement();
            if (!frameElement)
              return;
            const utility = yield parent._utilityContext();
            const injected = yield utility.injectedScript();
            const selector = yield injected.evaluate((injected2, element) => {
              return injected2.generateSelector(element, {
                testIdAttributeName: "",
                omitInternalEngines: true
              });
            }, frameElement);
            return selector;
          } catch (e) {
          }
        });
      }
      _performAction(frame, action) {
        return __async(this, null, function* () {
          this._generator.commitLastAction();
          const frameDescription = yield this._describeFrame(frame);
          const actionInContext = {
            frame: frameDescription,
            action
          };
          const perform = (action2, params, cb) => __async(this, null, function* () {
            const callMetadata = {
              id: `call@${(0, _utils2.createGuid)()}`,
              apiName: "frame." + action2,
              objectId: frame.guid,
              pageId: frame._page.guid,
              frameId: frame.guid,
              startTime: (0, _utils2.monotonicTime)(),
              endTime: 0,
              wallTime: Date.now(),
              type: "Frame",
              method: action2,
              params,
              log: []
            };
            this._generator.willPerformAction(actionInContext);
            try {
              yield frame.instrumentation.onBeforeCall(frame, callMetadata);
              yield cb(callMetadata);
            } catch (e) {
              callMetadata.endTime = (0, _utils2.monotonicTime)();
              yield frame.instrumentation.onAfterCall(frame, callMetadata);
              this._generator.performedActionFailed(actionInContext);
              return;
            }
            callMetadata.endTime = (0, _utils2.monotonicTime)();
            yield frame.instrumentation.onAfterCall(frame, callMetadata);
            const timer = setTimeout(() => {
              actionInContext.committed = true;
              this._timers.delete(timer);
            }, 5e3);
            this._generator.didPerformAction(actionInContext);
            this._timers.add(timer);
          });
          const kActionTimeout = 5e3;
          if (action.name === "click") {
            const {
              options
            } = (0, _utils.toClickOptions)(action);
            yield perform("click", {
              selector: action.selector
            }, (callMetadata) => frame.click(callMetadata, action.selector, __spreadProps(__spreadValues({}, options), {
              timeout: kActionTimeout,
              strict: true
            })));
          }
          if (action.name === "press") {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            yield perform("press", {
              selector: action.selector,
              key: shortcut
            }, (callMetadata) => frame.press(callMetadata, action.selector, shortcut, {
              timeout: kActionTimeout,
              strict: true
            }));
          }
          if (action.name === "check")
            yield perform("check", {
              selector: action.selector
            }, (callMetadata) => frame.check(callMetadata, action.selector, {
              timeout: kActionTimeout,
              strict: true
            }));
          if (action.name === "uncheck")
            yield perform("uncheck", {
              selector: action.selector
            }, (callMetadata) => frame.uncheck(callMetadata, action.selector, {
              timeout: kActionTimeout,
              strict: true
            }));
          if (action.name === "select") {
            const values = action.options.map((value) => ({
              value
            }));
            yield perform("selectOption", {
              selector: action.selector,
              values
            }, (callMetadata) => frame.selectOption(callMetadata, action.selector, [], values, {
              timeout: kActionTimeout,
              strict: true
            }));
          }
        });
      }
      _recordAction(frame, action) {
        return __async(this, null, function* () {
          this._generator.commitLastAction();
          const frameDescription = yield this._describeFrame(frame);
          const actionInContext = {
            frame: frameDescription,
            action
          };
          this._generator.addAction(actionInContext);
        });
      }
      _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, {
          name: "navigation",
          url: frame.url()
        });
      }
      _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "popup",
          popupAlias
        });
      }
      _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        ++this._lastDownloadOrdinal;
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "download",
          downloadAlias: this._lastDownloadOrdinal ? String(this._lastDownloadOrdinal) : ""
        });
      }
      _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        ++this._lastDialogOrdinal;
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "dialog",
          dialogAlias: this._lastDialogOrdinal ? String(this._lastDialogOrdinal) : ""
        });
      }
    };
    ContextRecorder.Events = {
      Change: "change"
    };
    function languageForFile(file) {
      if (file.endsWith(".py"))
        return "python";
      if (file.endsWith(".java"))
        return "java";
      if (file.endsWith(".cs"))
        return "csharp";
      return "javascript";
    }
    var ThrottledFile = class {
      constructor(file) {
        this._file = void 0;
        this._timer = void 0;
        this._text = void 0;
        this._file = file;
      }
      setContent(text) {
        this._text = text;
        if (!this._timer)
          this._timer = setTimeout(() => this.flush(), 250);
      }
      flush() {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
        if (this._text)
          fs.writeFileSync(this._file, this._text);
        this._text = void 0;
      }
    };
    function isScreenshotCommand(metadata) {
      return metadata.method.toLowerCase().includes("screenshot");
    }
  }
});

// node_modules/playwright-core/lib/server/browserContext.js
var require_browserContext = __commonJS({
  "node_modules/playwright-core/lib/server/browserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContext = void 0;
    exports2.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
    exports2.normalizeProxySettings = normalizeProxySettings;
    exports2.validateBrowserContextOptions = validateBrowserContextOptions;
    exports2.verifyGeolocation = verifyGeolocation;
    var os = _interopRequireWildcard(require("os"));
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network2());
    var _page6 = require_page();
    var _path = _interopRequireDefault(require("path"));
    var _fs = _interopRequireDefault(require("fs"));
    var _instrumentation = require_instrumentation();
    var _debugger = require_debugger();
    var _tracing = require_tracing();
    var _harRecorder = require_harRecorder();
    var _recorder = require_recorder();
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _fetch = require_fetch();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _instrumentation.SdkObject {
      constructor(browser, options, browserContextId) {
        super(browser, "browser-context");
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._pageBindings = /* @__PURE__ */ new Map();
        this._activeProgressControllers = /* @__PURE__ */ new Set();
        this._options = void 0;
        this._requestInterceptor = void 0;
        this._isPersistentContext = void 0;
        this._closedStatus = "open";
        this._closePromise = void 0;
        this._closePromiseFulfill = void 0;
        this._permissions = /* @__PURE__ */ new Map();
        this._downloads = /* @__PURE__ */ new Set();
        this._browser = void 0;
        this._browserContextId = void 0;
        this._selectors = void 0;
        this._origins = /* @__PURE__ */ new Set();
        this._harRecorders = /* @__PURE__ */ new Map();
        this.tracing = void 0;
        this.fetchRequest = void 0;
        this._customCloseHandler = void 0;
        this._tempDirs = [];
        this._settingStorageState = false;
        this.initScripts = [];
        this._routesInFlight = /* @__PURE__ */ new Set();
        this._debugger = void 0;
        this.attribution.context = this;
        this._browser = browser;
        this._options = options;
        this._browserContextId = browserContextId;
        this._isPersistentContext = !browserContextId;
        this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
        this.fetchRequest = new _fetch.BrowserContextAPIRequestContext(this);
        if (this._options.recordHar)
          this._harRecorders.set("", new _harRecorder.HarRecorder(this, null, this._options.recordHar));
        this.tracing = new _tracing.Tracing(this, browser.options.tracesDir);
      }
      isPersistentContext() {
        return this._isPersistentContext;
      }
      setSelectors(selectors) {
        this._selectors = selectors;
      }
      selectors() {
        return this._selectors || this.attribution.playwright.selectors;
      }
      _initialize() {
        return __async(this, null, function* () {
          if (this.attribution.playwright.options.isInternalPlaywright)
            return;
          this._debugger = new _debugger.Debugger(this);
          if ((0, _utils.debugMode)() === "inspector")
            yield _recorder.Recorder.show(this, {
              pauseOnNextStatement: true
            });
          if (this._debugger.isPaused())
            _recorder.Recorder.showInspector(this);
          this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => {
            _recorder.Recorder.showInspector(this);
          });
          if ((0, _utils.debugMode)() === "console")
            yield this.extendInjectedScript(consoleApiSource.source);
          if (this._options.serviceWorkers === "block")
            yield this.addInitScript(`
navigator.serviceWorker.register = async () => { console.warn('Service Worker registration blocked by Playwright'); };
`);
          if (this._options.permissions)
            yield this.grantPermissions(this._options.permissions);
        });
      }
      debugger() {
        return this._debugger;
      }
      _ensureVideosPath() {
        return __async(this, null, function* () {
          if (this._options.recordVideo)
            yield (0, _fileUtils.mkdirIfNeeded)(_path.default.join(this._options.recordVideo.dir, "dummy"));
        });
      }
      canResetForReuse() {
        if (this._closedStatus !== "open")
          return false;
        return true;
      }
      stopPendingOperations() {
        return __async(this, null, function* () {
          for (const controller of this._activeProgressControllers)
            controller.abort(new Error(`Context was reset for reuse.`));
        });
      }
      static reusableContextHash(params) {
        const paramsCopy = __spreadValues({}, params);
        for (const k of Object.keys(paramsCopy)) {
          const key = k;
          if (paramsCopy[key] === defaultNewContextParamValues[key])
            delete paramsCopy[key];
        }
        for (const key of paramsThatAllowContextReuse)
          delete paramsCopy[key];
        return JSON.stringify(paramsCopy);
      }
      resetForReuse(metadata, params) {
        return __async(this, null, function* () {
          var _page, _page2, _page3, _page4, _page5;
          this.setDefaultNavigationTimeout(void 0);
          this.setDefaultTimeout(void 0);
          this.tracing.resetForReuse();
          if (params) {
            for (const key of paramsThatAllowContextReuse)
              this._options[key] = params[key];
          }
          yield this._cancelAllRoutesInFlight();
          let page = this.pages()[0];
          const [, ...otherPages] = this.pages();
          for (const p of otherPages)
            yield p.close(metadata);
          if (page && page._crashedPromise.isDone()) {
            yield page.close(metadata);
            page = void 0;
          }
          (_page = page) === null || _page === void 0 ? void 0 : _page._frameManager.setCloseAllOpeningDialogs(true);
          yield (_page2 = page) === null || _page2 === void 0 ? void 0 : _page2._frameManager.closeOpenDialogs();
          yield (_page3 = page) === null || _page3 === void 0 ? void 0 : _page3.mainFrame().goto(metadata, "about:blank", {
            timeout: 0
          });
          (_page4 = page) === null || _page4 === void 0 ? void 0 : _page4._frameManager.setCloseAllOpeningDialogs(false);
          yield this._resetStorage();
          yield this._removeExposedBindings();
          yield this._removeInitScripts();
          if (this._options.permissions)
            yield this.grantPermissions(this._options.permissions);
          else
            yield this.clearPermissions();
          yield this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []);
          yield this.setGeolocation(this._options.geolocation);
          yield this.setOffline(!!this._options.offline);
          yield this.setUserAgent(this._options.userAgent);
          yield this.clearCache();
          yield this._resetCookies();
          yield (_page5 = page) === null || _page5 === void 0 ? void 0 : _page5.resetForReuse(metadata);
        });
      }
      _browserClosed() {
        for (const page of this.pages())
          page._didClose();
        this._didCloseInternal();
      }
      _didCloseInternal() {
        if (this._closedStatus === "closed") {
          return;
        }
        const gotClosedGracefully = this._closedStatus === "closing";
        this._closedStatus = "closed";
        if (!gotClosedGracefully) {
          this._deleteAllDownloads();
          this._downloads.clear();
        }
        this.tracing.dispose().catch(() => {
        });
        if (this._isPersistentContext)
          this.onClosePersistent();
        this._closePromiseFulfill(new Error("Context closed"));
        this.emit(BrowserContext.Events.Close);
      }
      cookies() {
        return __async(this, arguments, function* (urls = []) {
          if (urls && !Array.isArray(urls))
            urls = [urls];
          return yield this.doGetCookies(urls);
        });
      }
      setHTTPCredentials(httpCredentials) {
        return this.doSetHTTPCredentials(httpCredentials);
      }
      exposeBinding(name, needsHandle, playwrightBinding) {
        return __async(this, null, function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
          for (const page of this.pages()) {
            if (page.getBinding(name))
              throw new Error(`Function "${name}" has been already registered in one of the pages`);
          }
          const binding = new _page6.PageBinding(name, playwrightBinding, needsHandle);
          this._pageBindings.set(name, binding);
          yield this.doExposeBinding(binding);
        });
      }
      _removeExposedBindings() {
        return __async(this, null, function* () {
          for (const key of this._pageBindings.keys()) {
            if (!key.startsWith("__pw"))
              this._pageBindings.delete(key);
          }
          yield this.doRemoveExposedBindings();
        });
      }
      grantPermissions(permissions, origin) {
        return __async(this, null, function* () {
          let resolvedOrigin = "*";
          if (origin) {
            const url = new URL(origin);
            resolvedOrigin = url.origin;
          }
          const existing = new Set(this._permissions.get(resolvedOrigin) || []);
          permissions.forEach((p) => existing.add(p));
          const list = [...existing.values()];
          this._permissions.set(resolvedOrigin, list);
          yield this.doGrantPermissions(resolvedOrigin, list);
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          this._permissions.clear();
          yield this.doClearPermissions();
        });
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      _loadDefaultContextAsIs(progress2) {
        return __async(this, null, function* () {
          if (!this.pages().length) {
            const waitForEvent = _helper.helper.waitForEvent(progress2, this, BrowserContext.Events.Page);
            progress2.cleanupWhenAborted(() => waitForEvent.dispose);
            const page = yield waitForEvent.promise;
            if (page._pageIsError)
              throw page._pageIsError;
          }
          const pages = this.pages();
          if (pages[0]._pageIsError)
            throw pages[0]._pageIsError;
          yield pages[0].mainFrame()._waitForLoadState(progress2, "load");
          return pages;
        });
      }
      _loadDefaultContext(progress2) {
        return __async(this, null, function* () {
          const pages = yield this._loadDefaultContextAsIs(progress2);
          const browserName = this._browser.options.name;
          if (this._options.isMobile && browserName === "chromium" || this._options.locale && browserName === "webkit") {
            const oldPage = pages[0];
            yield this.newPage(progress2.metadata);
            yield oldPage.close(progress2.metadata);
          }
        });
      }
      _authenticateProxyViaHeader() {
        const proxy = this._options.proxy || this._browser.options.proxy || {
          username: void 0,
          password: void 0
        };
        const {
          username,
          password
        } = proxy;
        if (username) {
          this._options.httpCredentials = {
            username,
            password
          };
          const token = Buffer.from(`${username}:${password}`).toString("base64");
          this._options.extraHTTPHeaders = network.mergeHeaders([this._options.extraHTTPHeaders, network.singleHeader("Proxy-Authorization", `Basic ${token}`)]);
        }
      }
      _authenticateProxyViaCredentials() {
        const proxy = this._options.proxy || this._browser.options.proxy;
        if (!proxy)
          return;
        const {
          username,
          password
        } = proxy;
        if (username)
          this._options.httpCredentials = {
            username,
            password: password || ""
          };
      }
      addInitScript(script) {
        return __async(this, null, function* () {
          this.initScripts.push(script);
          yield this.doAddInitScript(script);
        });
      }
      _removeInitScripts() {
        return __async(this, null, function* () {
          this.initScripts.splice(0, this.initScripts.length);
          yield this.doRemoveInitScripts();
        });
      }
      setRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._requestInterceptor = handler;
          yield this.doUpdateRequestInterception();
        });
      }
      isClosingOrClosed() {
        return this._closedStatus !== "open";
      }
      _deleteAllDownloads() {
        return __async(this, null, function* () {
          yield Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
        });
      }
      _deleteAllTempDirs() {
        return __async(this, null, function* () {
          yield Promise.all(this._tempDirs.map((dir) => __async(this, null, function* () {
            return yield _fs.default.promises.unlink(dir).catch((e) => {
            });
          })));
        });
      }
      setCustomCloseHandler(handler) {
        this._customCloseHandler = handler;
      }
      close(metadata) {
        return __async(this, null, function* () {
          if (this._closedStatus === "open") {
            this.emit(BrowserContext.Events.BeforeClose);
            this._closedStatus = "closing";
            for (const harRecorder of this._harRecorders.values())
              yield harRecorder.flush();
            yield this.tracing.dispose();
            const promises = [];
            for (const {
              context,
              artifact
            } of this._browser._idToVideo.values()) {
              if (context === this)
                promises.push(artifact.finishedPromise());
            }
            if (this._customCloseHandler) {
              yield this._customCloseHandler();
            } else {
              yield this.doClose();
            }
            promises.push(this._deleteAllDownloads());
            promises.push(this._deleteAllTempDirs());
            yield Promise.all(promises);
            if (!this._customCloseHandler)
              this._didCloseInternal();
          }
          yield this._closePromise;
        });
      }
      newPage(metadata) {
        return __async(this, null, function* () {
          const pageDelegate = yield this.newPageDelegate();
          if (metadata.isServerSide)
            pageDelegate.potentiallyUninitializedPage().markAsServerSideOnly();
          const pageOrError = yield pageDelegate.pageOrError();
          if (pageOrError instanceof _page6.Page) {
            if (pageOrError.isClosed())
              throw new Error("Page has been closed.");
            return pageOrError;
          }
          throw pageOrError;
        });
      }
      addVisitedOrigin(origin) {
        this._origins.add(origin);
      }
      storageState() {
        return __async(this, null, function* () {
          const result = {
            cookies: yield this.cookies(),
            origins: []
          };
          if (this._origins.size) {
            const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
            const page = yield this.newPage(internalMetadata);
            yield page._setServerRequestInterceptor((handler) => {
              handler.fulfill({
                body: "<html></html>",
                requestUrl: handler.request().url()
              }).catch(() => {
              });
              return true;
            });
            for (const origin of this._origins) {
              const originStorage = {
                origin,
                localStorage: []
              };
              const frame = page.mainFrame();
              yield frame.goto(internalMetadata, origin);
              const storage = yield frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, {
                world: "utility"
              });
              originStorage.localStorage = storage.localStorage;
              if (storage.localStorage.length)
                result.origins.push(originStorage);
            }
            yield page.close(internalMetadata);
          }
          return result;
        });
      }
      _resetStorage() {
        return __async(this, null, function* () {
          var _this$_options$storag, _this$_options$storag2;
          const oldOrigins = this._origins;
          const newOrigins = new Map(((_this$_options$storag = this._options.storageState) === null || _this$_options$storag === void 0 ? void 0 : (_this$_options$storag2 = _this$_options$storag.origins) === null || _this$_options$storag2 === void 0 ? void 0 : _this$_options$storag2.map((p) => [p.origin, p])) || []);
          if (!oldOrigins.size && !newOrigins.size)
            return;
          let page = this.pages()[0];
          const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
          page = page || (yield this.newPage(internalMetadata));
          yield page._setServerRequestInterceptor((handler) => {
            handler.fulfill({
              body: "<html></html>",
              requestUrl: handler.request().url()
            }).catch(() => {
            });
            return true;
          });
          for (const origin of /* @__PURE__ */ new Set([...oldOrigins, ...newOrigins.keys()])) {
            const frame = page.mainFrame();
            yield frame.goto(internalMetadata, origin);
            yield frame.resetStorageForCurrentOriginBestEffort(newOrigins.get(origin));
          }
          yield page._setServerRequestInterceptor(void 0);
          this._origins = /* @__PURE__ */ new Set([...newOrigins.keys()]);
        });
      }
      _resetCookies() {
        return __async(this, null, function* () {
          var _this$_options$storag3, _this$_options$storag4;
          yield this.clearCookies();
          if ((_this$_options$storag3 = this._options.storageState) !== null && _this$_options$storag3 !== void 0 && _this$_options$storag3.cookies)
            yield this.addCookies((_this$_options$storag4 = this._options.storageState) === null || _this$_options$storag4 === void 0 ? void 0 : _this$_options$storag4.cookies);
        });
      }
      isSettingStorageState() {
        return this._settingStorageState;
      }
      setStorageState(metadata, state) {
        return __async(this, null, function* () {
          this._settingStorageState = true;
          try {
            if (state.cookies)
              yield this.addCookies(state.cookies);
            if (state.origins && state.origins.length) {
              const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
              const page = yield this.newPage(internalMetadata);
              yield page._setServerRequestInterceptor((handler) => {
                handler.fulfill({
                  body: "<html></html>",
                  requestUrl: handler.request().url()
                }).catch(() => {
                });
                return true;
              });
              for (const originState of state.origins) {
                const frame = page.mainFrame();
                yield frame.goto(metadata, originState.origin);
                yield frame.evaluateExpression(`
            originState => {
              for (const { name, value } of (originState.localStorage || []))
                localStorage.setItem(name, value);
            }`, {
                  isFunction: true,
                  world: "utility"
                }, originState);
              }
              yield page.close(internalMetadata);
            }
          } finally {
            this._settingStorageState = false;
          }
        });
      }
      extendInjectedScript(source, arg) {
        return __async(this, null, function* () {
          const installInFrame = (frame) => frame.extendInjectedScript(source, arg).catch(() => {
          });
          const installInPage = (page) => {
            page.on(_page6.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
            return Promise.all(page.frames().map(installInFrame));
          };
          this.on(BrowserContext.Events.Page, installInPage);
          return Promise.all(this.pages().map(installInPage));
        });
      }
      _harStart(page, options) {
        return __async(this, null, function* () {
          const harId = (0, _utils.createGuid)();
          this._harRecorders.set(harId, new _harRecorder.HarRecorder(this, page, options));
          return harId;
        });
      }
      _harExport(harId) {
        return __async(this, null, function* () {
          const recorder = this._harRecorders.get(harId || "");
          return recorder.export();
        });
      }
      addRouteInFlight(route) {
        this._routesInFlight.add(route);
      }
      removeRouteInFlight(route) {
        this._routesInFlight.delete(route);
      }
      _cancelAllRoutesInFlight() {
        return __async(this, null, function* () {
          yield Promise.all([...this._routesInFlight].map((r) => r.abort())).catch(() => {
          });
          this._routesInFlight.clear();
        });
      }
    };
    exports2.BrowserContext = BrowserContext;
    BrowserContext.Events = {
      Console: "console",
      Close: "close",
      Dialog: "dialog",
      Page: "page",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      RequestAborted: "requestaborted",
      RequestFulfilled: "requestfulfilled",
      RequestContinued: "requestcontinued",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
    function assertBrowserContextIsNotOwned(context) {
      for (const page of context.pages()) {
        if (page._ownedContext)
          throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
      }
    }
    function validateBrowserContextOptions(options, browserOptions) {
      if (options.noDefaultViewport && options.deviceScaleFactor !== void 0)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
      if (options.noDefaultViewport && !!options.isMobile)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
      if (options.acceptDownloads === void 0)
        options.acceptDownloads = true;
      if (!options.viewport && !options.noDefaultViewport)
        options.viewport = {
          width: 1280,
          height: 720
        };
      if (options.recordVideo) {
        if (!options.recordVideo.size) {
          if (options.noDefaultViewport) {
            options.recordVideo.size = {
              width: 800,
              height: 600
            };
          } else {
            const size = options.viewport;
            const scale = Math.min(1, 800 / Math.max(size.width, size.height));
            options.recordVideo.size = {
              width: Math.floor(size.width * scale),
              height: Math.floor(size.height * scale)
            };
          }
        }
        options.recordVideo.size.width &= ~1;
        options.recordVideo.size.height &= ~1;
      }
      if (options.proxy) {
        if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === "win32")
          throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
        options.proxy = normalizeProxySettings(options.proxy);
      }
      verifyGeolocation(options.geolocation);
    }
    function verifyGeolocation(geolocation) {
      if (!geolocation)
        return;
      geolocation.accuracy = geolocation.accuracy || 0;
      const {
        longitude,
        latitude,
        accuracy
      } = geolocation;
      if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
      if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
      if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
    }
    function normalizeProxySettings(proxy) {
      let {
        server,
        bypass
      } = proxy;
      let url;
      try {
        url = new URL(server);
        if (!url.host || !url.protocol)
          url = new URL("http://" + server);
      } catch (e) {
        url = new URL("http://" + server);
      }
      if (url.protocol === "socks4:" && (proxy.username || proxy.password))
        throw new Error(`Socks4 proxy protocol does not support authentication`);
      if (url.protocol === "socks5:" && (proxy.username || proxy.password))
        throw new Error(`Browser does not support socks5 proxy authentication`);
      server = url.protocol + "//" + url.host;
      if (bypass)
        bypass = bypass.split(",").map((t) => t.trim()).join(",");
      return __spreadProps(__spreadValues({}, proxy), {
        server,
        bypass
      });
    }
    var paramsThatAllowContextReuse = ["colorScheme", "forcedColors", "reducedMotion", "screen", "userAgent", "viewport"];
    var defaultNewContextParamValues = {
      noDefaultViewport: false,
      ignoreHTTPSErrors: false,
      javaScriptEnabled: true,
      bypassCSP: false,
      offline: false,
      isMobile: false,
      hasTouch: false,
      acceptDownloads: true,
      strictSelectors: false,
      serviceWorkers: "allow",
      locale: "en-US"
    };
  }
});

// node_modules/playwright-core/lib/server/cookieStore.js
var require_cookieStore = __commonJS({
  "node_modules/playwright-core/lib/server/cookieStore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CookieStore = void 0;
    exports2.domainMatches = domainMatches;
    var Cookie = class {
      constructor(data) {
        this._raw = void 0;
        this._raw = data;
      }
      name() {
        return this._raw.name;
      }
      matches(url) {
        if (this._raw.secure && url.protocol !== "https:" && url.hostname !== "localhost")
          return false;
        if (!domainMatches(url.hostname, this._raw.domain))
          return false;
        if (!pathMatches(url.pathname, this._raw.path))
          return false;
        return true;
      }
      equals(other) {
        return this._raw.name === other._raw.name && this._raw.domain === other._raw.domain && this._raw.path === other._raw.path;
      }
      networkCookie() {
        return this._raw;
      }
      updateExpiresFrom(other) {
        this._raw.expires = other._raw.expires;
      }
      expired() {
        if (this._raw.expires === -1)
          return false;
        return this._raw.expires * 1e3 < Date.now();
      }
    };
    var CookieStore = class {
      constructor() {
        this._nameToCookies = /* @__PURE__ */ new Map();
      }
      addCookies(cookies) {
        for (const cookie of cookies)
          this._addCookie(new Cookie(cookie));
      }
      cookies(url) {
        const result = [];
        for (const cookie of this._cookiesIterator()) {
          if (cookie.matches(url))
            result.push(cookie.networkCookie());
        }
        return result;
      }
      allCookies() {
        const result = [];
        for (const cookie of this._cookiesIterator())
          result.push(cookie.networkCookie());
        return result;
      }
      _addCookie(cookie) {
        let set = this._nameToCookies.get(cookie.name());
        if (!set) {
          set = /* @__PURE__ */ new Set();
          this._nameToCookies.set(cookie.name(), set);
        }
        for (const other of set) {
          if (other.equals(cookie))
            set.delete(other);
        }
        set.add(cookie);
        CookieStore.pruneExpired(set);
      }
      *_cookiesIterator() {
        for (const [name, cookies] of this._nameToCookies) {
          CookieStore.pruneExpired(cookies);
          for (const cookie of cookies)
            yield cookie;
          if (cookies.size === 0)
            this._nameToCookies.delete(name);
        }
      }
      static pruneExpired(cookies) {
        for (const cookie of cookies) {
          if (cookie.expired())
            cookies.delete(cookie);
        }
      }
    };
    exports2.CookieStore = CookieStore;
    function domainMatches(value, domain) {
      if (value === domain)
        return true;
      if (!domain.startsWith("."))
        return false;
      value = "." + value;
      return value.endsWith(domain);
    }
    function pathMatches(value, path) {
      if (value === path)
        return true;
      if (!value.endsWith("/"))
        value = value + "/";
      if (!path.endsWith("/"))
        path = path + "/";
      return value.startsWith(path);
    }
  }
});

// node_modules/playwright-core/lib/server/formData.js
var require_formData = __commonJS({
  "node_modules/playwright-core/lib/server/formData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MultipartFormData = void 0;
    var _utilsBundle = require_utilsBundle();
    var MultipartFormData = class {
      constructor() {
        this._boundary = void 0;
        this._chunks = [];
        this._boundary = generateUniqueBoundaryString();
      }
      contentTypeHeader() {
        return `multipart/form-data; boundary=${this._boundary}`;
      }
      addField(name, value) {
        this._beginMultiPartHeader(name);
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value));
        this._finishMultiPartField();
      }
      addFileField(name, value) {
        this._beginMultiPartHeader(name);
        this._chunks.push(Buffer.from(`; filename="${value.name}"`));
        this._chunks.push(Buffer.from(`\r
content-type: ${value.mimeType || _utilsBundle.mime.getType(value.name) || "application/octet-stream"}`));
        this._finishMultiPartHeader();
        this._chunks.push(value.buffer);
        this._finishMultiPartField();
      }
      finish() {
        this._addBoundary(true);
        return Buffer.concat(this._chunks);
      }
      _beginMultiPartHeader(name) {
        this._addBoundary();
        this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
      }
      _finishMultiPartHeader() {
        this._chunks.push(Buffer.from(`\r
\r
`));
      }
      _finishMultiPartField() {
        this._chunks.push(Buffer.from(`\r
`));
      }
      _addBoundary(isLastBoundary) {
        this._chunks.push(Buffer.from("--" + this._boundary));
        if (isLastBoundary)
          this._chunks.push(Buffer.from("--"));
        this._chunks.push(Buffer.from("\r\n"));
      }
    };
    exports2.MultipartFormData = MultipartFormData;
    var alphaNumericEncodingMap = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66];
    function generateUniqueBoundaryString() {
      const charCodes = [];
      for (let i = 0; i < 16; i++)
        charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);
      return "----WebKitFormBoundary" + String.fromCharCode(...charCodes);
    }
  }
});

// node_modules/playwright-core/lib/server/fetch.js
var require_fetch = __commonJS({
  "node_modules/playwright-core/lib/server/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GlobalAPIRequestContext = exports2.BrowserContextAPIRequestContext = exports2.APIRequestContext = void 0;
    var http = _interopRequireWildcard(require("http"));
    var https = _interopRequireWildcard(require("https"));
    var _stream = require("stream");
    var _url = _interopRequireDefault(require("url"));
    var _zlib = _interopRequireDefault(require("zlib"));
    var _timeoutSettings = require_timeoutSettings();
    var _userAgent = require_userAgent();
    var _utils = require_utils();
    var _utilsBundle = require_utilsBundle();
    var _browserContext = require_browserContext();
    var _cookieStore = require_cookieStore();
    var _formData = require_formData();
    var _happyEyeballs = require_happy_eyeballs();
    var _instrumentation = require_instrumentation();
    var _progress = require_progress();
    var _tracing = require_tracing();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var APIRequestContext = class extends _instrumentation.SdkObject {
      static findResponseBody(guid) {
        for (const request of APIRequestContext.allInstances) {
          const body = request.fetchResponses.get(guid);
          if (body)
            return body;
        }
        return void 0;
      }
      constructor(parent) {
        super(parent, "request-context");
        this.fetchResponses = /* @__PURE__ */ new Map();
        this.fetchLog = /* @__PURE__ */ new Map();
        this._activeProgressControllers = /* @__PURE__ */ new Set();
        APIRequestContext.allInstances.add(this);
      }
      _disposeImpl() {
        APIRequestContext.allInstances.delete(this);
        this.fetchResponses.clear();
        this.fetchLog.clear();
        this.emit(APIRequestContext.Events.Dispose);
      }
      disposeResponse(fetchUid) {
        this.fetchResponses.delete(fetchUid);
        this.fetchLog.delete(fetchUid);
      }
      _storeResponseBody(body) {
        const uid = (0, _utils.createGuid)();
        this.fetchResponses.set(uid, body);
        return uid;
      }
      fetch(params, metadata) {
        return __async(this, null, function* () {
          var _params$method;
          const defaults = this._defaultOptions();
          const headers = {
            "user-agent": defaults.userAgent,
            "accept": "*/*",
            "accept-encoding": "gzip,deflate,br"
          };
          if (defaults.extraHTTPHeaders) {
            for (const {
              name,
              value
            } of defaults.extraHTTPHeaders)
              setHeader(headers, name, value);
          }
          if (params.headers) {
            for (const {
              name,
              value
            } of params.headers)
              setHeader(headers, name, value);
          }
          const requestUrl = new URL(params.url, defaults.baseURL);
          if (params.params) {
            for (const {
              name,
              value
            } of params.params)
              requestUrl.searchParams.set(name, value);
          }
          const method = ((_params$method = params.method) === null || _params$method === void 0 ? void 0 : _params$method.toUpperCase()) || "GET";
          const proxy = defaults.proxy;
          let agent;
          if (proxy && proxy.server !== "per-context" && !shouldBypassProxy(requestUrl, proxy.bypass)) {
            var _proxyOpts$protocol;
            const proxyOpts = _url.default.parse(proxy.server);
            if ((_proxyOpts$protocol = proxyOpts.protocol) !== null && _proxyOpts$protocol !== void 0 && _proxyOpts$protocol.startsWith("socks")) {
              agent = new _utilsBundle.SocksProxyAgent({
                host: proxyOpts.hostname,
                port: proxyOpts.port || void 0
              });
            } else {
              if (proxy.username)
                proxyOpts.auth = `${proxy.username}:${proxy.password || ""}`;
              agent = new _utilsBundle.HttpsProxyAgent(proxyOpts);
            }
          }
          const timeout = defaults.timeoutSettings.timeout(params);
          const deadline = timeout && (0, _utils.monotonicTime)() + timeout;
          const options = {
            method,
            headers,
            agent,
            maxRedirects: params.maxRedirects === 0 ? -1 : params.maxRedirects === void 0 ? 20 : params.maxRedirects,
            timeout,
            deadline,
            __testHookLookup: params.__testHookLookup
          };
          if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)
            options.rejectUnauthorized = false;
          const postData = serializePostData(params, headers);
          if (postData)
            setHeader(headers, "content-length", String(postData.byteLength));
          const controller = new _progress.ProgressController(metadata, this);
          const fetchResponse = yield controller.run((progress2) => {
            return this._sendRequest(progress2, requestUrl, options, postData);
          });
          const fetchUid = this._storeResponseBody(fetchResponse.body);
          this.fetchLog.set(fetchUid, controller.metadata.log);
          if (params.failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400))
            throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}`);
          return __spreadProps(__spreadValues({}, fetchResponse), {
            fetchUid
          });
        });
      }
      _parseSetCookieHeader(responseUrl, setCookie) {
        if (!setCookie)
          return [];
        const url = new URL(responseUrl);
        const defaultPath = "/" + url.pathname.substr(1).split("/").slice(0, -1).join("/");
        const cookies = [];
        for (const header of setCookie) {
          const cookie = parseCookie(header);
          if (!cookie)
            continue;
          if (!cookie.domain)
            cookie.domain = url.hostname;
          else
            (0, _utils.assert)(cookie.domain.startsWith(".") || !cookie.domain.includes("."));
          if (!(0, _cookieStore.domainMatches)(url.hostname, cookie.domain))
            continue;
          if (!cookie.path || !cookie.path.startsWith("/"))
            cookie.path = defaultPath;
          cookies.push(cookie);
        }
        return cookies;
      }
      _updateRequestCookieHeader(url, headers) {
        return __async(this, null, function* () {
          if (getHeader(headers, "cookie") !== void 0)
            return;
          const cookies = yield this._cookies(url);
          if (cookies.length) {
            const valueArray = cookies.map((c) => `${c.name}=${c.value}`);
            setHeader(headers, "cookie", valueArray.join("; "));
          }
        });
      }
      _sendRequest(progress2, url, options, postData) {
        return __async(this, null, function* () {
          var _getHeader;
          yield this._updateRequestCookieHeader(url, options.headers);
          const requestCookies = ((_getHeader = getHeader(options.headers, "cookie")) === null || _getHeader === void 0 ? void 0 : _getHeader.split(";").map((p) => {
            const [name, value] = p.split("=").map((v) => v.trim());
            return {
              name,
              value
            };
          })) || [];
          const requestEvent = {
            url,
            method: options.method,
            headers: options.headers,
            cookies: requestCookies,
            postData
          };
          this.emit(APIRequestContext.Events.Request, requestEvent);
          return new Promise((fulfill, reject) => {
            const requestConstructor = (url.protocol === "https:" ? https : http).request;
            const agent = options.agent || (url.protocol === "https:" ? _happyEyeballs.httpsHappyEyeballsAgent : _happyEyeballs.httpHappyEyeballsAgent);
            const requestOptions = __spreadProps(__spreadValues({}, options), {
              agent
            });
            const request = requestConstructor(url, requestOptions, (response) => __async(this, null, function* () {
              const notifyRequestFinished = (body2) => {
                const requestFinishedEvent = {
                  requestEvent,
                  httpVersion: response.httpVersion,
                  statusCode: response.statusCode || 0,
                  statusMessage: response.statusMessage || "",
                  headers: response.headers,
                  rawHeaders: response.rawHeaders,
                  cookies,
                  body: body2
                };
                this.emit(APIRequestContext.Events.RequestFinished, requestFinishedEvent);
              };
              progress2.log(`\u2190 ${response.statusCode} ${response.statusMessage}`);
              for (const [name, value] of Object.entries(response.headers))
                progress2.log(`  ${name}: ${value}`);
              const cookies = this._parseSetCookieHeader(response.url || url.toString(), response.headers["set-cookie"]);
              if (cookies.length)
                yield this._addCookies(cookies);
              if (redirectStatus.includes(response.statusCode) && options.maxRedirects >= 0) {
                if (!options.maxRedirects) {
                  reject(new Error("Max redirect count exceeded"));
                  request.destroy();
                  return;
                }
                const headers = __spreadValues({}, options.headers);
                removeHeader(headers, `cookie`);
                const status = response.statusCode;
                let method = options.method;
                if ((status === 301 || status === 302) && method === "POST" || status === 303 && !["GET", "HEAD"].includes(method)) {
                  method = "GET";
                  postData = void 0;
                  removeHeader(headers, `content-encoding`);
                  removeHeader(headers, `content-language`);
                  removeHeader(headers, `content-length`);
                  removeHeader(headers, `content-location`);
                  removeHeader(headers, `content-type`);
                }
                const redirectOptions = {
                  method,
                  headers,
                  agent: options.agent,
                  maxRedirects: options.maxRedirects - 1,
                  timeout: options.timeout,
                  deadline: options.deadline,
                  __testHookLookup: options.__testHookLookup
                };
                if (options.rejectUnauthorized === false)
                  redirectOptions.rejectUnauthorized = false;
                if (response.headers.location) {
                  let locationURL;
                  try {
                    locationURL = new URL(response.headers.location, url);
                  } catch (error) {
                    reject(new Error(`uri requested responds with an invalid redirect URL: ${response.headers.location}`));
                    request.destroy();
                    return;
                  }
                  notifyRequestFinished();
                  fulfill(this._sendRequest(progress2, locationURL, redirectOptions, postData));
                  request.destroy();
                  return;
                }
              }
              if (response.statusCode === 401 && !getHeader(options.headers, "authorization")) {
                const auth = response.headers["www-authenticate"];
                const credentials = this._getHttpCredentials(url);
                if (auth !== null && auth !== void 0 && auth.trim().startsWith("Basic") && credentials) {
                  const {
                    username,
                    password
                  } = credentials;
                  const encoded = Buffer.from(`${username || ""}:${password || ""}`).toString("base64");
                  setHeader(options.headers, "authorization", `Basic ${encoded}`);
                  notifyRequestFinished();
                  fulfill(this._sendRequest(progress2, url, options, postData));
                  request.destroy();
                  return;
                }
              }
              response.on("aborted", () => reject(new Error("aborted")));
              const chunks = [];
              const notifyBodyFinished = () => {
                const body2 = Buffer.concat(chunks);
                notifyRequestFinished(body2);
                fulfill({
                  url: response.url || url.toString(),
                  status: response.statusCode || 0,
                  statusText: response.statusMessage || "",
                  headers: toHeadersArray(response.rawHeaders),
                  body: body2
                });
              };
              let body = response;
              let transform;
              const encoding = response.headers["content-encoding"];
              if (encoding === "gzip" || encoding === "x-gzip") {
                transform = _zlib.default.createGunzip({
                  flush: _zlib.default.constants.Z_SYNC_FLUSH,
                  finishFlush: _zlib.default.constants.Z_SYNC_FLUSH
                });
              } else if (encoding === "br") {
                transform = _zlib.default.createBrotliDecompress();
              } else if (encoding === "deflate") {
                transform = _zlib.default.createInflate();
              }
              if (transform) {
                const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);
                body = (0, _stream.pipeline)(response, emptyStreamTransform, transform, (e) => {
                  if (e)
                    reject(new Error(`failed to decompress '${encoding}' encoding: ${e.message}`));
                });
                body.on("error", (e) => reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`)));
              } else {
                body.on("error", reject);
              }
              body.on("data", (chunk) => chunks.push(chunk));
              body.on("end", notifyBodyFinished);
            }));
            request.on("error", reject);
            const disposeListener = () => {
              reject(new Error("Request context disposed."));
              request.destroy();
            };
            this.on(APIRequestContext.Events.Dispose, disposeListener);
            request.on("close", () => this.off(APIRequestContext.Events.Dispose, disposeListener));
            progress2.log(`\u2192 ${options.method} ${url.toString()}`);
            if (options.headers) {
              for (const [name, value] of Object.entries(options.headers))
                progress2.log(`  ${name}: ${value}`);
            }
            if (options.deadline) {
              const rejectOnTimeout = () => {
                reject(new Error(`Request timed out after ${options.timeout}ms`));
                request.destroy();
              };
              const remaining = options.deadline - (0, _utils.monotonicTime)();
              if (remaining <= 0) {
                rejectOnTimeout();
                return;
              }
              request.setTimeout(remaining, rejectOnTimeout);
            }
            if (postData)
              request.write(postData);
            request.end();
          });
        });
      }
      _getHttpCredentials(url) {
        var _this$_defaultOptions, _this$_defaultOptions2, _this$_defaultOptions3;
        if (!((_this$_defaultOptions = this._defaultOptions().httpCredentials) !== null && _this$_defaultOptions !== void 0 && _this$_defaultOptions.origin) || url.origin.toLowerCase() === ((_this$_defaultOptions2 = this._defaultOptions().httpCredentials) === null || _this$_defaultOptions2 === void 0 ? void 0 : (_this$_defaultOptions3 = _this$_defaultOptions2.origin) === null || _this$_defaultOptions3 === void 0 ? void 0 : _this$_defaultOptions3.toLowerCase()))
          return this._defaultOptions().httpCredentials;
        return void 0;
      }
    };
    exports2.APIRequestContext = APIRequestContext;
    APIRequestContext.Events = {
      Dispose: "dispose",
      Request: "request",
      RequestFinished: "requestfinished"
    };
    APIRequestContext.allInstances = /* @__PURE__ */ new Set();
    var SafeEmptyStreamTransform = class extends _stream.Transform {
      constructor(onEmptyStreamCallback) {
        super();
        this._receivedSomeData = false;
        this._onEmptyStreamCallback = void 0;
        this._onEmptyStreamCallback = onEmptyStreamCallback;
      }
      _transform(chunk, encoding, callback) {
        this._receivedSomeData = true;
        callback(null, chunk);
      }
      _flush(callback) {
        if (this._receivedSomeData)
          callback(null);
        else
          this._onEmptyStreamCallback();
      }
    };
    var BrowserContextAPIRequestContext = class extends APIRequestContext {
      constructor(context) {
        super(context);
        this._context = void 0;
        this._context = context;
        context.once(_browserContext.BrowserContext.Events.Close, () => this._disposeImpl());
      }
      tracing() {
        return this._context.tracing;
      }
      dispose() {
        return __async(this, null, function* () {
          this.fetchResponses.clear();
        });
      }
      _defaultOptions() {
        return {
          userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
          extraHTTPHeaders: this._context._options.extraHTTPHeaders,
          httpCredentials: this._context._options.httpCredentials,
          proxy: this._context._options.proxy || this._context._browser.options.proxy,
          timeoutSettings: this._context._timeoutSettings,
          ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
          baseURL: this._context._options.baseURL
        };
      }
      _addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._context.addCookies(cookies);
        });
      }
      _cookies(url) {
        return __async(this, null, function* () {
          return yield this._context.cookies(url.toString());
        });
      }
      storageState() {
        return __async(this, null, function* () {
          return this._context.storageState();
        });
      }
    };
    exports2.BrowserContextAPIRequestContext = BrowserContextAPIRequestContext;
    var GlobalAPIRequestContext = class extends APIRequestContext {
      constructor(playwright, options) {
        super(playwright);
        this._cookieStore = new _cookieStore.CookieStore();
        this._options = void 0;
        this._origins = void 0;
        this._tracing = void 0;
        this.attribution.context = this;
        const timeoutSettings = new _timeoutSettings.TimeoutSettings();
        if (options.timeout !== void 0)
          timeoutSettings.setDefaultTimeout(options.timeout);
        const proxy = options.proxy;
        if (proxy !== null && proxy !== void 0 && proxy.server) {
          let url = proxy === null || proxy === void 0 ? void 0 : proxy.server.trim();
          if (!/^\w+:\/\//.test(url))
            url = "http://" + url;
          proxy.server = url;
        }
        if (options.storageState) {
          this._origins = options.storageState.origins;
          this._cookieStore.addCookies(options.storageState.cookies);
        }
        this._options = {
          baseURL: options.baseURL,
          userAgent: options.userAgent || (0, _userAgent.getUserAgent)(),
          extraHTTPHeaders: options.extraHTTPHeaders,
          ignoreHTTPSErrors: !!options.ignoreHTTPSErrors,
          httpCredentials: options.httpCredentials,
          proxy,
          timeoutSettings
        };
        this._tracing = new _tracing.Tracing(this, options.tracesDir);
      }
      tracing() {
        return this._tracing;
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._tracing.dispose();
          yield this._tracing.deleteTmpTracesDir();
          this._disposeImpl();
        });
      }
      _defaultOptions() {
        return this._options;
      }
      _addCookies(cookies) {
        return __async(this, null, function* () {
          this._cookieStore.addCookies(cookies);
        });
      }
      _cookies(url) {
        return __async(this, null, function* () {
          return this._cookieStore.cookies(url);
        });
      }
      storageState() {
        return __async(this, null, function* () {
          return {
            cookies: this._cookieStore.allCookies(),
            origins: this._origins || []
          };
        });
      }
    };
    exports2.GlobalAPIRequestContext = GlobalAPIRequestContext;
    function toHeadersArray(rawHeaders) {
      const result = [];
      for (let i = 0; i < rawHeaders.length; i += 2)
        result.push({
          name: rawHeaders[i],
          value: rawHeaders[i + 1]
        });
      return result;
    }
    var redirectStatus = [301, 302, 303, 307, 308];
    function parseCookie(header) {
      const pairs = header.split(";").filter((s) => s.trim().length > 0).map((p) => {
        let key = "";
        let value2 = "";
        const separatorPos = p.indexOf("=");
        if (separatorPos === -1) {
          key = p.trim();
        } else {
          key = p.slice(0, separatorPos).trim();
          value2 = p.slice(separatorPos + 1).trim();
        }
        return [key, value2];
      });
      if (!pairs.length)
        return null;
      const [name, value] = pairs[0];
      const cookie = {
        name,
        value,
        domain: "",
        path: "",
        expires: -1,
        httpOnly: false,
        secure: false,
        sameSite: "Lax"
      };
      for (let i = 1; i < pairs.length; i++) {
        const [name2, value2] = pairs[i];
        switch (name2.toLowerCase()) {
          case "expires":
            const expiresMs = +new Date(value2);
            if (isFinite(expiresMs))
              cookie.expires = expiresMs / 1e3;
            break;
          case "max-age":
            const maxAgeSec = parseInt(value2, 10);
            if (isFinite(maxAgeSec))
              cookie.expires = Date.now() / 1e3 + maxAgeSec;
            break;
          case "domain":
            cookie.domain = value2.toLocaleLowerCase() || "";
            if (cookie.domain && !cookie.domain.startsWith(".") && cookie.domain.includes("."))
              cookie.domain = "." + cookie.domain;
            break;
          case "path":
            cookie.path = value2 || "";
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httpOnly = true;
            break;
          case "samesite":
            switch (value2.toLowerCase()) {
              case "none":
                cookie.sameSite = "None";
                break;
              case "lax":
                cookie.sameSite = "Lax";
                break;
              case "strict":
                cookie.sameSite = "Strict";
                break;
            }
            break;
        }
      }
      return cookie;
    }
    function isJsonParsable(value) {
      if (typeof value !== "string")
        return false;
      try {
        JSON.parse(value);
        return true;
      } catch (e) {
        if (e instanceof SyntaxError)
          return false;
        else
          throw e;
      }
    }
    function serializePostData(params, headers) {
      (0, _utils.assert)((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      if (params.jsonData !== void 0) {
        const json = isJsonParsable(params.jsonData) ? params.jsonData : JSON.stringify(params.jsonData);
        setHeader(headers, "content-type", "application/json", true);
        return Buffer.from(json, "utf8");
      } else if (params.formData) {
        const searchParams = new URLSearchParams();
        for (const {
          name,
          value
        } of params.formData)
          searchParams.append(name, value);
        setHeader(headers, "content-type", "application/x-www-form-urlencoded", true);
        return Buffer.from(searchParams.toString(), "utf8");
      } else if (params.multipartData) {
        const formData = new _formData.MultipartFormData();
        for (const field of params.multipartData) {
          if (field.file)
            formData.addFileField(field.name, field.file);
          else if (field.value)
            formData.addField(field.name, field.value);
        }
        setHeader(headers, "content-type", formData.contentTypeHeader(), true);
        return formData.finish();
      } else if (params.postData !== void 0) {
        setHeader(headers, "content-type", "application/octet-stream", true);
        return params.postData;
      }
      return void 0;
    }
    function setHeader(headers, name, value, keepExisting = false) {
      const existing = Object.entries(headers).find((pair) => pair[0].toLowerCase() === name.toLowerCase());
      if (!existing)
        headers[name] = value;
      else if (!keepExisting)
        headers[existing[0]] = value;
    }
    function getHeader(headers, name) {
      const existing = Object.entries(headers).find((pair) => pair[0].toLowerCase() === name.toLowerCase());
      return existing ? existing[1] : void 0;
    }
    function removeHeader(headers, name) {
      delete headers[name];
    }
    function shouldBypassProxy(url, bypass) {
      if (!bypass)
        return false;
      const domains = bypass.split(",").map((s) => {
        s = s.trim();
        if (!s.startsWith("."))
          s = "." + s;
        return s;
      });
      const domain = "." + url.hostname;
      return domains.some((d) => domain.endsWith(d));
    }
  }
});

// node_modules/playwright-core/lib/common/socksProxy.js
var require_socksProxy = __commonJS({
  "node_modules/playwright-core/lib/common/socksProxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SocksProxyHandler = exports2.SocksProxy = void 0;
    exports2.parsePattern = parsePattern;
    var _events = _interopRequireDefault(require("events"));
    var _net = _interopRequireDefault(require("net"));
    var _debugLogger = require_debugLogger();
    var _happyEyeballs = require_happy_eyeballs();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SocksAuth;
    (function(SocksAuth2) {
      SocksAuth2[SocksAuth2["NO_AUTHENTICATION_REQUIRED"] = 0] = "NO_AUTHENTICATION_REQUIRED";
      SocksAuth2[SocksAuth2["GSSAPI"] = 1] = "GSSAPI";
      SocksAuth2[SocksAuth2["USERNAME_PASSWORD"] = 2] = "USERNAME_PASSWORD";
      SocksAuth2[SocksAuth2["NO_ACCEPTABLE_METHODS"] = 255] = "NO_ACCEPTABLE_METHODS";
    })(SocksAuth || (SocksAuth = {}));
    var SocksAddressType;
    (function(SocksAddressType2) {
      SocksAddressType2[SocksAddressType2["IPv4"] = 1] = "IPv4";
      SocksAddressType2[SocksAddressType2["FqName"] = 3] = "FqName";
      SocksAddressType2[SocksAddressType2["IPv6"] = 4] = "IPv6";
    })(SocksAddressType || (SocksAddressType = {}));
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["CONNECT"] = 1] = "CONNECT";
      SocksCommand2[SocksCommand2["BIND"] = 2] = "BIND";
      SocksCommand2[SocksCommand2["UDP_ASSOCIATE"] = 3] = "UDP_ASSOCIATE";
    })(SocksCommand || (SocksCommand = {}));
    var SocksReply;
    (function(SocksReply2) {
      SocksReply2[SocksReply2["Succeeded"] = 0] = "Succeeded";
      SocksReply2[SocksReply2["GeneralServerFailure"] = 1] = "GeneralServerFailure";
      SocksReply2[SocksReply2["NotAllowedByRuleSet"] = 2] = "NotAllowedByRuleSet";
      SocksReply2[SocksReply2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      SocksReply2[SocksReply2["HostUnreachable"] = 4] = "HostUnreachable";
      SocksReply2[SocksReply2["ConnectionRefused"] = 5] = "ConnectionRefused";
      SocksReply2[SocksReply2["TtlExpired"] = 6] = "TtlExpired";
      SocksReply2[SocksReply2["CommandNotSupported"] = 7] = "CommandNotSupported";
      SocksReply2[SocksReply2["AddressTypeNotSupported"] = 8] = "AddressTypeNotSupported";
    })(SocksReply || (SocksReply = {}));
    var SocksConnection = class {
      constructor(uid, socket, client) {
        this._buffer = Buffer.from([]);
        this._offset = 0;
        this._fence = 0;
        this._fenceCallback = void 0;
        this._socket = void 0;
        this._boundOnData = void 0;
        this._uid = void 0;
        this._client = void 0;
        this._uid = uid;
        this._socket = socket;
        this._client = client;
        this._boundOnData = this._onData.bind(this);
        socket.on("data", this._boundOnData);
        socket.on("close", () => this._onClose());
        socket.on("end", () => this._onClose());
        socket.on("error", () => this._onClose());
        this._run().catch(() => this._socket.end());
      }
      _run() {
        return __async(this, null, function* () {
          (0, _utils.assert)(yield this._authenticate());
          const {
            command,
            host,
            port
          } = yield this._parseRequest();
          if (command !== SocksCommand.CONNECT) {
            this._writeBytes(Buffer.from([
              5,
              SocksReply.CommandNotSupported,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0
            ]));
            return;
          }
          this._socket.off("data", this._boundOnData);
          this._client.onSocketRequested({
            uid: this._uid,
            host,
            port
          });
        });
      }
      _authenticate() {
        return __async(this, null, function* () {
          const version = yield this._readByte();
          (0, _utils.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
          const nMethods = yield this._readByte();
          (0, _utils.assert)(nMethods, "No authentication methods specified");
          const methods = yield this._readBytes(nMethods);
          for (const method of methods) {
            if (method === 0) {
              this._writeBytes(Buffer.from([version, method]));
              return true;
            }
          }
          this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));
          return false;
        });
      }
      _parseRequest() {
        return __async(this, null, function* () {
          const version = yield this._readByte();
          (0, _utils.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
          const command = yield this._readByte();
          yield this._readByte();
          const addressType = yield this._readByte();
          let host = "";
          switch (addressType) {
            case SocksAddressType.IPv4:
              host = (yield this._readBytes(4)).join(".");
              break;
            case SocksAddressType.FqName:
              const length = yield this._readByte();
              host = (yield this._readBytes(length)).toString();
              break;
            case SocksAddressType.IPv6:
              const bytes = yield this._readBytes(16);
              const tokens = [];
              for (let i = 0; i < 8; ++i)
                tokens.push(bytes.readUInt16BE(i * 2).toString(16));
              host = tokens.join(":");
              break;
          }
          const port = (yield this._readBytes(2)).readUInt16BE(0);
          this._buffer = Buffer.from([]);
          this._offset = 0;
          this._fence = 0;
          return {
            command,
            host,
            port
          };
        });
      }
      _readByte() {
        return __async(this, null, function* () {
          const buffer = yield this._readBytes(1);
          return buffer[0];
        });
      }
      _readBytes(length) {
        return __async(this, null, function* () {
          this._fence = this._offset + length;
          if (!this._buffer || this._buffer.length < this._fence)
            yield new Promise((f) => this._fenceCallback = f);
          this._offset += length;
          return this._buffer.slice(this._offset - length, this._offset);
        });
      }
      _writeBytes(buffer) {
        if (this._socket.writable)
          this._socket.write(buffer);
      }
      _onClose() {
        this._client.onSocketClosed({
          uid: this._uid
        });
      }
      _onData(buffer) {
        this._buffer = Buffer.concat([this._buffer, buffer]);
        if (this._fenceCallback && this._buffer.length >= this._fence) {
          const callback = this._fenceCallback;
          this._fenceCallback = void 0;
          callback();
        }
      }
      socketConnected(host, port) {
        this._writeBytes(Buffer.from([
          5,
          SocksReply.Succeeded,
          0,
          ...ipToSocksAddress(host),
          port >> 8,
          port & 255
        ]));
        this._socket.on("data", (data) => this._client.onSocketData({
          uid: this._uid,
          data
        }));
      }
      socketFailed(errorCode) {
        const buffer = Buffer.from([
          5,
          0,
          0,
          ...ipToSocksAddress("0.0.0.0"),
          0,
          0
        ]);
        switch (errorCode) {
          case "ENOENT":
          case "ENOTFOUND":
          case "ETIMEDOUT":
          case "EHOSTUNREACH":
            buffer[1] = SocksReply.HostUnreachable;
            break;
          case "ENETUNREACH":
            buffer[1] = SocksReply.NetworkUnreachable;
            break;
          case "ECONNREFUSED":
            buffer[1] = SocksReply.ConnectionRefused;
            break;
          case "ERULESET":
            buffer[1] = SocksReply.NotAllowedByRuleSet;
            break;
        }
        this._writeBytes(buffer);
        this._socket.end();
      }
      sendData(data) {
        this._socket.write(data);
      }
      end() {
        this._socket.end();
      }
      error(error) {
        this._socket.destroy(new Error(error));
      }
    };
    function hexToNumber(hex) {
      return [...hex].reduce((value, digit) => {
        const code = digit.charCodeAt(0);
        if (code >= 48 && code <= 57)
          return value + code;
        if (code >= 97 && code <= 102)
          return value + (code - 97) + 10;
        if (code >= 65 && code <= 70)
          return value + (code - 65) + 10;
        throw new Error("Invalid IPv6 token " + hex);
      }, 0);
    }
    function ipToSocksAddress(address) {
      if (_net.default.isIPv4(address)) {
        return [
          1,
          ...address.split(".", 4).map((t) => +t & 255)
        ];
      }
      if (_net.default.isIPv6(address)) {
        const result = [4];
        const tokens = address.split(":", 8);
        while (tokens.length < 8)
          tokens.unshift("");
        for (const token of tokens) {
          const value = hexToNumber(token);
          result.push(value >> 8 & 255, value & 255);
        }
        return result;
      }
      throw new Error("Only IPv4 and IPv6 addresses are supported");
    }
    function starMatchToRegex(pattern) {
      const source = pattern.split("*").map((s) => {
        return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }).join(".*");
      return new RegExp("^" + source + "$");
    }
    function parsePattern(pattern) {
      if (!pattern)
        return () => false;
      const matchers = pattern.split(",").map((token) => {
        const match = token.match(/^(.*?)(?::(\d+))?$/);
        if (!match)
          throw new Error(`Unsupported token "${token}" in pattern "${pattern}"`);
        const tokenPort = match[2] ? +match[2] : void 0;
        const portMatches = (port) => tokenPort === void 0 || tokenPort === port;
        let tokenHost = match[1];
        if (tokenHost === "<loopback>") {
          return (host, port) => {
            if (!portMatches(port))
              return false;
            return host === "localhost" || host.endsWith(".localhost") || host === "127.0.0.1" || host === "[::1]";
          };
        }
        if (tokenHost === "*")
          return (host, port) => portMatches(port);
        if (_net.default.isIPv4(tokenHost) || _net.default.isIPv6(tokenHost))
          return (host, port) => host === tokenHost && portMatches(port);
        if (tokenHost[0] === ".")
          tokenHost = "*" + tokenHost;
        const tokenRegex = starMatchToRegex(tokenHost);
        return (host, port) => {
          if (!portMatches(port))
            return false;
          if (_net.default.isIPv4(host) || _net.default.isIPv6(host))
            return false;
          return !!host.match(tokenRegex);
        };
      });
      return (host, port) => matchers.some((matcher) => matcher(host, port));
    }
    var SocksProxy = class extends _events.default {
      constructor() {
        super();
        this._server = void 0;
        this._connections = /* @__PURE__ */ new Map();
        this._sockets = /* @__PURE__ */ new Set();
        this._closed = false;
        this._port = void 0;
        this._patternMatcher = () => false;
        this._directSockets = /* @__PURE__ */ new Map();
        this._server = new _net.default.Server((socket) => {
          const uid = (0, _utils.createGuid)();
          const connection = new SocksConnection(uid, socket, this);
          this._connections.set(uid, connection);
        });
        this._server.on("connection", (socket) => {
          if (this._closed) {
            socket.destroy();
            return;
          }
          this._sockets.add(socket);
          socket.once("close", () => this._sockets.delete(socket));
        });
      }
      setPattern(pattern) {
        try {
          this._patternMatcher = parsePattern(pattern);
        } catch (e) {
          this._patternMatcher = () => false;
        }
      }
      _handleDirect(request) {
        return __async(this, null, function* () {
          try {
            var _this$_connections$ge4;
            const socket = yield (0, _happyEyeballs.createSocket)(request.host, request.port);
            socket.on("data", (data) => {
              var _this$_connections$ge;
              return (_this$_connections$ge = this._connections.get(request.uid)) === null || _this$_connections$ge === void 0 ? void 0 : _this$_connections$ge.sendData(data);
            });
            socket.on("error", (error) => {
              var _this$_connections$ge2;
              (_this$_connections$ge2 = this._connections.get(request.uid)) === null || _this$_connections$ge2 === void 0 ? void 0 : _this$_connections$ge2.error(error.message);
              this._directSockets.delete(request.uid);
            });
            socket.on("end", () => {
              var _this$_connections$ge3;
              (_this$_connections$ge3 = this._connections.get(request.uid)) === null || _this$_connections$ge3 === void 0 ? void 0 : _this$_connections$ge3.end();
              this._directSockets.delete(request.uid);
            });
            const localAddress = socket.localAddress;
            const localPort = socket.localPort;
            this._directSockets.set(request.uid, socket);
            (_this$_connections$ge4 = this._connections.get(request.uid)) === null || _this$_connections$ge4 === void 0 ? void 0 : _this$_connections$ge4.socketConnected(localAddress, localPort);
          } catch (error) {
            var _this$_connections$ge5;
            (_this$_connections$ge5 = this._connections.get(request.uid)) === null || _this$_connections$ge5 === void 0 ? void 0 : _this$_connections$ge5.socketFailed(error.code);
          }
        });
      }
      port() {
        return this._port;
      }
      listen(port) {
        return __async(this, null, function* () {
          return new Promise((f) => {
            this._server.listen(port, () => {
              const port2 = this._server.address().port;
              this._port = port2;
              f(port2);
            });
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          if (this._closed)
            return;
          this._closed = true;
          for (const socket of this._sockets)
            socket.destroy();
          this._sockets.clear();
          yield new Promise((f) => this._server.close(f));
        });
      }
      onSocketRequested(payload) {
        if (!this._patternMatcher(payload.host, payload.port)) {
          this._handleDirect(payload);
          return;
        }
        this.emit(SocksProxy.Events.SocksRequested, payload);
      }
      onSocketData(payload) {
        const direct = this._directSockets.get(payload.uid);
        if (direct) {
          direct.write(payload.data);
          return;
        }
        this.emit(SocksProxy.Events.SocksData, payload);
      }
      onSocketClosed(payload) {
        const direct = this._directSockets.get(payload.uid);
        if (direct) {
          direct.destroy();
          this._directSockets.delete(payload.uid);
          return;
        }
        this.emit(SocksProxy.Events.SocksClosed, payload);
      }
      socketConnected({
        uid,
        host,
        port
      }) {
        var _this$_connections$ge6;
        (_this$_connections$ge6 = this._connections.get(uid)) === null || _this$_connections$ge6 === void 0 ? void 0 : _this$_connections$ge6.socketConnected(host, port);
      }
      socketFailed({
        uid,
        errorCode
      }) {
        var _this$_connections$ge7;
        (_this$_connections$ge7 = this._connections.get(uid)) === null || _this$_connections$ge7 === void 0 ? void 0 : _this$_connections$ge7.socketFailed(errorCode);
      }
      sendSocketData({
        uid,
        data
      }) {
        var _this$_connections$ge8;
        (_this$_connections$ge8 = this._connections.get(uid)) === null || _this$_connections$ge8 === void 0 ? void 0 : _this$_connections$ge8.sendData(data);
      }
      sendSocketEnd({
        uid
      }) {
        var _this$_connections$ge9;
        (_this$_connections$ge9 = this._connections.get(uid)) === null || _this$_connections$ge9 === void 0 ? void 0 : _this$_connections$ge9.end();
      }
      sendSocketError({
        uid,
        error
      }) {
        var _this$_connections$ge10;
        (_this$_connections$ge10 = this._connections.get(uid)) === null || _this$_connections$ge10 === void 0 ? void 0 : _this$_connections$ge10.error(error);
      }
    };
    exports2.SocksProxy = SocksProxy;
    SocksProxy.Events = {
      SocksRequested: "socksRequested",
      SocksData: "socksData",
      SocksClosed: "socksClosed"
    };
    var SocksProxyHandler = class extends _events.default {
      constructor(pattern, redirectPortForTest) {
        super();
        this._sockets = /* @__PURE__ */ new Map();
        this._patternMatcher = () => false;
        this._redirectPortForTest = void 0;
        this._patternMatcher = parsePattern(pattern);
        this._redirectPortForTest = redirectPortForTest;
      }
      cleanup() {
        for (const uid of this._sockets.keys())
          this.socketClosed({
            uid
          });
      }
      socketRequested(_0) {
        return __async(this, arguments, function* ({
          uid,
          host,
          port
        }) {
          _debugLogger.debugLogger.log("socks", `[${uid}] => request ${host}:${port}`);
          if (!this._patternMatcher(host, port)) {
            const payload = {
              uid,
              errorCode: "ERULESET"
            };
            _debugLogger.debugLogger.log("socks", `[${uid}] <= pattern error ${payload.errorCode}`);
            this.emit(SocksProxyHandler.Events.SocksFailed, payload);
            return;
          }
          if (host === "local.playwright")
            host = "localhost";
          try {
            if (this._redirectPortForTest)
              port = this._redirectPortForTest;
            const socket = yield (0, _happyEyeballs.createSocket)(host, port);
            socket.on("data", (data) => {
              const payload2 = {
                uid,
                data
              };
              this.emit(SocksProxyHandler.Events.SocksData, payload2);
            });
            socket.on("error", (error) => {
              const payload2 = {
                uid,
                error: error.message
              };
              _debugLogger.debugLogger.log("socks", `[${uid}] <= network socket error ${payload2.error}`);
              this.emit(SocksProxyHandler.Events.SocksError, payload2);
              this._sockets.delete(uid);
            });
            socket.on("end", () => {
              const payload2 = {
                uid
              };
              _debugLogger.debugLogger.log("socks", `[${uid}] <= network socket closed`);
              this.emit(SocksProxyHandler.Events.SocksEnd, payload2);
              this._sockets.delete(uid);
            });
            const localAddress = socket.localAddress;
            const localPort = socket.localPort;
            this._sockets.set(uid, socket);
            const payload = {
              uid,
              host: localAddress,
              port: localPort
            };
            _debugLogger.debugLogger.log("socks", `[${uid}] <= connected to network ${payload.host}:${payload.port}`);
            this.emit(SocksProxyHandler.Events.SocksConnected, payload);
          } catch (error) {
            const payload = {
              uid,
              errorCode: error.code
            };
            _debugLogger.debugLogger.log("socks", `[${uid}] <= connect error ${payload.errorCode}`);
            this.emit(SocksProxyHandler.Events.SocksFailed, payload);
          }
        });
      }
      sendSocketData({
        uid,
        data
      }) {
        var _this$_sockets$get;
        (_this$_sockets$get = this._sockets.get(uid)) === null || _this$_sockets$get === void 0 ? void 0 : _this$_sockets$get.write(data);
      }
      socketClosed({
        uid
      }) {
        var _this$_sockets$get2;
        _debugLogger.debugLogger.log("socks", `[${uid}] <= browser socket closed`);
        (_this$_sockets$get2 = this._sockets.get(uid)) === null || _this$_sockets$get2 === void 0 ? void 0 : _this$_sockets$get2.destroy();
        this._sockets.delete(uid);
      }
    };
    exports2.SocksProxyHandler = SocksProxyHandler;
    SocksProxyHandler.Events = {
      SocksConnected: "socksConnected",
      SocksData: "socksData",
      SocksError: "socksError",
      SocksFailed: "socksFailed",
      SocksEnd: "socksEnd"
    };
  }
});

// node_modules/playwright-core/lib/server/dispatchers/jsHandleDispatcher.js
var require_jsHandleDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/jsHandleDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSHandleDispatcher = void 0;
    exports2.parseArgument = parseArgument;
    exports2.parseValue = parseValue;
    exports2.serializeResult = serializeResult;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _serializers = require_serializers();
    var JSHandleDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, jsHandle) {
        super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
          preview: jsHandle.toString()
        });
        this._type_JSHandle = true;
        jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", {
          preview
        }));
      }
      evaluateExpression(params) {
        return __async(this, null, function* () {
          return {
            value: serializeResult(yield this._object.evaluateExpression(params.expression, {
              isFunction: params.isFunction
            }, parseArgument(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params) {
        return __async(this, null, function* () {
          const jsHandle = yield this._object.evaluateExpressionHandle(params.expression, {
            isFunction: params.isFunction
          }, parseArgument(params.arg));
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle)
          };
        });
      }
      getProperty(params) {
        return __async(this, null, function* () {
          const jsHandle = yield this._object.getProperty(params.name);
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), jsHandle)
          };
        });
      }
      getPropertyList() {
        return __async(this, null, function* () {
          const map = yield this._object.getProperties();
          const properties = [];
          for (const [name, value] of map)
            properties.push({
              name,
              value: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), value)
            });
          return {
            properties
          };
        });
      }
      jsonValue() {
        return __async(this, null, function* () {
          return {
            value: serializeResult(yield this._object.jsonValue())
          };
        });
      }
      objectCount(params) {
        return __async(this, null, function* () {
          return {
            count: yield this._object.objectCount()
          };
        });
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._object.dispose();
        });
      }
    };
    exports2.JSHandleDispatcher = JSHandleDispatcher;
    function parseArgument(arg) {
      return (0, _serializers.parseSerializedValue)(arg.value, arg.handles.map((a) => a._object));
    }
    function parseValue(v) {
      return (0, _serializers.parseSerializedValue)(v, []);
    }
    function serializeResult(arg) {
      return (0, _serializers.serializeValue)(arg, (value) => ({
        fallThrough: value
      }));
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/elementHandlerDispatcher.js
var require_elementHandlerDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/elementHandlerDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElementHandleDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var _utils = require_utils();
    var _path = _interopRequireDefault(require("path"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ElementHandleDispatcher = class extends _jsHandleDispatcher.JSHandleDispatcher {
      static from(scope, handle) {
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromNullable(scope, handle) {
        if (!handle)
          return void 0;
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromJSHandle(scope, handle) {
        const result = (0, _dispatcher.existingDispatcher)(handle);
        if (result)
          return result;
        return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new _jsHandleDispatcher.JSHandleDispatcher(scope, handle);
      }
      constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._type_ElementHandle = true;
        this._elementHandle = void 0;
        this._elementHandle = elementHandle;
      }
      ownerFrame(params, metadata) {
        return __async(this, null, function* () {
          const frame = yield this._elementHandle.ownerFrame();
          return {
            frame: frame ? _frameDispatcher.FrameDispatcher.from(this.parentScope(), frame) : void 0
          };
        });
      }
      contentFrame(params, metadata) {
        return __async(this, null, function* () {
          const frame = yield this._elementHandle.contentFrame();
          return {
            frame: frame ? _frameDispatcher.FrameDispatcher.from(this.parentScope(), frame) : void 0
          };
        });
      }
      getAttribute(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.getAttribute(metadata, params.name);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      inputValue(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.inputValue(metadata);
          return {
            value
          };
        });
      }
      textContent(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.textContent(metadata);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      innerText(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.innerText(metadata)
          };
        });
      }
      innerHTML(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.innerHTML(metadata)
          };
        });
      }
      isChecked(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isChecked(metadata)
          };
        });
      }
      isDisabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isDisabled(metadata)
          };
        });
      }
      isEditable(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isEditable(metadata)
          };
        });
      }
      isEnabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isEnabled(metadata)
          };
        });
      }
      isHidden(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isHidden(metadata)
          };
        });
      }
      isVisible(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isVisible(metadata)
          };
        });
      }
      dispatchEvent(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.dispatchEvent(metadata, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit));
        });
      }
      scrollIntoViewIfNeeded(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
        });
      }
      hover(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.hover(metadata, params);
        });
      }
      click(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.click(metadata, params);
        });
      }
      dblclick(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.dblclick(metadata, params);
        });
      }
      tap(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.tap(metadata, params);
        });
      }
      selectOption(params, metadata) {
        return __async(this, null, function* () {
          const elements = (params.elements || []).map((e) => e._elementHandle);
          return {
            values: yield this._elementHandle.selectOption(metadata, elements, params.options || [], params)
          };
        });
      }
      fill(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.fill(metadata, params.value, params);
        });
      }
      selectText(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.selectText(metadata, params);
        });
      }
      setInputFiles(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.setInputFiles(metadata, {
            files: params.files
          }, params);
        });
      }
      setInputFilePaths(params, metadata) {
        return __async(this, null, function* () {
          let {
            localPaths
          } = params;
          if (!localPaths) {
            if (!params.streams)
              throw new Error("Neither localPaths nor streams is specified");
            localPaths = params.streams.map((c) => c.path());
          }
          for (const p of localPaths)
            (0, _utils.assert)(_path.default.isAbsolute(p) && _path.default.resolve(p) === p, "Paths provided to localPaths must be absolute and fully resolved.");
          return yield this._elementHandle.setInputFiles(metadata, {
            localPaths
          }, params);
        });
      }
      focus(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.focus(metadata);
        });
      }
      type(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.type(metadata, params.text, params);
        });
      }
      press(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.press(metadata, params.key, params);
        });
      }
      check(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.check(metadata, params);
        });
      }
      uncheck(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.uncheck(metadata, params);
        });
      }
      boundingBox(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.boundingBox();
          return {
            value: value || void 0
          };
        });
      }
      screenshot(params, metadata) {
        return __async(this, null, function* () {
          const mask = (params.mask || []).map(({
            frame,
            selector
          }) => ({
            frame: frame._object,
            selector
          }));
          return {
            binary: yield this._elementHandle.screenshot(metadata, __spreadProps(__spreadValues({}, params), {
              mask
            }))
          };
        });
      }
      querySelector(params, metadata) {
        return __async(this, null, function* () {
          const handle = yield this._elementHandle.querySelector(params.selector, params);
          return {
            element: ElementHandleDispatcher.fromNullable(this.parentScope(), handle)
          };
        });
      }
      querySelectorAll(params, metadata) {
        return __async(this, null, function* () {
          const elements = yield this._elementHandle.querySelectorAll(params.selector);
          return {
            elements: elements.map((e) => ElementHandleDispatcher.from(this.parentScope(), e))
          };
        });
      }
      evalOnSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._elementHandle.evalOnSelector(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evalOnSelectorAll(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._elementHandle.evalOnSelectorAll(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      waitForElementState(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.waitForElementState(metadata, params.state, params);
        });
      }
      waitForSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: ElementHandleDispatcher.fromNullable(this.parentScope(), yield this._elementHandle.waitForSelector(metadata, params.selector, params))
          };
        });
      }
    };
    exports2.ElementHandleDispatcher = ElementHandleDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/streamDispatcher.js
var require_streamDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/streamDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.StreamDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var StreamDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, stream) {
        super(scope, {
          guid: "stream@" + (0, _utils.createGuid)(),
          stream
        }, "Stream", {});
        this._type_Stream = true;
        this._ended = false;
        stream.once("end", () => this._ended = true);
        stream.once("error", () => this._ended = true);
      }
      read(params) {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          if (this._ended)
            return {
              binary: Buffer.from("")
            };
          if (!stream.readableLength) {
            yield new Promise((fulfill, reject) => {
              stream.once("readable", fulfill);
              stream.once("end", fulfill);
              stream.once("error", reject);
            });
          }
          const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
          return {
            binary: buffer || Buffer.from("")
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          this._object.stream.destroy();
        });
      }
    };
    exports2.StreamDispatcher = StreamDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/artifactDispatcher.js
var require_artifactDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/artifactDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArtifactDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _streamDispatcher = require_streamDispatcher();
    var _fs = _interopRequireDefault(require("fs"));
    var _fileUtils = require_fileUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ArtifactDispatcher = class extends _dispatcher.Dispatcher {
      static from(parentScope, artifact) {
        return ArtifactDispatcher.fromNullable(parentScope, artifact);
      }
      static fromNullable(parentScope, artifact) {
        if (!artifact)
          return void 0;
        const result = (0, _dispatcher.existingDispatcher)(artifact);
        return result || new ArtifactDispatcher(parentScope, artifact);
      }
      constructor(scope, artifact) {
        super(scope, artifact, "Artifact", {
          absolutePath: artifact.localPath()
        });
        this._type_Artifact = true;
      }
      pathAfterFinished() {
        return __async(this, null, function* () {
          const path = yield this._object.localPathAfterFinished();
          return {
            value: path || void 0
          };
        });
      }
      saveAs(params) {
        return __async(this, null, function* () {
          return yield new Promise((resolve, reject) => {
            this._object.saveAs((localPath, error) => __async(this, null, function* () {
              if (error !== void 0) {
                reject(new Error(error));
                return;
              }
              try {
                yield (0, _fileUtils.mkdirIfNeeded)(params.path);
                yield _fs.default.promises.copyFile(localPath, params.path);
                resolve();
              } catch (e) {
                reject(e);
              }
            }));
          });
        });
      }
      saveAsStream() {
        return __async(this, null, function* () {
          return yield new Promise((resolve, reject) => {
            this._object.saveAs((localPath, error) => __async(this, null, function* () {
              if (error !== void 0) {
                reject(new Error(error));
                return;
              }
              try {
                const readable = _fs.default.createReadStream(localPath, {
                  highWaterMark: 1024 * 1024
                });
                const stream = new _streamDispatcher.StreamDispatcher(this, readable);
                resolve({
                  stream
                });
                yield new Promise((resolve2) => {
                  readable.on("close", resolve2);
                  readable.on("end", resolve2);
                  readable.on("error", resolve2);
                });
              } catch (e) {
                reject(e);
              }
            }));
          });
        });
      }
      stream() {
        return __async(this, null, function* () {
          const fileName = yield this._object.localPathAfterFinished();
          if (!fileName)
            return {};
          const readable = _fs.default.createReadStream(fileName, {
            highWaterMark: 1024 * 1024
          });
          return {
            stream: new _streamDispatcher.StreamDispatcher(this, readable)
          };
        });
      }
      failure() {
        return __async(this, null, function* () {
          const error = yield this._object.failureError();
          return {
            error: error || void 0
          };
        });
      }
      cancel() {
        return __async(this, null, function* () {
          yield this._object.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          yield this._object.delete();
          this._dispose();
        });
      }
    };
    exports2.ArtifactDispatcher = ArtifactDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/tracingDispatcher.js
var require_tracingDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/tracingDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TracingDispatcher = void 0;
    var _artifactDispatcher = require_artifactDispatcher();
    var _dispatcher = require_dispatcher();
    var TracingDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, tracing) {
        const result = (0, _dispatcher.existingDispatcher)(tracing);
        return result || new TracingDispatcher(scope, tracing);
      }
      constructor(scope, tracing) {
        super(scope, tracing, "Tracing", {});
        this._type_Tracing = true;
      }
      tracingStart(params) {
        return __async(this, null, function* () {
          yield this._object.start(params);
        });
      }
      tracingStartChunk(params) {
        return __async(this, null, function* () {
          return yield this._object.startChunk(params);
        });
      }
      tracingStopChunk(params) {
        return __async(this, null, function* () {
          const {
            artifact,
            entries
          } = yield this._object.stopChunk(params);
          return {
            artifact: artifact ? _artifactDispatcher.ArtifactDispatcher.from(this, artifact) : void 0,
            entries
          };
        });
      }
      tracingStop(params) {
        return __async(this, null, function* () {
          yield this._object.stop();
        });
      }
    };
    exports2.TracingDispatcher = TracingDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/networkDispatchers.js
var require_networkDispatchers = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/networkDispatchers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocketDispatcher = exports2.RouteDispatcher = exports2.ResponseDispatcher = exports2.RequestDispatcher = exports2.APIRequestContextDispatcher = void 0;
    var _network = require_network2();
    var _dispatcher = require_dispatcher();
    var _tracingDispatcher = require_tracingDispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var _pageDispatcher = require_pageDispatcher();
    var RequestDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new RequestDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, "Request", {
          frame: _frameDispatcher.FrameDispatcher.fromNullable(scope, request.frame()),
          serviceWorker: _pageDispatcher.WorkerDispatcher.fromNullable(scope, request.serviceWorker()),
          url: request.url(),
          resourceType: request.resourceType(),
          method: request.method(),
          postData: postData === null ? void 0 : postData,
          headers: request.headers(),
          isNavigationRequest: request.isNavigationRequest(),
          redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
        });
        this._type_Request = void 0;
        this._type_Request = true;
      }
      rawRequestHeaders(params) {
        return __async(this, null, function* () {
          return {
            headers: yield this._object.rawRequestHeaders()
          };
        });
      }
      response() {
        return __async(this, null, function* () {
          return {
            response: ResponseDispatcher.fromNullable(this.parentScope(), yield this._object.response())
          };
        });
      }
    };
    exports2.RequestDispatcher = RequestDispatcher;
    var ResponseDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, response) {
        const result = (0, _dispatcher.existingDispatcher)(response);
        return result || new ResponseDispatcher(scope, response);
      }
      static fromNullable(scope, response) {
        return response ? ResponseDispatcher.from(scope, response) : void 0;
      }
      constructor(scope, response) {
        super(scope, response, "Response", {
          request: RequestDispatcher.from(scope, response.request()),
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          headers: response.headers(),
          timing: response.timing(),
          fromServiceWorker: response.fromServiceWorker()
        });
        this._type_Response = true;
      }
      body() {
        return __async(this, null, function* () {
          return {
            binary: yield this._object.body()
          };
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return {
            value: (yield this._object.securityDetails()) || void 0
          };
        });
      }
      serverAddr() {
        return __async(this, null, function* () {
          return {
            value: (yield this._object.serverAddr()) || void 0
          };
        });
      }
      rawResponseHeaders(params) {
        return __async(this, null, function* () {
          return {
            headers: yield this._object.rawResponseHeaders()
          };
        });
      }
      sizes(params) {
        return __async(this, null, function* () {
          return {
            sizes: yield this._object.sizes()
          };
        });
      }
    };
    exports2.ResponseDispatcher = ResponseDispatcher;
    var RouteDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, route) {
        const result = (0, _dispatcher.existingDispatcher)(route);
        return result || new RouteDispatcher(scope, route);
      }
      constructor(scope, route) {
        super(scope, route, "Route", {
          request: scope
        });
        this._type_Route = true;
      }
      continue(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.continue({
            url: params.url,
            method: params.method,
            headers: params.headers,
            postData: params.postData,
            isFallback: params.isFallback
          });
        });
      }
      fulfill(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.fulfill(params);
        });
      }
      abort(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.abort(params.errorCode || "failed");
        });
      }
      redirectNavigationRequest(params) {
        return __async(this, null, function* () {
          yield this._object.redirectNavigationRequest(params.url);
        });
      }
    };
    exports2.RouteDispatcher = RouteDispatcher;
    var WebSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, webSocket) {
        super(scope, webSocket, "WebSocket", {
          url: webSocket.url()
        });
        this._type_EventTarget = true;
        this._type_WebSocket = true;
        this.addObjectListener(_network.WebSocket.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
        this.addObjectListener(_network.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
        this.addObjectListener(_network.WebSocket.Events.SocketError, (error) => this._dispatchEvent("socketError", {
          error
        }));
        this.addObjectListener(_network.WebSocket.Events.Close, () => this._dispatchEvent("close", {}));
      }
    };
    exports2.WebSocketDispatcher = WebSocketDispatcher;
    var APIRequestContextDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new APIRequestContextDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? APIRequestContextDispatcher.from(scope, request) : void 0;
      }
      constructor(parentScope, request) {
        const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, request.tracing());
        super(parentScope, request, "APIRequestContext", {
          tracing
        });
        this._type_APIRequestContext = true;
        this.adopt(tracing);
      }
      storageState(params) {
        return __async(this, null, function* () {
          return this._object.storageState();
        });
      }
      dispose(params) {
        return __async(this, null, function* () {
          yield this._object.dispose();
        });
      }
      fetch(params, metadata) {
        return __async(this, null, function* () {
          const fetchResponse = yield this._object.fetch(params, metadata);
          return {
            response: {
              url: fetchResponse.url,
              status: fetchResponse.status,
              statusText: fetchResponse.statusText,
              headers: fetchResponse.headers,
              fetchUid: fetchResponse.fetchUid
            }
          };
        });
      }
      fetchResponseBody(params) {
        return __async(this, null, function* () {
          return {
            binary: this._object.fetchResponses.get(params.fetchUid)
          };
        });
      }
      fetchLog(params) {
        return __async(this, null, function* () {
          const log = this._object.fetchLog.get(params.fetchUid) || [];
          return {
            log
          };
        });
      }
      disposeAPIResponse(params) {
        return __async(this, null, function* () {
          this._object.disposeResponse(params.fetchUid);
        });
      }
    };
    exports2.APIRequestContextDispatcher = APIRequestContextDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/frameDispatcher.js
var require_frameDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/frameDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FrameDispatcher = void 0;
    var _frames = require_frames();
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _utils = require_utils();
    var _path = _interopRequireDefault(require("path"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FrameDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, frame) {
        const result = (0, _dispatcher.existingDispatcher)(frame);
        return result || new FrameDispatcher(scope, frame);
      }
      static fromNullable(scope, frame) {
        if (!frame)
          return;
        return FrameDispatcher.from(scope, frame);
      }
      constructor(scope, frame) {
        super(scope, frame, "Frame", {
          url: frame.url(),
          name: frame.name(),
          parentFrame: FrameDispatcher.fromNullable(scope, frame.parentFrame()),
          loadStates: Array.from(frame._firedLifecycleEvents)
        });
        this._type_Frame = true;
        this._frame = void 0;
        this._frame = frame;
        this.addObjectListener(_frames.Frame.Events.AddLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            add: lifecycleEvent
          });
        });
        this.addObjectListener(_frames.Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            remove: lifecycleEvent
          });
        });
        this.addObjectListener(_frames.Frame.Events.InternalNavigation, (event) => {
          if (!event.isPublic)
            return;
          const params = {
            url: event.url,
            name: event.name,
            error: event.error ? event.error.message : void 0
          };
          if (event.newDocument)
            params.newDocument = {
              request: _networkDispatchers.RequestDispatcher.fromNullable(this.parentScope().parentScope(), event.newDocument.request || null)
            };
          this._dispatchEvent("navigated", params);
        });
      }
      goto(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope().parentScope(), yield this._frame.goto(metadata, params.url, params))
          };
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), yield this._frame.frameElement())
          };
        });
      }
      evaluateExpression(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evaluateExpression(params.expression, {
              isFunction: params.isFunction,
              exposeUtilityScript: params.exposeUtilityScript
            }, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), yield this._frame.evaluateExpressionHandle(params.expression, {
              isFunction: params.isFunction
            }, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      waitForSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this.parentScope(), yield this._frame.waitForSelector(metadata, params.selector, params))
          };
        });
      }
      dispatchEvent(params, metadata) {
        return __async(this, null, function* () {
          return this._frame.dispatchEvent(metadata, params.selector, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit), params);
        });
      }
      evalOnSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evalOnSelector(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evalOnSelectorAll(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evalOnSelectorAll(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      querySelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this.parentScope(), yield this._frame.querySelector(params.selector, params))
          };
        });
      }
      querySelectorAll(params, metadata) {
        return __async(this, null, function* () {
          const elements = yield this._frame.querySelectorAll(params.selector);
          return {
            elements: elements.map((e) => _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), e))
          };
        });
      }
      queryCount(params) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.queryCount(params.selector)
          };
        });
      }
      content() {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.content()
          };
        });
      }
      setContent(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.setContent(metadata, params.html, params);
        });
      }
      addScriptTag(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), yield this._frame.addScriptTag(params))
          };
        });
      }
      addStyleTag(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this.parentScope(), yield this._frame.addStyleTag(params))
          };
        });
      }
      click(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.click(metadata, params.selector, params);
        });
      }
      dblclick(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.dblclick(metadata, params.selector, params);
        });
      }
      dragAndDrop(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.dragAndDrop(metadata, params.source, params.target, params);
        });
      }
      tap(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.tap(metadata, params.selector, params);
        });
      }
      fill(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.fill(metadata, params.selector, params.value, params);
        });
      }
      focus(params, metadata) {
        return __async(this, null, function* () {
          yield this._frame.focus(metadata, params.selector, params);
        });
      }
      blur(params, metadata) {
        return __async(this, null, function* () {
          yield this._frame.blur(metadata, params.selector, params);
        });
      }
      textContent(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.textContent(metadata, params.selector, params);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      innerText(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.innerText(metadata, params.selector, params)
          };
        });
      }
      innerHTML(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.innerHTML(metadata, params.selector, params)
          };
        });
      }
      getAttribute(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.getAttribute(metadata, params.selector, params.name, params);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      inputValue(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.inputValue(metadata, params.selector, params);
          return {
            value
          };
        });
      }
      isChecked(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isChecked(metadata, params.selector, params)
          };
        });
      }
      isDisabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isDisabled(metadata, params.selector, params)
          };
        });
      }
      isEditable(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isEditable(metadata, params.selector, params)
          };
        });
      }
      isEnabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isEnabled(metadata, params.selector, params)
          };
        });
      }
      isHidden(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isHidden(metadata, params.selector, params)
          };
        });
      }
      isVisible(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isVisible(metadata, params.selector, params)
          };
        });
      }
      hover(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.hover(metadata, params.selector, params);
        });
      }
      selectOption(params, metadata) {
        return __async(this, null, function* () {
          const elements = (params.elements || []).map((e) => e._elementHandle);
          return {
            values: yield this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)
          };
        });
      }
      setInputFiles(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.setInputFiles(metadata, params.selector, {
            files: params.files
          }, params);
        });
      }
      setInputFilePaths(params, metadata) {
        return __async(this, null, function* () {
          let {
            localPaths
          } = params;
          if (!localPaths) {
            if (!params.streams)
              throw new Error("Neither localPaths nor streams is specified");
            localPaths = params.streams.map((c) => c.path());
          }
          for (const p of localPaths)
            (0, _utils.assert)(_path.default.isAbsolute(p) && _path.default.resolve(p) === p, "Paths provided to localPaths must be absolute and fully resolved.");
          return yield this._frame.setInputFiles(metadata, params.selector, {
            localPaths
          }, params);
        });
      }
      type(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.type(metadata, params.selector, params.text, params);
        });
      }
      press(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.press(metadata, params.selector, params.key, params);
        });
      }
      check(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.check(metadata, params.selector, params);
        });
      }
      uncheck(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.uncheck(metadata, params.selector, params);
        });
      }
      waitForTimeout(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.waitForTimeout(metadata, params.timeout);
        });
      }
      waitForFunction(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this.parentScope(), yield this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), params))
          };
        });
      }
      title(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.title()
          };
        });
      }
      highlight(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.highlight(params.selector);
        });
      }
      expect(params, metadata) {
        return __async(this, null, function* () {
          const expectedValue = params.expectedValue ? (0, _jsHandleDispatcher.parseArgument)(params.expectedValue) : void 0;
          const result = yield this._frame.expect(metadata, params.selector, __spreadProps(__spreadValues({}, params), {
            expectedValue
          }));
          if (result.received !== void 0)
            result.received = (0, _jsHandleDispatcher.serializeResult)(result.received);
          if (result.matches === params.isNot)
            metadata.error = {
              error: {
                name: "Expect",
                message: "Expect failed"
              }
            };
          return result;
        });
      }
    };
    exports2.FrameDispatcher = FrameDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/pageDispatcher.js
var require_pageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/pageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WorkerDispatcher = exports2.PageDispatcher = exports2.BindingCallDispatcher = void 0;
    var _page = require_page();
    var _dispatcher = require_dispatcher();
    var _serializers = require_serializers();
    var _frameDispatcher = require_frameDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _artifactDispatcher = require_artifactDispatcher();
    var _utils = require_utils();
    var PageDispatcher = class extends _dispatcher.Dispatcher {
      static from(parentScope, page) {
        return PageDispatcher.fromNullable(parentScope, page);
      }
      static fromNullable(parentScope, page) {
        if (!page)
          return void 0;
        const result = (0, _dispatcher.existingDispatcher)(page);
        return result || new PageDispatcher(parentScope, page);
      }
      constructor(parentScope, page) {
        const mainFrame = _frameDispatcher.FrameDispatcher.from(parentScope, page.mainFrame());
        super(parentScope, page, "Page", {
          mainFrame,
          viewportSize: page.viewportSize() || void 0,
          isClosed: page.isClosed(),
          opener: PageDispatcher.fromNullable(parentScope, page.opener())
        });
        this._type_EventTarget = true;
        this._type_Page = true;
        this._page = void 0;
        this._subscriptions = /* @__PURE__ */ new Set();
        this.adopt(mainFrame);
        this._page = page;
        this.addObjectListener(_page.Page.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        this.addObjectListener(_page.Page.Events.Crash, () => this._dispatchEvent("crash"));
        this.addObjectListener(_page.Page.Events.Download, (download) => {
          this._dispatchEvent("download", {
            url: download.url,
            suggestedFilename: download.suggestedFilename(),
            artifact: _artifactDispatcher.ArtifactDispatcher.from(parentScope, download.artifact)
          });
        });
        this.addObjectListener(_page.Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this, fileChooser.element()),
          isMultiple: fileChooser.isMultiple()
        }));
        this.addObjectListener(_page.Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
        this.addObjectListener(_page.Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
        this.addObjectListener(_page.Page.Events.PageError, (error) => this._dispatchEvent("pageError", {
          error: (0, _serializers.serializeError)(error)
        }));
        this.addObjectListener(_page.Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", {
          webSocket: new _networkDispatchers.WebSocketDispatcher(this, webSocket)
        }));
        this.addObjectListener(_page.Page.Events.Worker, (worker) => this._dispatchEvent("worker", {
          worker: new WorkerDispatcher(this, worker)
        }));
        this.addObjectListener(_page.Page.Events.Video, (artifact) => this._dispatchEvent("video", {
          artifact: _artifactDispatcher.ArtifactDispatcher.from(parentScope, artifact)
        }));
        if (page._video)
          this._dispatchEvent("video", {
            artifact: _artifactDispatcher.ArtifactDispatcher.from(this.parentScope(), page._video)
          });
        const frames = page._frameManager.frames();
        for (let i = 1; i < frames.length; i++)
          this._onFrameAttached(frames[i]);
      }
      page() {
        return this._page;
      }
      setDefaultNavigationTimeoutNoReply(params, metadata) {
        return __async(this, null, function* () {
          this._page.setDefaultNavigationTimeout(params.timeout);
        });
      }
      setDefaultTimeoutNoReply(params, metadata) {
        return __async(this, null, function* () {
          this._page.setDefaultTimeout(params.timeout);
        });
      }
      exposeBinding(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            if (this._disposed)
              return;
            const binding = new BindingCallDispatcher(this, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent("bindingCall", {
              binding
            });
            return binding.promise();
          });
        });
      }
      setExtraHTTPHeaders(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setExtraHTTPHeaders(params.headers);
        });
      }
      reload(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope(), yield this._page.reload(metadata, params))
          };
        });
      }
      goBack(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope(), yield this._page.goBack(metadata, params))
          };
        });
      }
      goForward(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: _networkDispatchers.ResponseDispatcher.fromNullable(this.parentScope(), yield this._page.goForward(metadata, params))
          };
        });
      }
      emulateMedia(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.emulateMedia({
            media: params.media,
            colorScheme: params.colorScheme,
            reducedMotion: params.reducedMotion,
            forcedColors: params.forcedColors
          });
        });
      }
      setViewportSize(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setViewportSize(params.viewportSize);
        });
      }
      addInitScript(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.addInitScript(params.source);
        });
      }
      setNetworkInterceptionPatterns(params, metadata) {
        return __async(this, null, function* () {
          if (!params.patterns.length) {
            yield this._page.setClientRequestInterceptor(void 0);
            return;
          }
          const urlMatchers = params.patterns.map((pattern) => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);
          yield this._page.setClientRequestInterceptor((route, request) => {
            const matchesSome = urlMatchers.some((urlMatch) => (0, _utils.urlMatches)(this._page._browserContext._options.baseURL, request.url(), urlMatch));
            if (!matchesSome)
              return false;
            this._dispatchEvent("route", {
              route: _networkDispatchers.RouteDispatcher.from(_networkDispatchers.RequestDispatcher.from(this.parentScope(), request), route)
            });
            return true;
          });
        });
      }
      expectScreenshot(params, metadata) {
        return __async(this, null, function* () {
          var _params$screenshotOpt, _params$comparatorOpt;
          const mask = (((_params$screenshotOpt = params.screenshotOptions) === null || _params$screenshotOpt === void 0 ? void 0 : _params$screenshotOpt.mask) || []).map(({
            frame,
            selector
          }) => ({
            frame: frame._object,
            selector
          }));
          const locator = params.locator ? {
            frame: params.locator.frame._object,
            selector: params.locator.selector
          } : void 0;
          return yield this._page.expectScreenshot(metadata, __spreadProps(__spreadValues({}, params), {
            locator,
            comparatorOptions: __spreadProps(__spreadValues({}, params.comparatorOptions), {
              _comparator: (_params$comparatorOpt = params.comparatorOptions) === null || _params$comparatorOpt === void 0 ? void 0 : _params$comparatorOpt.comparator
            }),
            screenshotOptions: __spreadProps(__spreadValues({}, params.screenshotOptions), {
              mask
            })
          }));
        });
      }
      screenshot(params, metadata) {
        return __async(this, null, function* () {
          const mask = (params.mask || []).map(({
            frame,
            selector
          }) => ({
            frame: frame._object,
            selector
          }));
          return {
            binary: yield this._page.screenshot(metadata, __spreadProps(__spreadValues({}, params), {
              mask
            }))
          };
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.close(metadata, params);
        });
      }
      updateSubscription(params) {
        return __async(this, null, function* () {
          if (params.event === "fileChooser")
            yield this._page.setFileChooserIntercepted(params.enabled);
          if (params.enabled)
            this._subscriptions.add(params.event);
          else
            this._subscriptions.delete(params.event);
        });
      }
      keyboardDown(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.down(params.key);
        });
      }
      keyboardUp(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.up(params.key);
        });
      }
      keyboardInsertText(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.insertText(params.text);
        });
      }
      keyboardType(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.type(params.text, params);
        });
      }
      keyboardPress(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.press(params.key, params);
        });
      }
      mouseMove(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.move(params.x, params.y, params);
        });
      }
      mouseDown(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.down(params);
        });
      }
      mouseUp(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.up(params);
        });
      }
      mouseClick(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.click(params.x, params.y, params);
        });
      }
      mouseWheel(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.wheel(params.deltaX, params.deltaY);
        });
      }
      touchscreenTap(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.touchscreen.tap(params.x, params.y);
        });
      }
      accessibilitySnapshot(params, metadata) {
        return __async(this, null, function* () {
          const rootAXNode = yield this._page.accessibility.snapshot({
            interestingOnly: params.interestingOnly,
            root: params.root ? params.root._elementHandle : void 0
          });
          return {
            rootAXNode: rootAXNode || void 0
          };
        });
      }
      pdf(params, metadata) {
        return __async(this, null, function* () {
          if (!this._page.pdf)
            throw new Error("PDF generation is only supported for Headless Chromium");
          const buffer = yield this._page.pdf(params);
          return {
            pdf: buffer
          };
        });
      }
      bringToFront(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.bringToFront();
        });
      }
      startJSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          yield coverage.startJSCoverage(params);
        });
      }
      stopJSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          return yield coverage.stopJSCoverage();
        });
      }
      startCSSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          yield coverage.startCSSCoverage(params);
        });
      }
      stopCSSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          return yield coverage.stopCSSCoverage();
        });
      }
      _onFrameAttached(frame) {
        this._dispatchEvent("frameAttached", {
          frame: _frameDispatcher.FrameDispatcher.from(this, frame)
        });
      }
      _onFrameDetached(frame) {
        this._dispatchEvent("frameDetached", {
          frame: _frameDispatcher.FrameDispatcher.from(this, frame)
        });
      }
      _onDispose() {
        if (!this._page.isClosedOrClosingOrCrashed())
          this._page.setClientRequestInterceptor(void 0).catch(() => {
          });
      }
    };
    exports2.PageDispatcher = PageDispatcher;
    var WorkerDispatcher = class extends _dispatcher.Dispatcher {
      static fromNullable(scope, worker) {
        if (!worker)
          return void 0;
        const result = (0, _dispatcher.existingDispatcher)(worker);
        return result || new WorkerDispatcher(scope, worker);
      }
      constructor(scope, worker) {
        super(scope, worker, "Worker", {
          url: worker.url()
        });
        this._type_Worker = true;
        this.addObjectListener(_page.Worker.Events.Close, () => this._dispatchEvent("close"));
      }
      evaluateExpression(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._object.evaluateExpression(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this, yield this._object.evaluateExpressionHandle(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
    };
    exports2.WorkerDispatcher = WorkerDispatcher;
    var BindingCallDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, name, needsHandle, source, args) {
        super(scope, {
          guid: "bindingCall@" + (0, _utils.createGuid)()
        }, "BindingCall", {
          frame: _frameDispatcher.FrameDispatcher.from(scope, source.frame),
          name,
          args: needsHandle ? void 0 : args.map(_jsHandleDispatcher.serializeResult),
          handle: needsHandle ? _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : void 0
        });
        this._type_BindingCall = true;
        this._resolve = void 0;
        this._reject = void 0;
        this._promise = void 0;
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      promise() {
        return this._promise;
      }
      resolve(params, metadata) {
        return __async(this, null, function* () {
          this._resolve((0, _jsHandleDispatcher.parseArgument)(params.result));
        });
      }
      reject(params, metadata) {
        return __async(this, null, function* () {
          this._reject((0, _serializers.parseError)(params.error));
        });
      }
    };
    exports2.BindingCallDispatcher = BindingCallDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/cdpSessionDispatcher.js
var require_cdpSessionDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/cdpSessionDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CDPSessionDispatcher = void 0;
    var _crConnection = require_crConnection();
    var _dispatcher = require_dispatcher();
    var CDPSessionDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, crSession) {
        super(scope, crSession, "CDPSession", {});
        this._type_CDPSession = true;
        crSession._eventListener = (method, params) => {
          this._dispatchEvent("event", {
            method,
            params
          });
        };
        this.addObjectListener(_crConnection.CRSessionEvents.Disconnected, () => this._dispose());
      }
      send(params) {
        return __async(this, null, function* () {
          return {
            result: yield this._object.send(params.method, params.params)
          };
        });
      }
      detach() {
        return __async(this, null, function* () {
          return this._object.detach();
        });
      }
    };
    exports2.CDPSessionDispatcher = CDPSessionDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/writableStreamDispatcher.js
var require_writableStreamDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/writableStreamDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WritableStreamDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var WritableStreamDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, stream) {
        super(scope, {
          guid: "writableStream@" + (0, _utils.createGuid)(),
          stream
        }, "WritableStream", {});
        this._type_WritableStream = true;
      }
      write(params) {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          yield new Promise((fulfill, reject) => {
            stream.write(params.binary, (error) => {
              if (error)
                reject(error);
              else
                fulfill();
            });
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          yield new Promise((fulfill) => stream.end(fulfill));
        });
      }
      path() {
        return this._object.stream.path;
      }
    };
    exports2.WritableStreamDispatcher = WritableStreamDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/consoleMessageDispatcher.js
var require_consoleMessageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/consoleMessageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessageDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ConsoleMessageDispatcher = class extends _dispatcher.Dispatcher {
      constructor(page, message) {
        super(page, message, "ConsoleMessage", {
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(page, a)),
          location: message.location(),
          page
        });
        this._type_ConsoleMessage = true;
      }
    };
    exports2.ConsoleMessageDispatcher = ConsoleMessageDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/dialogDispatcher.js
var require_dialogDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/dialogDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DialogDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _pageDispatcher = require_pageDispatcher();
    var DialogDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, dialog) {
        const page = _pageDispatcher.PageDispatcher.fromNullable(scope, dialog.page().initializedOrUndefined());
        super(page || scope, dialog, "Dialog", {
          page,
          type: dialog.type(),
          message: dialog.message(),
          defaultValue: dialog.defaultValue()
        });
        this._type_Dialog = true;
      }
      accept(params) {
        return __async(this, null, function* () {
          yield this._object.accept(params.promptText);
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          yield this._object.dismiss();
        });
      }
    };
    exports2.DialogDispatcher = DialogDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/browserContextDispatcher.js
var require_browserContextDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/browserContextDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContextDispatcher = void 0;
    var _browserContext = require_browserContext();
    var _dispatcher = require_dispatcher();
    var _pageDispatcher = require_pageDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _crBrowser = require_crBrowser();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _recorder = require_recorder();
    var _artifactDispatcher = require_artifactDispatcher();
    var _tracingDispatcher = require_tracingDispatcher();
    var fs = _interopRequireWildcard(require("fs"));
    var path = _interopRequireWildcard(require("path"));
    var _utils = require_utils();
    var _writableStreamDispatcher = require_writableStreamDispatcher();
    var _consoleMessageDispatcher = require_consoleMessageDispatcher();
    var _dialogDispatcher = require_dialogDispatcher();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContextDispatcher = class extends _dispatcher.Dispatcher {
      constructor(parentScope, context) {
        const requestContext = _networkDispatchers.APIRequestContextDispatcher.from(parentScope, context.fetchRequest);
        const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, context.tracing);
        super(parentScope, context, "BrowserContext", {
          isChromium: context._browser.options.isChromium,
          requestContext,
          tracing
        });
        this._type_EventTarget = true;
        this._type_BrowserContext = true;
        this._context = void 0;
        this._subscriptions = /* @__PURE__ */ new Set();
        this.adopt(requestContext);
        this.adopt(tracing);
        this._context = context;
        const onVideo = (artifact) => {
          const artifactDispatcher = _artifactDispatcher.ArtifactDispatcher.from(parentScope, artifact);
          this._dispatchEvent("video", {
            artifact: artifactDispatcher
          });
        };
        this.addObjectListener(_browserContext.BrowserContext.Events.VideoStarted, onVideo);
        for (const video of context._browser._idToVideo.values()) {
          if (video.context === context)
            onVideo(video.artifact);
        }
        for (const page of context.pages())
          this._dispatchEvent("page", {
            page: _pageDispatcher.PageDispatcher.from(this, page)
          });
        this.addObjectListener(_browserContext.BrowserContext.Events.Page, (page) => {
          this._dispatchEvent("page", {
            page: _pageDispatcher.PageDispatcher.from(this, page)
          });
        });
        this.addObjectListener(_browserContext.BrowserContext.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        this.addObjectListener(_browserContext.BrowserContext.Events.Console, (message) => {
          if (this._shouldDispatchEvent(message.page(), "console"))
            this._dispatchEvent("console", {
              message: new _consoleMessageDispatcher.ConsoleMessageDispatcher(_pageDispatcher.PageDispatcher.from(this, message.page()), message)
            });
        });
        this.addObjectListener(_browserContext.BrowserContext.Events.Dialog, (dialog) => {
          if (this._shouldDispatchEvent(dialog.page(), "dialog"))
            this._dispatchEvent("dialog", {
              dialog: new _dialogDispatcher.DialogDispatcher(this, dialog)
            });
          else
            dialog.close().catch(() => {
            });
        });
        if (context._browser.options.name === "chromium") {
          for (const page of context.backgroundPages())
            this._dispatchEvent("backgroundPage", {
              page: _pageDispatcher.PageDispatcher.from(this, page)
            });
          this.addObjectListener(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", {
            page: _pageDispatcher.PageDispatcher.from(this, page)
          }));
          for (const serviceWorker of context.serviceWorkers())
            this._dispatchEvent("serviceWorker", {
              worker: new _pageDispatcher.WorkerDispatcher(this, serviceWorker)
            });
          this.addObjectListener(_crBrowser.CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", {
            worker: new _pageDispatcher.WorkerDispatcher(this, serviceWorker)
          }));
        }
        this.addObjectListener(_browserContext.BrowserContext.Events.Request, (request) => {
          var _request$frame;
          const redirectFromDispatcher = request.redirectedFrom() && (0, _dispatcher.existingDispatcher)(request.redirectedFrom());
          if (!redirectFromDispatcher && !this._shouldDispatchNetworkEvent(request, "request") && !request.isNavigationRequest())
            return;
          const requestDispatcher = _networkDispatchers.RequestDispatcher.from(this, request);
          this._dispatchEvent("request", {
            request: requestDispatcher,
            page: _pageDispatcher.PageDispatcher.fromNullable(this, (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page.initializedOrUndefined())
          });
        });
        this.addObjectListener(_browserContext.BrowserContext.Events.Response, (response) => {
          var _response$frame;
          const requestDispatcher = (0, _dispatcher.existingDispatcher)(response.request());
          if (!requestDispatcher && !this._shouldDispatchNetworkEvent(response.request(), "response"))
            return;
          this._dispatchEvent("response", {
            response: _networkDispatchers.ResponseDispatcher.from(this, response),
            page: _pageDispatcher.PageDispatcher.fromNullable(this, (_response$frame = response.frame()) === null || _response$frame === void 0 ? void 0 : _response$frame._page.initializedOrUndefined())
          });
        });
        this.addObjectListener(_browserContext.BrowserContext.Events.RequestFailed, (request) => {
          var _request$frame2;
          const requestDispatcher = (0, _dispatcher.existingDispatcher)(request);
          if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request, "requestFailed"))
            return;
          this._dispatchEvent("requestFailed", {
            request: _networkDispatchers.RequestDispatcher.from(this, request),
            failureText: request._failureText || void 0,
            responseEndTiming: request._responseEndTiming,
            page: _pageDispatcher.PageDispatcher.fromNullable(this, (_request$frame2 = request.frame()) === null || _request$frame2 === void 0 ? void 0 : _request$frame2._page.initializedOrUndefined())
          });
        });
        this.addObjectListener(_browserContext.BrowserContext.Events.RequestFinished, ({
          request,
          response
        }) => {
          var _request$frame3;
          const requestDispatcher = (0, _dispatcher.existingDispatcher)(request);
          if (!requestDispatcher && !this._shouldDispatchNetworkEvent(request, "requestFinished"))
            return;
          this._dispatchEvent("requestFinished", {
            request: _networkDispatchers.RequestDispatcher.from(this, request),
            response: _networkDispatchers.ResponseDispatcher.fromNullable(this, response),
            responseEndTiming: request._responseEndTiming,
            page: _pageDispatcher.PageDispatcher.fromNullable(this, (_request$frame3 = request.frame()) === null || _request$frame3 === void 0 ? void 0 : _request$frame3._page.initializedOrUndefined())
          });
        });
      }
      _shouldDispatchNetworkEvent(request, event) {
        var _request$frame4, _request$frame4$_page;
        return this._shouldDispatchEvent((_request$frame4 = request.frame()) === null || _request$frame4 === void 0 ? void 0 : (_request$frame4$_page = _request$frame4._page) === null || _request$frame4$_page === void 0 ? void 0 : _request$frame4$_page.initializedOrUndefined(), event);
      }
      _shouldDispatchEvent(page, event) {
        if (this._subscriptions.has(event))
          return true;
        const pageDispatcher = page ? (0, _dispatcher.existingDispatcher)(page) : void 0;
        if (pageDispatcher !== null && pageDispatcher !== void 0 && pageDispatcher._subscriptions.has(event))
          return true;
        return false;
      }
      createTempFile(params) {
        return __async(this, null, function* () {
          const dir = this._context._browser.options.artifactsDir;
          const tmpDir = path.join(dir, "upload-" + (0, _utils.createGuid)());
          yield fs.promises.mkdir(tmpDir);
          this._context._tempDirs.push(tmpDir);
          const file = fs.createWriteStream(path.join(tmpDir, params.name));
          return {
            writableStream: new _writableStreamDispatcher.WritableStreamDispatcher(this, file)
          };
        });
      }
      setDefaultNavigationTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._context.setDefaultNavigationTimeout(params.timeout);
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._context.setDefaultTimeout(params.timeout);
        });
      }
      exposeBinding(params) {
        return __async(this, null, function* () {
          yield this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            if (this._disposed)
              return;
            const pageDispatcher = _pageDispatcher.PageDispatcher.from(this, source.page);
            const binding = new _pageDispatcher.BindingCallDispatcher(pageDispatcher, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent("bindingCall", {
              binding
            });
            return binding.promise();
          });
        });
      }
      newPage(params, metadata) {
        return __async(this, null, function* () {
          return {
            page: _pageDispatcher.PageDispatcher.from(this, yield this._context.newPage(metadata))
          };
        });
      }
      cookies(params) {
        return __async(this, null, function* () {
          return {
            cookies: yield this._context.cookies(params.urls)
          };
        });
      }
      addCookies(params) {
        return __async(this, null, function* () {
          yield this._context.addCookies(params.cookies);
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._context.clearCookies();
        });
      }
      grantPermissions(params) {
        return __async(this, null, function* () {
          yield this._context.grantPermissions(params.permissions, params.origin);
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          yield this._context.clearPermissions();
        });
      }
      setGeolocation(params) {
        return __async(this, null, function* () {
          yield this._context.setGeolocation(params.geolocation);
        });
      }
      setExtraHTTPHeaders(params) {
        return __async(this, null, function* () {
          yield this._context.setExtraHTTPHeaders(params.headers);
        });
      }
      setOffline(params) {
        return __async(this, null, function* () {
          yield this._context.setOffline(params.offline);
        });
      }
      setHTTPCredentials(params) {
        return __async(this, null, function* () {
          yield this._context.setHTTPCredentials(params.httpCredentials);
        });
      }
      addInitScript(params) {
        return __async(this, null, function* () {
          yield this._context.addInitScript(params.source);
        });
      }
      setNetworkInterceptionPatterns(params) {
        return __async(this, null, function* () {
          if (!params.patterns.length) {
            yield this._context.setRequestInterceptor(void 0);
            return;
          }
          const urlMatchers = params.patterns.map((pattern) => pattern.regexSource ? new RegExp(pattern.regexSource, pattern.regexFlags) : pattern.glob);
          yield this._context.setRequestInterceptor((route, request) => {
            const matchesSome = urlMatchers.some((urlMatch) => (0, _utils.urlMatches)(this._context._options.baseURL, request.url(), urlMatch));
            if (!matchesSome)
              return false;
            this._dispatchEvent("route", {
              route: _networkDispatchers.RouteDispatcher.from(_networkDispatchers.RequestDispatcher.from(this, request), route)
            });
            return true;
          });
        });
      }
      storageState(params, metadata) {
        return __async(this, null, function* () {
          return yield this._context.storageState();
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          yield this._context.close(metadata);
        });
      }
      recorderSupplementEnable(params) {
        return __async(this, null, function* () {
          yield _recorder.Recorder.show(this._context, params);
        });
      }
      pause(params, metadata) {
        return __async(this, null, function* () {
        });
      }
      newCDPSession(params) {
        return __async(this, null, function* () {
          if (!this._object._browser.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          if (!params.page && !params.frame || params.page && params.frame)
            throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
          const crBrowserContext = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this, yield crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))
          };
        });
      }
      harStart(params) {
        return __async(this, null, function* () {
          const harId = yield this._context._harStart(params.page ? params.page._object : null, params.options);
          return {
            harId
          };
        });
      }
      harExport(params) {
        return __async(this, null, function* () {
          const artifact = yield this._context._harExport(params.harId);
          if (!artifact)
            throw new Error("No HAR artifact. Ensure record.harPath is set.");
          return {
            artifact: _artifactDispatcher.ArtifactDispatcher.from(this, artifact)
          };
        });
      }
      updateSubscription(params) {
        return __async(this, null, function* () {
          if (params.enabled)
            this._subscriptions.add(params.event);
          else
            this._subscriptions.delete(params.event);
        });
      }
      _onDispose() {
        if (!this._context.isClosingOrClosed())
          this._context.setRequestInterceptor(void 0).catch(() => {
          });
      }
    };
    exports2.BrowserContextDispatcher = BrowserContextDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/androidDispatcher.js
var require_androidDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/androidDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidSocketDispatcher = exports2.AndroidDispatcher = exports2.AndroidDeviceDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _android = require_android();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var AndroidDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, android) {
        super(scope, android, "Android", {});
        this._type_Android = true;
      }
      devices(params) {
        return __async(this, null, function* () {
          const devices = yield this._object.devices(params);
          return {
            devices: devices.map((d) => AndroidDeviceDispatcher.from(this, d))
          };
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._object.setDefaultTimeout(params.timeout);
        });
      }
    };
    exports2.AndroidDispatcher = AndroidDispatcher;
    var AndroidDeviceDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, device) {
        const result = (0, _dispatcher.existingDispatcher)(device);
        return result || new AndroidDeviceDispatcher(scope, device);
      }
      constructor(scope, device) {
        super(scope, device, "AndroidDevice", {
          model: device.model,
          serial: device.serial
        });
        this._type_EventTarget = true;
        this._type_AndroidDevice = true;
        for (const webView of device.webViews())
          this._dispatchEvent("webViewAdded", {
            webView
          });
        this.addObjectListener(_android.AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", {
          webView
        }));
        this.addObjectListener(_android.AndroidDevice.Events.WebViewRemoved, (socketName) => this._dispatchEvent("webViewRemoved", {
          socketName
        }));
        this.addObjectListener(_android.AndroidDevice.Events.Close, (socketName) => this._dispatchEvent("close"));
      }
      wait(params) {
        return __async(this, null, function* () {
          yield this._object.send("wait", params);
        });
      }
      fill(params) {
        return __async(this, null, function* () {
          yield this._object.send("click", {
            selector: params.selector
          });
          yield this._object.send("fill", params);
        });
      }
      tap(params) {
        return __async(this, null, function* () {
          yield this._object.send("click", params);
        });
      }
      drag(params) {
        return __async(this, null, function* () {
          yield this._object.send("drag", params);
        });
      }
      fling(params) {
        return __async(this, null, function* () {
          yield this._object.send("fling", params);
        });
      }
      longTap(params) {
        return __async(this, null, function* () {
          yield this._object.send("longClick", params);
        });
      }
      pinchClose(params) {
        return __async(this, null, function* () {
          yield this._object.send("pinchClose", params);
        });
      }
      pinchOpen(params) {
        return __async(this, null, function* () {
          yield this._object.send("pinchOpen", params);
        });
      }
      scroll(params) {
        return __async(this, null, function* () {
          yield this._object.send("scroll", params);
        });
      }
      swipe(params) {
        return __async(this, null, function* () {
          yield this._object.send("swipe", params);
        });
      }
      info(params) {
        return __async(this, null, function* () {
          return {
            info: yield this._object.send("info", params)
          };
        });
      }
      inputType(params) {
        return __async(this, null, function* () {
          const text = params.text;
          const keyCodes = [];
          for (let i = 0; i < text.length; ++i) {
            const code = keyMap.get(text[i].toUpperCase());
            if (code === void 0)
              throw new Error("No mapping for " + text[i] + " found");
            keyCodes.push(code);
          }
          yield Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", {
            keyCode
          })));
        });
      }
      inputPress(params) {
        return __async(this, null, function* () {
          if (!keyMap.has(params.key))
            throw new Error("Unknown key: " + params.key);
          yield this._object.send("inputPress", {
            keyCode: keyMap.get(params.key)
          });
        });
      }
      inputTap(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputClick", params);
        });
      }
      inputSwipe(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputSwipe", params);
        });
      }
      inputDrag(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputDrag", params);
        });
      }
      screenshot(params) {
        return __async(this, null, function* () {
          return {
            binary: yield this._object.screenshot()
          };
        });
      }
      shell(params) {
        return __async(this, null, function* () {
          return {
            result: yield this._object.shell(params.command)
          };
        });
      }
      open(params, metadata) {
        return __async(this, null, function* () {
          const socket = yield this._object.open(params.command);
          return {
            socket: new AndroidSocketDispatcher(this, socket)
          };
        });
      }
      installApk(params) {
        return __async(this, null, function* () {
          yield this._object.installApk(params.file, {
            args: params.args
          });
        });
      }
      push(params) {
        return __async(this, null, function* () {
          yield this._object.push(params.file, params.path, params.mode);
        });
      }
      launchBrowser(params) {
        return __async(this, null, function* () {
          const context = yield this._object.launchBrowser(params.pkg, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this, context)
          };
        });
      }
      close(params) {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._object.setDefaultTimeout(params.timeout);
        });
      }
      connectToWebView(params) {
        return __async(this, null, function* () {
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this, yield this._object.connectToWebView(params.socketName))
          };
        });
      }
    };
    exports2.AndroidDeviceDispatcher = AndroidDeviceDispatcher;
    var AndroidSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, socket) {
        super(scope, socket, "AndroidSocket", {});
        this._type_AndroidSocket = true;
        this.addObjectListener("data", (data) => this._dispatchEvent("data", {
          data
        }));
        this.addObjectListener("close", () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      write(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.write(params.data);
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          this._object.close();
        });
      }
    };
    exports2.AndroidSocketDispatcher = AndroidSocketDispatcher;
    var keyMap = /* @__PURE__ */ new Map([["Unknown", 0], ["SoftLeft", 1], ["SoftRight", 2], ["Home", 3], ["Back", 4], ["Call", 5], ["EndCall", 6], ["0", 7], ["1", 8], ["2", 9], ["3", 10], ["4", 11], ["5", 12], ["6", 13], ["7", 14], ["8", 15], ["9", 16], ["Star", 17], ["*", 17], ["Pound", 18], ["#", 18], ["DialUp", 19], ["DialDown", 20], ["DialLeft", 21], ["DialRight", 22], ["DialCenter", 23], ["VolumeUp", 24], ["VolumeDown", 25], ["Power", 26], ["Camera", 27], ["Clear", 28], ["A", 29], ["B", 30], ["C", 31], ["D", 32], ["E", 33], ["F", 34], ["G", 35], ["H", 36], ["I", 37], ["J", 38], ["K", 39], ["L", 40], ["M", 41], ["N", 42], ["O", 43], ["P", 44], ["Q", 45], ["R", 46], ["S", 47], ["T", 48], ["U", 49], ["V", 50], ["W", 51], ["X", 52], ["Y", 53], ["Z", 54], ["Comma", 55], [",", 55], ["Period", 56], [".", 56], ["AltLeft", 57], ["AltRight", 58], ["ShiftLeft", 59], ["ShiftRight", 60], ["Tab", 61], ["	", 61], ["Space", 62], [" ", 62], ["Sym", 63], ["Explorer", 64], ["Envelop", 65], ["Enter", 66], ["Del", 67], ["Grave", 68], ["Minus", 69], ["-", 69], ["Equals", 70], ["=", 70], ["LeftBracket", 71], ["(", 71], ["RightBracket", 72], [")", 72], ["Backslash", 73], ["\\", 73], ["Semicolon", 74], [";", 74], ["Apostrophe", 75], ["`", 75], ["Slash", 76], ["/", 76], ["At", 77], ["@", 77], ["Num", 78], ["HeadsetHook", 79], ["Focus", 80], ["Plus", 81], ["Menu", 82], ["Notification", 83], ["Search", 84], ["AppSwitch", 187], ["Assist", 219], ["Cut", 277], ["Copy", 278], ["Paste", 279]]);
  }
});

// node_modules/playwright-core/lib/server/dispatchers/browserDispatcher.js
var require_browserDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/browserDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConnectedBrowserDispatcher = exports2.BrowserDispatcher = void 0;
    var _browser = require_browser();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _dispatcher = require_dispatcher();
    var _instrumentation = require_instrumentation();
    var _browserContext = require_browserContext();
    var _selectors = require_selectors();
    var BrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        });
        this._type_Browser = true;
        this.addObjectListener(_browser.Browser.Events.Disconnected, () => this._didClose());
      }
      _didClose() {
        this._dispatchEvent("close");
        this._dispose();
      }
      newContext(params, metadata) {
        return __async(this, null, function* () {
          const context = yield this._object.newContext(metadata, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this, context)
          };
        });
      }
      newContextForReuse(params, metadata) {
        return __async(this, null, function* () {
          return yield newContextForReuse(this._object, this, params, null, metadata);
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
      killForTests() {
        return __async(this, null, function* () {
          yield this._object.killForTests();
        });
      }
      defaultUserAgentForTest() {
        return __async(this, null, function* () {
          return {
            userAgent: this._object.userAgent()
          };
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          const crBrowser = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this, yield crBrowser.newBrowserCDPSession())
          };
        });
      }
      startTracing(params) {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          yield crBrowser.startTracing(params.page ? params.page._object : void 0, params);
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          return {
            binary: yield crBrowser.stopTracing()
          };
        });
      }
    };
    exports2.BrowserDispatcher = BrowserDispatcher;
    var ConnectedBrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        });
        this._type_Browser = true;
        this._contexts = /* @__PURE__ */ new Set();
        this.selectors = void 0;
        this.selectors = new _selectors.Selectors();
      }
      newContext(params, metadata) {
        return __async(this, null, function* () {
          if (params.recordVideo)
            params.recordVideo.dir = this._object.options.artifactsDir;
          const context = yield this._object.newContext(metadata, params);
          this._contexts.add(context);
          context.setSelectors(this.selectors);
          context.on(_browserContext.BrowserContext.Events.Close, () => this._contexts.delete(context));
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this, context)
          };
        });
      }
      newContextForReuse(params, metadata) {
        return __async(this, null, function* () {
          return yield newContextForReuse(this._object, this, params, this.selectors, metadata);
        });
      }
      close() {
        return __async(this, null, function* () {
        });
      }
      killForTests() {
        return __async(this, null, function* () {
        });
      }
      defaultUserAgentForTest() {
        return __async(this, null, function* () {
          throw new Error("Client should not send us Browser.defaultUserAgentForTest");
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          const crBrowser = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this, yield crBrowser.newBrowserCDPSession())
          };
        });
      }
      startTracing(params) {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          yield crBrowser.startTracing(params.page ? params.page._object : void 0, params);
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          return {
            binary: yield crBrowser.stopTracing()
          };
        });
      }
      cleanupContexts() {
        return __async(this, null, function* () {
          yield Promise.all(Array.from(this._contexts).map((context) => context.close((0, _instrumentation.serverSideCallMetadata)())));
        });
      }
    };
    exports2.ConnectedBrowserDispatcher = ConnectedBrowserDispatcher;
    function newContextForReuse(browser, scope, params, selectors, metadata) {
      return __async(this, null, function* () {
        const {
          context,
          needsReset
        } = yield browser.newContextForReuse(params, metadata);
        if (needsReset) {
          const oldContextDispatcher = (0, _dispatcher.existingDispatcher)(context);
          if (oldContextDispatcher)
            oldContextDispatcher._dispose();
          yield context.resetForReuse(metadata, params);
        }
        if (selectors)
          context.setSelectors(selectors);
        const contextDispatcher = new _browserContextDispatcher.BrowserContextDispatcher(scope, context);
        return {
          context: contextDispatcher
        };
      });
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/browserTypeDispatcher.js
var require_browserTypeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/browserTypeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserTypeDispatcher = void 0;
    var _browserDispatcher = require_browserDispatcher();
    var _dispatcher = require_dispatcher();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var BrowserTypeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browserType) {
        super(scope, browserType, "BrowserType", {
          executablePath: browserType.executablePath(),
          name: browserType.name()
        });
        this._type_BrowserType = true;
      }
      launch(params, metadata) {
        return __async(this, null, function* () {
          const browser = yield this._object.launch(metadata, params);
          return {
            browser: new _browserDispatcher.BrowserDispatcher(this, browser)
          };
        });
      }
      launchPersistentContext(params, metadata) {
        return __async(this, null, function* () {
          const browserContext = yield this._object.launchPersistentContext(metadata, params.userDataDir, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this, browserContext)
          };
        });
      }
      connectOverCDP(params, metadata) {
        return __async(this, null, function* () {
          const browser = yield this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
          const browserDispatcher = new _browserDispatcher.BrowserDispatcher(this, browser);
          return {
            browser: browserDispatcher,
            defaultContext: browser._defaultContext ? new _browserContextDispatcher.BrowserContextDispatcher(browserDispatcher, browser._defaultContext) : void 0
          };
        });
      }
    };
    exports2.BrowserTypeDispatcher = BrowserTypeDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/electronDispatcher.js
var require_electronDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/electronDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronDispatcher = exports2.ElectronApplicationDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _electron = require_electron2();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ElectronDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electron) {
        super(scope, electron, "Electron", {});
        this._type_Electron = true;
      }
      launch(params) {
        return __async(this, null, function* () {
          const electronApplication = yield this._object.launch(params);
          return {
            electronApplication: new ElectronApplicationDispatcher(this, electronApplication)
          };
        });
      }
    };
    exports2.ElectronDispatcher = ElectronDispatcher;
    var ElectronApplicationDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electronApplication) {
        super(scope, electronApplication, "ElectronApplication", {
          context: new _browserContextDispatcher.BrowserContextDispatcher(scope, electronApplication.context())
        });
        this._type_EventTarget = true;
        this._type_ElectronApplication = true;
        this.addObjectListener(_electron.ElectronApplication.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      browserWindow(params) {
        return __async(this, null, function* () {
          const handle = yield this._object.browserWindow(params.page.page());
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this, handle)
          };
        });
      }
      evaluateExpression(params) {
        return __async(this, null, function* () {
          const handle = yield this._object._nodeElectronHandlePromise;
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield handle.evaluateExpression(params.expression, {
              isFunction: params.isFunction
            }, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params) {
        return __async(this, null, function* () {
          const handle = yield this._object._nodeElectronHandlePromise;
          const result = yield handle.evaluateExpressionHandle(params.expression, {
            isFunction: params.isFunction
          }, (0, _jsHandleDispatcher.parseArgument)(params.arg));
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this, result)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
    };
    exports2.ElectronApplicationDispatcher = ElectronApplicationDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/jsonPipeDispatcher.js
var require_jsonPipeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/jsonPipeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonPipeDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var _serializers = require_serializers();
    var JsonPipeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope) {
        super(scope, {
          guid: "jsonPipe@" + (0, _utils.createGuid)()
        }, "JsonPipe", {});
        this._type_JsonPipe = true;
      }
      send(params) {
        return __async(this, null, function* () {
          this.emit("message", params.message);
        });
      }
      close() {
        return __async(this, null, function* () {
          this.emit("close");
          if (!this._disposed) {
            this._dispatchEvent("closed", {});
            this._dispose();
          }
        });
      }
      dispatch(message) {
        if (!this._disposed)
          this._dispatchEvent("message", {
            message
          });
      }
      wasClosed(error) {
        if (!this._disposed) {
          const params = error ? {
            error: (0, _serializers.serializeError)(error)
          } : {};
          this._dispatchEvent("closed", params);
          this._dispose();
        }
      }
      dispose() {
        this._dispose();
      }
    };
    exports2.JsonPipeDispatcher = JsonPipeDispatcher;
  }
});

// node_modules/playwright-core/lib/server/socksInterceptor.js
var require_socksInterceptor = __commonJS({
  "node_modules/playwright-core/lib/server/socksInterceptor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SocksInterceptor = void 0;
    var socks = _interopRequireWildcard(require_socksProxy());
    var _events = _interopRequireDefault(require("events"));
    var _validator = require_validator();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var SocksInterceptor = class {
      constructor(transport, pattern, redirectPortForTest) {
        this._handler = void 0;
        this._channel = void 0;
        this._socksSupportObjectGuid = void 0;
        this._ids = /* @__PURE__ */ new Set();
        this._handler = new socks.SocksProxyHandler(pattern, redirectPortForTest);
        let lastId = -1;
        this._channel = new Proxy(new _events.default(), {
          get: (obj, prop) => {
            if (prop in obj || obj[prop] !== void 0 || typeof prop !== "string")
              return obj[prop];
            return (params) => {
              try {
                const id = --lastId;
                this._ids.add(id);
                const validator = (0, _validator.findValidator)("SocksSupport", prop, "Params");
                params = validator(params, "", {
                  tChannelImpl: tChannelForSocks,
                  binary: "toBase64"
                });
                transport.send({
                  id,
                  guid: this._socksSupportObjectGuid,
                  method: prop,
                  params,
                  metadata: {
                    stack: [],
                    apiName: "",
                    internal: true
                  }
                });
              } catch (e) {
              }
            };
          }
        });
        this._handler.on(socks.SocksProxyHandler.Events.SocksConnected, (payload) => this._channel.socksConnected(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksData, (payload) => this._channel.socksData(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksError, (payload) => this._channel.socksError(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksFailed, (payload) => this._channel.socksFailed(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksEnd, (payload) => this._channel.socksEnd(payload));
        this._channel.on("socksRequested", (payload) => this._handler.socketRequested(payload));
        this._channel.on("socksClosed", (payload) => this._handler.socketClosed(payload));
        this._channel.on("socksData", (payload) => this._handler.sendSocketData(payload));
      }
      cleanup() {
        this._handler.cleanup();
      }
      interceptMessage(message) {
        if (this._ids.has(message.id)) {
          this._ids.delete(message.id);
          return true;
        }
        if (message.method === "__create__" && message.params.type === "SocksSupport") {
          this._socksSupportObjectGuid = message.params.guid;
          return false;
        }
        if (this._socksSupportObjectGuid && message.guid === this._socksSupportObjectGuid) {
          const validator = (0, _validator.findValidator)("SocksSupport", message.method, "Event");
          const params = validator(message.params, "", {
            tChannelImpl: tChannelForSocks,
            binary: "fromBase64"
          });
          this._channel.emit(message.method, params);
          return true;
        }
        return false;
      }
    };
    exports2.SocksInterceptor = SocksInterceptor;
    function tChannelForSocks(names, arg, path, context) {
      throw new _validator.ValidationError(`${path}: channels are not expected in SocksSupport`);
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/localUtilsDispatcher.js
var require_localUtilsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/localUtilsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LocalUtilsDispatcher = void 0;
    exports2.urlToWSEndpoint = urlToWSEndpoint;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _os = _interopRequireDefault(require("os"));
    var _manualPromise = require_manualPromise();
    var _utils = require_utils();
    var _dispatcher = require_dispatcher();
    var _zipBundle = require_zipBundle();
    var _zipFile = require_zipFile();
    var _jsonPipeDispatcher = require_jsonPipeDispatcher();
    var _transport = require_transport2();
    var _socksInterceptor = require_socksInterceptor();
    var _userAgent = require_userAgent();
    var _progress = require_progress();
    var _network = require_network();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LocalUtilsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, playwright) {
        const localUtils = new _instrumentation.SdkObject(playwright, "localUtils", "localUtils");
        super(scope, localUtils, "LocalUtils", {});
        this._type_LocalUtils = void 0;
        this._harBackends = /* @__PURE__ */ new Map();
        this._stackSessions = /* @__PURE__ */ new Map();
        this._type_LocalUtils = true;
      }
      zip(params) {
        return __async(this, null, function* () {
          const promise = new _manualPromise.ManualPromise();
          const zipFile = new _zipBundle.yazl.ZipFile();
          zipFile.on("error", (error) => promise.reject(error));
          const addFile = (file, name) => {
            try {
              if (_fs.default.statSync(file).isFile())
                zipFile.addFile(file, name);
            } catch (e) {
            }
          };
          for (const entry of params.entries)
            addFile(entry.value, entry.name);
          const stackSession = params.stacksId ? this._stackSessions.get(params.stacksId) : void 0;
          if (stackSession !== null && stackSession !== void 0 && stackSession.callStacks.length) {
            yield stackSession.writer;
            if (process.env.PW_LIVE_TRACE_STACKS) {
              zipFile.addFile(stackSession.file, "trace.stacks");
            } else {
              const buffer = Buffer.from(JSON.stringify((0, _utils.serializeClientSideCallMetadata)(stackSession.callStacks)));
              zipFile.addBuffer(buffer, "trace.stacks");
            }
          }
          if (params.includeSources) {
            const sourceFiles = /* @__PURE__ */ new Set();
            for (const {
              stack
            } of (stackSession === null || stackSession === void 0 ? void 0 : stackSession.callStacks) || []) {
              if (!stack)
                continue;
              for (const {
                file
              } of stack)
                sourceFiles.add(file);
            }
            for (const sourceFile of sourceFiles)
              addFile(sourceFile, "resources/src@" + (0, _utils.calculateSha1)(sourceFile) + ".txt");
          }
          if (params.mode === "write") {
            yield _fs.default.promises.mkdir(_path.default.dirname(params.zipFile), {
              recursive: true
            });
            zipFile.end(void 0, () => {
              zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on("close", () => promise.resolve()).on("error", (error) => promise.reject(error));
            });
            yield promise;
            yield this._deleteStackSession(params.stacksId);
            return;
          }
          const tempFile = params.zipFile + ".tmp";
          yield _fs.default.promises.rename(params.zipFile, tempFile);
          _zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
            if (err) {
              promise.reject(err);
              return;
            }
            (0, _utils.assert)(inZipFile);
            let pendingEntries = inZipFile.entryCount;
            inZipFile.on("entry", (entry) => {
              inZipFile.openReadStream(entry, (err2, readStream) => {
                if (err2) {
                  promise.reject(err2);
                  return;
                }
                zipFile.addReadStream(readStream, entry.fileName);
                if (--pendingEntries === 0) {
                  zipFile.end(void 0, () => {
                    zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on("close", () => {
                      _fs.default.promises.unlink(tempFile).then(() => {
                        promise.resolve();
                      });
                    });
                  });
                }
              });
            });
          });
          yield promise;
          yield this._deleteStackSession(params.stacksId);
        });
      }
      harOpen(params, metadata) {
        return __async(this, null, function* () {
          let harBackend;
          if (params.file.endsWith(".zip")) {
            const zipFile = new _zipFile.ZipFile(params.file);
            const entryNames = yield zipFile.entries();
            const harEntryName = entryNames.find((e) => e.endsWith(".har"));
            if (!harEntryName)
              return {
                error: "Specified archive does not have a .har file"
              };
            const har = yield zipFile.read(harEntryName);
            const harFile = JSON.parse(har.toString());
            harBackend = new HarBackend(harFile, null, zipFile);
          } else {
            const harFile = JSON.parse(yield _fs.default.promises.readFile(params.file, "utf-8"));
            harBackend = new HarBackend(harFile, _path.default.dirname(params.file), null);
          }
          this._harBackends.set(harBackend.id, harBackend);
          return {
            harId: harBackend.id
          };
        });
      }
      harLookup(params, metadata) {
        return __async(this, null, function* () {
          const harBackend = this._harBackends.get(params.harId);
          if (!harBackend)
            return {
              action: "error",
              message: `Internal error: har was not opened`
            };
          return yield harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest);
        });
      }
      harClose(params, metadata) {
        return __async(this, null, function* () {
          const harBackend = this._harBackends.get(params.harId);
          if (harBackend) {
            this._harBackends.delete(harBackend.id);
            harBackend.dispose();
          }
        });
      }
      harUnzip(params, metadata) {
        return __async(this, null, function* () {
          const dir = _path.default.dirname(params.zipFile);
          const zipFile = new _zipFile.ZipFile(params.zipFile);
          for (const entry of yield zipFile.entries()) {
            const buffer = yield zipFile.read(entry);
            if (entry === "har.har")
              yield _fs.default.promises.writeFile(params.harFile, buffer);
            else
              yield _fs.default.promises.writeFile(_path.default.join(dir, entry), buffer);
          }
          zipFile.close();
          yield _fs.default.promises.unlink(params.zipFile);
        });
      }
      connect(params, metadata) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this._object);
          controller.setLogName("browser");
          return yield controller.run((progress2) => __async(this, null, function* () {
            var _params$exposeNetwork;
            const wsHeaders = __spreadValues({
              "User-Agent": (0, _userAgent.getUserAgent)(),
              "x-playwright-proxy": (_params$exposeNetwork = params.exposeNetwork) !== null && _params$exposeNetwork !== void 0 ? _params$exposeNetwork : ""
            }, params.headers);
            const wsEndpoint = yield urlToWSEndpoint(progress2, params.wsEndpoint);
            const transport = yield _transport.WebSocketTransport.connect(progress2, wsEndpoint, wsHeaders, true, "x-playwright-debug-log");
            const socksInterceptor = new _socksInterceptor.SocksInterceptor(transport, params.exposeNetwork, params.socksProxyRedirectPortForTest);
            const pipe = new _jsonPipeDispatcher.JsonPipeDispatcher(this);
            transport.onmessage = (json) => {
              if (socksInterceptor.interceptMessage(json))
                return;
              const cb = () => {
                try {
                  pipe.dispatch(json);
                } catch (e) {
                  transport.close();
                }
              };
              if (params.slowMo)
                setTimeout(cb, params.slowMo);
              else
                cb();
            };
            pipe.on("message", (message) => {
              transport.send(message);
            });
            transport.onclose = () => {
              socksInterceptor === null || socksInterceptor === void 0 ? void 0 : socksInterceptor.cleanup();
              pipe.wasClosed();
            };
            pipe.on("close", () => transport.close());
            return {
              pipe,
              headers: transport.headers
            };
          }), params.timeout || 0);
        });
      }
      tracingStarted(params, metadata) {
        return __async(this, null, function* () {
          let tmpDir = void 0;
          if (!params.tracesDir)
            tmpDir = yield _fs.default.promises.mkdtemp(_path.default.join(_os.default.tmpdir(), "playwright-tracing-"));
          const traceStacksFile = _path.default.join(params.tracesDir || tmpDir, params.traceName + ".stacks");
          this._stackSessions.set(traceStacksFile, {
            callStacks: [],
            file: traceStacksFile,
            writer: Promise.resolve(),
            tmpDir
          });
          return {
            stacksId: traceStacksFile
          };
        });
      }
      traceDiscarded(params, metadata) {
        return __async(this, null, function* () {
          yield this._deleteStackSession(params.stacksId);
        });
      }
      addStackToTracingNoReply(params, metadata) {
        return __async(this, null, function* () {
          for (const session of this._stackSessions.values()) {
            session.callStacks.push(params.callData);
            if (process.env.PW_LIVE_TRACE_STACKS) {
              session.writer = session.writer.then(() => {
                const buffer = Buffer.from(JSON.stringify((0, _utils.serializeClientSideCallMetadata)(session.callStacks)));
                return _fs.default.promises.writeFile(session.file, buffer);
              });
            }
          }
        });
      }
      _deleteStackSession(stacksId) {
        return __async(this, null, function* () {
          const session = stacksId ? this._stackSessions.get(stacksId) : void 0;
          if (!session)
            return;
          yield session.writer;
          if (session.tmpDir)
            yield (0, _utils.removeFolders)([session.tmpDir]);
          this._stackSessions.delete(stacksId);
        });
      }
    };
    exports2.LocalUtilsDispatcher = LocalUtilsDispatcher;
    var redirectStatus = [301, 302, 303, 307, 308];
    var HarBackend = class {
      constructor(harFile, baseDir, zipFile) {
        this.id = (0, _utils.createGuid)();
        this._harFile = void 0;
        this._zipFile = void 0;
        this._baseDir = void 0;
        this._harFile = harFile;
        this._baseDir = baseDir;
        this._zipFile = zipFile;
      }
      lookup(url, method, headers, postData, isNavigationRequest) {
        return __async(this, null, function* () {
          let entry;
          try {
            entry = yield this._harFindResponse(url, method, headers, postData);
          } catch (e) {
            return {
              action: "error",
              message: "HAR error: " + e.message
            };
          }
          if (!entry)
            return {
              action: "noentry"
            };
          if (entry.request.url !== url && isNavigationRequest)
            return {
              action: "redirect",
              redirectURL: entry.request.url
            };
          const response = entry.response;
          try {
            const buffer = yield this._loadContent(response.content);
            return {
              action: "fulfill",
              status: response.status,
              headers: response.headers,
              body: buffer
            };
          } catch (e) {
            return {
              action: "error",
              message: e.message
            };
          }
        });
      }
      _loadContent(content) {
        return __async(this, null, function* () {
          const file = content._file;
          let buffer;
          if (file) {
            if (this._zipFile)
              buffer = yield this._zipFile.read(file);
            else
              buffer = yield _fs.default.promises.readFile(_path.default.resolve(this._baseDir, file));
          } else {
            buffer = Buffer.from(content.text || "", content.encoding === "base64" ? "base64" : "utf-8");
          }
          return buffer;
        });
      }
      _harFindResponse(url, method, headers, postData) {
        return __async(this, null, function* () {
          const harLog = this._harFile.log;
          const visited = /* @__PURE__ */ new Set();
          while (true) {
            const entries = [];
            for (const candidate of harLog.entries) {
              if (candidate.request.url !== url || candidate.request.method !== method)
                continue;
              if (method === "POST" && postData && candidate.request.postData) {
                const buffer = yield this._loadContent(candidate.request.postData);
                if (!buffer.equals(postData))
                  continue;
              }
              entries.push(candidate);
            }
            if (!entries.length)
              return;
            let entry = entries[0];
            if (entries.length > 1) {
              const list = [];
              for (const candidate of entries) {
                const matchingHeaders = countMatchingHeaders(candidate.request.headers, headers);
                list.push({
                  candidate,
                  matchingHeaders
                });
              }
              list.sort((a, b) => b.matchingHeaders - a.matchingHeaders);
              entry = list[0].candidate;
            }
            if (visited.has(entry))
              throw new Error(`Found redirect cycle for ${url}`);
            visited.add(entry);
            const locationHeader = entry.response.headers.find((h) => h.name.toLowerCase() === "location");
            if (redirectStatus.includes(entry.response.status) && locationHeader) {
              const locationURL = new URL(locationHeader.value, url);
              url = locationURL.toString();
              if ((entry.response.status === 301 || entry.response.status === 302) && method === "POST" || entry.response.status === 303 && !["GET", "HEAD"].includes(method)) {
                method = "GET";
              }
              continue;
            }
            return entry;
          }
        });
      }
      dispose() {
        var _this$_zipFile;
        (_this$_zipFile = this._zipFile) === null || _this$_zipFile === void 0 ? void 0 : _this$_zipFile.close();
      }
    };
    function countMatchingHeaders(harHeaders, headers) {
      const set = new Set(headers.map((h) => h.name.toLowerCase() + ":" + h.value));
      let matches = 0;
      for (const h of harHeaders) {
        if (set.has(h.name.toLowerCase() + ":" + h.value))
          ++matches;
      }
      return matches;
    }
    function urlToWSEndpoint(progress2, endpointURL) {
      return __async(this, null, function* () {
        var _progress$timeUntilDe;
        if (endpointURL.startsWith("ws"))
          return endpointURL;
        progress2 === null || progress2 === void 0 ? void 0 : progress2.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
        const fetchUrl = new URL(endpointURL);
        if (!fetchUrl.pathname.endsWith("/"))
          fetchUrl.pathname += "/";
        fetchUrl.pathname += "json";
        const json = yield (0, _network.fetchData)({
          url: fetchUrl.toString(),
          method: "GET",
          timeout: (_progress$timeUntilDe = progress2 === null || progress2 === void 0 ? void 0 : progress2.timeUntilDeadline()) !== null && _progress$timeUntilDe !== void 0 ? _progress$timeUntilDe : 3e4,
          headers: {
            "User-Agent": (0, _userAgent.getUserAgent)()
          }
        }, (params, response) => __async(this, null, function* () {
          return new Error(`Unexpected status ${response.statusCode} when connecting to ${fetchUrl.toString()}.
This does not look like a Playwright server, try connecting via ws://.`);
        }));
        progress2 === null || progress2 === void 0 ? void 0 : progress2.throwIfAborted();
        const wsUrl = new URL(endpointURL);
        let wsEndpointPath = JSON.parse(json).wsEndpointPath;
        if (wsEndpointPath.startsWith("/"))
          wsEndpointPath = wsEndpointPath.substring(1);
        if (!wsUrl.pathname.endsWith("/"))
          wsUrl.pathname += "/";
        wsUrl.pathname += wsEndpointPath;
        wsUrl.protocol = wsUrl.protocol === "https:" ? "wss:" : "ws:";
        return wsUrl.toString();
      });
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/selectorsDispatcher.js
var require_selectorsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/selectorsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SelectorsDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var SelectorsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, selectors) {
        super(scope, selectors, "Selectors", {});
        this._type_Selectors = true;
      }
      register(params) {
        return __async(this, null, function* () {
          yield this._object.register(params.name, params.source, params.contentScript);
        });
      }
      setTestIdAttributeName(params) {
        return __async(this, null, function* () {
          this._object.setTestIdAttributeName(params.testIdAttributeName);
        });
      }
    };
    exports2.SelectorsDispatcher = SelectorsDispatcher;
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptors.js
var require_deviceDescriptors = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptors.js"(exports2, module2) {
    module2.exports = require_deviceDescriptorsSource();
  }
});

// node_modules/playwright-core/lib/server/dispatchers/playwrightDispatcher.js
var require_playwrightDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/playwrightDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightDispatcher = void 0;
    var _fetch = require_fetch();
    var _socksProxy = require_socksProxy();
    var _androidDispatcher = require_androidDispatcher();
    var _browserTypeDispatcher = require_browserTypeDispatcher();
    var _dispatcher = require_dispatcher();
    var _electronDispatcher = require_electronDispatcher();
    var _localUtilsDispatcher = require_localUtilsDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _selectorsDispatcher = require_selectorsDispatcher();
    var _browserDispatcher = require_browserDispatcher();
    var _utils = require_utils();
    var _eventsHelper = require_eventsHelper();
    var PlaywrightDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, playwright, socksProxy, preLaunchedBrowser, prelaunchedAndroidDevice) {
        const descriptors = require_deviceDescriptors();
        const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({
          name,
          descriptor
        }));
        const browserDispatcher = preLaunchedBrowser ? new _browserDispatcher.ConnectedBrowserDispatcher(scope, preLaunchedBrowser) : void 0;
        const android = new _androidDispatcher.AndroidDispatcher(scope, playwright.android);
        const prelaunchedAndroidDeviceDispatcher = prelaunchedAndroidDevice ? new _androidDispatcher.AndroidDeviceDispatcher(android, prelaunchedAndroidDevice) : void 0;
        super(scope, playwright, "Playwright", {
          chromium: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.chromium),
          firefox: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.firefox),
          webkit: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.webkit),
          android,
          electron: new _electronDispatcher.ElectronDispatcher(scope, playwright.electron),
          utils: new _localUtilsDispatcher.LocalUtilsDispatcher(scope, playwright),
          deviceDescriptors,
          selectors: new _selectorsDispatcher.SelectorsDispatcher(scope, (browserDispatcher === null || browserDispatcher === void 0 ? void 0 : browserDispatcher.selectors) || playwright.selectors),
          preLaunchedBrowser: browserDispatcher,
          preConnectedAndroidDevice: prelaunchedAndroidDeviceDispatcher,
          socksSupport: socksProxy ? new SocksSupportDispatcher(scope, socksProxy) : void 0
        });
        this._type_Playwright = void 0;
        this._browserDispatcher = void 0;
        this._type_Playwright = true;
        this._browserDispatcher = browserDispatcher;
      }
      newRequest(params) {
        return __async(this, null, function* () {
          const request = new _fetch.GlobalAPIRequestContext(this._object, params);
          return {
            request: _networkDispatchers.APIRequestContextDispatcher.from(this.parentScope(), request)
          };
        });
      }
      cleanup() {
        return __async(this, null, function* () {
          var _this$_browserDispatc;
          yield (_this$_browserDispatc = this._browserDispatcher) === null || _this$_browserDispatc === void 0 ? void 0 : _this$_browserDispatc.cleanupContexts();
        });
      }
    };
    exports2.PlaywrightDispatcher = PlaywrightDispatcher;
    var SocksSupportDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, socksProxy) {
        super(scope, {
          guid: "socksSupport@" + (0, _utils.createGuid)()
        }, "SocksSupport", {});
        this._type_SocksSupport = void 0;
        this._socksProxy = void 0;
        this._socksListeners = void 0;
        this._type_SocksSupport = true;
        this._socksProxy = socksProxy;
        this._socksListeners = [_eventsHelper.eventsHelper.addEventListener(socksProxy, _socksProxy.SocksProxy.Events.SocksRequested, (payload) => this._dispatchEvent("socksRequested", payload)), _eventsHelper.eventsHelper.addEventListener(socksProxy, _socksProxy.SocksProxy.Events.SocksData, (payload) => this._dispatchEvent("socksData", payload)), _eventsHelper.eventsHelper.addEventListener(socksProxy, _socksProxy.SocksProxy.Events.SocksClosed, (payload) => this._dispatchEvent("socksClosed", payload))];
      }
      socksConnected(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy;
          (_this$_socksProxy = this._socksProxy) === null || _this$_socksProxy === void 0 ? void 0 : _this$_socksProxy.socketConnected(params);
        });
      }
      socksFailed(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy2;
          (_this$_socksProxy2 = this._socksProxy) === null || _this$_socksProxy2 === void 0 ? void 0 : _this$_socksProxy2.socketFailed(params);
        });
      }
      socksData(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy3;
          (_this$_socksProxy3 = this._socksProxy) === null || _this$_socksProxy3 === void 0 ? void 0 : _this$_socksProxy3.sendSocketData(params);
        });
      }
      socksError(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy4;
          (_this$_socksProxy4 = this._socksProxy) === null || _this$_socksProxy4 === void 0 ? void 0 : _this$_socksProxy4.sendSocketError(params);
        });
      }
      socksEnd(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy5;
          (_this$_socksProxy5 = this._socksProxy) === null || _this$_socksProxy5 === void 0 ? void 0 : _this$_socksProxy5.sendSocketEnd(params);
        });
      }
      _onDispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._socksListeners);
      }
    };
  }
});

// node_modules/playwright-core/lib/server/trace/viewer/traceViewer.js
var require_traceViewer = __commonJS({
  "node_modules/playwright-core/lib/server/trace/viewer/traceViewer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.openTraceInBrowser = openTraceInBrowser;
    exports2.openTraceViewerApp = openTraceViewerApp;
    var _path = _interopRequireDefault(require("path"));
    var _fs = _interopRequireDefault(require("fs"));
    var _httpServer = require_httpServer();
    var _registry = require_registry();
    var _utils = require_utils();
    var _crApp = require_crApp();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _progress = require_progress();
    var _utilsBundle = require_utilsBundle();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function startTraceViewerServer(traceUrls, options) {
      return __async(this, null, function* () {
        for (const traceUrl of traceUrls) {
          let traceFile = traceUrl;
          if (traceUrl.endsWith(".json"))
            traceFile = traceUrl.substring(0, traceUrl.length - ".json".length);
          if (!traceUrl.startsWith("http://") && !traceUrl.startsWith("https://") && !_fs.default.existsSync(traceFile) && !_fs.default.existsSync(traceFile + ".trace")) {
            console.error(`Trace file ${traceUrl} does not exist!`);
            process.exit(1);
          }
        }
        const server = new _httpServer.HttpServer();
        server.routePrefix("/trace", (request, response) => {
          const url2 = new URL("http://localhost" + request.url);
          const relativePath = url2.pathname.slice("/trace".length);
          if (relativePath.endsWith("/stall.js"))
            return true;
          if (relativePath.startsWith("/file")) {
            try {
              const filePath = url2.searchParams.get("path");
              if (_fs.default.existsSync(filePath))
                return server.serveFile(request, response, url2.searchParams.get("path"));
              if (filePath.endsWith(".json")) {
                const traceName = filePath.substring(0, filePath.length - ".json".length);
                response.statusCode = 200;
                response.setHeader("Content-Type", "application/json");
                response.end(JSON.stringify(traceDescriptor(traceName)));
                return true;
              }
            } catch (e) {
              return false;
            }
          }
          const absolutePath = _path.default.join(__dirname, "..", "..", "..", "webpack", "traceViewer", ...relativePath.split("/"));
          return server.serveFile(request, response, absolutePath);
        });
        const params = traceUrls.map((t) => `trace=${encodeURIComponent(t)}`);
        const transport = (options === null || options === void 0 ? void 0 : options.transport) || (options !== null && options !== void 0 && options.isServer ? new StdinServer() : void 0);
        if (transport) {
          const guid = (0, _utils.createGuid)();
          params.push("ws=" + guid);
          const wss = new _utilsBundle.wsServer({
            server: server.server(),
            path: "/" + guid
          });
          wss.on("connection", (ws2) => {
            transport.sendEvent = (method, params2) => ws2.send(JSON.stringify({
              method,
              params: params2
            }));
            transport.close = () => ws2.close();
            ws2.on("message", (message) => __async(this, null, function* () {
              const {
                id,
                method,
                params: params2
              } = JSON.parse(message);
              const result = yield transport.dispatch(method, params2);
              ws2.send(JSON.stringify({
                id,
                result
              }));
            }));
            ws2.on("close", () => transport.onclose());
            ws2.on("error", () => transport.onclose());
          });
        }
        if (options !== null && options !== void 0 && options.isServer)
          params.push("isServer");
        if ((0, _utils.isUnderTest)())
          params.push("isUnderTest=true");
        const {
          host,
          port
        } = options || {};
        const url = yield server.start({
          preferredPort: port,
          host
        });
        const {
          app
        } = options || {};
        const searchQuery = params.length ? "?" + params.join("&") : "";
        const urlPath = `/trace/${app || "index.html"}${searchQuery}`;
        server.routePath("/", (_, response) => {
          response.statusCode = 302;
          response.setHeader("Location", urlPath);
          response.end();
          return true;
        });
        return {
          server,
          url
        };
      });
    }
    function openTraceViewerApp(traceUrls, browserName, options) {
      return __async(this, null, function* () {
        const {
          url
        } = yield startTraceViewerServer(traceUrls, options);
        const traceViewerPlaywright = (0, _playwright.createPlaywright)({
          sdkLanguage: "javascript",
          isInternalPlaywright: true
        });
        const traceViewerBrowser = (0, _utils.isUnderTest)() ? "chromium" : browserName;
        const args = traceViewerBrowser === "chromium" ? ["--app=data:text/html,", "--window-size=1280,800", "--test-type="] : [];
        const context = yield traceViewerPlaywright[traceViewerBrowser].launchPersistentContext((0, _instrumentation.serverSideCallMetadata)(), "", {
          channel: (0, _registry.findChromiumChannel)(traceViewerPlaywright.options.sdkLanguage),
          args,
          noDefaultViewport: true,
          headless: options === null || options === void 0 ? void 0 : options.headless,
          ignoreDefaultArgs: ["--enable-automation"],
          colorScheme: "no-override",
          useWebSocket: (0, _utils.isUnderTest)()
        });
        const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), context._browser);
        yield controller.run((progress2) => __async(this, null, function* () {
          yield context._browser._defaultContext._loadDefaultContextAsIs(progress2);
        }));
        const [page] = context.pages();
        if (process.env.PWTEST_PRINT_WS_ENDPOINT)
          process.stderr.write("DevTools listening on: " + context._browser.options.wsEndpoint + "\n");
        if (traceViewerBrowser === "chromium")
          yield (0, _crApp.installAppIcon)(page);
        if (!(0, _utils.isUnderTest)())
          yield (0, _crApp.syncLocalStorageWithSettings)(page, "traceviewer");
        if ((0, _utils.isUnderTest)())
          page.on("close", () => context.close((0, _instrumentation.serverSideCallMetadata)()).catch(() => {
          }));
        yield page.mainFrame().goto((0, _instrumentation.serverSideCallMetadata)(), url);
        return page;
      });
    }
    function openTraceInBrowser(traceUrls, options) {
      return __async(this, null, function* () {
        const {
          url
        } = yield startTraceViewerServer(traceUrls, options);
        console.log("\nListening on " + url);
        yield (0, _utilsBundle.open)(url).catch(() => {
        });
      });
    }
    var StdinServer = class {
      constructor() {
        this._pollTimer = void 0;
        this._traceUrl = void 0;
        this.sendEvent = void 0;
        this.close = void 0;
        process.stdin.on("data", (data) => {
          const url = data.toString().trim();
          if (url === this._traceUrl)
            return;
          if (url.endsWith(".json"))
            this._pollLoadTrace(url);
          else
            this._loadTrace(url);
        });
        process.stdin.on("close", () => this._selfDestruct());
      }
      dispatch(method, params) {
        return __async(this, null, function* () {
          if (method === "ready") {
            if (this._traceUrl)
              this._loadTrace(this._traceUrl);
          }
        });
      }
      onclose() {
        this._selfDestruct();
      }
      _loadTrace(url) {
        var _this$sendEvent;
        this._traceUrl = url;
        clearTimeout(this._pollTimer);
        (_this$sendEvent = this.sendEvent) === null || _this$sendEvent === void 0 ? void 0 : _this$sendEvent.call(this, "loadTrace", {
          url
        });
      }
      _pollLoadTrace(url) {
        this._loadTrace(url);
        this._pollTimer = setTimeout(() => {
          this._pollLoadTrace(url);
        }, 500);
      }
      _selfDestruct() {
        setTimeout(() => process.exit(0), 3e4);
        (0, _utils.gracefullyCloseAll)().then(() => {
          process.exit(0);
        });
      }
    };
    function traceDescriptor(traceName) {
      const result = {
        entries: []
      };
      const traceDir = _path.default.dirname(traceName);
      const traceFile = _path.default.basename(traceName);
      for (const name of _fs.default.readdirSync(traceDir)) {
        if (name.startsWith(traceFile))
          result.entries.push({
            name,
            path: _path.default.join(traceDir, name)
          });
      }
      const resourcesDir = _path.default.join(traceDir, "resources");
      if (_fs.default.existsSync(resourcesDir)) {
        for (const name of _fs.default.readdirSync(resourcesDir))
          result.entries.push({
            name: "resources/" + name,
            path: _path.default.join(resourcesDir, name)
          });
      }
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/index.js
var require_server = __commonJS({
  "node_modules/playwright-core/lib/server/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DispatcherConnection", {
      enumerable: true,
      get: function() {
        return _dispatcher.DispatcherConnection;
      }
    });
    Object.defineProperty(exports2, "PlaywrightDispatcher", {
      enumerable: true,
      get: function() {
        return _playwrightDispatcher.PlaywrightDispatcher;
      }
    });
    Object.defineProperty(exports2, "Registry", {
      enumerable: true,
      get: function() {
        return _registry.Registry;
      }
    });
    Object.defineProperty(exports2, "RootDispatcher", {
      enumerable: true,
      get: function() {
        return _dispatcher.RootDispatcher;
      }
    });
    Object.defineProperty(exports2, "createPlaywright", {
      enumerable: true,
      get: function() {
        return _playwright.createPlaywright;
      }
    });
    Object.defineProperty(exports2, "installBrowsersForNpmInstall", {
      enumerable: true,
      get: function() {
        return _registry.installBrowsersForNpmInstall;
      }
    });
    Object.defineProperty(exports2, "installDefaultBrowsersForNpmInstall", {
      enumerable: true,
      get: function() {
        return _registry.installDefaultBrowsersForNpmInstall;
      }
    });
    Object.defineProperty(exports2, "openTraceInBrowser", {
      enumerable: true,
      get: function() {
        return _traceViewer.openTraceInBrowser;
      }
    });
    Object.defineProperty(exports2, "openTraceViewerApp", {
      enumerable: true,
      get: function() {
        return _traceViewer.openTraceViewerApp;
      }
    });
    Object.defineProperty(exports2, "registry", {
      enumerable: true,
      get: function() {
        return _registry.registry;
      }
    });
    Object.defineProperty(exports2, "registryDirectory", {
      enumerable: true,
      get: function() {
        return _registry.registryDirectory;
      }
    });
    Object.defineProperty(exports2, "serverSideCallMetadata", {
      enumerable: true,
      get: function() {
        return _instrumentation.serverSideCallMetadata;
      }
    });
    Object.defineProperty(exports2, "writeDockerVersion", {
      enumerable: true,
      get: function() {
        return _registry.writeDockerVersion;
      }
    });
    var _registry = require_registry();
    var _dispatcher = require_dispatcher();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _playwright = require_playwright();
    var _traceViewer = require_traceViewer();
    var _instrumentation = require_instrumentation();
  }
});

// node_modules/playwright-core/lib/client/accessibility.js
var require_accessibility2 = __commonJS({
  "node_modules/playwright-core/lib/client/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Accessibility = void 0;
    function axNodeFromProtocol(axNode) {
      const result = __spreadProps(__spreadValues({}, axNode), {
        value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
        checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
        pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
        children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
      });
      delete result.valueNumber;
      delete result.valueString;
      return result;
    }
    var Accessibility = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      snapshot() {
        return __async(this, arguments, function* (options = {}) {
          const root = options.root ? options.root._elementChannel : void 0;
          const result = yield this._channel.accessibilitySnapshot({
            interestingOnly: options.interestingOnly,
            root
          });
          return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
        });
      }
    };
    exports2.Accessibility = Accessibility;
  }
});

// node_modules/playwright-core/lib/client/channelOwner.js
var require_channelOwner = __commonJS({
  "node_modules/playwright-core/lib/client/channelOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ChannelOwner = void 0;
    var _events = require("events");
    var _validator = require_validator();
    var _debugLogger = require_debugLogger();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var _zones = require_zones();
    var ChannelOwner = class extends _events.EventEmitter {
      constructor(parent, type, guid, initializer) {
        super();
        this._connection = void 0;
        this._parent = void 0;
        this._objects = /* @__PURE__ */ new Map();
        this._type = void 0;
        this._guid = void 0;
        this._channel = void 0;
        this._initializer = void 0;
        this._logger = void 0;
        this._instrumentation = void 0;
        this._eventToSubscriptionMapping = /* @__PURE__ */ new Map();
        this.setMaxListeners(0);
        this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
        this._type = type;
        this._guid = guid;
        this._parent = parent instanceof ChannelOwner ? parent : void 0;
        this._instrumentation = this._connection._instrumentation;
        this._connection._objects.set(guid, this);
        if (this._parent) {
          this._parent._objects.set(guid, this);
          this._logger = this._parent._logger;
        }
        this._channel = this._createChannel(new _events.EventEmitter());
        this._initializer = initializer;
      }
      _setEventToSubscriptionMapping(mapping) {
        this._eventToSubscriptionMapping = mapping;
      }
      _updateSubscription(event, enabled) {
        const protocolEvent = this._eventToSubscriptionMapping.get(String(event));
        if (protocolEvent) {
          this._wrapApiCall(() => __async(this, null, function* () {
            yield this._channel.updateSubscription({
              event: protocolEvent,
              enabled
            });
          }), true).catch(() => {
          });
        }
      }
      on(event, listener) {
        if (!this.listenerCount(event))
          this._updateSubscription(event, true);
        super.on(event, listener);
        return this;
      }
      addListener(event, listener) {
        if (!this.listenerCount(event))
          this._updateSubscription(event, true);
        super.addListener(event, listener);
        return this;
      }
      prependListener(event, listener) {
        if (!this.listenerCount(event))
          this._updateSubscription(event, true);
        super.prependListener(event, listener);
        return this;
      }
      off(event, listener) {
        super.off(event, listener);
        if (!this.listenerCount(event))
          this._updateSubscription(event, false);
        return this;
      }
      removeListener(event, listener) {
        super.removeListener(event, listener);
        if (!this.listenerCount(event))
          this._updateSubscription(event, false);
        return this;
      }
      _adopt(child) {
        child._parent._objects.delete(child._guid);
        this._objects.set(child._guid, child);
        child._parent = this;
      }
      _dispose() {
        if (this._parent)
          this._parent._objects.delete(this._guid);
        this._connection._objects.delete(this._guid);
        for (const object of [...this._objects.values()])
          object._dispose();
        this._objects.clear();
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
        };
      }
      _createChannel(base) {
        const channel = new Proxy(base, {
          get: (obj, prop) => {
            if (typeof prop === "string") {
              const validator = (0, _validator.maybeFindValidator)(this._type, prop, "Params");
              if (validator) {
                return (params) => {
                  return this._wrapApiCall((apiZone) => {
                    const {
                      stackTrace,
                      csi,
                      callCookie,
                      wallTime
                    } = apiZone.reported ? {
                      csi: void 0,
                      callCookie: void 0,
                      stackTrace: null,
                      wallTime: void 0
                    } : apiZone;
                    apiZone.reported = true;
                    if (csi && stackTrace && stackTrace.apiName)
                      csi.onApiCallBegin(stackTrace.apiName, params, stackTrace, wallTime, callCookie);
                    return this._connection.sendMessageToServer(this, this._type, prop, validator(params, "", {
                      tChannelImpl: tChannelImplToWire,
                      binary: this._connection.isRemote() ? "toBase64" : "buffer"
                    }), stackTrace, wallTime);
                  });
                };
              }
            }
            return obj[prop];
          }
        });
        channel._object = this;
        return channel;
      }
      _wrapApiCall(func, isInternal = false) {
        return __async(this, null, function* () {
          const logger = this._logger;
          const stack = (0, _stackTrace.captureRawStack)();
          const apiZone = _zones.zones.zoneData("apiZone", stack);
          if (apiZone)
            return func(apiZone);
          const stackTrace = (0, _stackTrace.captureLibraryStackTrace)(stack);
          isInternal = isInternal || this._type === "LocalUtils";
          if (isInternal)
            delete stackTrace.apiName;
          const expectZone = _zones.zones.zoneData("expectZone", stack);
          const wallTime = expectZone ? expectZone.wallTime : Date.now();
          if (!isInternal && expectZone)
            stackTrace.apiName = expectZone.title;
          const csi = isInternal ? void 0 : this._instrumentation;
          const callCookie = {};
          const {
            apiName,
            frameTexts
          } = stackTrace;
          try {
            logApiCall(logger, `=> ${apiName} started`, isInternal);
            const apiZone2 = {
              stackTrace,
              isInternal,
              reported: false,
              csi,
              callCookie,
              wallTime
            };
            const result = yield _zones.zones.run("apiZone", apiZone2, () => __async(this, null, function* () {
              return yield func(apiZone2);
            }));
            csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie);
            logApiCall(logger, `<= ${apiName} succeeded`, isInternal);
            return result;
          } catch (e) {
            const innerError = (process.env.PWDEBUGIMPL || (0, _utils.isUnderTest)()) && e.stack ? "\n<inner error>\n" + e.stack : "";
            if (apiName && !apiName.includes("<anonymous>"))
              e.message = apiName + ": " + e.message;
            const stackFrames = "\n" + frameTexts.join("\n") + innerError;
            if (stackFrames.trim())
              e.stack = e.message + stackFrames;
            else
              e.stack = "";
            csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie, e);
            logApiCall(logger, `<= ${apiName} failed`, isInternal);
            throw e;
          }
        });
      }
      _toImpl() {
        var _this$_connection$toI, _this$_connection;
        return (_this$_connection$toI = (_this$_connection = this._connection).toImpl) === null || _this$_connection$toI === void 0 ? void 0 : _this$_connection$toI.call(_this$_connection, this);
      }
      toJSON() {
        return {
          _type: this._type,
          _guid: this._guid
        };
      }
    };
    exports2.ChannelOwner = ChannelOwner;
    function logApiCall(logger, message, isNested) {
      if (isNested)
        return;
      if (logger && logger.isEnabled("api", "info"))
        logger.log("api", "info", message, [], {
          color: "cyan"
        });
      _debugLogger.debugLogger.log("api", message);
    }
    function tChannelImplToWire(names, arg, path, context) {
      if (arg._object instanceof ChannelOwner && (names === "*" || names.includes(arg._object._type)))
        return {
          guid: arg._object._guid
        };
      throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
    }
  }
});

// node_modules/playwright-core/lib/client/stream.js
var require_stream = __commonJS({
  "node_modules/playwright-core/lib/client/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Stream = void 0;
    var _stream = require("stream");
    var _channelOwner = require_channelOwner();
    var Stream = class extends _channelOwner.ChannelOwner {
      static from(Stream2) {
        return Stream2._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new StreamImpl(this._channel);
      }
    };
    exports2.Stream = Stream;
    var StreamImpl = class extends _stream.Readable {
      constructor(channel) {
        super();
        this._channel = void 0;
        this._channel = channel;
      }
      _read() {
        return __async(this, null, function* () {
          const result = yield this._channel.read({
            size: 1024 * 1024
          });
          if (result.binary.byteLength)
            this.push(result.binary);
          else
            this.push(null);
        });
      }
      _destroy(error, callback) {
        this._channel.close().catch((e) => null);
        super._destroy(error, callback);
      }
    };
  }
});

// node_modules/playwright-core/lib/client/artifact.js
var require_artifact2 = __commonJS({
  "node_modules/playwright-core/lib/client/artifact.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Artifact = void 0;
    var fs = _interopRequireWildcard(require("fs"));
    var _stream = require_stream();
    var _fileUtils = require_fileUtils();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Artifact = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      pathAfterFinished() {
        return __async(this, null, function* () {
          if (this._connection.isRemote())
            throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
          return (yield this._channel.pathAfterFinished()).value || null;
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          if (!this._connection.isRemote()) {
            yield this._channel.saveAs({
              path
            });
            return;
          }
          const result = yield this._channel.saveAsStream();
          const stream = _stream.Stream.from(result.stream);
          yield (0, _fileUtils.mkdirIfNeeded)(path);
          yield new Promise((resolve, reject) => {
            stream.stream().pipe(fs.createWriteStream(path)).on("finish", resolve).on("error", reject);
          });
        });
      }
      failure() {
        return __async(this, null, function* () {
          return (yield this._channel.failure()).error || null;
        });
      }
      createReadStream() {
        return __async(this, null, function* () {
          const result = yield this._channel.stream();
          if (!result.stream)
            return null;
          const stream = _stream.Stream.from(result.stream);
          return stream.stream();
        });
      }
      cancel() {
        return __async(this, null, function* () {
          return this._channel.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          return this._channel.delete();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/client/clientHelper.js
var require_clientHelper = __commonJS({
  "node_modules/playwright-core/lib/client/clientHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.envObjectToArray = envObjectToArray;
    exports2.evaluationScript = evaluationScript;
    var _fs = _interopRequireDefault(require("fs"));
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function envObjectToArray(env) {
      const result = [];
      for (const name in env) {
        if (!Object.is(env[name], void 0))
          result.push({
            name,
            value: String(env[name])
          });
      }
      return result;
    }
    function evaluationScript(fun, arg, addSourceUrl = true) {
      return __async(this, null, function* () {
        if (typeof fun === "function") {
          const source = fun.toString();
          const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
          return `(${source})(${argString})`;
        }
        if (arg !== void 0)
          throw new Error("Cannot evaluate a string with arguments");
        if ((0, _utils.isString)(fun))
          return fun;
        if (fun.content !== void 0)
          return fun.content;
        if (fun.path !== void 0) {
          let source = yield _fs.default.promises.readFile(fun.path, "utf8");
          if (addSourceUrl)
            source += "\n//# sourceURL=" + fun.path.replace(/\n/g, "");
          return source;
        }
        throw new Error("Either path or content property must be present");
      });
    }
  }
});

// node_modules/playwright-core/lib/client/coverage.js
var require_coverage = __commonJS({
  "node_modules/playwright-core/lib/client/coverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Coverage = void 0;
    var Coverage = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      startJSCoverage() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.startJSCoverage(options);
        });
      }
      stopJSCoverage() {
        return __async(this, null, function* () {
          return (yield this._channel.stopJSCoverage()).entries;
        });
      }
      startCSSCoverage() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.startCSSCoverage(options);
        });
      }
      stopCSSCoverage() {
        return __async(this, null, function* () {
          return (yield this._channel.stopCSSCoverage()).entries;
        });
      }
    };
    exports2.Coverage = Coverage;
  }
});

// node_modules/playwright-core/lib/client/download.js
var require_download2 = __commonJS({
  "node_modules/playwright-core/lib/client/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Download = void 0;
    var Download = class {
      constructor(page, url, suggestedFilename, artifact) {
        this._page = void 0;
        this._url = void 0;
        this._suggestedFilename = void 0;
        this._artifact = void 0;
        this._page = page;
        this._url = url;
        this._suggestedFilename = suggestedFilename;
        this._artifact = artifact;
      }
      page() {
        return this._page;
      }
      url() {
        return this._url;
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
      path() {
        return __async(this, null, function* () {
          return this._artifact.pathAfterFinished();
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          return this._artifact.saveAs(path);
        });
      }
      failure() {
        return __async(this, null, function* () {
          return this._artifact.failure();
        });
      }
      createReadStream() {
        return __async(this, null, function* () {
          return this._artifact.createReadStream();
        });
      }
      cancel() {
        return __async(this, null, function* () {
          return this._artifact.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          return this._artifact.delete();
        });
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright-core/lib/client/jsHandle.js
var require_jsHandle = __commonJS({
  "node_modules/playwright-core/lib/client/jsHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSHandle = void 0;
    exports2.assertMaxArguments = assertMaxArguments;
    exports2.parseResult = parseResult;
    exports2.serializeArgument = serializeArgument;
    var _channelOwner = require_channelOwner();
    var _serializers = require_serializers();
    var JSHandle = class extends _channelOwner.ChannelOwner {
      static from(handle) {
        return handle._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._preview = void 0;
        this._preview = this._initializer.preview;
        this._channel.on("previewUpdated", ({
          preview
        }) => this._preview = preview);
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return parseResult(result.value);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return JSHandle.from(result.handle);
        });
      }
      getProperty(propertyName) {
        return __async(this, null, function* () {
          const result = yield this._channel.getProperty({
            name: propertyName
          });
          return JSHandle.from(result.handle);
        });
      }
      getProperties() {
        return __async(this, null, function* () {
          const map = /* @__PURE__ */ new Map();
          for (const {
            name,
            value
          } of (yield this._channel.getPropertyList()).properties)
            map.set(name, JSHandle.from(value));
          return map;
        });
      }
      jsonValue() {
        return __async(this, null, function* () {
          return parseResult((yield this._channel.jsonValue()).value);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        return __async(this, null, function* () {
          return yield this._channel.dispose();
        });
      }
      _objectCount() {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const {
              count
            } = yield this._channel.objectCount();
            return count;
          }));
        });
      }
      toString() {
        return this._preview;
      }
    };
    exports2.JSHandle = JSHandle;
    function serializeArgument(arg) {
      const handles = [];
      const pushHandle = (channel) => {
        handles.push(channel);
        return handles.length - 1;
      };
      const value = (0, _serializers.serializeValue)(arg, (value2) => {
        if (value2 instanceof JSHandle)
          return {
            h: pushHandle(value2._channel)
          };
        return {
          fallThrough: value2
        };
      });
      return {
        value,
        handles
      };
    }
    function parseResult(value) {
      return (0, _serializers.parseSerializedValue)(value, void 0);
    }
    function assertMaxArguments(count, max) {
      if (count > max)
        throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
    }
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/locatorUtils.js
var require_locatorUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/locatorUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getByAltTextSelector = getByAltTextSelector;
    exports2.getByLabelSelector = getByLabelSelector;
    exports2.getByPlaceholderSelector = getByPlaceholderSelector;
    exports2.getByRoleSelector = getByRoleSelector;
    exports2.getByTestIdSelector = getByTestIdSelector;
    exports2.getByTextSelector = getByTextSelector;
    exports2.getByTitleSelector = getByTitleSelector;
    var _stringUtils = require_stringUtils();
    function getByAttributeTextSelector(attrName, text, options) {
      return `internal:attr=[${attrName}=${(0, _stringUtils.escapeForAttributeSelector)(text, (options === null || options === void 0 ? void 0 : options.exact) || false)}]`;
    }
    function getByTestIdSelector(testIdAttributeName, testId) {
      return `internal:testid=[${testIdAttributeName}=${(0, _stringUtils.escapeForAttributeSelector)(testId, true)}]`;
    }
    function getByLabelSelector(text, options) {
      return "internal:label=" + (0, _stringUtils.escapeForTextSelector)(text, !!(options !== null && options !== void 0 && options.exact));
    }
    function getByAltTextSelector(text, options) {
      return getByAttributeTextSelector("alt", text, options);
    }
    function getByTitleSelector(text, options) {
      return getByAttributeTextSelector("title", text, options);
    }
    function getByPlaceholderSelector(text, options) {
      return getByAttributeTextSelector("placeholder", text, options);
    }
    function getByTextSelector(text, options) {
      return "internal:text=" + (0, _stringUtils.escapeForTextSelector)(text, !!(options !== null && options !== void 0 && options.exact));
    }
    function getByRoleSelector(role, options = {}) {
      const props = [];
      if (options.checked !== void 0)
        props.push(["checked", String(options.checked)]);
      if (options.disabled !== void 0)
        props.push(["disabled", String(options.disabled)]);
      if (options.selected !== void 0)
        props.push(["selected", String(options.selected)]);
      if (options.expanded !== void 0)
        props.push(["expanded", String(options.expanded)]);
      if (options.includeHidden !== void 0)
        props.push(["include-hidden", String(options.includeHidden)]);
      if (options.level !== void 0)
        props.push(["level", String(options.level)]);
      if (options.name !== void 0)
        props.push(["name", (0, _stringUtils.isString)(options.name) ? (0, _stringUtils.escapeForAttributeSelector)(options.name, !!options.exact) : String(options.name)]);
      if (options.pressed !== void 0)
        props.push(["pressed", String(options.pressed)]);
      return `internal:role=${role}${props.map(([n, v]) => `[${n}=${v}]`).join("")}`;
    }
  }
});

// node_modules/playwright-core/lib/client/locator.js
var require_locator = __commonJS({
  "node_modules/playwright-core/lib/client/locator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Locator = exports2.FrameLocator = void 0;
    exports2.setTestIdAttribute = setTestIdAttribute;
    exports2.testIdAttributeName = testIdAttributeName;
    var util = _interopRequireWildcard(require("util"));
    var _utils = require_utils();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _stringUtils = require_stringUtils();
    var _locatorUtils = require_locatorUtils();
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    _util$inspect$custom = util.inspect.custom;
    var Locator = class {
      constructor(frame, selector, options) {
        this._frame = void 0;
        this._selector = void 0;
        this._frame = frame;
        this._selector = selector;
        if (options !== null && options !== void 0 && options.hasText)
          this._selector += ` >> internal:has-text=${(0, _stringUtils.escapeForTextSelector)(options.hasText, false)}`;
        if (options !== null && options !== void 0 && options.hasNotText)
          this._selector += ` >> internal:has-not-text=${(0, _stringUtils.escapeForTextSelector)(options.hasNotText, false)}`;
        if (options !== null && options !== void 0 && options.has) {
          const locator = options.has;
          if (locator._frame !== frame)
            throw new Error(`Inner "has" locator must belong to the same frame.`);
          this._selector += ` >> internal:has=` + JSON.stringify(locator._selector);
        }
        if (options !== null && options !== void 0 && options.hasNot) {
          const locator = options.hasNot;
          if (locator._frame !== frame)
            throw new Error(`Inner "hasNot" locator must belong to the same frame.`);
          this._selector += ` >> internal:has-not=` + JSON.stringify(locator._selector);
        }
      }
      _withElement(task, timeout) {
        return __async(this, null, function* () {
          timeout = this._frame.page()._timeoutSettings.timeout({
            timeout
          });
          const deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
          return this._frame._wrapApiCall(() => __async(this, null, function* () {
            const result = yield this._frame._channel.waitForSelector({
              selector: this._selector,
              strict: true,
              state: "attached",
              timeout
            });
            const handle = _elementHandle.ElementHandle.fromNullable(result.element);
            if (!handle)
              throw new Error(`Could not resolve ${this._selector} to DOM Element`);
            try {
              return yield task(handle, deadline ? deadline - (0, _utils.monotonicTime)() : 0);
            } finally {
              yield handle.dispose();
            }
          }));
        });
      }
      page() {
        return this._frame.page();
      }
      boundingBox(options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.boundingBox(), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      check() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.check(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      click() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.click(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      dblclick() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.dblclick(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}, options) {
          return this._frame.dispatchEvent(this._selector, type, eventInit, __spreadValues({
            strict: true
          }, options));
        });
      }
      dragTo(_0) {
        return __async(this, arguments, function* (target, options = {}) {
          return this._frame.dragAndDrop(this._selector, target._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      evaluate(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.evaluate(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      evaluateAll(pageFunction, arg) {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, pageFunction, arg);
        });
      }
      evaluateHandle(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.evaluateHandle(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      fill(_0) {
        return __async(this, arguments, function* (value, options = {}) {
          return this._frame.fill(this._selector, value, __spreadValues({
            strict: true
          }, options));
        });
      }
      clear() {
        return __async(this, arguments, function* (options = {}) {
          return this.fill("", options);
        });
      }
      _highlight() {
        return __async(this, null, function* () {
          return this._frame._highlight(this._selector);
        });
      }
      highlight() {
        return __async(this, null, function* () {
          return this._frame._highlight(this._selector);
        });
      }
      locator(selectorOrLocator, options) {
        if ((0, _utils.isString)(selectorOrLocator))
          return new Locator(this._frame, this._selector + " >> " + selectorOrLocator, options);
        if (selectorOrLocator._frame !== this._frame)
          throw new Error(`Locators must belong to the same frame.`);
        return new Locator(this._frame, this._selector + " >> " + selectorOrLocator._selector, options);
      }
      getByTestId(testId) {
        return this.locator((0, _locatorUtils.getByTestIdSelector)(testIdAttributeName(), testId));
      }
      getByAltText(text, options) {
        return this.locator((0, _locatorUtils.getByAltTextSelector)(text, options));
      }
      getByLabel(text, options) {
        return this.locator((0, _locatorUtils.getByLabelSelector)(text, options));
      }
      getByPlaceholder(text, options) {
        return this.locator((0, _locatorUtils.getByPlaceholderSelector)(text, options));
      }
      getByText(text, options) {
        return this.locator((0, _locatorUtils.getByTextSelector)(text, options));
      }
      getByTitle(text, options) {
        return this.locator((0, _locatorUtils.getByTitleSelector)(text, options));
      }
      getByRole(role, options = {}) {
        return this.locator((0, _locatorUtils.getByRoleSelector)(role, options));
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._selector + " >> " + selector);
      }
      filter(options) {
        return new Locator(this._frame, this._selector, options);
      }
      elementHandle(options) {
        return __async(this, null, function* () {
          return yield this._frame.waitForSelector(this._selector, __spreadValues({
            strict: true,
            state: "attached"
          }, options));
        });
      }
      elementHandles() {
        return __async(this, null, function* () {
          return this._frame.$$(this._selector);
        });
      }
      first() {
        return new Locator(this._frame, this._selector + " >> nth=0");
      }
      last() {
        return new Locator(this._frame, this._selector + ` >> nth=-1`);
      }
      nth(index) {
        return new Locator(this._frame, this._selector + ` >> nth=${index}`);
      }
      and(locator) {
        if (locator._frame !== this._frame)
          throw new Error(`Locators must belong to the same frame.`);
        return new Locator(this._frame, this._selector + ` >> internal:and=` + JSON.stringify(locator._selector));
      }
      or(locator) {
        if (locator._frame !== this._frame)
          throw new Error(`Locators must belong to the same frame.`);
        return new Locator(this._frame, this._selector + ` >> internal:or=` + JSON.stringify(locator._selector));
      }
      focus(options) {
        return __async(this, null, function* () {
          return this._frame.focus(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      blur(options) {
        return __async(this, null, function* () {
          yield this._frame._channel.blur(__spreadValues({
            selector: this._selector,
            strict: true
          }, options));
        });
      }
      count() {
        return __async(this, null, function* () {
          return this._frame._queryCount(this._selector);
        });
      }
      getAttribute(name, options) {
        return __async(this, null, function* () {
          return this._frame.getAttribute(this._selector, name, __spreadValues({
            strict: true
          }, options));
        });
      }
      hover() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.hover(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      innerHTML(options) {
        return __async(this, null, function* () {
          return this._frame.innerHTML(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      innerText(options) {
        return __async(this, null, function* () {
          return this._frame.innerText(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      inputValue(options) {
        return __async(this, null, function* () {
          return this._frame.inputValue(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isChecked(options) {
        return __async(this, null, function* () {
          return this._frame.isChecked(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isDisabled(options) {
        return __async(this, null, function* () {
          return this._frame.isDisabled(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isEditable(options) {
        return __async(this, null, function* () {
          return this._frame.isEditable(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isEnabled(options) {
        return __async(this, null, function* () {
          return this._frame.isEnabled(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isHidden(options) {
        return __async(this, null, function* () {
          return this._frame.isHidden(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isVisible(options) {
        return __async(this, null, function* () {
          return this._frame.isVisible(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          return this._frame.press(this._selector, key, __spreadValues({
            strict: true
          }, options));
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.screenshot(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      scrollIntoViewIfNeeded() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.scrollIntoViewIfNeeded(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      selectOption(_0) {
        return __async(this, arguments, function* (values, options = {}) {
          return this._frame.selectOption(this._selector, values, __spreadValues({
            strict: true
          }, options));
        });
      }
      selectText() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.selectText(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      setChecked(checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(options);
          else
            yield this.uncheck(options);
        });
      }
      setInputFiles(_0) {
        return __async(this, arguments, function* (files, options = {}) {
          return this._frame.setInputFiles(this._selector, files, __spreadValues({
            strict: true
          }, options));
        });
      }
      tap() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.tap(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      textContent(options) {
        return __async(this, null, function* () {
          return this._frame.textContent(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          return this._frame.type(this._selector, text, __spreadValues({
            strict: true
          }, options));
        });
      }
      uncheck() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.uncheck(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      all() {
        return __async(this, null, function* () {
          return new Array(yield this.count()).fill(0).map((e, i) => this.nth(i));
        });
      }
      allInnerTexts() {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.innerText));
        });
      }
      allTextContents() {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.textContent || ""));
        });
      }
      waitFor(options) {
        return __async(this, null, function* () {
          yield this._frame._channel.waitForSelector(__spreadValues({
            selector: this._selector,
            strict: true,
            omitReturnValue: true
          }, options));
        });
      }
      _expect(expression, options) {
        return __async(this, null, function* () {
          const params = __spreadProps(__spreadValues({
            selector: this._selector,
            expression
          }, options), {
            isNot: !!options.isNot
          });
          params.expectedValue = (0, _jsHandle.serializeArgument)(options.expectedValue);
          const result = yield this._frame._channel.expect(params);
          if (result.received !== void 0)
            result.received = (0, _jsHandle.parseResult)(result.received);
          return result;
        });
      }
      [_util$inspect$custom]() {
        return this.toString();
      }
      toString() {
        return `Locator@${this._selector}`;
      }
    };
    exports2.Locator = Locator;
    var FrameLocator = class {
      constructor(frame, selector) {
        this._frame = void 0;
        this._frameSelector = void 0;
        this._frame = frame;
        this._frameSelector = selector;
      }
      locator(selectorOrLocator, options) {
        if ((0, _utils.isString)(selectorOrLocator))
          return new Locator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selectorOrLocator, options);
        if (selectorOrLocator._frame !== this._frame)
          throw new Error(`Locators must belong to the same frame.`);
        return new Locator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selectorOrLocator._selector, options);
      }
      getByTestId(testId) {
        return this.locator((0, _locatorUtils.getByTestIdSelector)(testIdAttributeName(), testId));
      }
      getByAltText(text, options) {
        return this.locator((0, _locatorUtils.getByAltTextSelector)(text, options));
      }
      getByLabel(text, options) {
        return this.locator((0, _locatorUtils.getByLabelSelector)(text, options));
      }
      getByPlaceholder(text, options) {
        return this.locator((0, _locatorUtils.getByPlaceholderSelector)(text, options));
      }
      getByText(text, options) {
        return this.locator((0, _locatorUtils.getByTextSelector)(text, options));
      }
      getByTitle(text, options) {
        return this.locator((0, _locatorUtils.getByTitleSelector)(text, options));
      }
      getByRole(role, options = {}) {
        return this.locator((0, _locatorUtils.getByRoleSelector)(role, options));
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._frameSelector + " >> internal:control=enter-frame >> " + selector);
      }
      first() {
        return new FrameLocator(this._frame, this._frameSelector + " >> nth=0");
      }
      last() {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
      }
      nth(index) {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);
      }
    };
    exports2.FrameLocator = FrameLocator;
    var _testIdAttributeName = "data-testid";
    function testIdAttributeName() {
      return _testIdAttributeName;
    }
    function setTestIdAttribute(attributeName) {
      _testIdAttributeName = attributeName;
    }
  }
});

// node_modules/playwright-core/lib/client/events.js
var require_events = __commonJS({
  "node_modules/playwright-core/lib/client/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Events = void 0;
    var Events = {
      AndroidDevice: {
        WebView: "webview",
        Close: "close"
      },
      AndroidSocket: {
        Data: "data",
        Close: "close"
      },
      AndroidWebView: {
        Close: "close"
      },
      Browser: {
        Disconnected: "disconnected"
      },
      BrowserContext: {
        Console: "console",
        Close: "close",
        Dialog: "dialog",
        Page: "page",
        BackgroundPage: "backgroundpage",
        ServiceWorker: "serviceworker",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished"
      },
      BrowserServer: {
        Close: "close"
      },
      Page: {
        Close: "close",
        Crash: "crash",
        Console: "console",
        Dialog: "dialog",
        Download: "download",
        FileChooser: "filechooser",
        DOMContentLoaded: "domcontentloaded",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Popup: "popup",
        WebSocket: "websocket",
        Worker: "worker"
      },
      WebSocket: {
        Close: "close",
        Error: "socketerror",
        FrameReceived: "framereceived",
        FrameSent: "framesent"
      },
      Worker: {
        Close: "close"
      },
      ElectronApplication: {
        Close: "close",
        Window: "window"
      }
    };
    exports2.Events = Events;
  }
});

// node_modules/playwright-core/lib/client/worker.js
var require_worker = __commonJS({
  "node_modules/playwright-core/lib/client/worker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Worker = void 0;
    var _events = require_events();
    var _channelOwner = require_channelOwner();
    var _jsHandle = require_jsHandle();
    var _utils = require_utils();
    var _errors = require_errors();
    var Worker = class extends _channelOwner.ChannelOwner {
      static from(worker) {
        return worker._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._context = void 0;
        this._closedRace = new _utils.ScopedRace();
        this._channel.on("close", () => {
          if (this._page)
            this._page._workers.delete(this);
          if (this._context)
            this._context._serviceWorkers.delete(this);
          this.emit(_events.Events.Worker.Close, this);
        });
        this.once(_events.Events.Worker.Close, () => this._closedRace.scopeClosed(new Error(_errors.kBrowserOrContextClosedError)));
      }
      url() {
        return this._initializer.url;
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports2.Worker = Worker;
  }
});

// node_modules/playwright-core/lib/client/waiter.js
var require_waiter = __commonJS({
  "node_modules/playwright-core/lib/client/waiter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Waiter = void 0;
    var _stackTrace = require_stackTrace();
    var _errors = require_errors();
    var _utils = require_utils();
    var Waiter = class {
      constructor(channelOwner, event) {
        this._dispose = void 0;
        this._failures = [];
        this._immediateError = void 0;
        this._logs = [];
        this._channelOwner = void 0;
        this._waitId = void 0;
        this._error = void 0;
        this._waitId = (0, _utils.createGuid)();
        this._channelOwner = channelOwner;
        this._channelOwner._channel.waitForEventInfo({
          info: {
            waitId: this._waitId,
            phase: "before",
            event
          }
        }).catch(() => {
        });
        this._dispose = [() => this._channelOwner._wrapApiCall(() => __async(this, null, function* () {
          yield this._channelOwner._channel.waitForEventInfo({
            info: {
              waitId: this._waitId,
              phase: "after",
              error: this._error
            }
          });
        }), true).catch(() => {
        })];
      }
      static createForEvent(channelOwner, event) {
        return new Waiter(channelOwner, event);
      }
      waitForEvent(emitter, event, predicate) {
        return __async(this, null, function* () {
          const {
            promise,
            dispose
          } = waitForEvent(emitter, event, predicate);
          return this.waitForPromise(promise, dispose);
        });
      }
      rejectOnEvent(emitter, event, error, predicate) {
        const {
          promise,
          dispose
        } = waitForEvent(emitter, event, predicate);
        this._rejectOn(promise.then(() => {
          throw error;
        }), dispose);
      }
      rejectOnTimeout(timeout, message) {
        if (!timeout)
          return;
        const {
          promise,
          dispose
        } = waitForTimeout(timeout);
        this._rejectOn(promise.then(() => {
          throw new _errors.TimeoutError(message);
        }), dispose);
      }
      rejectImmediately(error) {
        this._immediateError = error;
      }
      dispose() {
        for (const dispose of this._dispose)
          dispose();
      }
      waitForPromise(promise, dispose) {
        return __async(this, null, function* () {
          try {
            if (this._immediateError)
              throw this._immediateError;
            const result = yield Promise.race([promise, ...this._failures]);
            if (dispose)
              dispose();
            return result;
          } catch (e) {
            if (dispose)
              dispose();
            this._error = e.message;
            this.dispose();
            (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(this._logs));
            throw e;
          }
        });
      }
      log(s) {
        this._logs.push(s);
        this._channelOwner._wrapApiCall(() => __async(this, null, function* () {
          yield this._channelOwner._channel.waitForEventInfo({
            info: {
              waitId: this._waitId,
              phase: "log",
              message: s
            }
          }).catch(() => {
          });
        }), true);
      }
      _rejectOn(promise, dispose) {
        this._failures.push(promise);
        if (dispose)
          this._dispose.push(dispose);
      }
    };
    exports2.Waiter = Waiter;
    function waitForEvent(emitter, event, predicate) {
      let listener;
      const promise = new Promise((resolve, reject) => {
        listener = (eventArg) => __async(this, null, function* () {
          try {
            if (predicate && !(yield predicate(eventArg)))
              return;
            emitter.removeListener(event, listener);
            resolve(eventArg);
          } catch (e) {
            emitter.removeListener(event, listener);
            reject(e);
          }
        });
        emitter.addListener(event, listener);
      });
      const dispose = () => emitter.removeListener(event, listener);
      return {
        promise,
        dispose
      };
    }
    function waitForTimeout(timeout) {
      let timeoutId;
      const promise = new Promise((resolve) => timeoutId = setTimeout(resolve, timeout));
      const dispose = () => clearTimeout(timeoutId);
      return {
        promise,
        dispose
      };
    }
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
  }
});

// node_modules/playwright-core/lib/client/tracing.js
var require_tracing2 = __commonJS({
  "node_modules/playwright-core/lib/client/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Tracing = void 0;
    var _artifact = require_artifact2();
    var _channelOwner = require_channelOwner();
    var Tracing = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._includeSources = false;
        this._tracesDir = void 0;
        this._stacksId = void 0;
        this._isTracing = false;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          this._includeSources = !!options.sources;
          const traceName = yield this._wrapApiCall(() => __async(this, null, function* () {
            yield this._channel.tracingStart(options);
            const response = yield this._channel.tracingStartChunk({
              name: options.name,
              title: options.title
            });
            return response.traceName;
          }));
          yield this._startCollectingStacks(traceName);
        });
      }
      startChunk() {
        return __async(this, arguments, function* (options = {}) {
          const {
            traceName
          } = yield this._channel.tracingStartChunk(options);
          yield this._startCollectingStacks(traceName);
        });
      }
      _startCollectingStacks(traceName) {
        return __async(this, null, function* () {
          if (!this._isTracing) {
            this._isTracing = true;
            this._connection.setIsTracing(true);
          }
          const result = yield this._connection.localUtils()._channel.tracingStarted({
            tracesDir: this._tracesDir,
            traceName
          });
          this._stacksId = result.stacksId;
        });
      }
      stopChunk() {
        return __async(this, arguments, function* (options = {}) {
          yield this._doStopChunk(options.path);
        });
      }
      stop() {
        return __async(this, arguments, function* (options = {}) {
          yield this._wrapApiCall(() => __async(this, null, function* () {
            yield this._doStopChunk(options.path);
            yield this._channel.tracingStop();
          }));
        });
      }
      _doStopChunk(filePath) {
        return __async(this, null, function* () {
          if (this._isTracing) {
            this._isTracing = false;
            this._connection.setIsTracing(false);
          }
          if (!filePath) {
            yield this._channel.tracingStopChunk({
              mode: "discard"
            });
            if (this._stacksId)
              yield this._connection.localUtils()._channel.traceDiscarded({
                stacksId: this._stacksId
              });
            return;
          }
          const isLocal = !this._connection.isRemote();
          if (isLocal) {
            const result2 = yield this._channel.tracingStopChunk({
              mode: "entries"
            });
            yield this._connection.localUtils()._channel.zip({
              zipFile: filePath,
              entries: result2.entries,
              mode: "write",
              stacksId: this._stacksId,
              includeSources: this._includeSources
            });
            return;
          }
          const result = yield this._channel.tracingStopChunk({
            mode: "archive"
          });
          if (!result.artifact) {
            if (this._stacksId)
              yield this._connection.localUtils()._channel.traceDiscarded({
                stacksId: this._stacksId
              });
            return;
          }
          const artifact = _artifact.Artifact.from(result.artifact);
          yield artifact.saveAs(filePath);
          yield artifact.delete();
          yield this._connection.localUtils()._channel.zip({
            zipFile: filePath,
            entries: [],
            mode: "append",
            stacksId: this._stacksId,
            includeSources: this._includeSources
          });
        });
      }
    };
    exports2.Tracing = Tracing;
  }
});

// node_modules/playwright-core/lib/client/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/playwright-core/lib/client/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.APIResponse = exports2.APIRequestContext = exports2.APIRequest = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var util = _interopRequireWildcard(require("util"));
    var _errors = require_errors();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _channelOwner = require_channelOwner();
    var _network = require_network3();
    var _tracing = require_tracing2();
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var APIRequest = class {
      constructor(playwright) {
        this._playwright = void 0;
        this._contexts = /* @__PURE__ */ new Set();
        this._defaultContextOptions = void 0;
        this._playwright = playwright;
      }
      newContext() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_defaultContext;
          options = __spreadValues(__spreadValues({}, this._defaultContextOptions), options);
          const storageState = typeof options.storageState === "string" ? JSON.parse(yield _fs.default.promises.readFile(options.storageState, "utf8")) : options.storageState;
          const tracesDir = (_this$_defaultContext = this._defaultContextOptions) === null || _this$_defaultContext === void 0 ? void 0 : _this$_defaultContext.tracesDir;
          const context = APIRequestContext.from((yield this._playwright._channel.newRequest(__spreadProps(__spreadValues({}, options), {
            extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : void 0,
            storageState,
            tracesDir
          }))).request);
          this._contexts.add(context);
          context._request = this;
          context._tracing._tracesDir = tracesDir;
          yield context._instrumentation.onDidCreateRequestContext(context);
          return context;
        });
      }
    };
    exports2.APIRequest = APIRequest;
    var APIRequestContext = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._request = void 0;
        this._tracing = void 0;
        this._tracing = _tracing.Tracing.from(initializer.tracing);
      }
      dispose() {
        return __async(this, null, function* () {
          var _this$_request;
          yield this._instrumentation.onWillCloseRequestContext(this);
          yield this._channel.dispose();
          (_this$_request = this._request) === null || _this$_request === void 0 ? void 0 : _this$_request._contexts.delete(this);
        });
      }
      delete(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "DELETE"
          }));
        });
      }
      head(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "HEAD"
          }));
        });
      }
      get(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "GET"
          }));
        });
      }
      patch(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "PATCH"
          }));
        });
      }
      post(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "POST"
          }));
        });
      }
      put(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "PUT"
          }));
        });
      }
      fetch(_0) {
        return __async(this, arguments, function* (urlOrRequest, options = {}) {
          const url = (0, _utils.isString)(urlOrRequest) ? urlOrRequest : void 0;
          const request = (0, _utils.isString)(urlOrRequest) ? void 0 : urlOrRequest;
          return this._innerFetch(__spreadValues({
            url,
            request
          }, options));
        });
      }
      _innerFetch() {
        return __async(this, arguments, function* (options = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            var _options$request, _options$request2, _options$request3;
            (0, _utils.assert)(options.request || typeof options.url === "string", "First argument must be either URL string or Request");
            (0, _utils.assert)((options.data === void 0 ? 0 : 1) + (options.form === void 0 ? 0 : 1) + (options.multipart === void 0 ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
            (0, _utils.assert)(options.maxRedirects === void 0 || options.maxRedirects >= 0, `'maxRedirects' should be greater than or equal to '0'`);
            const url = options.url !== void 0 ? options.url : options.request.url();
            const params = objectToArray(options.params);
            const method = options.method || ((_options$request = options.request) === null || _options$request === void 0 ? void 0 : _options$request.method());
            const maxRedirects = options.maxRedirects;
            const headersObj = options.headers || ((_options$request2 = options.request) === null || _options$request2 === void 0 ? void 0 : _options$request2.headers());
            const headers = headersObj ? (0, _utils.headersObjectToArray)(headersObj) : void 0;
            let jsonData;
            let formData;
            let multipartData;
            let postDataBuffer;
            if (options.data !== void 0) {
              if ((0, _utils.isString)(options.data)) {
                if (isJsonContentType(headers))
                  jsonData = options.data;
                else
                  postDataBuffer = Buffer.from(options.data, "utf8");
              } else if (Buffer.isBuffer(options.data)) {
                postDataBuffer = options.data;
              } else if (typeof options.data === "object" || typeof options.data === "number" || typeof options.data === "boolean") {
                jsonData = options.data;
              } else {
                throw new Error(`Unexpected 'data' type`);
              }
            } else if (options.form) {
              formData = objectToArray(options.form);
            } else if (options.multipart) {
              multipartData = [];
              for (const [name, value] of Object.entries(options.multipart)) {
                if (isFilePayload(value)) {
                  const payload = value;
                  if (!Buffer.isBuffer(payload.buffer))
                    throw new Error(`Unexpected buffer type of 'data.${name}'`);
                  multipartData.push({
                    name,
                    file: filePayloadToJson(payload)
                  });
                } else if (value instanceof _fs.default.ReadStream) {
                  multipartData.push({
                    name,
                    file: yield readStreamToJson(value)
                  });
                } else {
                  multipartData.push({
                    name,
                    value: String(value)
                  });
                }
              }
            }
            if (postDataBuffer === void 0 && jsonData === void 0 && formData === void 0 && multipartData === void 0)
              postDataBuffer = ((_options$request3 = options.request) === null || _options$request3 === void 0 ? void 0 : _options$request3.postDataBuffer()) || void 0;
            const fixtures = {
              __testHookLookup: options.__testHookLookup
            };
            const result = yield this._channel.fetch(__spreadValues({
              url,
              params,
              method,
              headers,
              postData: postDataBuffer,
              jsonData,
              formData,
              multipartData,
              timeout: options.timeout,
              failOnStatusCode: options.failOnStatusCode,
              ignoreHTTPSErrors: options.ignoreHTTPSErrors,
              maxRedirects
            }, fixtures));
            return new APIResponse(this, result.response);
          }));
        });
      }
      storageState() {
        return __async(this, arguments, function* (options = {}) {
          const state = yield this._channel.storageState();
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
    };
    exports2.APIRequestContext = APIRequestContext;
    _util$inspect$custom = util.inspect.custom;
    var APIResponse = class {
      constructor(context, initializer) {
        this._initializer = void 0;
        this._headers = void 0;
        this._request = void 0;
        this._request = context;
        this._initializer = initializer;
        this._headers = new _network.RawHeaders(this._initializer.headers);
      }
      ok() {
        return this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      url() {
        return this._initializer.url;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._headers.headers();
      }
      headersArray() {
        return this._headers.headersArray();
      }
      body() {
        return __async(this, null, function* () {
          try {
            const result = yield this._request._channel.fetchResponseBody({
              fetchUid: this._fetchUid()
            });
            if (result.binary === void 0)
              throw new Error("Response has been disposed");
            return result.binary;
          } catch (e) {
            if (e.message.includes(_errors.kBrowserOrContextClosedError))
              throw new Error("Response has been disposed");
            throw e;
          }
        });
      }
      text() {
        return __async(this, null, function* () {
          const content = yield this.body();
          return content.toString("utf8");
        });
      }
      json() {
        return __async(this, null, function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._request._channel.disposeAPIResponse({
            fetchUid: this._fetchUid()
          });
        });
      }
      [_util$inspect$custom]() {
        const headers = this.headersArray().map(({
          name,
          value
        }) => `  ${name}: ${value}`);
        return `APIResponse: ${this.status()} ${this.statusText()}
${headers.join("\n")}`;
      }
      _fetchUid() {
        return this._initializer.fetchUid;
      }
      _fetchLog() {
        return __async(this, null, function* () {
          const {
            log
          } = yield this._request._channel.fetchLog({
            fetchUid: this._fetchUid()
          });
          return log;
        });
      }
    };
    exports2.APIResponse = APIResponse;
    function filePayloadToJson(payload) {
      return {
        name: payload.name,
        mimeType: payload.mimeType,
        buffer: payload.buffer
      };
    }
    function readStreamToJson(stream) {
      return __async(this, null, function* () {
        const buffer = yield new Promise((resolve, reject) => {
          const chunks = [];
          stream.on("data", (chunk) => chunks.push(chunk));
          stream.on("end", () => resolve(Buffer.concat(chunks)));
          stream.on("error", (err) => reject(err));
        });
        const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString("utf8") : stream.path;
        return {
          name: _path.default.basename(streamPath),
          buffer
        };
      });
    }
    function isJsonContentType(headers) {
      if (!headers)
        return false;
      for (const {
        name,
        value
      } of headers) {
        if (name.toLocaleLowerCase() === "content-type")
          return value === "application/json";
      }
      return false;
    }
    function objectToArray(map) {
      if (!map)
        return void 0;
      const result = [];
      for (const [name, value] of Object.entries(map))
        result.push({
          name,
          value: String(value)
        });
      return result;
    }
    function isFilePayload(value) {
      return typeof value === "object" && value["name"] && value["mimeType"] && value["buffer"];
    }
  }
});

// node_modules/playwright-core/lib/client/network.js
var require_network3 = __commonJS({
  "node_modules/playwright-core/lib/client/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocket = exports2.RouteHandler = exports2.Route = exports2.Response = exports2.Request = exports2.RawHeaders = void 0;
    exports2.validateHeaders = validateHeaders;
    var _url = require("url");
    var _channelOwner = require_channelOwner();
    var _frame = require_frame();
    var _worker = require_worker();
    var _fs = _interopRequireDefault(require("fs"));
    var _utilsBundle = require_utilsBundle();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _events = require_events();
    var _waiter = require_waiter();
    var _network = require_network();
    var _multimap = require_multimap();
    var _fetch = require_fetch2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Request = class extends _channelOwner.ChannelOwner {
      static from(request) {
        return request._object;
      }
      static fromNullable(request) {
        return request ? Request.from(request) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._timing = void 0;
        this._fallbackOverrides = {};
        this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
          this._redirectedFrom._redirectedTo = this;
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._fallbackOverrides.postDataBuffer = initializer.postData;
        this._timing = {
          startTime: 0,
          domainLookupStart: -1,
          domainLookupEnd: -1,
          connectStart: -1,
          secureConnectionStart: -1,
          connectEnd: -1,
          requestStart: -1,
          responseStart: -1,
          responseEnd: -1
        };
      }
      url() {
        return this._fallbackOverrides.url || this._initializer.url;
      }
      resourceType() {
        return this._initializer.resourceType;
      }
      method() {
        return this._fallbackOverrides.method || this._initializer.method;
      }
      postData() {
        var _this$_fallbackOverri;
        return ((_this$_fallbackOverri = this._fallbackOverrides.postDataBuffer) === null || _this$_fallbackOverri === void 0 ? void 0 : _this$_fallbackOverri.toString("utf-8")) || null;
      }
      postDataBuffer() {
        return this._fallbackOverrides.postDataBuffer || null;
      }
      postDataJSON() {
        const postData = this.postData();
        if (!postData)
          return null;
        const contentType = this.headers()["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          const entries = {};
          const parsed = new _url.URLSearchParams(postData);
          for (const [k, v] of parsed.entries())
            entries[k] = v;
          return entries;
        }
        try {
          return JSON.parse(postData);
        } catch (e) {
          throw new Error("POST data is not a valid JSON object: " + postData);
        }
      }
      headers() {
        if (this._fallbackOverrides.headers)
          return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers).headers();
        return this._provisionalHeaders.headers();
      }
      _context() {
        return this.frame().page().context();
      }
      _actualHeaders() {
        if (this._fallbackOverrides.headers)
          return Promise.resolve(RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers));
        if (!this._actualHeadersPromise) {
          this._actualHeadersPromise = this._wrapApiCall(() => __async(this, null, function* () {
            return new RawHeaders((yield this._channel.rawRequestHeaders()).headers);
          }));
        }
        return this._actualHeadersPromise;
      }
      allHeaders() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headers();
        });
      }
      headersArray() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headersArray();
        });
      }
      headerValue(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).get(name);
        });
      }
      response() {
        return __async(this, null, function* () {
          return Response.fromNullable((yield this._channel.response()).response);
        });
      }
      _internalResponse() {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            return Response.fromNullable((yield this._channel.response()).response);
          }), true);
        });
      }
      frame() {
        if (!this._initializer.frame) {
          (0, _utils.assert)(this.serviceWorker());
          throw new Error("Service Worker requests do not have an associated frame.");
        }
        return _frame.Frame.from(this._initializer.frame);
      }
      serviceWorker() {
        return this._initializer.serviceWorker ? _worker.Worker.from(this._initializer.serviceWorker) : null;
      }
      isNavigationRequest() {
        return this._initializer.isNavigationRequest;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      redirectedTo() {
        return this._redirectedTo;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      timing() {
        return this._timing;
      }
      sizes() {
        return __async(this, null, function* () {
          const response = yield this.response();
          if (!response)
            throw new Error("Unable to fetch sizes for failed request");
          return (yield response._channel.sizes()).sizes;
        });
      }
      _setResponseEndTiming(responseEndTiming) {
        this._timing.responseEnd = responseEndTiming;
        if (this._timing.responseStart === -1)
          this._timing.responseStart = responseEndTiming;
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
      _applyFallbackOverrides(overrides) {
        if (overrides.url)
          this._fallbackOverrides.url = overrides.url;
        if (overrides.method)
          this._fallbackOverrides.method = overrides.method;
        if (overrides.headers)
          this._fallbackOverrides.headers = overrides.headers;
        if ((0, _utils.isString)(overrides.postData))
          this._fallbackOverrides.postDataBuffer = Buffer.from(overrides.postData, "utf-8");
        else if (overrides.postData instanceof Buffer)
          this._fallbackOverrides.postDataBuffer = overrides.postData;
        else if (overrides.postData)
          this._fallbackOverrides.postDataBuffer = Buffer.from(JSON.stringify(overrides.postData), "utf-8");
      }
      _fallbackOverridesForContinue() {
        return this._fallbackOverrides;
      }
      _targetClosedRace() {
        var _this$serviceWorker, _this$frame$_page;
        return ((_this$serviceWorker = this.serviceWorker()) === null || _this$serviceWorker === void 0 ? void 0 : _this$serviceWorker._closedRace) || ((_this$frame$_page = this.frame()._page) === null || _this$frame$_page === void 0 ? void 0 : _this$frame$_page._closedOrCrashedRace) || new _manualPromise.ScopedRace();
      }
    };
    exports2.Request = Request;
    var Route = class extends _channelOwner.ChannelOwner {
      static from(route) {
        return route._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._handlingPromise = null;
      }
      request() {
        return Request.from(this._initializer.request);
      }
      _raceWithTargetClose(promise) {
        return this.request()._targetClosedRace().safeRace(promise);
      }
      _startHandling() {
        this._handlingPromise = new _manualPromise.ManualPromise();
        return this._handlingPromise;
      }
      fallback() {
        return __async(this, arguments, function* (options = {}) {
          this._checkNotHandled();
          this.request()._applyFallbackOverrides(options);
          this._reportHandled(false);
        });
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          this._checkNotHandled();
          yield this._raceWithTargetClose(this._channel.abort({
            requestUrl: this.request()._initializer.url,
            errorCode
          }));
          this._reportHandled(true);
        });
      }
      _redirectNavigationRequest(url) {
        return __async(this, null, function* () {
          this._checkNotHandled();
          yield this._raceWithTargetClose(this._channel.redirectNavigationRequest({
            url
          }));
          this._reportHandled(true);
        });
      }
      fetch() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const context = this.request()._context();
            return context.request._innerFetch(__spreadValues({
              request: this.request(),
              data: options.postData
            }, options));
          }));
        });
      }
      fulfill() {
        return __async(this, arguments, function* (options = {}) {
          this._checkNotHandled();
          yield this._wrapApiCall(() => __async(this, null, function* () {
            yield this._innerFulfill(options);
            this._reportHandled(true);
          }));
        });
      }
      _innerFulfill() {
        return __async(this, arguments, function* (options = {}) {
          let fetchResponseUid;
          let {
            status: statusOption,
            headers: headersOption,
            body
          } = options;
          if (options.json !== void 0) {
            (0, _utils.assert)(options.body === void 0, "Can specify either body or json parameters");
            body = JSON.stringify(options.json);
          }
          if (options.response instanceof _fetch.APIResponse) {
            var _statusOption, _headersOption;
            (_statusOption = statusOption) !== null && _statusOption !== void 0 ? _statusOption : statusOption = options.response.status();
            (_headersOption = headersOption) !== null && _headersOption !== void 0 ? _headersOption : headersOption = options.response.headers();
            if (body === void 0 && options.path === void 0) {
              if (options.response._request._connection === this._connection)
                fetchResponseUid = options.response._fetchUid();
              else
                body = yield options.response.body();
            }
          }
          let isBase64 = false;
          let length = 0;
          if (options.path) {
            const buffer = yield _fs.default.promises.readFile(options.path);
            body = buffer.toString("base64");
            isBase64 = true;
            length = buffer.length;
          } else if ((0, _utils.isString)(body)) {
            isBase64 = false;
            length = Buffer.byteLength(body);
          } else if (body) {
            length = body.length;
            body = body.toString("base64");
            isBase64 = true;
          }
          const headers = {};
          for (const header of Object.keys(headersOption || {}))
            headers[header.toLowerCase()] = String(headersOption[header]);
          if (options.contentType)
            headers["content-type"] = String(options.contentType);
          else if (options.json)
            headers["content-type"] = "application/json";
          else if (options.path)
            headers["content-type"] = _utilsBundle.mime.getType(options.path) || "application/octet-stream";
          if (length && !("content-length" in headers))
            headers["content-length"] = String(length);
          yield this._raceWithTargetClose(this._channel.fulfill({
            requestUrl: this.request()._initializer.url,
            status: statusOption || 200,
            headers: (0, _utils.headersObjectToArray)(headers),
            body,
            isBase64,
            fetchResponseUid
          }));
        });
      }
      continue() {
        return __async(this, arguments, function* (options = {}) {
          this._checkNotHandled();
          this.request()._applyFallbackOverrides(options);
          yield this._innerContinue();
          this._reportHandled(true);
        });
      }
      _checkNotHandled() {
        if (!this._handlingPromise)
          throw new Error("Route is already handled!");
      }
      _reportHandled(done) {
        const chain = this._handlingPromise;
        this._handlingPromise = null;
        chain.resolve(done);
      }
      _innerContinue(internal = false) {
        return __async(this, null, function* () {
          const options = this.request()._fallbackOverridesForContinue();
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            yield this._raceWithTargetClose(this._channel.continue({
              requestUrl: this.request()._initializer.url,
              url: options.url,
              method: options.method,
              headers: options.headers ? (0, _utils.headersObjectToArray)(options.headers) : void 0,
              postData: options.postDataBuffer,
              isFallback: internal
            }));
          }), !!internal);
        });
      }
    };
    exports2.Route = Route;
    var Response = class extends _channelOwner.ChannelOwner {
      static from(response) {
        return response._object;
      }
      static fromNullable(response) {
        return response ? Response.from(response) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._request = void 0;
        this._finishedPromise = new _manualPromise.ManualPromise();
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._request = Request.from(this._initializer.request);
        Object.assign(this._request._timing, this._initializer.timing);
      }
      url() {
        return this._initializer.url;
      }
      ok() {
        return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      fromServiceWorker() {
        return this._initializer.fromServiceWorker;
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      _actualHeaders() {
        return __async(this, null, function* () {
          if (!this._actualHeadersPromise) {
            this._actualHeadersPromise = (() => __async(this, null, function* () {
              return new RawHeaders((yield this._channel.rawResponseHeaders()).headers);
            }))();
          }
          return this._actualHeadersPromise;
        });
      }
      allHeaders() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headers();
        });
      }
      headersArray() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headersArray().slice();
        });
      }
      headerValue(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).get(name);
        });
      }
      headerValues(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).getAll(name);
        });
      }
      finished() {
        return __async(this, null, function* () {
          return this.request()._targetClosedRace().race(this._finishedPromise);
        });
      }
      body() {
        return __async(this, null, function* () {
          return (yield this._channel.body()).binary;
        });
      }
      text() {
        return __async(this, null, function* () {
          const content = yield this.body();
          return content.toString("utf8");
        });
      }
      json() {
        return __async(this, null, function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      serverAddr() {
        return __async(this, null, function* () {
          return (yield this._channel.serverAddr()).value || null;
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return (yield this._channel.securityDetails()).value || null;
        });
      }
    };
    exports2.Response = Response;
    var WebSocket = class extends _channelOwner.ChannelOwner {
      static from(webSocket) {
        return webSocket._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._isClosed = void 0;
        this._isClosed = false;
        this._page = parent;
        this._channel.on("frameSent", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("frameReceived", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("socketError", ({
          error
        }) => this.emit(_events.Events.WebSocket.Error, error));
        this._channel.on("close", () => {
          this._isClosed = true;
          this.emit(_events.Events.WebSocket.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      isClosed() {
        return this._isClosed;
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.WebSocket.Error)
              waiter.rejectOnEvent(this, _events.Events.WebSocket.Error, new Error("Socket error"));
            if (event !== _events.Events.WebSocket.Close)
              waiter.rejectOnEvent(this, _events.Events.WebSocket.Close, new Error("Socket closed"));
            waiter.rejectOnEvent(this._page, _events.Events.Page.Close, new Error("Page closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
    };
    exports2.WebSocket = WebSocket;
    function validateHeaders(headers) {
      for (const key of Object.keys(headers)) {
        const value = headers[key];
        if (!Object.is(value, void 0) && !(0, _utils.isString)(value))
          throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      }
    }
    var RouteHandler = class {
      constructor(baseURL, url, handler, times = Number.MAX_SAFE_INTEGER) {
        this.handledCount = 0;
        this._baseURL = void 0;
        this._times = void 0;
        this.url = void 0;
        this.handler = void 0;
        this._baseURL = baseURL;
        this._times = times;
        this.url = url;
        this.handler = handler;
      }
      static prepareInterceptionPatterns(handlers) {
        const patterns = [];
        let all = false;
        for (const handler of handlers) {
          if ((0, _utils.isString)(handler.url))
            patterns.push({
              glob: handler.url
            });
          else if ((0, _utils.isRegExp)(handler.url))
            patterns.push({
              regexSource: handler.url.source,
              regexFlags: handler.url.flags
            });
          else
            all = true;
        }
        if (all)
          return [{
            glob: "**/*"
          }];
        return patterns;
      }
      matches(requestURL) {
        return (0, _network.urlMatches)(this._baseURL, requestURL, this.url);
      }
      handle(route) {
        return __async(this, null, function* () {
          ++this.handledCount;
          const handledPromise = route._startHandling();
          const handler = this.handler;
          const [handled] = yield Promise.all([handledPromise, handler(route, route.request())]);
          return handled;
        });
      }
      willExpire() {
        return this.handledCount + 1 >= this._times;
      }
    };
    exports2.RouteHandler = RouteHandler;
    var RawHeaders = class {
      static _fromHeadersObjectLossy(headers) {
        const headersArray = Object.entries(headers).map(([name, value]) => ({
          name,
          value
        })).filter((header) => header.value !== void 0);
        return new RawHeaders(headersArray);
      }
      constructor(headers) {
        this._headersArray = void 0;
        this._headersMap = new _multimap.MultiMap();
        this._headersArray = headers;
        for (const header of headers)
          this._headersMap.set(header.name.toLowerCase(), header.value);
      }
      get(name) {
        const values = this.getAll(name);
        if (!values || !values.length)
          return null;
        return values.join(name.toLowerCase() === "set-cookie" ? "\n" : ", ");
      }
      getAll(name) {
        return [...this._headersMap.get(name.toLowerCase())];
      }
      headers() {
        const result = {};
        for (const name of this._headersMap.keys())
          result[name] = this.get(name);
        return result;
      }
      headersArray() {
        return this._headersArray;
      }
    };
    exports2.RawHeaders = RawHeaders;
  }
});

// node_modules/playwright-core/lib/client/types.js
var require_types2 = __commonJS({
  "node_modules/playwright-core/lib/client/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kLifecycleEvents = void 0;
    var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports2.kLifecycleEvents = kLifecycleEvents;
  }
});

// node_modules/playwright-core/lib/client/frame.js
var require_frame = __commonJS({
  "node_modules/playwright-core/lib/client/frame.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Frame = void 0;
    exports2.verifyLoadState = verifyLoadState;
    var _utils = require_utils();
    var _channelOwner = require_channelOwner();
    var _locator = require_locator();
    var _locatorUtils = require_locatorUtils();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _fs = _interopRequireDefault(require("fs"));
    var network = _interopRequireWildcard(require_network3());
    var _events = require("events");
    var _waiter = require_waiter();
    var _events2 = require_events();
    var _types = require_types2();
    var _network2 = require_network();
    var _debugLogger = require_debugLogger();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Frame = class extends _channelOwner.ChannelOwner {
      static from(frame) {
        return frame._object;
      }
      static fromNullable(frame) {
        return frame ? Frame.from(frame) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._eventEmitter = void 0;
        this._loadStates = void 0;
        this._parentFrame = null;
        this._url = "";
        this._name = "";
        this._detached = false;
        this._childFrames = /* @__PURE__ */ new Set();
        this._page = void 0;
        this._eventEmitter = new _events.EventEmitter();
        this._eventEmitter.setMaxListeners(0);
        this._parentFrame = Frame.fromNullable(initializer.parentFrame);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._name = initializer.name;
        this._url = initializer.url;
        this._loadStates = new Set(initializer.loadStates);
        this._channel.on("loadstate", (event) => {
          if (event.add) {
            this._loadStates.add(event.add);
            this._eventEmitter.emit("loadstate", event.add);
          }
          if (event.remove)
            this._loadStates.delete(event.remove);
          if (!this._parentFrame && event.add === "load" && this._page)
            this._page.emit(_events2.Events.Page.Load, this._page);
          if (!this._parentFrame && event.add === "domcontentloaded" && this._page)
            this._page.emit(_events2.Events.Page.DOMContentLoaded, this._page);
        });
        this._channel.on("navigated", (event) => {
          this._url = event.url;
          this._name = event.name;
          this._eventEmitter.emit("navigated", event);
          if (!event.error && this._page)
            this._page.emit(_events2.Events.Page.FrameNavigated, this);
        });
      }
      page() {
        return this._page;
      }
      goto(_0) {
        return __async(this, arguments, function* (url, options = {}) {
          const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return network.Response.fromNullable((yield this._channel.goto(__spreadProps(__spreadValues({
            url
          }, options), {
            waitUntil
          }))).response);
        });
      }
      _setupNavigationWaiter(options) {
        const waiter = new _waiter.Waiter(this._page, "");
        if (this._page.isClosed())
          waiter.rejectImmediately(new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Close, new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Crash, new Error("Navigation failed because page crashed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
        const timeout = this._page._timeoutSettings.navigationTimeout(options);
        waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
        return waiter;
      }
      waitForNavigation() {
        return __async(this, arguments, function* (options = {}) {
          return this._page._wrapApiCall(() => __async(this, null, function* () {
            const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
            const waiter = this._setupNavigationWaiter(options);
            const toUrl = typeof options.url === "string" ? ` to "${options.url}"` : "";
            waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
            const navigatedEvent = yield waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
              var _this$_page;
              if (event.error)
                return true;
              waiter.log(`  navigated to "${event.url}"`);
              return (0, _network2.urlMatches)((_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page.context()._options.baseURL, event.url, options.url);
            });
            if (navigatedEvent.error) {
              const e = new Error(navigatedEvent.error);
              e.stack = "";
              yield waiter.waitForPromise(Promise.reject(e));
            }
            if (!this._loadStates.has(waitUntil)) {
              yield waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
                waiter.log(`  "${s}" event fired`);
                return s === waitUntil;
              });
            }
            const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
            const response = request ? yield waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;
            waiter.dispose();
            return response;
          }));
        });
      }
      waitForLoadState() {
        return __async(this, arguments, function* (state = "load", options = {}) {
          state = verifyLoadState("state", state);
          return this._page._wrapApiCall(() => __async(this, null, function* () {
            const waiter = this._setupNavigationWaiter(options);
            if (this._loadStates.has(state)) {
              waiter.log(`  not waiting, "${state}" event already fired`);
            } else {
              yield waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
                waiter.log(`  "${s}" event fired`);
                return s === state;
              });
            }
            waiter.dispose();
          }));
        });
      }
      waitForURL(_0) {
        return __async(this, arguments, function* (url, options = {}) {
          var _this$_page2;
          if ((0, _network2.urlMatches)((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2.context()._options.baseURL, this.url(), url))
            return yield this.waitForLoadState(options.waitUntil, options);
          yield this.waitForNavigation(__spreadValues({
            url
          }, options));
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return _elementHandle.ElementHandle.from((yield this._channel.frameElement()).element);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      _evaluateExposeUtilityScript(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            exposeUtilityScript: true,
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $(selector, options) {
        return __async(this, null, function* () {
          const result = yield this._channel.querySelector(__spreadValues({
            selector
          }, options));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      waitForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          if (options.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options.waitFor && options.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const result = yield this._channel.waitForSelector(__spreadValues({
            selector
          }, options));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      dispatchEvent(_0, _1, _2) {
        return __async(this, arguments, function* (selector, type, eventInit, options = {}) {
          yield this._channel.dispatchEvent(__spreadValues({
            selector,
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          }, options));
        });
      }
      $eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          const result = yield this._channel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          const result = yield this._channel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          const result = yield this._channel.querySelectorAll({
            selector
          });
          return result.elements.map((e) => _elementHandle.ElementHandle.from(e));
        });
      }
      _queryCount(selector) {
        return __async(this, null, function* () {
          return (yield this._channel.queryCount({
            selector
          })).value;
        });
      }
      content() {
        return __async(this, null, function* () {
          return (yield this._channel.content()).value;
        });
      }
      setContent(_0) {
        return __async(this, arguments, function* (html, options = {}) {
          const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          yield this._channel.setContent(__spreadProps(__spreadValues({
            html
          }, options), {
            waitUntil
          }));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      addScriptTag() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (copy.path) {
            copy.content = (yield _fs.default.promises.readFile(copy.path)).toString();
            copy.content += "//# sourceURL=" + copy.path.replace(/\n/g, "");
          }
          return _elementHandle.ElementHandle.from((yield this._channel.addScriptTag(__spreadValues({}, copy))).element);
        });
      }
      addStyleTag() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (copy.path) {
            copy.content = (yield _fs.default.promises.readFile(copy.path)).toString();
            copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
          }
          return _elementHandle.ElementHandle.from((yield this._channel.addStyleTag(__spreadValues({}, copy))).element);
        });
      }
      click(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.click(__spreadValues({
            selector
          }, options));
        });
      }
      dblclick(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.dblclick(__spreadValues({
            selector
          }, options));
        });
      }
      dragAndDrop(_0, _1) {
        return __async(this, arguments, function* (source, target, options = {}) {
          return yield this._channel.dragAndDrop(__spreadValues({
            source,
            target
          }, options));
        });
      }
      tap(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.tap(__spreadValues({
            selector
          }, options));
        });
      }
      fill(_0, _1) {
        return __async(this, arguments, function* (selector, value, options = {}) {
          return yield this._channel.fill(__spreadValues({
            selector,
            value
          }, options));
        });
      }
      _highlight(selector) {
        return __async(this, null, function* () {
          return yield this._channel.highlight({
            selector
          });
        });
      }
      locator(selector, options) {
        return new _locator.Locator(this, selector, options);
      }
      getByTestId(testId) {
        return this.locator((0, _locatorUtils.getByTestIdSelector)((0, _locator.testIdAttributeName)(), testId));
      }
      getByAltText(text, options) {
        return this.locator((0, _locatorUtils.getByAltTextSelector)(text, options));
      }
      getByLabel(text, options) {
        return this.locator((0, _locatorUtils.getByLabelSelector)(text, options));
      }
      getByPlaceholder(text, options) {
        return this.locator((0, _locatorUtils.getByPlaceholderSelector)(text, options));
      }
      getByText(text, options) {
        return this.locator((0, _locatorUtils.getByTextSelector)(text, options));
      }
      getByTitle(text, options) {
        return this.locator((0, _locatorUtils.getByTitleSelector)(text, options));
      }
      getByRole(role, options = {}) {
        return this.locator((0, _locatorUtils.getByRoleSelector)(role, options));
      }
      frameLocator(selector) {
        return new _locator.FrameLocator(this, selector);
      }
      focus(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.focus(__spreadValues({
            selector
          }, options));
        });
      }
      textContent(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          const value = (yield this._channel.textContent(__spreadValues({
            selector
          }, options))).value;
          return value === void 0 ? null : value;
        });
      }
      innerText(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.innerText(__spreadValues({
            selector
          }, options))).value;
        });
      }
      innerHTML(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.innerHTML(__spreadValues({
            selector
          }, options))).value;
        });
      }
      getAttribute(_0, _1) {
        return __async(this, arguments, function* (selector, name, options = {}) {
          const value = (yield this._channel.getAttribute(__spreadValues({
            selector,
            name
          }, options))).value;
          return value === void 0 ? null : value;
        });
      }
      inputValue(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.inputValue(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isChecked(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isChecked(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isDisabled(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isDisabled(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isEditable(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isEditable(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isEnabled(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isEnabled(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isHidden(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isHidden(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isVisible(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isVisible(__spreadValues({
            selector
          }, options))).value;
        });
      }
      hover(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.hover(__spreadValues({
            selector
          }, options));
        });
      }
      selectOption(_0, _1) {
        return __async(this, arguments, function* (selector, values, options = {}) {
          return (yield this._channel.selectOption(__spreadValues(__spreadValues({
            selector
          }, (0, _elementHandle.convertSelectOptionValues)(values)), options))).values;
        });
      }
      setInputFiles(_0, _1) {
        return __async(this, arguments, function* (selector, files, options = {}) {
          const converted = yield (0, _elementHandle.convertInputFiles)(files, this.page().context());
          if (converted.files) {
            yield this._channel.setInputFiles(__spreadValues({
              selector,
              files: converted.files
            }, options));
          } else {
            _debugLogger.debugLogger.log("api", "switching to large files mode");
            yield this._channel.setInputFilePaths(__spreadValues(__spreadValues({
              selector
            }, converted), options));
          }
        });
      }
      type(_0, _1) {
        return __async(this, arguments, function* (selector, text, options = {}) {
          yield this._channel.type(__spreadValues({
            selector,
            text
          }, options));
        });
      }
      press(_0, _1) {
        return __async(this, arguments, function* (selector, key, options = {}) {
          yield this._channel.press(__spreadValues({
            selector,
            key
          }, options));
        });
      }
      check(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.check(__spreadValues({
            selector
          }, options));
        });
      }
      uncheck(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.uncheck(__spreadValues({
            selector
          }, options));
        });
      }
      setChecked(selector, checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(selector, options);
          else
            yield this.uncheck(selector, options);
        });
      }
      waitForTimeout(timeout) {
        return __async(this, null, function* () {
          yield this._channel.waitForTimeout({
            timeout
          });
        });
      }
      waitForFunction(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg, options = {}) {
          if (typeof options.polling === "string")
            (0, _utils.assert)(options.polling === "raf", "Unknown polling option: " + options.polling);
          const result = yield this._channel.waitForFunction(__spreadProps(__spreadValues({}, options), {
            pollingInterval: options.polling === "raf" ? void 0 : options.polling,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          }));
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      title() {
        return __async(this, null, function* () {
          return (yield this._channel.title()).value;
        });
      }
    };
    exports2.Frame = Frame;
    function verifyLoadState(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!_types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/client/writableStream.js
var require_writableStream = __commonJS({
  "node_modules/playwright-core/lib/client/writableStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WritableStream = void 0;
    var _stream = require("stream");
    var _channelOwner = require_channelOwner();
    var WritableStream = class extends _channelOwner.ChannelOwner {
      static from(Stream) {
        return Stream._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new WritableStreamImpl(this._channel);
      }
    };
    exports2.WritableStream = WritableStream;
    var WritableStreamImpl = class extends _stream.Writable {
      constructor(channel) {
        super();
        this._channel = void 0;
        this._channel = channel;
      }
      _write(chunk, encoding, callback) {
        return __async(this, null, function* () {
          const error = yield this._channel.write({
            binary: typeof chunk === "string" ? Buffer.from(chunk) : chunk
          }).catch((e) => e);
          callback(error || null);
        });
      }
      _final(callback) {
        return __async(this, null, function* () {
          const error = yield this._channel.close().catch((e) => e);
          callback(error || null);
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/client/elementHandle.js
var require_elementHandle = __commonJS({
  "node_modules/playwright-core/lib/client/elementHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElementHandle = void 0;
    exports2.convertInputFiles = convertInputFiles;
    exports2.convertSelectOptionValues = convertSelectOptionValues;
    exports2.determineScreenshotType = determineScreenshotType;
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _fs = _interopRequireDefault(require("fs"));
    var _utilsBundle = require_utilsBundle();
    var _path = _interopRequireDefault(require("path"));
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _writableStream = require_writableStream();
    var _stream = require("stream");
    var _util = require("util");
    var _debugLogger = require_debugLogger();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pipelineAsync = (0, _util.promisify)(_stream.pipeline);
    var ElementHandle = class extends _jsHandle.JSHandle {
      static from(handle) {
        return handle._object;
      }
      static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._elementChannel = void 0;
        this._elementChannel = this._channel;
      }
      asElement() {
        return this;
      }
      ownerFrame() {
        return __async(this, null, function* () {
          return _frame.Frame.fromNullable((yield this._elementChannel.ownerFrame()).frame);
        });
      }
      contentFrame() {
        return __async(this, null, function* () {
          return _frame.Frame.fromNullable((yield this._elementChannel.contentFrame()).frame);
        });
      }
      getAttribute(name) {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.getAttribute({
            name
          })).value;
          return value === void 0 ? null : value;
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.inputValue()).value;
        });
      }
      textContent() {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.textContent()).value;
          return value === void 0 ? null : value;
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.innerText()).value;
        });
      }
      innerHTML() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.innerHTML()).value;
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isChecked()).value;
        });
      }
      isDisabled() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isDisabled()).value;
        });
      }
      isEditable() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isEditable()).value;
        });
      }
      isEnabled() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isEnabled()).value;
        });
      }
      isHidden() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isHidden()).value;
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isVisible()).value;
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}) {
          yield this._elementChannel.dispatchEvent({
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          });
        });
      }
      scrollIntoViewIfNeeded() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.scrollIntoViewIfNeeded(options);
        });
      }
      hover() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.hover(options);
        });
      }
      click() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.click(options);
        });
      }
      dblclick() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.dblclick(options);
        });
      }
      tap() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.tap(options);
        });
      }
      selectOption(_0) {
        return __async(this, arguments, function* (values, options = {}) {
          const result = yield this._elementChannel.selectOption(__spreadValues(__spreadValues({}, convertSelectOptionValues(values)), options));
          return result.values;
        });
      }
      fill(_0) {
        return __async(this, arguments, function* (value, options = {}) {
          return yield this._elementChannel.fill(__spreadValues({
            value
          }, options));
        });
      }
      selectText() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.selectText(options);
        });
      }
      setInputFiles(_0) {
        return __async(this, arguments, function* (files, options = {}) {
          const frame = yield this.ownerFrame();
          if (!frame)
            throw new Error("Cannot set input files to detached element");
          const converted = yield convertInputFiles(files, frame.page().context());
          if (converted.files) {
            yield this._elementChannel.setInputFiles(__spreadValues({
              files: converted.files
            }, options));
          } else {
            _debugLogger.debugLogger.log("api", "switching to large files mode");
            yield this._elementChannel.setInputFilePaths(__spreadValues(__spreadValues({}, converted), options));
          }
        });
      }
      focus() {
        return __async(this, null, function* () {
          yield this._elementChannel.focus();
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          yield this._elementChannel.type(__spreadValues({
            text
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          yield this._elementChannel.press(__spreadValues({
            key
          }, options));
        });
      }
      check() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.check(options);
        });
      }
      uncheck() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.uncheck(options);
        });
      }
      setChecked(checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(options);
          else
            yield this.uncheck(options);
        });
      }
      boundingBox() {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.boundingBox()).value;
          return value === void 0 ? null : value;
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadProps(__spreadValues({}, options), {
            mask: void 0
          });
          if (!copy.type)
            copy.type = determineScreenshotType(options);
          if (options.mask) {
            copy.mask = options.mask.map((locator) => ({
              frame: locator._frame._channel,
              selector: locator._selector
            }));
          }
          const result = yield this._elementChannel.screenshot(copy);
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, result.binary);
          }
          return result.binary;
        });
      }
      $(selector) {
        return __async(this, null, function* () {
          return ElementHandle.fromNullable((yield this._elementChannel.querySelector({
            selector
          })).element);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.querySelectorAll({
            selector
          });
          return result.elements.map((h) => ElementHandle.from(h));
        });
      }
      $eval(selector, pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$eval(selector, pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      waitForElementState(_0) {
        return __async(this, arguments, function* (state, options = {}) {
          return yield this._elementChannel.waitForElementState(__spreadValues({
            state
          }, options));
        });
      }
      waitForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          const result = yield this._elementChannel.waitForSelector(__spreadValues({
            selector
          }, options));
          return ElementHandle.fromNullable(result.element);
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    function convertSelectOptionValues(values) {
      if (values === null)
        return {};
      if (!Array.isArray(values))
        values = [values];
      if (!values.length)
        return {};
      for (let i = 0; i < values.length; i++)
        (0, _utils.assert)(values[i] !== null, `options[${i}]: expected object, got null`);
      if (values[0] instanceof ElementHandle)
        return {
          elements: values.map((v) => v._elementChannel)
        };
      if ((0, _utils.isString)(values[0]))
        return {
          options: values.map((valueOrLabel) => ({
            valueOrLabel
          }))
        };
      return {
        options: values
      };
    }
    function convertInputFiles(files, context) {
      return __async(this, null, function* () {
        const items = Array.isArray(files) ? files.slice() : [files];
        const sizeLimit = 50 * 1024 * 1024;
        const totalBufferSizeExceedsLimit = items.reduce((size, item) => size + (typeof item === "object" && item.buffer ? item.buffer.byteLength : 0), 0) > sizeLimit;
        if (totalBufferSizeExceedsLimit)
          throw new Error("Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.");
        const stats = yield Promise.all(items.filter(_utils.isString).map((item) => _fs.default.promises.stat(item)));
        const totalFileSizeExceedsLimit = stats.reduce((acc, stat) => acc + stat.size, 0) > sizeLimit;
        if (totalFileSizeExceedsLimit) {
          if (context._connection.isRemote()) {
            const streams = yield Promise.all(items.map((item) => __async(this, null, function* () {
              (0, _utils.assert)((0, _utils.isString)(item));
              const {
                writableStream: stream
              } = yield context._channel.createTempFile({
                name: _path.default.basename(item)
              });
              const writable = _writableStream.WritableStream.from(stream);
              yield pipelineAsync(_fs.default.createReadStream(item), writable.stream());
              return stream;
            })));
            return {
              streams
            };
          }
          return {
            localPaths: items.map((f) => _path.default.resolve(f))
          };
        }
        const filePayloads = yield Promise.all(items.map((item) => __async(this, null, function* () {
          if (typeof item === "string") {
            return {
              name: _path.default.basename(item),
              buffer: yield _fs.default.promises.readFile(item)
            };
          } else {
            return {
              name: item.name,
              mimeType: item.mimeType,
              buffer: item.buffer
            };
          }
        })));
        return {
          files: filePayloads
        };
      });
    }
    function determineScreenshotType(options) {
      if (options.path) {
        const mimeType = _utilsBundle.mime.getType(options.path);
        if (mimeType === "image/png")
          return "png";
        else if (mimeType === "image/jpeg")
          return "jpeg";
        throw new Error(`path: unsupported mime type "${mimeType}"`);
      }
      return options.type;
    }
  }
});

// node_modules/playwright-core/lib/client/fileChooser.js
var require_fileChooser2 = __commonJS({
  "node_modules/playwright-core/lib/client/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
      setFiles(files, options) {
        return __async(this, null, function* () {
          return this._elementHandle.setInputFiles(files, options);
        });
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/client/input.js
var require_input2 = __commonJS({
  "node_modules/playwright-core/lib/client/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = void 0;
    var Keyboard = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      down(key) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardDown({
            key
          });
        });
      }
      up(key) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardUp({
            key
          });
        });
      }
      insertText(text) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardInsertText({
            text
          });
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          yield this._page._channel.keyboardType(__spreadValues({
            text
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          yield this._page._channel.keyboardPress(__spreadValues({
            key
          }, options));
        });
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      move(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this._page._channel.mouseMove(__spreadValues({
            x,
            y
          }, options));
        });
      }
      down() {
        return __async(this, arguments, function* (options = {}) {
          yield this._page._channel.mouseDown(__spreadValues({}, options));
        });
      }
      up() {
        return __async(this, arguments, function* (options = {}) {
          yield this._page._channel.mouseUp(options);
        });
      }
      click(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this._page._channel.mouseClick(__spreadValues({
            x,
            y
          }, options));
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this.click(x, y, __spreadProps(__spreadValues({}, options), {
            clickCount: 2
          }));
        });
      }
      wheel(deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._page._channel.mouseWheel({
            deltaX,
            deltaY
          });
        });
      }
    };
    exports2.Mouse = Mouse;
    var Touchscreen = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      tap(x, y) {
        return __async(this, null, function* () {
          yield this._page._channel.touchscreenTap({
            x,
            y
          });
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/client/video.js
var require_video = __commonJS({
  "node_modules/playwright-core/lib/client/video.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Video = void 0;
    var _utils = require_utils();
    var Video = class {
      constructor(page, connection) {
        this._artifact = null;
        this._artifactReadyPromise = new _utils.ManualPromise();
        this._isRemote = false;
        this._isRemote = connection.isRemote();
        this._artifact = page._closedOrCrashedRace.safeRace(this._artifactReadyPromise);
      }
      _artifactReady(artifact) {
        this._artifactReadyPromise.resolve(artifact);
      }
      path() {
        return __async(this, null, function* () {
          if (this._isRemote)
            throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
          const artifact = yield this._artifact;
          if (!artifact)
            throw new Error("Page did not produce any video frames");
          return artifact._initializer.absolutePath;
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          const artifact = yield this._artifact;
          if (!artifact)
            throw new Error("Page did not produce any video frames");
          return artifact.saveAs(path);
        });
      }
      delete() {
        return __async(this, null, function* () {
          const artifact = yield this._artifact;
          if (artifact)
            yield artifact.delete();
        });
      }
    };
    exports2.Video = Video;
  }
});

// node_modules/playwright-core/lib/client/harRouter.js
var require_harRouter = __commonJS({
  "node_modules/playwright-core/lib/client/harRouter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarRouter = void 0;
    var _debugLogger = require_debugLogger();
    var _events = require_events();
    var HarRouter = class {
      static create(localUtils, file, notFoundAction, options) {
        return __async(this, null, function* () {
          const {
            harId,
            error
          } = yield localUtils._channel.harOpen({
            file
          });
          if (error)
            throw new Error(error);
          return new HarRouter(localUtils, harId, notFoundAction, options);
        });
      }
      constructor(localUtils, harId, notFoundAction, options) {
        this._localUtils = void 0;
        this._harId = void 0;
        this._notFoundAction = void 0;
        this._options = void 0;
        this._localUtils = localUtils;
        this._harId = harId;
        this._options = options;
        this._notFoundAction = notFoundAction;
      }
      _handle(route) {
        return __async(this, null, function* () {
          const request = route.request();
          const response = yield this._localUtils._channel.harLookup({
            harId: this._harId,
            url: request.url(),
            method: request.method(),
            headers: yield request.headersArray(),
            postData: request.postDataBuffer() || void 0,
            isNavigationRequest: request.isNavigationRequest()
          });
          if (response.action === "redirect") {
            _debugLogger.debugLogger.log("api", `HAR: ${route.request().url()} redirected to ${response.redirectURL}`);
            yield route._redirectNavigationRequest(response.redirectURL);
            return;
          }
          if (response.action === "fulfill") {
            yield route.fulfill({
              status: response.status,
              headers: Object.fromEntries(response.headers.map((h) => [h.name, h.value])),
              body: response.body
            });
            return;
          }
          if (response.action === "error")
            _debugLogger.debugLogger.log("api", "HAR: " + response.message);
          if (this._notFoundAction === "abort") {
            yield route.abort();
            return;
          }
          yield route.fallback();
        });
      }
      addContextRoute(context) {
        return __async(this, null, function* () {
          yield context.route(this._options.urlMatch || "**/*", (route) => this._handle(route));
          context.once(_events.Events.BrowserContext.Close, () => this.dispose());
        });
      }
      addPageRoute(page) {
        return __async(this, null, function* () {
          yield page.route(this._options.urlMatch || "**/*", (route) => this._handle(route));
          page.once(_events.Events.Page.Close, () => this.dispose());
        });
      }
      dispose() {
        this._localUtils._channel.harClose({
          harId: this._harId
        }).catch(() => {
        });
      }
    };
    exports2.HarRouter = HarRouter;
  }
});

// node_modules/playwright-core/lib/client/page.js
var require_page2 = __commonJS({
  "node_modules/playwright-core/lib/client/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Page = exports2.BindingCall = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _errors = require_errors();
    var _network = require_network();
    var _timeoutSettings = require_timeoutSettings();
    var _serializers = require_serializers();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _accessibility = require_accessibility2();
    var _artifact = require_artifact2();
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _coverage = require_coverage();
    var _download = require_download2();
    var _elementHandle = require_elementHandle();
    var _events = require_events();
    var _fileChooser = require_fileChooser2();
    var _frame = require_frame();
    var _input = require_input2();
    var _jsHandle = require_jsHandle();
    var _network2 = require_network3();
    var _video = require_video();
    var _waiter = require_waiter();
    var _worker = require_worker();
    var _harRouter = require_harRouter();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Page = class extends _channelOwner.ChannelOwner {
      static from(page) {
        return page._object;
      }
      static fromNullable(page) {
        return page ? Page.from(page) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._browserContext = void 0;
        this._ownedContext = void 0;
        this._mainFrame = void 0;
        this._frames = /* @__PURE__ */ new Set();
        this._workers = /* @__PURE__ */ new Set();
        this._closed = false;
        this._closedOrCrashedRace = new _utils.ScopedRace();
        this._viewportSize = void 0;
        this._routes = [];
        this.accessibility = void 0;
        this.coverage = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.request = void 0;
        this.touchscreen = void 0;
        this._bindings = /* @__PURE__ */ new Map();
        this._timeoutSettings = void 0;
        this._video = null;
        this._opener = void 0;
        this._browserContext = parent;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(this._browserContext._timeoutSettings);
        this.accessibility = new _accessibility.Accessibility(this._channel);
        this.keyboard = new _input.Keyboard(this);
        this.mouse = new _input.Mouse(this);
        this.request = this._browserContext.request;
        this.touchscreen = new _input.Touchscreen(this);
        this._mainFrame = _frame.Frame.from(initializer.mainFrame);
        this._mainFrame._page = this;
        this._frames.add(this._mainFrame);
        this._viewportSize = initializer.viewportSize || null;
        this._closed = initializer.isClosed;
        this._opener = Page.fromNullable(initializer.opener);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("crash", () => this._onCrash());
        this._channel.on("download", ({
          url,
          suggestedFilename,
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this.emit(_events.Events.Page.Download, new _download.Download(this, url, suggestedFilename, artifactObject));
        });
        this._channel.on("fileChooser", ({
          element,
          isMultiple
        }) => this.emit(_events.Events.Page.FileChooser, new _fileChooser.FileChooser(this, _elementHandle.ElementHandle.from(element), isMultiple)));
        this._channel.on("frameAttached", ({
          frame
        }) => this._onFrameAttached(_frame.Frame.from(frame)));
        this._channel.on("frameDetached", ({
          frame
        }) => this._onFrameDetached(_frame.Frame.from(frame)));
        this._channel.on("pageError", ({
          error
        }) => this.emit(_events.Events.Page.PageError, (0, _serializers.parseError)(error)));
        this._channel.on("route", ({
          route
        }) => this._onRoute(_network2.Route.from(route)));
        this._channel.on("video", ({
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this._forceVideo()._artifactReady(artifactObject);
        });
        this._channel.on("webSocket", ({
          webSocket
        }) => this.emit(_events.Events.Page.WebSocket, _network2.WebSocket.from(webSocket)));
        this._channel.on("worker", ({
          worker
        }) => this._onWorker(_worker.Worker.from(worker)));
        this.coverage = new _coverage.Coverage(this._channel);
        this.once(_events.Events.Page.Close, () => this._closedOrCrashedRace.scopeClosed(new Error(_errors.kBrowserOrContextClosedError)));
        this.once(_events.Events.Page.Crash, () => this._closedOrCrashedRace.scopeClosed(new Error(_errors.kBrowserOrContextClosedError)));
        this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([[_events.Events.Page.Console, "console"], [_events.Events.Page.Dialog, "dialog"], [_events.Events.Page.Request, "request"], [_events.Events.Page.Response, "response"], [_events.Events.Page.RequestFinished, "requestFinished"], [_events.Events.Page.RequestFailed, "requestFailed"], [_events.Events.Page.FileChooser, "fileChooser"]]));
      }
      _onFrameAttached(frame) {
        frame._page = this;
        this._frames.add(frame);
        if (frame._parentFrame)
          frame._parentFrame._childFrames.add(frame);
        this.emit(_events.Events.Page.FrameAttached, frame);
      }
      _onFrameDetached(frame) {
        this._frames.delete(frame);
        frame._detached = true;
        if (frame._parentFrame)
          frame._parentFrame._childFrames.delete(frame);
        this.emit(_events.Events.Page.FrameDetached, frame);
      }
      _onRoute(route) {
        return __async(this, null, function* () {
          const routeHandlers = this._routes.slice();
          for (const routeHandler of routeHandlers) {
            if (!routeHandler.matches(route.request().url()))
              continue;
            if (routeHandler.willExpire())
              this._routes.splice(this._routes.indexOf(routeHandler), 1);
            const handled = yield routeHandler.handle(route);
            if (!this._routes.length)
              this._wrapApiCall(() => this._updateInterceptionPatterns(), true).catch(() => {
              });
            if (handled)
              return;
          }
          yield this._browserContext._onRoute(route);
        });
      }
      _onBinding(bindingCall) {
        return __async(this, null, function* () {
          const func = this._bindings.get(bindingCall._initializer.name);
          if (func) {
            yield bindingCall.call(func);
            return;
          }
          yield this._browserContext._onBinding(bindingCall);
        });
      }
      _onWorker(worker) {
        this._workers.add(worker);
        worker._page = this;
        this.emit(_events.Events.Page.Worker, worker);
      }
      _onClose() {
        this._closed = true;
        this._browserContext._pages.delete(this);
        this._browserContext._backgroundPages.delete(this);
        this.emit(_events.Events.Page.Close, this);
      }
      _onCrash() {
        this.emit(_events.Events.Page.Crash, this);
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return __async(this, null, function* () {
          if (!this._opener || this._opener.isClosed())
            return null;
          return this._opener;
        });
      }
      mainFrame() {
        return this._mainFrame;
      }
      frame(frameSelector) {
        const name = (0, _utils.isString)(frameSelector) ? frameSelector : frameSelector.name;
        const url = (0, _utils.isObject)(frameSelector) ? frameSelector.url : void 0;
        (0, _utils.assert)(name || url, "Either name or url matcher should be specified");
        return this.frames().find((f) => {
          if (name)
            return f.name() === name;
          return (0, _network.urlMatches)(this._browserContext._options.baseURL, f.url(), url);
        }) || null;
      }
      frames() {
        return [...this._frames];
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultNavigationTimeoutNoReply({
            timeout
          }).catch(() => {
          });
        }), true);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultTimeoutNoReply({
            timeout
          }).catch(() => {
          });
        }), true);
      }
      _forceVideo() {
        if (!this._video)
          this._video = new _video.Video(this, this._connection);
        return this._video;
      }
      video() {
        if (!this._browserContext._options.recordVideo)
          return null;
        return this._forceVideo();
      }
      $(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.$(selector, options);
        });
      }
      waitForSelector(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForSelector(selector, options);
        });
      }
      dispatchEvent(selector, type, eventInit, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dispatchEvent(selector, type, eventInit, options);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          return this._mainFrame.evaluateHandle(pageFunction, arg);
        });
      }
      $eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          return this._mainFrame.$eval(selector, pageFunction, arg);
        });
      }
      $$eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          return this._mainFrame.$$eval(selector, pageFunction, arg);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          return this._mainFrame.$$(selector);
        });
      }
      addScriptTag() {
        return __async(this, arguments, function* (options = {}) {
          return this._mainFrame.addScriptTag(options);
        });
      }
      addStyleTag() {
        return __async(this, arguments, function* (options = {}) {
          return this._mainFrame.addStyleTag(options);
        });
      }
      exposeFunction(name, callback) {
        return __async(this, null, function* () {
          yield this._channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      exposeBinding(_0, _1) {
        return __async(this, arguments, function* (name, callback, options = {}) {
          yield this._channel.exposeBinding({
            name,
            needsHandle: options.handle
          });
          this._bindings.set(name, callback);
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          (0, _network2.validateHeaders)(headers);
          yield this._channel.setExtraHTTPHeaders({
            headers: (0, _utils.headersObjectToArray)(headers)
          });
        });
      }
      url() {
        return this._mainFrame.url();
      }
      content() {
        return __async(this, null, function* () {
          return this._mainFrame.content();
        });
      }
      setContent(html, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setContent(html, options);
        });
      }
      goto(url, options) {
        return __async(this, null, function* () {
          return this._mainFrame.goto(url, options);
        });
      }
      reload() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network2.Response.fromNullable((yield this._channel.reload(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      waitForLoadState(state, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForLoadState(state, options);
        });
      }
      waitForNavigation(options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForNavigation(options);
        });
      }
      waitForURL(url, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForURL(url, options);
        });
      }
      waitForRequest(_0) {
        return __async(this, arguments, function* (urlOrPredicate, options = {}) {
          const predicate = (request) => {
            if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate))
              return (0, _network.urlMatches)(this._browserContext._options.baseURL, request.url(), urlOrPredicate);
            return urlOrPredicate(request);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
          return this._waitForEvent(_events.Events.Page.Request, {
            predicate,
            timeout: options.timeout
          }, logLine);
        });
      }
      waitForResponse(_0) {
        return __async(this, arguments, function* (urlOrPredicate, options = {}) {
          const predicate = (response) => {
            if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate))
              return (0, _network.urlMatches)(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
            return urlOrPredicate(response);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
          return this._waitForEvent(_events.Events.Page.Response, {
            predicate,
            timeout: options.timeout
          }, logLine);
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
        });
      }
      _waitForEvent(event, optionsOrPredicate, logLine) {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            if (logLine)
              waiter.log(logLine);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.Page.Crash)
              waiter.rejectOnEvent(this, _events.Events.Page.Crash, new Error("Page crashed"));
            if (event !== _events.Events.Page.Close)
              waiter.rejectOnEvent(this, _events.Events.Page.Close, new Error("Page closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      goBack() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network2.Response.fromNullable((yield this._channel.goBack(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      goForward() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network2.Response.fromNullable((yield this._channel.goForward(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      emulateMedia() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.emulateMedia({
            media: options.media === null ? "no-override" : options.media,
            colorScheme: options.colorScheme === null ? "no-override" : options.colorScheme,
            reducedMotion: options.reducedMotion === null ? "no-override" : options.reducedMotion,
            forcedColors: options.forcedColors === null ? "no-override" : options.forcedColors
          });
        });
      }
      setViewportSize(viewportSize) {
        return __async(this, null, function* () {
          this._viewportSize = viewportSize;
          yield this._channel.setViewportSize({
            viewportSize
          });
        });
      }
      viewportSize() {
        return this._viewportSize;
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          return this._mainFrame.evaluate(pageFunction, arg);
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield (0, _clientHelper.evaluationScript)(script, arg);
          yield this._channel.addInitScript({
            source
          });
        });
      }
      route(_0, _1) {
        return __async(this, arguments, function* (url, handler, options = {}) {
          this._routes.unshift(new _network2.RouteHandler(this._browserContext._options.baseURL, url, handler, options.times));
          yield this._updateInterceptionPatterns();
        });
      }
      routeFromHAR(_0) {
        return __async(this, arguments, function* (har, options = {}) {
          if (options.update) {
            yield this._browserContext._recordIntoHAR(har, this, options);
            return;
          }
          const harRouter = yield _harRouter.HarRouter.create(this._connection.localUtils(), har, options.notFound || "abort", {
            urlMatch: options.url
          });
          harRouter.addPageRoute(this);
        });
      }
      unroute(url, handler) {
        return __async(this, null, function* () {
          this._routes = this._routes.filter((route) => !(0, _utils.urlMatchesEqual)(route.url, url) || handler && route.handler !== handler);
          yield this._updateInterceptionPatterns();
        });
      }
      _updateInterceptionPatterns() {
        return __async(this, null, function* () {
          const patterns = _network2.RouteHandler.prepareInterceptionPatterns(this._routes);
          yield this._channel.setNetworkInterceptionPatterns({
            patterns
          });
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadProps(__spreadValues({}, options), {
            mask: void 0
          });
          if (!copy.type)
            copy.type = (0, _elementHandle.determineScreenshotType)(options);
          if (options.mask) {
            copy.mask = options.mask.map((locator) => ({
              frame: locator._frame._channel,
              selector: locator._selector
            }));
          }
          const result = yield this._channel.screenshot(copy);
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, result.binary);
          }
          return result.binary;
        });
      }
      _expectScreenshot(options) {
        return __async(this, null, function* () {
          var _options$screenshotOp, _options$screenshotOp2;
          const mask = (_options$screenshotOp = options.screenshotOptions) !== null && _options$screenshotOp !== void 0 && _options$screenshotOp.mask ? (_options$screenshotOp2 = options.screenshotOptions) === null || _options$screenshotOp2 === void 0 ? void 0 : _options$screenshotOp2.mask.map((locator2) => ({
            frame: locator2._frame._channel,
            selector: locator2._selector
          })) : void 0;
          const locator = options.locator ? {
            frame: options.locator._frame._channel,
            selector: options.locator._selector
          } : void 0;
          return yield this._channel.expectScreenshot(__spreadProps(__spreadValues({}, options), {
            isNot: !!options.isNot,
            locator,
            screenshotOptions: __spreadProps(__spreadValues({}, options.screenshotOptions), {
              mask
            })
          }));
        });
      }
      title() {
        return __async(this, null, function* () {
          return this._mainFrame.title();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._channel.bringToFront();
        });
      }
      close() {
        return __async(this, arguments, function* (options = {
          runBeforeUnload: void 0
        }) {
          try {
            if (this._ownedContext)
              yield this._ownedContext.close();
            else
              yield this._channel.close(options);
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e) && !options.runBeforeUnload)
              return;
            throw e;
          }
        });
      }
      isClosed() {
        return this._closed;
      }
      click(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.click(selector, options);
        });
      }
      dragAndDrop(source, target, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dragAndDrop(source, target, options);
        });
      }
      dblclick(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dblclick(selector, options);
        });
      }
      tap(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.tap(selector, options);
        });
      }
      fill(selector, value, options) {
        return __async(this, null, function* () {
          return this._mainFrame.fill(selector, value, options);
        });
      }
      locator(selector, options) {
        return this.mainFrame().locator(selector, options);
      }
      getByTestId(testId) {
        return this.mainFrame().getByTestId(testId);
      }
      getByAltText(text, options) {
        return this.mainFrame().getByAltText(text, options);
      }
      getByLabel(text, options) {
        return this.mainFrame().getByLabel(text, options);
      }
      getByPlaceholder(text, options) {
        return this.mainFrame().getByPlaceholder(text, options);
      }
      getByText(text, options) {
        return this.mainFrame().getByText(text, options);
      }
      getByTitle(text, options) {
        return this.mainFrame().getByTitle(text, options);
      }
      getByRole(role, options = {}) {
        return this.mainFrame().getByRole(role, options);
      }
      frameLocator(selector) {
        return this.mainFrame().frameLocator(selector);
      }
      focus(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.focus(selector, options);
        });
      }
      textContent(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.textContent(selector, options);
        });
      }
      innerText(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.innerText(selector, options);
        });
      }
      innerHTML(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.innerHTML(selector, options);
        });
      }
      getAttribute(selector, name, options) {
        return __async(this, null, function* () {
          return this._mainFrame.getAttribute(selector, name, options);
        });
      }
      inputValue(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.inputValue(selector, options);
        });
      }
      isChecked(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isChecked(selector, options);
        });
      }
      isDisabled(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isDisabled(selector, options);
        });
      }
      isEditable(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isEditable(selector, options);
        });
      }
      isEnabled(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isEnabled(selector, options);
        });
      }
      isHidden(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isHidden(selector, options);
        });
      }
      isVisible(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isVisible(selector, options);
        });
      }
      hover(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.hover(selector, options);
        });
      }
      selectOption(selector, values, options) {
        return __async(this, null, function* () {
          return this._mainFrame.selectOption(selector, values, options);
        });
      }
      setInputFiles(selector, files, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setInputFiles(selector, files, options);
        });
      }
      type(selector, text, options) {
        return __async(this, null, function* () {
          return this._mainFrame.type(selector, text, options);
        });
      }
      press(selector, key, options) {
        return __async(this, null, function* () {
          return this._mainFrame.press(selector, key, options);
        });
      }
      check(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.check(selector, options);
        });
      }
      uncheck(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.uncheck(selector, options);
        });
      }
      setChecked(selector, checked, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setChecked(selector, checked, options);
        });
      }
      waitForTimeout(timeout) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForTimeout(timeout);
        });
      }
      waitForFunction(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForFunction(pageFunction, arg, options);
        });
      }
      workers() {
        return [...this._workers];
      }
      pause() {
        return __async(this, null, function* () {
          var _this$_instrumentatio;
          if (require("inspector").url())
            return;
          const defaultNavigationTimeout = this._browserContext._timeoutSettings.defaultNavigationTimeout();
          const defaultTimeout = this._browserContext._timeoutSettings.defaultTimeout();
          this._browserContext.setDefaultNavigationTimeout(0);
          this._browserContext.setDefaultTimeout(0);
          (_this$_instrumentatio = this._instrumentation) === null || _this$_instrumentatio === void 0 ? void 0 : _this$_instrumentatio.onWillPause();
          yield this._closedOrCrashedRace.safeRace(this.context()._channel.pause());
          this._browserContext.setDefaultNavigationTimeout(defaultNavigationTimeout);
          this._browserContext.setDefaultTimeout(defaultTimeout);
        });
      }
      pdf() {
        return __async(this, arguments, function* (options = {}) {
          const transportOptions = __spreadValues({}, options);
          if (transportOptions.margin)
            transportOptions.margin = __spreadValues({}, transportOptions.margin);
          if (typeof options.width === "number")
            transportOptions.width = options.width + "px";
          if (typeof options.height === "number")
            transportOptions.height = options.height + "px";
          for (const margin of ["top", "right", "bottom", "left"]) {
            const index = margin;
            if (options.margin && typeof options.margin[index] === "number")
              transportOptions.margin[index] = transportOptions.margin[index] + "px";
          }
          const result = yield this._channel.pdf(transportOptions);
          if (options.path) {
            yield _fs.default.promises.mkdir(_path.default.dirname(options.path), {
              recursive: true
            });
            yield _fs.default.promises.writeFile(options.path, result.pdf);
          }
          return result.pdf;
        });
      }
    };
    exports2.Page = Page;
    var BindingCall = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      call(func) {
        return __async(this, null, function* () {
          try {
            const frame = _frame.Frame.from(this._initializer.frame);
            const source = {
              context: frame._page.context(),
              page: frame._page,
              frame
            };
            let result;
            if (this._initializer.handle)
              result = yield func(source, _jsHandle.JSHandle.from(this._initializer.handle));
            else
              result = yield func(source, ...this._initializer.args.map(_jsHandle.parseResult));
            this._channel.resolve({
              result: (0, _jsHandle.serializeArgument)(result)
            }).catch(() => {
            });
          } catch (e) {
            this._channel.reject({
              error: (0, _serializers.serializeError)(e)
            }).catch(() => {
            });
          }
        });
      }
    };
    exports2.BindingCall = BindingCall;
    function trimEnd(s) {
      if (s.length > 50)
        s = s.substring(0, 50) + "\u2026";
      return s;
    }
    function trimUrl(param) {
      if ((0, _utils.isRegExp)(param))
        return `/${trimEnd(param.source)}/${param.flags}`;
      if ((0, _utils.isString)(param))
        return `"${trimEnd(param)}"`;
    }
  }
});

// node_modules/playwright-core/lib/client/cdpSession.js
var require_cdpSession = __commonJS({
  "node_modules/playwright-core/lib/client/cdpSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CDPSession = void 0;
    var _channelOwner = require_channelOwner();
    var CDPSession = class extends _channelOwner.ChannelOwner {
      static from(cdpSession) {
        return cdpSession._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("event", ({
          method,
          params
        }) => {
          this.emit(method, params);
        });
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          const result = yield this._channel.send({
            method,
            params
          });
          return result.result;
        });
      }
      detach() {
        return __async(this, null, function* () {
          return this._channel.detach();
        });
      }
    };
    exports2.CDPSession = CDPSession;
  }
});

// node_modules/playwright-core/lib/client/consoleMessage.js
var require_consoleMessage = __commonJS({
  "node_modules/playwright-core/lib/client/consoleMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessage = void 0;
    var util = _interopRequireWildcard(require("util"));
    var _jsHandle = require_jsHandle();
    var _channelOwner = require_channelOwner();
    var _page = require_page2();
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    _util$inspect$custom = util.inspect.custom;
    var ConsoleMessage = class extends _channelOwner.ChannelOwner {
      static from(message) {
        return message._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._page = _page.Page.fromNullable(initializer.page);
      }
      page() {
        return this._page;
      }
      type() {
        return this._initializer.type;
      }
      text() {
        return this._initializer.text;
      }
      args() {
        return this._initializer.args.map(_jsHandle.JSHandle.from);
      }
      location() {
        return this._initializer.location;
      }
      [_util$inspect$custom]() {
        return this.text();
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/client/dialog.js
var require_dialog2 = __commonJS({
  "node_modules/playwright-core/lib/client/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Dialog = void 0;
    var _channelOwner = require_channelOwner();
    var _page = require_page2();
    var Dialog = class extends _channelOwner.ChannelOwner {
      static from(dialog) {
        return dialog._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._page = _page.Page.fromNullable(initializer.page);
      }
      page() {
        return this._page;
      }
      type() {
        return this._initializer.type;
      }
      message() {
        return this._initializer.message;
      }
      defaultValue() {
        return this._initializer.defaultValue;
      }
      accept(promptText) {
        return __async(this, null, function* () {
          yield this._channel.accept({
            promptText
          });
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          yield this._channel.dismiss();
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/client/browserContext.js
var require_browserContext2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContext = void 0;
    exports2.prepareBrowserContextParams = prepareBrowserContextParams;
    var _page = require_page2();
    var _frame = require_frame();
    var network = _interopRequireWildcard(require_network3());
    var _fs = _interopRequireDefault(require("fs"));
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _browser = require_browser2();
    var _worker = require_worker();
    var _events = require_events();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _cdpSession = require_cdpSession();
    var _tracing = require_tracing2();
    var _artifact = require_artifact2();
    var _fetch = require_fetch2();
    var _stackTrace = require_stackTrace();
    var _harRouter = require_harRouter();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _channelOwner.ChannelOwner {
      static from(context) {
        return context._object;
      }
      static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
      }
      constructor(parent, type, guid, initializer) {
        var _this$_browser, _this$_browser2;
        super(parent, type, guid, initializer);
        this._pages = /* @__PURE__ */ new Set();
        this._routes = [];
        this._browser = null;
        this._browserType = void 0;
        this._bindings = /* @__PURE__ */ new Map();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._ownerPage = void 0;
        this._closedPromise = void 0;
        this._options = {};
        this.request = void 0;
        this.tracing = void 0;
        this._backgroundPages = /* @__PURE__ */ new Set();
        this._serviceWorkers = /* @__PURE__ */ new Set();
        this._isChromium = void 0;
        this._harRecorders = /* @__PURE__ */ new Map();
        this._closeWasCalled = false;
        if (parent instanceof _browser.Browser)
          this._browser = parent;
        (_this$_browser = this._browser) === null || _this$_browser === void 0 ? void 0 : _this$_browser._contexts.add(this);
        this._isChromium = ((_this$_browser2 = this._browser) === null || _this$_browser2 === void 0 ? void 0 : _this$_browser2._name) === "chromium";
        this.tracing = _tracing.Tracing.from(initializer.tracing);
        this.request = _fetch.APIRequestContext.from(initializer.requestContext);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(_page.BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("page", ({
          page
        }) => this._onPage(_page.Page.from(page)));
        this._channel.on("route", ({
          route
        }) => this._onRoute(network.Route.from(route)));
        this._channel.on("backgroundPage", ({
          page
        }) => {
          const backgroundPage = _page.Page.from(page);
          this._backgroundPages.add(backgroundPage);
          this.emit(_events.Events.BrowserContext.BackgroundPage, backgroundPage);
        });
        this._channel.on("serviceWorker", ({
          worker
        }) => {
          const serviceWorker = _worker.Worker.from(worker);
          serviceWorker._context = this;
          this._serviceWorkers.add(serviceWorker);
          this.emit(_events.Events.BrowserContext.ServiceWorker, serviceWorker);
        });
        this._channel.on("console", ({
          message
        }) => {
          const consoleMessage = _consoleMessage.ConsoleMessage.from(message);
          this.emit(_events.Events.BrowserContext.Console, consoleMessage);
          const page = consoleMessage.page();
          if (page)
            page.emit(_events.Events.Page.Console, consoleMessage);
        });
        this._channel.on("dialog", ({
          dialog
        }) => {
          const dialogObject = _dialog.Dialog.from(dialog);
          let hasListeners = this.emit(_events.Events.BrowserContext.Dialog, dialogObject);
          const page = dialogObject.page();
          if (page)
            hasListeners = page.emit(_events.Events.Page.Dialog, dialogObject) || hasListeners;
          if (!hasListeners) {
            if (dialogObject.type() === "beforeunload")
              dialog.accept({}).catch(() => {
              });
            else
              dialog.dismiss().catch(() => {
              });
          }
        });
        this._channel.on("request", ({
          request,
          page
        }) => this._onRequest(network.Request.from(request), _page.Page.fromNullable(page)));
        this._channel.on("requestFailed", ({
          request,
          failureText,
          responseEndTiming,
          page
        }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, _page.Page.fromNullable(page)));
        this._channel.on("requestFinished", (params) => this._onRequestFinished(params));
        this._channel.on("response", ({
          response,
          page
        }) => this._onResponse(network.Response.from(response), _page.Page.fromNullable(page)));
        this._closedPromise = new Promise((f) => this.once(_events.Events.BrowserContext.Close, f));
        this._setEventToSubscriptionMapping(/* @__PURE__ */ new Map([[_events.Events.BrowserContext.Console, "console"], [_events.Events.BrowserContext.Dialog, "dialog"], [_events.Events.BrowserContext.Request, "request"], [_events.Events.BrowserContext.Response, "response"], [_events.Events.BrowserContext.RequestFinished, "requestFinished"], [_events.Events.BrowserContext.RequestFailed, "requestFailed"]]));
      }
      _setOptions(contextOptions, browserOptions) {
        this._options = contextOptions;
        if (this._options.recordHar)
          this._harRecorders.set("", {
            path: this._options.recordHar.path,
            content: this._options.recordHar.content
          });
        this.tracing._tracesDir = browserOptions.tracesDir;
      }
      _onPage(page) {
        this._pages.add(page);
        this.emit(_events.Events.BrowserContext.Page, page);
        if (page._opener && !page._opener.isClosed())
          page._opener.emit(_events.Events.Page.Popup, page);
      }
      _onRequest(request, page) {
        this.emit(_events.Events.BrowserContext.Request, request);
        if (page)
          page.emit(_events.Events.Page.Request, request);
      }
      _onResponse(response, page) {
        this.emit(_events.Events.BrowserContext.Response, response);
        if (page)
          page.emit(_events.Events.Page.Response, response);
      }
      _onRequestFailed(request, responseEndTiming, failureText, page) {
        request._failureText = failureText || null;
        request._setResponseEndTiming(responseEndTiming);
        this.emit(_events.Events.BrowserContext.RequestFailed, request);
        if (page)
          page.emit(_events.Events.Page.RequestFailed, request);
      }
      _onRequestFinished(params) {
        const {
          responseEndTiming
        } = params;
        const request = network.Request.from(params.request);
        const response = network.Response.fromNullable(params.response);
        const page = _page.Page.fromNullable(params.page);
        request._setResponseEndTiming(responseEndTiming);
        this.emit(_events.Events.BrowserContext.RequestFinished, request);
        if (page)
          page.emit(_events.Events.Page.RequestFinished, request);
        if (response)
          response._finishedPromise.resolve(null);
      }
      _onRoute(route) {
        return __async(this, null, function* () {
          const routeHandlers = this._routes.slice();
          for (const routeHandler of routeHandlers) {
            if (!routeHandler.matches(route.request().url()))
              continue;
            if (routeHandler.willExpire())
              this._routes.splice(this._routes.indexOf(routeHandler), 1);
            const handled = yield routeHandler.handle(route);
            if (!this._routes.length)
              this._wrapApiCall(() => this._updateInterceptionPatterns(), true).catch(() => {
              });
            if (handled)
              return;
          }
          yield route._innerContinue(true);
        });
      }
      _onBinding(bindingCall) {
        return __async(this, null, function* () {
          const func = this._bindings.get(bindingCall._initializer.name);
          if (!func)
            return;
          yield bindingCall.call(func);
        });
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultNavigationTimeoutNoReply({
            timeout
          }).catch(() => {
          });
        }), true);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultTimeoutNoReply({
            timeout
          }).catch(() => {
          });
        }), true);
      }
      browser() {
        return this._browser;
      }
      pages() {
        return [...this._pages];
      }
      newPage() {
        return __async(this, null, function* () {
          if (this._ownerPage)
            throw new Error("Please use browser.newContext()");
          return _page.Page.from((yield this._channel.newPage()).page);
        });
      }
      cookies(urls) {
        return __async(this, null, function* () {
          if (!urls)
            urls = [];
          if (urls && typeof urls === "string")
            urls = [urls];
          return (yield this._channel.cookies({
            urls
          })).cookies;
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._channel.addCookies({
            cookies
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._channel.clearCookies();
        });
      }
      grantPermissions(permissions, options) {
        return __async(this, null, function* () {
          yield this._channel.grantPermissions(__spreadValues({
            permissions
          }, options));
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          yield this._channel.clearPermissions();
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          yield this._channel.setGeolocation({
            geolocation: geolocation || void 0
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          network.validateHeaders(headers);
          yield this._channel.setExtraHTTPHeaders({
            headers: (0, _utils.headersObjectToArray)(headers)
          });
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          yield this._channel.setOffline({
            offline
          });
        });
      }
      setHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          yield this._channel.setHTTPCredentials({
            httpCredentials: httpCredentials || void 0
          });
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield (0, _clientHelper.evaluationScript)(script, arg);
          yield this._channel.addInitScript({
            source
          });
        });
      }
      exposeBinding(_0, _1) {
        return __async(this, arguments, function* (name, callback, options = {}) {
          yield this._channel.exposeBinding({
            name,
            needsHandle: options.handle
          });
          this._bindings.set(name, callback);
        });
      }
      exposeFunction(name, callback) {
        return __async(this, null, function* () {
          yield this._channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      route(_0, _1) {
        return __async(this, arguments, function* (url, handler, options = {}) {
          this._routes.unshift(new network.RouteHandler(this._options.baseURL, url, handler, options.times));
          yield this._updateInterceptionPatterns();
        });
      }
      _recordIntoHAR(_0, _1) {
        return __async(this, arguments, function* (har, page, options = {}) {
          var _options$updateConten, _options$updateMode, _options$updateConten2;
          const {
            harId
          } = yield this._channel.harStart({
            page: page === null || page === void 0 ? void 0 : page._channel,
            options: prepareRecordHarOptions({
              path: har,
              content: (_options$updateConten = options.updateContent) !== null && _options$updateConten !== void 0 ? _options$updateConten : "attach",
              mode: (_options$updateMode = options.updateMode) !== null && _options$updateMode !== void 0 ? _options$updateMode : "minimal",
              urlFilter: options.url
            })
          });
          this._harRecorders.set(harId, {
            path: har,
            content: (_options$updateConten2 = options.updateContent) !== null && _options$updateConten2 !== void 0 ? _options$updateConten2 : "attach"
          });
        });
      }
      routeFromHAR(_0) {
        return __async(this, arguments, function* (har, options = {}) {
          if (options.update) {
            yield this._recordIntoHAR(har, null, options);
            return;
          }
          const harRouter = yield _harRouter.HarRouter.create(this._connection.localUtils(), har, options.notFound || "abort", {
            urlMatch: options.url
          });
          harRouter.addContextRoute(this);
        });
      }
      unroute(url, handler) {
        return __async(this, null, function* () {
          this._routes = this._routes.filter((route) => !(0, _utils.urlMatchesEqual)(route.url, url) || handler && route.handler !== handler);
          yield this._updateInterceptionPatterns();
        });
      }
      _updateInterceptionPatterns() {
        return __async(this, null, function* () {
          const patterns = network.RouteHandler.prepareInterceptionPatterns(this._routes);
          yield this._channel.setNetworkInterceptionPatterns({
            patterns
          });
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.BrowserContext.Close)
              waiter.rejectOnEvent(this, _events.Events.BrowserContext.Close, new Error("Context closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      storageState() {
        return __async(this, arguments, function* (options = {}) {
          const state = yield this._channel.storageState();
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
      backgroundPages() {
        return [...this._backgroundPages];
      }
      serviceWorkers() {
        return [...this._serviceWorkers];
      }
      newCDPSession(page) {
        return __async(this, null, function* () {
          if (!(page instanceof _page.Page) && !(page instanceof _frame.Frame))
            throw new Error("page: expected Page or Frame");
          const result = yield this._channel.newCDPSession(page instanceof _page.Page ? {
            page: page._channel
          } : {
            frame: page._channel
          });
          return _cdpSession.CDPSession.from(result.session);
        });
      }
      _onClose() {
        var _this$_browserType, _this$_browserType$_c;
        if (this._browser)
          this._browser._contexts.delete(this);
        (_this$_browserType = this._browserType) === null || _this$_browserType === void 0 ? void 0 : (_this$_browserType$_c = _this$_browserType._contexts) === null || _this$_browserType$_c === void 0 ? void 0 : _this$_browserType$_c.delete(this);
        this.emit(_events.Events.BrowserContext.Close, this);
      }
      close() {
        return __async(this, null, function* () {
          if (this._closeWasCalled)
            return;
          this._closeWasCalled = true;
          yield this._wrapApiCall(() => __async(this, null, function* () {
            var _this$_browserType2;
            yield (_this$_browserType2 = this._browserType) === null || _this$_browserType2 === void 0 ? void 0 : _this$_browserType2._willCloseContext(this);
            for (const [harId, harParams] of this._harRecorders) {
              const har = yield this._channel.harExport({
                harId
              });
              const artifact = _artifact.Artifact.from(har.artifact);
              const isCompressed = harParams.content === "attach" || harParams.path.endsWith(".zip");
              const needCompressed = harParams.path.endsWith(".zip");
              if (isCompressed && !needCompressed) {
                yield artifact.saveAs(harParams.path + ".tmp");
                yield this._connection.localUtils()._channel.harUnzip({
                  zipFile: harParams.path + ".tmp",
                  harFile: harParams.path
                });
              } else {
                yield artifact.saveAs(harParams.path);
              }
              yield artifact.delete();
            }
          }), true);
          yield this._channel.close();
          yield this._closedPromise;
        });
      }
      _enableRecorder(params) {
        return __async(this, null, function* () {
          yield this._channel.recorderSupplementEnable(params);
        });
      }
    };
    exports2.BrowserContext = BrowserContext;
    function prepareStorageState(options) {
      return __async(this, null, function* () {
        if (typeof options.storageState !== "string")
          return options.storageState;
        try {
          return JSON.parse(yield _fs.default.promises.readFile(options.storageState, "utf8"));
        } catch (e) {
          (0, _stackTrace.rewriteErrorMessage)(e, `Error reading storage state from ${options.storageState}:
` + e.message);
          throw e;
        }
      });
    }
    function prepareRecordHarOptions(options) {
      if (!options)
        return;
      return {
        path: options.path,
        content: options.content || (options.omitContent ? "omit" : void 0),
        urlGlob: (0, _utils.isString)(options.urlFilter) ? options.urlFilter : void 0,
        urlRegexSource: (0, _utils.isRegExp)(options.urlFilter) ? options.urlFilter.source : void 0,
        urlRegexFlags: (0, _utils.isRegExp)(options.urlFilter) ? options.urlFilter.flags : void 0,
        mode: options.mode
      };
    }
    function prepareBrowserContextParams(options) {
      return __async(this, null, function* () {
        if (options.videoSize && !options.videosPath)
          throw new Error(`"videoSize" option requires "videosPath" to be specified`);
        if (options.extraHTTPHeaders)
          network.validateHeaders(options.extraHTTPHeaders);
        const contextParams = __spreadProps(__spreadValues({}, options), {
          viewport: options.viewport === null ? void 0 : options.viewport,
          noDefaultViewport: options.viewport === null,
          extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : void 0,
          storageState: yield prepareStorageState(options),
          serviceWorkers: options.serviceWorkers,
          recordHar: prepareRecordHarOptions(options.recordHar),
          colorScheme: options.colorScheme === null ? "no-override" : options.colorScheme,
          reducedMotion: options.reducedMotion === null ? "no-override" : options.reducedMotion,
          forcedColors: options.forcedColors === null ? "no-override" : options.forcedColors
        });
        if (!contextParams.recordVideo && options.videosPath) {
          contextParams.recordVideo = {
            dir: options.videosPath,
            size: options.videoSize
          };
        }
        return contextParams;
      });
    }
  }
});

// node_modules/playwright-core/lib/client/browser.js
var require_browser2 = __commonJS({
  "node_modules/playwright-core/lib/client/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Browser = void 0;
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _events = require_events();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var Browser = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._contexts = /* @__PURE__ */ new Set();
        this._isConnected = true;
        this._closedPromise = void 0;
        this._shouldCloseConnectionOnClose = false;
        this._browserType = void 0;
        this._options = {};
        this._name = void 0;
        this._connectHeaders = void 0;
        this._name = initializer.name;
        this._channel.on("close", () => this._didClose());
        this._closedPromise = new Promise((f) => this.once(_events.Events.Browser.Disconnected, f));
      }
      browserType() {
        return this._browserType;
      }
      newContext() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._innerNewContext(options, false);
        });
      }
      _newContextForReuse() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            for (const context of this._contexts) {
              yield this._browserType._willCloseContext(context);
              for (const page of context.pages())
                page._onClose();
              context._onClose();
            }
            return yield this._innerNewContext(options, true);
          }), true);
        });
      }
      _innerNewContext() {
        return __async(this, arguments, function* (options = {}, forReuse) {
          options = __spreadValues(__spreadValues({}, this._browserType._defaultContextOptions), options);
          const contextOptions = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const response = forReuse ? yield this._channel.newContextForReuse(contextOptions) : yield this._channel.newContext(contextOptions);
          const context = _browserContext.BrowserContext.from(response.context);
          yield this._browserType._didCreateContext(context, contextOptions, this._options, options.logger || this._logger);
          return context;
        });
      }
      contexts() {
        return [...this._contexts];
      }
      version() {
        return this._initializer.version;
      }
      newPage() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const context = yield this.newContext(options);
            const page = yield context.newPage();
            page._ownedContext = context;
            context._ownerPage = page;
            return page;
          }));
        });
      }
      isConnected() {
        return this._isConnected;
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          return _cdpSession.CDPSession.from((yield this._channel.newBrowserCDPSession()).session);
        });
      }
      startTracing(_0) {
        return __async(this, arguments, function* (page, options = {}) {
          yield this._channel.startTracing(__spreadProps(__spreadValues({}, options), {
            page: page ? page._channel : void 0
          }));
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          return (yield this._channel.stopTracing()).binary;
        });
      }
      close() {
        return __async(this, null, function* () {
          try {
            if (this._shouldCloseConnectionOnClose)
              this._connection.close(_errors.kBrowserClosedError);
            else
              yield this._channel.close();
            yield this._closedPromise;
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      _didClose() {
        this._isConnected = false;
        this.emit(_events.Events.Browser.Disconnected, this);
      }
    };
    exports2.Browser = Browser;
  }
});

// node_modules/playwright-core/lib/client/browserType.js
var require_browserType2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserType = void 0;
    var _browser3 = require_browser2();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _connection = require_connection();
    var _events = require_events();
    var _clientHelper = require_clientHelper();
    var _utils = require_utils();
    var _errors = require_errors();
    var _timeoutRunner = require_timeoutRunner();
    var BrowserType = class extends _channelOwner.ChannelOwner {
      constructor(...args) {
        super(...args);
        this._serverLauncher = void 0;
        this._contexts = /* @__PURE__ */ new Set();
        this._playwright = void 0;
        this._defaultContextOptions = void 0;
        this._defaultContextTimeout = void 0;
        this._defaultContextNavigationTimeout = void 0;
        this._defaultLaunchOptions = void 0;
        this._defaultConnectOptions = void 0;
      }
      static from(browserType) {
        return browserType._object;
      }
      executablePath() {
        if (!this._initializer.executablePath)
          throw new Error("Browser is not supported on current platform");
        return this._initializer.executablePath;
      }
      name() {
        return this._initializer.name;
      }
      launch() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_defaultLaunchO;
          (0, _utils.assert)(!options.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
          (0, _utils.assert)(!options.port, "Cannot specify a port without launching as a server.");
          if (this._defaultConnectOptions)
            return yield this._connectInsteadOfLaunching(this._defaultConnectOptions, options);
          const logger = options.logger || ((_this$_defaultLaunchO = this._defaultLaunchOptions) === null || _this$_defaultLaunchO === void 0 ? void 0 : _this$_defaultLaunchO.logger);
          options = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options);
          const launchOptions = __spreadProps(__spreadValues({}, options), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0
          });
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const browser = _browser3.Browser.from((yield this._channel.launch(launchOptions)).browser);
            this._didLaunchBrowser(browser, options, logger);
            return browser;
          }));
        });
      }
      _connectInsteadOfLaunching(connectOptions, launchOptions) {
        return __async(this, null, function* () {
          var _connectOptions$timeo;
          return this._connect({
            wsEndpoint: connectOptions.wsEndpoint,
            headers: __spreadValues({
              "x-playwright-launch-options": JSON.stringify(__spreadValues(__spreadValues({}, this._defaultLaunchOptions), launchOptions))
            }, connectOptions.headers),
            _exposeNetwork: connectOptions._exposeNetwork,
            slowMo: connectOptions.slowMo,
            timeout: (_connectOptions$timeo = connectOptions.timeout) !== null && _connectOptions$timeo !== void 0 ? _connectOptions$timeo : 3 * 60 * 1e3
          });
        });
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          if (!this._serverLauncher)
            throw new Error("Launching server is not supported");
          options = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options);
          return this._serverLauncher.launchServer(options);
        });
      }
      launchPersistentContext(_0) {
        return __async(this, arguments, function* (userDataDir, options = {}) {
          var _this$_defaultLaunchO2;
          const logger = options.logger || ((_this$_defaultLaunchO2 = this._defaultLaunchOptions) === null || _this$_defaultLaunchO2 === void 0 ? void 0 : _this$_defaultLaunchO2.logger);
          (0, _utils.assert)(!options.port, "Cannot specify a port without launching as a server.");
          options = __spreadValues(__spreadValues(__spreadValues({}, this._defaultLaunchOptions), this._defaultContextOptions), options);
          const contextParams = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const persistentParams = __spreadProps(__spreadValues({}, contextParams), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0,
            channel: options.channel,
            userDataDir
          });
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const result = yield this._channel.launchPersistentContext(persistentParams);
            const context = _browserContext.BrowserContext.from(result.context);
            yield this._didCreateContext(context, contextParams, options, logger);
            return context;
          }));
        });
      }
      connect(optionsOrWsEndpoint, options) {
        return __async(this, null, function* () {
          if (typeof optionsOrWsEndpoint === "string")
            return this._connect(__spreadProps(__spreadValues({}, options), {
              wsEndpoint: optionsOrWsEndpoint
            }));
          (0, _utils.assert)(optionsOrWsEndpoint.wsEndpoint, "options.wsEndpoint is required");
          return this._connect(optionsOrWsEndpoint);
        });
      }
      _connect(params) {
        return __async(this, null, function* () {
          const logger = params.logger;
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const deadline = params.timeout ? (0, _utils.monotonicTime)() + params.timeout : 0;
            const headers = __spreadValues({
              "x-playwright-browser": this.name()
            }, params.headers);
            const localUtils = this._connection.localUtils();
            const connectParams = {
              wsEndpoint: params.wsEndpoint,
              headers,
              exposeNetwork: params._exposeNetwork,
              slowMo: params.slowMo,
              timeout: params.timeout
            };
            if (params.__testHookRedirectPortForwarding)
              connectParams.socksProxyRedirectPortForTest = params.__testHookRedirectPortForwarding;
            const {
              pipe,
              headers: connectHeaders
            } = yield localUtils._channel.connect(connectParams);
            const closePipe = () => pipe.close().catch(() => {
            });
            const connection = new _connection.Connection(localUtils, this._instrumentation);
            connection.markAsRemote();
            connection.on("close", closePipe);
            let browser;
            let closeError;
            const onPipeClosed = () => {
              var _browser2;
              for (const context of ((_browser = browser) === null || _browser === void 0 ? void 0 : _browser.contexts()) || []) {
                var _browser;
                for (const page of context.pages())
                  page._onClose();
                context._onClose();
              }
              (_browser2 = browser) === null || _browser2 === void 0 ? void 0 : _browser2._didClose();
              connection.close(closeError || _errors.kBrowserClosedError);
            };
            pipe.on("closed", onPipeClosed);
            connection.onmessage = (message) => pipe.send({
              message
            }).catch(onPipeClosed);
            pipe.on("message", ({
              message
            }) => {
              try {
                connection.dispatch(message);
              } catch (e) {
                closeError = e.toString();
                closePipe();
              }
            });
            const result = yield (0, _timeoutRunner.raceAgainstTimeout)(() => __async(this, null, function* () {
              if (params.__testHookBeforeCreateBrowser)
                yield params.__testHookBeforeCreateBrowser();
              const playwright = yield connection.initializePlaywright();
              if (!playwright._initializer.preLaunchedBrowser) {
                closePipe();
                throw new Error("Malformed endpoint. Did you use BrowserType.launchServer method?");
              }
              playwright._setSelectors(this._playwright.selectors);
              browser = _browser3.Browser.from(playwright._initializer.preLaunchedBrowser);
              this._didLaunchBrowser(browser, {}, logger);
              browser._shouldCloseConnectionOnClose = true;
              browser._connectHeaders = connectHeaders;
              browser.on(_events.Events.Browser.Disconnected, closePipe);
              return browser;
            }), deadline ? deadline - (0, _utils.monotonicTime)() : 0);
            if (!result.timedOut) {
              return result.result;
            } else {
              closePipe();
              throw new Error(`Timeout ${params.timeout}ms exceeded`);
            }
          }));
        });
      }
      connectOverCDP(endpointURLOrOptions, options) {
        if (typeof endpointURLOrOptions === "string")
          return this._connectOverCDP(endpointURLOrOptions, options);
        const endpointURL = "endpointURL" in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
        (0, _utils.assert)(endpointURL, "Cannot connect over CDP without wsEndpoint.");
        return this.connectOverCDP(endpointURL, endpointURLOrOptions);
      }
      _connectOverCDP(_0) {
        return __async(this, arguments, function* (endpointURL, params = {}) {
          if (this.name() !== "chromium")
            throw new Error("Connecting over CDP is only supported in Chromium.");
          const headers = params.headers ? (0, _utils.headersObjectToArray)(params.headers) : void 0;
          const result = yield this._channel.connectOverCDP({
            endpointURL,
            headers,
            slowMo: params.slowMo,
            timeout: params.timeout
          });
          const browser = _browser3.Browser.from(result.browser);
          this._didLaunchBrowser(browser, {}, params.logger);
          if (result.defaultContext)
            yield this._didCreateContext(_browserContext.BrowserContext.from(result.defaultContext), {}, {}, void 0);
          return browser;
        });
      }
      _didLaunchBrowser(browser, browserOptions, logger) {
        browser._browserType = this;
        browser._options = browserOptions;
        browser._logger = logger;
      }
      _didCreateContext(context, contextOptions, browserOptions, logger) {
        return __async(this, null, function* () {
          context._logger = logger;
          context._browserType = this;
          this._contexts.add(context);
          context._setOptions(contextOptions, browserOptions);
          if (this._defaultContextTimeout !== void 0)
            context.setDefaultTimeout(this._defaultContextTimeout);
          if (this._defaultContextNavigationTimeout !== void 0)
            context.setDefaultNavigationTimeout(this._defaultContextNavigationTimeout);
          yield this._instrumentation.onDidCreateBrowserContext(context);
        });
      }
      _willCloseContext(context) {
        return __async(this, null, function* () {
          this._contexts.delete(context);
          yield this._instrumentation.onWillCloseBrowserContext(context);
        });
      }
    };
    exports2.BrowserType = BrowserType;
  }
});

// node_modules/playwright-core/lib/client/android.js
var require_android2 = __commonJS({
  "node_modules/playwright-core/lib/client/android.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidWebView = exports2.AndroidSocket = exports2.AndroidInput = exports2.AndroidDevice = exports2.Android = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _utils = require_utils();
    var _events = require_events();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _events2 = require("events");
    var _connection = require_connection();
    var _errors = require_errors();
    var _timeoutRunner = require_timeoutRunner();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Android = class extends _channelOwner.ChannelOwner {
      static from(android) {
        return android._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._serverLauncher = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      devices() {
        return __async(this, arguments, function* (options = {}) {
          const {
            devices
          } = yield this._channel.devices(options);
          return devices.map((d) => AndroidDevice.from(d));
        });
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          if (!this._serverLauncher)
            throw new Error("Launching server is not supported");
          return this._serverLauncher.launchServer(options);
        });
      }
      connect(_0) {
        return __async(this, arguments, function* (wsEndpoint, options = {}) {
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const deadline = options.timeout ? (0, _utils.monotonicTime)() + options.timeout : 0;
            const headers = __spreadValues({
              "x-playwright-browser": "android"
            }, options.headers);
            const localUtils = this._connection.localUtils();
            const connectParams = {
              wsEndpoint,
              headers,
              slowMo: options.slowMo,
              timeout: options.timeout
            };
            const {
              pipe
            } = yield localUtils._channel.connect(connectParams);
            const closePipe = () => pipe.close().catch(() => {
            });
            const connection = new _connection.Connection(localUtils, this._instrumentation);
            connection.markAsRemote();
            connection.on("close", closePipe);
            let device;
            let closeError;
            const onPipeClosed = () => {
              var _device;
              (_device = device) === null || _device === void 0 ? void 0 : _device._didClose();
              connection.close(closeError || _errors.kBrowserClosedError);
            };
            pipe.on("closed", onPipeClosed);
            connection.onmessage = (message) => pipe.send({
              message
            }).catch(onPipeClosed);
            pipe.on("message", ({
              message
            }) => {
              try {
                connection.dispatch(message);
              } catch (e) {
                closeError = e.toString();
                closePipe();
              }
            });
            const result = yield (0, _timeoutRunner.raceAgainstTimeout)(() => __async(this, null, function* () {
              const playwright = yield connection.initializePlaywright();
              if (!playwright._initializer.preConnectedAndroidDevice) {
                closePipe();
                throw new Error("Malformed endpoint. Did you use Android.launchServer method?");
              }
              device = AndroidDevice.from(playwright._initializer.preConnectedAndroidDevice);
              device._shouldCloseConnectionOnClose = true;
              device.on(_events.Events.AndroidDevice.Close, closePipe);
              return device;
            }), deadline ? deadline - (0, _utils.monotonicTime)() : 0);
            if (!result.timedOut) {
              return result.result;
            } else {
              closePipe();
              throw new Error(`Timeout ${options.timeout}ms exceeded`);
            }
          }));
        });
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._webViews = /* @__PURE__ */ new Map();
        this._shouldCloseConnectionOnClose = false;
        this.input = void 0;
        this.input = new AndroidInput(this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(parent._timeoutSettings);
        this._channel.on("webViewAdded", ({
          webView
        }) => this._onWebViewAdded(webView));
        this._channel.on("webViewRemoved", ({
          socketName
        }) => this._onWebViewRemoved(socketName));
        this._channel.on("close", () => this._didClose());
      }
      _onWebViewAdded(webView) {
        const view = new AndroidWebView(this, webView);
        this._webViews.set(webView.socketName, view);
        this.emit(_events.Events.AndroidDevice.WebView, view);
      }
      _onWebViewRemoved(socketName) {
        const view = this._webViews.get(socketName);
        this._webViews.delete(socketName);
        if (view)
          view.emit(_events.Events.AndroidWebView.Close);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      serial() {
        return this._initializer.serial;
      }
      model() {
        return this._initializer.model;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      webView(selector, options) {
        return __async(this, null, function* () {
          const predicate = (v) => {
            if (selector.pkg)
              return v.pkg() === selector.pkg;
            if (selector.socketName)
              return v._socketName() === selector.socketName;
            return false;
          };
          const webView = [...this._webViews.values()].find(predicate);
          if (webView)
            return webView;
          return this.waitForEvent("webview", __spreadProps(__spreadValues({}, options), {
            predicate
          }));
        });
      }
      wait(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.wait(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      fill(selector, text, options) {
        return __async(this, null, function* () {
          yield this._channel.fill(__spreadValues({
            selector: toSelectorChannel(selector),
            text
          }, options));
        });
      }
      press(selector, key, options) {
        return __async(this, null, function* () {
          yield this.tap(selector, options);
          yield this.input.press(key);
        });
      }
      tap(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.tap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      drag(selector, dest, options) {
        return __async(this, null, function* () {
          yield this._channel.drag(__spreadValues({
            selector: toSelectorChannel(selector),
            dest
          }, options));
        });
      }
      fling(selector, direction, options) {
        return __async(this, null, function* () {
          yield this._channel.fling(__spreadValues({
            selector: toSelectorChannel(selector),
            direction
          }, options));
        });
      }
      longTap(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.longTap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      pinchClose(selector, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.pinchClose(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options));
        });
      }
      pinchOpen(selector, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.pinchOpen(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options));
        });
      }
      scroll(selector, direction, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.scroll(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options));
        });
      }
      swipe(selector, direction, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.swipe(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options));
        });
      }
      info(selector) {
        return __async(this, null, function* () {
          return (yield this._channel.info({
            selector: toSelectorChannel(selector)
          })).info;
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const {
            binary
          } = yield this._channel.screenshot();
          if (options.path)
            yield _fs.default.promises.writeFile(options.path, binary);
          return binary;
        });
      }
      close() {
        return __async(this, null, function* () {
          try {
            if (this._shouldCloseConnectionOnClose)
              this._connection.close(_errors.kBrowserClosedError);
            else
              yield this._channel.close();
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      _didClose() {
        this.emit(_events.Events.AndroidDevice.Close, this);
      }
      shell(command) {
        return __async(this, null, function* () {
          const {
            result
          } = yield this._channel.shell({
            command
          });
          return result;
        });
      }
      open(command) {
        return __async(this, null, function* () {
          return AndroidSocket.from((yield this._channel.open({
            command
          })).socket);
        });
      }
      installApk(file, options) {
        return __async(this, null, function* () {
          yield this._channel.installApk({
            file: yield loadFile(file),
            args: options && options.args
          });
        });
      }
      push(file, path, options) {
        return __async(this, null, function* () {
          yield this._channel.push({
            file: yield loadFile(file),
            path,
            mode: options ? options.mode : void 0
          });
        });
      }
      launchBrowser() {
        return __async(this, arguments, function* (options = {}) {
          const contextOptions = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const {
            context
          } = yield this._channel.launchBrowser(contextOptions);
          return _browserContext.BrowserContext.from(context);
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.AndroidDevice.Close)
              waiter.rejectOnEvent(this, _events.Events.AndroidDevice.Close, new Error("Device closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    var AndroidSocket = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("data", ({
          data
        }) => this.emit(_events.Events.AndroidSocket.Data, data));
        this._channel.on("close", () => this.emit(_events.Events.AndroidSocket.Close));
      }
      write(data) {
        return __async(this, null, function* () {
          yield this._channel.write({
            data
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
        });
      }
    };
    exports2.AndroidSocket = AndroidSocket;
    function loadFile(file) {
      return __async(this, null, function* () {
        if ((0, _utils.isString)(file))
          return _fs.default.promises.readFile(file);
        return file;
      });
    }
    var AndroidInput = class {
      constructor(device) {
        this._device = void 0;
        this._device = device;
      }
      type(text) {
        return __async(this, null, function* () {
          yield this._device._channel.inputType({
            text
          });
        });
      }
      press(key) {
        return __async(this, null, function* () {
          yield this._device._channel.inputPress({
            key
          });
        });
      }
      tap(point) {
        return __async(this, null, function* () {
          yield this._device._channel.inputTap({
            point
          });
        });
      }
      swipe(from, segments, steps) {
        return __async(this, null, function* () {
          yield this._device._channel.inputSwipe({
            segments,
            steps
          });
        });
      }
      drag(from, to, steps) {
        return __async(this, null, function* () {
          yield this._device._channel.inputDrag({
            from,
            to,
            steps
          });
        });
      }
    };
    exports2.AndroidInput = AndroidInput;
    function toSelectorChannel(selector) {
      const {
        checkable,
        checked,
        clazz,
        clickable,
        depth,
        desc,
        enabled,
        focusable,
        focused,
        hasChild,
        hasDescendant,
        longClickable,
        pkg,
        res,
        scrollable,
        selected,
        text
      } = selector;
      const toRegex = (value) => {
        if (value === void 0)
          return void 0;
        if ((0, _utils.isRegExp)(value))
          return value.source;
        return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
      };
      return {
        checkable,
        checked,
        clazz: toRegex(clazz),
        pkg: toRegex(pkg),
        desc: toRegex(desc),
        res: toRegex(res),
        text: toRegex(text),
        clickable,
        depth,
        enabled,
        focusable,
        focused,
        hasChild: hasChild ? {
          selector: toSelectorChannel(hasChild.selector)
        } : void 0,
        hasDescendant: hasDescendant ? {
          selector: toSelectorChannel(hasDescendant.selector),
          maxDepth: hasDescendant.maxDepth
        } : void 0,
        longClickable,
        scrollable,
        selected
      };
    }
    var AndroidWebView = class extends _events2.EventEmitter {
      constructor(device, data) {
        super();
        this._device = void 0;
        this._data = void 0;
        this._pagePromise = void 0;
        this._device = device;
        this._data = data;
      }
      pid() {
        return this._data.pid;
      }
      pkg() {
        return this._data.pkg;
      }
      _socketName() {
        return this._data.socketName;
      }
      page() {
        return __async(this, null, function* () {
          if (!this._pagePromise)
            this._pagePromise = this._fetchPage();
          return this._pagePromise;
        });
      }
      _fetchPage() {
        return __async(this, null, function* () {
          const {
            context
          } = yield this._device._channel.connectToWebView({
            socketName: this._data.socketName
          });
          return _browserContext.BrowserContext.from(context).pages()[0];
        });
      }
    };
    exports2.AndroidWebView = AndroidWebView;
  }
});

// node_modules/playwright-core/lib/client/electron.js
var require_electron3 = __commonJS({
  "node_modules/playwright-core/lib/client/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronApplication = exports2.Electron = void 0;
    var _timeoutSettings = require_timeoutSettings();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _events = require_events();
    var _jsHandle = require_jsHandle();
    var _waiter = require_waiter();
    var Electron = class extends _channelOwner.ChannelOwner {
      static from(electron) {
        return electron._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      launch() {
        return __async(this, arguments, function* (options = {}) {
          const params = __spreadProps(__spreadValues({}, yield (0, _browserContext.prepareBrowserContextParams)(options)), {
            env: (0, _clientHelper.envObjectToArray)(options.env ? options.env : process.env),
            tracesDir: options.tracesDir
          });
          const app = ElectronApplication.from((yield this._channel.launch(params)).electronApplication);
          app._context._options = params;
          return app;
        });
      }
    };
    exports2.Electron = Electron;
    var ElectronApplication = class extends _channelOwner.ChannelOwner {
      static from(electronApplication) {
        return electronApplication._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._context = void 0;
        this._windows = /* @__PURE__ */ new Set();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._isClosed = false;
        this._context = _browserContext.BrowserContext.from(initializer.context);
        for (const page of this._context._pages)
          this._onPage(page);
        this._context.on(_events.Events.BrowserContext.Page, (page) => this._onPage(page));
        this._channel.on("close", () => {
          this._isClosed = true;
          this.emit(_events.Events.ElectronApplication.Close);
        });
      }
      process() {
        return this._toImpl().process();
      }
      _onPage(page) {
        this._windows.add(page);
        this.emit(_events.Events.ElectronApplication.Window, page);
        page.once(_events.Events.Page.Close, () => this._windows.delete(page));
      }
      windows() {
        return [...this._windows];
      }
      firstWindow(options) {
        return __async(this, null, function* () {
          if (this._windows.size)
            return this._windows.values().next().value;
          return this.waitForEvent("window", options);
        });
      }
      context() {
        return this._context;
      }
      close() {
        return __async(this, null, function* () {
          if (this._isClosed)
            return;
          yield this._channel.close().catch(() => {
          });
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.ElectronApplication.Close)
              waiter.rejectOnEvent(this, _events.Events.ElectronApplication.Close, new Error("Electron application closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      browserWindow(page) {
        return __async(this, null, function* () {
          const result = yield this._channel.browserWindow({
            page: page._channel
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
  }
});

// node_modules/playwright-core/lib/client/selectors.js
var require_selectors2 = __commonJS({
  "node_modules/playwright-core/lib/client/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SelectorsOwner = exports2.Selectors = void 0;
    var _clientHelper = require_clientHelper();
    var _channelOwner = require_channelOwner();
    var _locator = require_locator();
    var Selectors = class {
      constructor() {
        this._channels = /* @__PURE__ */ new Set();
        this._registrations = [];
      }
      register(_0, _1) {
        return __async(this, arguments, function* (name, script, options = {}) {
          const source = yield (0, _clientHelper.evaluationScript)(script, void 0, false);
          const params = __spreadProps(__spreadValues({}, options), {
            name,
            source
          });
          for (const channel of this._channels)
            yield channel._channel.register(params);
          this._registrations.push(params);
        });
      }
      setTestIdAttribute(attributeName) {
        (0, _locator.setTestIdAttribute)(attributeName);
        for (const channel of this._channels)
          channel._channel.setTestIdAttributeName({
            testIdAttributeName: attributeName
          }).catch(() => {
          });
      }
      _addChannel(channel) {
        this._channels.add(channel);
        for (const params of this._registrations) {
          channel._channel.register(params).catch(() => {
          });
          channel._channel.setTestIdAttributeName({
            testIdAttributeName: (0, _locator.testIdAttributeName)()
          }).catch(() => {
          });
        }
      }
      _removeChannel(channel) {
        this._channels.delete(channel);
      }
    };
    exports2.Selectors = Selectors;
    var SelectorsOwner = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
    };
    exports2.SelectorsOwner = SelectorsOwner;
  }
});

// node_modules/playwright-core/lib/client/playwright.js
var require_playwright2 = __commonJS({
  "node_modules/playwright-core/lib/client/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Playwright = void 0;
    var _errors = require_errors();
    var _android = require_android2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _electron = require_electron3();
    var _fetch = require_fetch2();
    var _selectors = require_selectors2();
    var Playwright = class extends _channelOwner.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._android = void 0;
        this._electron = void 0;
        this.chromium = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.devices = void 0;
        this.selectors = void 0;
        this.request = void 0;
        this.errors = void 0;
        this.request = new _fetch.APIRequest(this);
        this.chromium = _browserType.BrowserType.from(initializer.chromium);
        this.chromium._playwright = this;
        this.firefox = _browserType.BrowserType.from(initializer.firefox);
        this.firefox._playwright = this;
        this.webkit = _browserType.BrowserType.from(initializer.webkit);
        this.webkit._playwright = this;
        this._android = _android.Android.from(initializer.android);
        this._electron = _electron.Electron.from(initializer.electron);
        this.devices = {};
        for (const {
          name,
          descriptor
        } of initializer.deviceDescriptors)
          this.devices[name] = descriptor;
        this.selectors = new _selectors.Selectors();
        this.errors = {
          TimeoutError: _errors.TimeoutError
        };
        const selectorsOwner = _selectors.SelectorsOwner.from(initializer.selectors);
        this.selectors._addChannel(selectorsOwner);
        this._connection.on("close", () => {
          this.selectors._removeChannel(selectorsOwner);
        });
        global._playwrightInstance = this;
      }
      _setSelectors(selectors) {
        const selectorsOwner = _selectors.SelectorsOwner.from(this._initializer.selectors);
        this.selectors._removeChannel(selectorsOwner);
        this.selectors = selectors;
        this.selectors._addChannel(selectorsOwner);
      }
      static from(channel) {
        return channel._object;
      }
    };
    exports2.Playwright = Playwright;
  }
});

// node_modules/playwright-core/lib/client/jsonPipe.js
var require_jsonPipe = __commonJS({
  "node_modules/playwright-core/lib/client/jsonPipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonPipe = void 0;
    var _channelOwner = require_channelOwner();
    var JsonPipe = class extends _channelOwner.ChannelOwner {
      static from(jsonPipe) {
        return jsonPipe._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      channel() {
        return this._channel;
      }
    };
    exports2.JsonPipe = JsonPipe;
  }
});

// node_modules/playwright-core/lib/client/localUtils.js
var require_localUtils = __commonJS({
  "node_modules/playwright-core/lib/client/localUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LocalUtils = void 0;
    var _channelOwner = require_channelOwner();
    var LocalUtils = class extends _channelOwner.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
    };
    exports2.LocalUtils = LocalUtils;
  }
});

// node_modules/playwright-core/lib/client/clientInstrumentation.js
var require_clientInstrumentation = __commonJS({
  "node_modules/playwright-core/lib/client/clientInstrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInstrumentation = createInstrumentation;
    function createInstrumentation() {
      const listeners = [];
      return new Proxy({}, {
        get: (obj, prop) => {
          if (typeof prop !== "string")
            return obj[prop];
          if (prop === "addListener")
            return (listener) => listeners.push(listener);
          if (prop === "removeListener")
            return (listener) => listeners.splice(listeners.indexOf(listener), 1);
          if (prop === "removeAllListeners")
            return () => listeners.splice(0, listeners.length);
          if (!prop.startsWith("on"))
            return obj[prop];
          return (...params) => __async(this, null, function* () {
            for (const listener of listeners) {
              var _prop, _ref;
              yield (_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params);
            }
          });
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/client/connection.js
var require_connection = __commonJS({
  "node_modules/playwright-core/lib/client/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Connection = void 0;
    var _browser = require_browser2();
    var _browserContext = require_browserContext2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _elementHandle = require_elementHandle();
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _network = require_network3();
    var _page = require_page2();
    var _worker = require_worker();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _serializers = require_serializers();
    var _cdpSession = require_cdpSession();
    var _playwright = require_playwright2();
    var _electron = require_electron3();
    var _stream = require_stream();
    var _writableStream = require_writableStream();
    var _debugLogger = require_debugLogger();
    var _selectors = require_selectors2();
    var _android = require_android2();
    var _stackTrace = require_stackTrace();
    var _artifact = require_artifact2();
    var _events = require("events");
    var _jsonPipe = require_jsonPipe();
    var _fetch = require_fetch2();
    var _localUtils = require_localUtils();
    var _tracing = require_tracing2();
    var _validator = require_validator();
    var _clientInstrumentation = require_clientInstrumentation();
    var Root = class extends _channelOwner.ChannelOwner {
      constructor(connection) {
        super(connection, "Root", "", {});
      }
      initialize() {
        return __async(this, null, function* () {
          return _playwright.Playwright.from((yield this._channel.initialize({
            sdkLanguage: "javascript"
          })).playwright);
        });
      }
    };
    var DummyChannelOwner = class extends _channelOwner.ChannelOwner {
    };
    var Connection = class extends _events.EventEmitter {
      constructor(localUtils, instrumentation) {
        super();
        this._objects = /* @__PURE__ */ new Map();
        this.onmessage = (message) => {
        };
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._rootObject = void 0;
        this._closedErrorMessage = void 0;
        this._isRemote = false;
        this._localUtils = void 0;
        this.toImpl = void 0;
        this._tracingCount = 0;
        this._instrumentation = void 0;
        this._rootObject = new Root(this);
        this._localUtils = localUtils;
        this._instrumentation = instrumentation || (0, _clientInstrumentation.createInstrumentation)();
      }
      markAsRemote() {
        this._isRemote = true;
      }
      isRemote() {
        return this._isRemote;
      }
      localUtils() {
        return this._localUtils;
      }
      initializePlaywright() {
        return __async(this, null, function* () {
          return yield this._rootObject.initialize();
        });
      }
      pendingProtocolCalls() {
        return Array.from(this._callbacks.values()).map((callback) => callback.stackTrace).filter(Boolean);
      }
      getObjectWithKnownName(guid) {
        return this._objects.get(guid);
      }
      setIsTracing(isTracing) {
        return __async(this, null, function* () {
          if (isTracing)
            this._tracingCount++;
          else
            this._tracingCount--;
        });
      }
      sendMessageToServer(object, type, method, params, stackTrace, wallTime) {
        return __async(this, null, function* () {
          var _this$_localUtils;
          if (this._closedErrorMessage)
            throw new Error(this._closedErrorMessage);
          const {
            apiName,
            frames
          } = stackTrace || {
            apiName: "",
            frames: []
          };
          const guid = object._guid;
          const id = ++this._lastId;
          const converted = {
            id,
            guid,
            method,
            params
          };
          _debugLogger.debugLogger.log("channel:command", converted);
          const location2 = frames[0] ? {
            file: frames[0].file,
            line: frames[0].line,
            column: frames[0].column
          } : void 0;
          const metadata = {
            wallTime,
            apiName,
            location: location2,
            internal: !apiName
          };
          this.onmessage(__spreadProps(__spreadValues({}, converted), {
            metadata
          }));
          if (this._tracingCount && frames && type !== "LocalUtils")
            (_this$_localUtils = this._localUtils) === null || _this$_localUtils === void 0 ? void 0 : _this$_localUtils._channel.addStackToTracingNoReply({
              callData: {
                stack: frames,
                id
              }
            }).catch(() => {
            });
          return yield new Promise((resolve, reject) => this._callbacks.set(id, {
            resolve,
            reject,
            stackTrace,
            type,
            method
          }));
        });
      }
      dispatch(message) {
        if (this._closedErrorMessage)
          return;
        const {
          id,
          guid,
          method,
          params,
          result,
          error
        } = message;
        if (id) {
          _debugLogger.debugLogger.log("channel:response", message);
          const callback = this._callbacks.get(id);
          if (!callback)
            throw new Error(`Cannot find command to respond: ${id}`);
          this._callbacks.delete(id);
          if (error && !result) {
            callback.reject((0, _serializers.parseError)(error));
          } else {
            const validator2 = (0, _validator.findValidator)(callback.type, callback.method, "Result");
            callback.resolve(validator2(result, "", {
              tChannelImpl: this._tChannelImplFromWire.bind(this),
              binary: this.isRemote() ? "fromBase64" : "buffer"
            }));
          }
          return;
        }
        _debugLogger.debugLogger.log("channel:event", message);
        if (method === "__create__") {
          this._createRemoteObject(guid, params.type, params.guid, params.initializer);
          return;
        }
        const object = this._objects.get(guid);
        if (!object)
          throw new Error(`Cannot find object to "${method}": ${guid}`);
        if (method === "__adopt__") {
          const child = this._objects.get(params.guid);
          if (!child)
            throw new Error(`Unknown new child: ${params.guid}`);
          object._adopt(child);
          return;
        }
        if (method === "__dispose__") {
          object._dispose();
          return;
        }
        const validator = (0, _validator.findValidator)(object._type, method, "Event");
        object._channel.emit(method, validator(params, "", {
          tChannelImpl: this._tChannelImplFromWire.bind(this),
          binary: this.isRemote() ? "fromBase64" : "buffer"
        }));
      }
      close(errorMessage = "Connection closed") {
        const stack = (0, _stackTrace.captureLibraryStackTrace)().frameTexts.join("\n");
        if (stack)
          errorMessage += "\n    ==== Closed by ====\n" + stack + "\n";
        this._closedErrorMessage = errorMessage;
        for (const callback of this._callbacks.values())
          callback.reject(new Error(errorMessage));
        this._callbacks.clear();
        this.emit("close");
      }
      _tChannelImplFromWire(names, arg, path, context) {
        if (arg && typeof arg === "object" && typeof arg.guid === "string") {
          const object = this._objects.get(arg.guid);
          if (!object)
            throw new Error(`Object with guid ${arg.guid} was not bound in the connection`);
          if (names !== "*" && !names.includes(object._type))
            throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
          return object._channel;
        }
        throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
      }
      _createRemoteObject(parentGuid, type, guid, initializer) {
        const parent = this._objects.get(parentGuid);
        if (!parent)
          throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
        let result;
        const validator = (0, _validator.findValidator)(type, "", "Initializer");
        initializer = validator(initializer, "", {
          tChannelImpl: this._tChannelImplFromWire.bind(this),
          binary: this.isRemote() ? "fromBase64" : "buffer"
        });
        switch (type) {
          case "Android":
            result = new _android.Android(parent, type, guid, initializer);
            break;
          case "AndroidSocket":
            result = new _android.AndroidSocket(parent, type, guid, initializer);
            break;
          case "AndroidDevice":
            result = new _android.AndroidDevice(parent, type, guid, initializer);
            break;
          case "APIRequestContext":
            result = new _fetch.APIRequestContext(parent, type, guid, initializer);
            break;
          case "Artifact":
            result = new _artifact.Artifact(parent, type, guid, initializer);
            break;
          case "BindingCall":
            result = new _page.BindingCall(parent, type, guid, initializer);
            break;
          case "Browser":
            result = new _browser.Browser(parent, type, guid, initializer);
            break;
          case "BrowserContext":
            result = new _browserContext.BrowserContext(parent, type, guid, initializer);
            break;
          case "BrowserType":
            result = new _browserType.BrowserType(parent, type, guid, initializer);
            break;
          case "CDPSession":
            result = new _cdpSession.CDPSession(parent, type, guid, initializer);
            break;
          case "ConsoleMessage":
            result = new _consoleMessage.ConsoleMessage(parent, type, guid, initializer);
            break;
          case "Dialog":
            result = new _dialog.Dialog(parent, type, guid, initializer);
            break;
          case "Electron":
            result = new _electron.Electron(parent, type, guid, initializer);
            break;
          case "ElectronApplication":
            result = new _electron.ElectronApplication(parent, type, guid, initializer);
            break;
          case "ElementHandle":
            result = new _elementHandle.ElementHandle(parent, type, guid, initializer);
            break;
          case "Frame":
            result = new _frame.Frame(parent, type, guid, initializer);
            break;
          case "JSHandle":
            result = new _jsHandle.JSHandle(parent, type, guid, initializer);
            break;
          case "JsonPipe":
            result = new _jsonPipe.JsonPipe(parent, type, guid, initializer);
            break;
          case "LocalUtils":
            result = new _localUtils.LocalUtils(parent, type, guid, initializer);
            if (!this._localUtils)
              this._localUtils = result;
            break;
          case "Page":
            result = new _page.Page(parent, type, guid, initializer);
            break;
          case "Playwright":
            result = new _playwright.Playwright(parent, type, guid, initializer);
            break;
          case "Request":
            result = new _network.Request(parent, type, guid, initializer);
            break;
          case "Response":
            result = new _network.Response(parent, type, guid, initializer);
            break;
          case "Route":
            result = new _network.Route(parent, type, guid, initializer);
            break;
          case "Stream":
            result = new _stream.Stream(parent, type, guid, initializer);
            break;
          case "Selectors":
            result = new _selectors.SelectorsOwner(parent, type, guid, initializer);
            break;
          case "SocksSupport":
            result = new DummyChannelOwner(parent, type, guid, initializer);
            break;
          case "Tracing":
            result = new _tracing.Tracing(parent, type, guid, initializer);
            break;
          case "WebSocket":
            result = new _network.WebSocket(parent, type, guid, initializer);
            break;
          case "Worker":
            result = new _worker.Worker(parent, type, guid, initializer);
            break;
          case "WritableStream":
            result = new _writableStream.WritableStream(parent, type, guid, initializer);
            break;
          default:
            throw new Error("Missing type " + type);
        }
        return result;
      }
    };
    exports2.Connection = Connection;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/debugControllerDispatcher.js
var require_debugControllerDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/debugControllerDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DebugControllerDispatcher = void 0;
    var _utils = require_utils();
    var _debugController = require_debugController();
    var _dispatcher = require_dispatcher();
    var DebugControllerDispatcher = class extends _dispatcher.Dispatcher {
      constructor(connection, debugController) {
        super(connection, debugController, "DebugController", {});
        this._type_DebugController = void 0;
        this._listeners = void 0;
        this._type_DebugController = true;
        this._listeners = [_utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.StateChanged, (params) => {
          this._dispatchEvent("stateChanged", params);
        }), _utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.InspectRequested, ({
          selector,
          locator
        }) => {
          this._dispatchEvent("inspectRequested", {
            selector,
            locator
          });
        }), _utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.SourceChanged, ({
          text,
          header,
          footer,
          actions
        }) => {
          this._dispatchEvent("sourceChanged", {
            text,
            header,
            footer,
            actions
          });
        }), _utils.eventsHelper.addEventListener(this._object, _debugController.DebugController.Events.Paused, ({
          paused
        }) => {
          this._dispatchEvent("paused", {
            paused
          });
        })];
      }
      initialize(params) {
        return __async(this, null, function* () {
          this._object.initialize(params.codegenId, params.sdkLanguage);
        });
      }
      setReportStateChanged(params) {
        return __async(this, null, function* () {
          this._object.setReportStateChanged(params.enabled);
        });
      }
      resetForReuse() {
        return __async(this, null, function* () {
          yield this._object.resetForReuse();
        });
      }
      navigate(params) {
        return __async(this, null, function* () {
          yield this._object.navigate(params.url);
        });
      }
      setRecorderMode(params) {
        return __async(this, null, function* () {
          yield this._object.setRecorderMode(params);
        });
      }
      highlight(params) {
        return __async(this, null, function* () {
          yield this._object.highlight(params.selector);
        });
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield this._object.hideHighlight();
        });
      }
      resume() {
        return __async(this, null, function* () {
          yield this._object.resume();
        });
      }
      kill() {
        return __async(this, null, function* () {
          yield this._object.kill();
        });
      }
      closeAllBrowsers() {
        return __async(this, null, function* () {
          yield this._object.closeAllBrowsers();
        });
      }
      _onDispose() {
        _utils.eventsHelper.removeEventListeners(this._listeners);
        this._object.dispose();
      }
    };
    exports2.DebugControllerDispatcher = DebugControllerDispatcher;
  }
});

// node_modules/playwright-core/lib/remote/playwrightConnection.js
var require_playwrightConnection = __commonJS({
  "node_modules/playwright-core/lib/remote/playwrightConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightConnection = void 0;
    var _server = require_server();
    var _browser = require_browser();
    var _instrumentation = require_instrumentation();
    var _socksProxy = require_socksProxy();
    var _utils = require_utils();
    var _android = require_android();
    var _debugControllerDispatcher = require_debugControllerDispatcher();
    var _debugLogger = require_debugLogger();
    var PlaywrightConnection = class {
      constructor(lock, clientType, ws2, options, preLaunched, id, onClose) {
        this._ws = void 0;
        this._onClose = void 0;
        this._dispatcherConnection = void 0;
        this._cleanups = [];
        this._id = void 0;
        this._disconnected = false;
        this._preLaunched = void 0;
        this._options = void 0;
        this._root = void 0;
        this._profileName = void 0;
        this._ws = ws2;
        this._preLaunched = preLaunched;
        this._options = options;
        options.launchOptions = filterLaunchOptions(options.launchOptions);
        if (clientType === "reuse-browser" || clientType === "pre-launched-browser-or-android")
          (0, _utils.assert)(preLaunched.playwright);
        if (clientType === "pre-launched-browser-or-android")
          (0, _utils.assert)(preLaunched.browser || preLaunched.androidDevice);
        this._onClose = onClose;
        this._id = id;
        this._profileName = `${new Date().toISOString()}-${clientType}`;
        this._dispatcherConnection = new _server.DispatcherConnection();
        this._dispatcherConnection.onmessage = (message) => __async(this, null, function* () {
          yield lock;
          if (ws2.readyState !== ws2.CLOSING) {
            const messageString = JSON.stringify(message);
            if (_debugLogger.debugLogger.isEnabled("server:channel"))
              _debugLogger.debugLogger.log("server:channel", `[${this._id}] ${(0, _utils.monotonicTime)() * 1e3} SEND \u25BA ${messageString}`);
            ws2.send(messageString);
          }
        });
        ws2.on("message", (message) => __async(this, null, function* () {
          yield lock;
          const messageString = Buffer.from(message).toString();
          if (_debugLogger.debugLogger.isEnabled("server:channel"))
            _debugLogger.debugLogger.log("server:channel", `[${this._id}] ${(0, _utils.monotonicTime)() * 1e3} \u25C0 RECV ${messageString}`);
          this._dispatcherConnection.dispatch(JSON.parse(messageString));
        }));
        ws2.on("close", () => this._onDisconnect());
        ws2.on("error", (error) => this._onDisconnect(error));
        if (clientType === "controller") {
          this._root = this._initDebugControllerMode();
          return;
        }
        this._root = new _server.RootDispatcher(this._dispatcherConnection, (scope) => __async(this, null, function* () {
          yield (0, _utils.startProfiling)();
          if (clientType === "reuse-browser")
            return yield this._initReuseBrowsersMode(scope);
          if (clientType === "pre-launched-browser-or-android")
            return this._preLaunched.browser ? yield this._initPreLaunchedBrowserMode(scope) : yield this._initPreLaunchedAndroidMode(scope);
          if (clientType === "launch-browser")
            return yield this._initLaunchBrowserMode(scope);
          throw new Error("Unsupported client type: " + clientType);
        }));
      }
      _initLaunchBrowserMode(scope) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("server", `[${this._id}] engaged launch mode for "${this._options.browserName}"`);
          const playwright = (0, _server.createPlaywright)({
            sdkLanguage: "javascript",
            isServer: true
          });
          const ownedSocksProxy = yield this._createOwnedSocksProxy(playwright);
          const browser = yield playwright[this._options.browserName].launch((0, _instrumentation.serverSideCallMetadata)(), this._options.launchOptions);
          this._cleanups.push(() => __async(this, null, function* () {
            for (const browser2 of playwright.allBrowsers())
              yield browser2.close();
          }));
          browser.on(_browser.Browser.Events.Disconnected, () => {
            this.close({
              code: 1001,
              reason: "Browser closed"
            });
          });
          return new _server.PlaywrightDispatcher(scope, playwright, ownedSocksProxy, browser);
        });
      }
      _initPreLaunchedBrowserMode(scope) {
        return __async(this, null, function* () {
          var _this$_preLaunched$so;
          _debugLogger.debugLogger.log("server", `[${this._id}] engaged pre-launched (browser) mode`);
          const playwright = this._preLaunched.playwright;
          (_this$_preLaunched$so = this._preLaunched.socksProxy) === null || _this$_preLaunched$so === void 0 ? void 0 : _this$_preLaunched$so.setPattern(this._options.socksProxyPattern);
          const browser = this._preLaunched.browser;
          browser.on(_browser.Browser.Events.Disconnected, () => {
            this.close({
              code: 1001,
              reason: "Browser closed"
            });
          });
          const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, this._preLaunched.socksProxy, browser);
          for (const b of playwright.allBrowsers()) {
            if (b !== browser)
              yield b.close();
          }
          this._cleanups.push(() => playwrightDispatcher.cleanup());
          return playwrightDispatcher;
        });
      }
      _initPreLaunchedAndroidMode(scope) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("server", `[${this._id}] engaged pre-launched (Android) mode`);
          const playwright = this._preLaunched.playwright;
          const androidDevice = this._preLaunched.androidDevice;
          androidDevice.on(_android.AndroidDevice.Events.Close, () => {
            this.close({
              code: 1001,
              reason: "Android device disconnected"
            });
          });
          const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, void 0, void 0, androidDevice);
          this._cleanups.push(() => playwrightDispatcher.cleanup());
          return playwrightDispatcher;
        });
      }
      _initDebugControllerMode() {
        _debugLogger.debugLogger.log("server", `[${this._id}] engaged reuse controller mode`);
        const playwright = this._preLaunched.playwright;
        return new _debugControllerDispatcher.DebugControllerDispatcher(this._dispatcherConnection, playwright.debugController);
      }
      _initReuseBrowsersMode(scope) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("server", `[${this._id}] engaged reuse browsers mode for ${this._options.browserName}`);
          const playwright = this._preLaunched.playwright;
          const requestedOptions = launchOptionsHash(this._options.launchOptions);
          let browser = playwright.allBrowsers().find((b) => {
            if (b.options.name !== this._options.browserName)
              return false;
            const existingOptions = launchOptionsHash(b.options.originalLaunchOptions);
            return existingOptions === requestedOptions;
          });
          for (const b of playwright.allBrowsers()) {
            if (b === browser)
              continue;
            if (b.options.name === this._options.browserName && b.options.channel === this._options.launchOptions.channel)
              yield b.close();
          }
          if (!browser) {
            browser = yield playwright[this._options.browserName || "chromium"].launch((0, _instrumentation.serverSideCallMetadata)(), __spreadProps(__spreadValues({}, this._options.launchOptions), {
              headless: !!process.env.PW_DEBUG_CONTROLLER_HEADLESS
            }));
            browser.on(_browser.Browser.Events.Disconnected, () => {
              this.close({
                code: 1001,
                reason: "Browser closed"
              });
            });
          }
          this._cleanups.push(() => __async(this, null, function* () {
            for (const browser2 of playwright.allBrowsers()) {
              for (const context of browser2.contexts()) {
                if (!context.pages().length)
                  yield context.close((0, _instrumentation.serverSideCallMetadata)());
                else
                  yield context.stopPendingOperations();
              }
              if (!browser2.contexts())
                yield browser2.close();
            }
          }));
          const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, void 0, browser);
          return playwrightDispatcher;
        });
      }
      _createOwnedSocksProxy(playwright) {
        return __async(this, null, function* () {
          if (!this._options.socksProxyPattern)
            return;
          const socksProxy = new _socksProxy.SocksProxy();
          socksProxy.setPattern(this._options.socksProxyPattern);
          playwright.options.socksProxyPort = yield socksProxy.listen(0);
          _debugLogger.debugLogger.log("server", `[${this._id}] started socks proxy on port ${playwright.options.socksProxyPort}`);
          this._cleanups.push(() => socksProxy.close());
          return socksProxy;
        });
      }
      _onDisconnect(error) {
        return __async(this, null, function* () {
          this._disconnected = true;
          _debugLogger.debugLogger.log("server", `[${this._id}] disconnected. error: ${error}`);
          this._root._dispose();
          _debugLogger.debugLogger.log("server", `[${this._id}] starting cleanup`);
          for (const cleanup of this._cleanups)
            yield cleanup().catch(() => {
            });
          yield (0, _utils.stopProfiling)(this._profileName);
          this._onClose();
          _debugLogger.debugLogger.log("server", `[${this._id}] finished cleanup`);
        });
      }
      close(reason) {
        return __async(this, null, function* () {
          if (this._disconnected)
            return;
          _debugLogger.debugLogger.log("server", `[${this._id}] force closing connection: ${(reason === null || reason === void 0 ? void 0 : reason.reason) || ""} (${(reason === null || reason === void 0 ? void 0 : reason.code) || 0})`);
          try {
            this._ws.close(reason === null || reason === void 0 ? void 0 : reason.code, reason === null || reason === void 0 ? void 0 : reason.reason);
          } catch (e) {
          }
        });
      }
    };
    exports2.PlaywrightConnection = PlaywrightConnection;
    function launchOptionsHash(options) {
      const copy = __spreadValues({}, options);
      for (const k of Object.keys(copy)) {
        const key = k;
        if (copy[key] === defaultLaunchOptions[key])
          delete copy[key];
      }
      for (const key of optionsThatAllowBrowserReuse)
        delete copy[key];
      return JSON.stringify(copy);
    }
    function filterLaunchOptions(options) {
      return {
        channel: options.channel,
        args: options.args,
        ignoreAllDefaultArgs: options.ignoreAllDefaultArgs,
        ignoreDefaultArgs: options.ignoreDefaultArgs,
        timeout: options.timeout,
        headless: options.headless,
        proxy: options.proxy,
        chromiumSandbox: options.chromiumSandbox,
        firefoxUserPrefs: options.firefoxUserPrefs,
        slowMo: options.slowMo,
        executablePath: (0, _utils.isUnderTest)() ? options.executablePath : void 0
      };
    }
    var defaultLaunchOptions = {
      ignoreAllDefaultArgs: false,
      handleSIGINT: false,
      handleSIGTERM: false,
      handleSIGHUP: false,
      headless: true,
      devtools: false
    };
    var optionsThatAllowBrowserReuse = ["headless", "tracesDir"];
  }
});

// node_modules/playwright-core/lib/remote/playwrightServer.js
var require_playwrightServer = __commonJS({
  "node_modules/playwright-core/lib/remote/playwrightServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Semaphore = exports2.PlaywrightServer = void 0;
    var _utilsBundle = require_utilsBundle();
    var _playwright = require_playwright();
    var _playwrightConnection = require_playwrightConnection();
    var _manualPromise = require_manualPromise();
    var _debugLogger = require_debugLogger();
    var _utils = require_utils();
    var lastConnectionId = 0;
    var kConnectionSymbol = Symbol("kConnection");
    var PlaywrightServer = class {
      constructor(options) {
        this._preLaunchedPlaywright = void 0;
        this._wsServer = void 0;
        this._options = void 0;
        this._options = options;
        if (options.preLaunchedBrowser)
          this._preLaunchedPlaywright = options.preLaunchedBrowser.attribution.playwright;
        if (options.preLaunchedAndroidDevice)
          this._preLaunchedPlaywright = options.preLaunchedAndroidDevice._android.attribution.playwright;
      }
      listen(port = 0) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("server", `Server started at ${new Date()}`);
          const server = (0, _utils.createHttpServer)((request, response) => {
            if (request.method === "GET" && request.url === "/json") {
              response.setHeader("Content-Type", "application/json");
              response.end(JSON.stringify({
                wsEndpointPath: this._options.path
              }));
              return;
            }
            response.end("Running");
          });
          server.on("error", (error) => _debugLogger.debugLogger.log("server", String(error)));
          const wsEndpoint = yield new Promise((resolve, reject) => {
            server.listen(port, () => {
              const address = server.address();
              if (!address) {
                reject(new Error("Could not bind server socket"));
                return;
              }
              const wsEndpoint2 = typeof address === "string" ? `${address}${this._options.path}` : `ws://127.0.0.1:${address.port}${this._options.path}`;
              resolve(wsEndpoint2);
            }).on("error", reject);
          });
          _debugLogger.debugLogger.log("server", "Listening at " + wsEndpoint);
          this._wsServer = new _utilsBundle.wsServer({
            server,
            path: this._options.path
          });
          const browserSemaphore = new Semaphore(this._options.maxConnections);
          const controllerSemaphore = new Semaphore(1);
          const reuseBrowserSemaphore = new Semaphore(1);
          if (process.env.PWTEST_SERVER_WS_HEADERS) {
            this._wsServer.on("headers", (headers, request) => {
              headers.push(process.env.PWTEST_SERVER_WS_HEADERS);
            });
          }
          this._wsServer.on("connection", (ws2, request) => {
            const url = new URL("http://localhost" + (request.url || ""));
            const browserHeader = request.headers["x-playwright-browser"];
            const browserName = url.searchParams.get("browser") || (Array.isArray(browserHeader) ? browserHeader[0] : browserHeader) || null;
            const proxyHeader = request.headers["x-playwright-proxy"];
            const proxyValue = url.searchParams.get("proxy") || (Array.isArray(proxyHeader) ? proxyHeader[0] : proxyHeader);
            const launchOptionsHeader = request.headers["x-playwright-launch-options"] || "";
            const launchOptionsHeaderValue = Array.isArray(launchOptionsHeader) ? launchOptionsHeader[0] : launchOptionsHeader;
            const launchOptionsParam = url.searchParams.get("launch-options");
            let launchOptions = {};
            try {
              launchOptions = JSON.parse(launchOptionsParam || launchOptionsHeaderValue);
            } catch (e) {
            }
            const id = String(++lastConnectionId);
            _debugLogger.debugLogger.log("server", `[${id}] serving connection: ${request.url}`);
            const isExtension = this._options.mode === "extension";
            if (isExtension) {
              if (!this._preLaunchedPlaywright)
                this._preLaunchedPlaywright = (0, _playwright.createPlaywright)({
                  sdkLanguage: "javascript",
                  isServer: true
                });
            }
            let clientType = "launch-browser";
            let semaphore = browserSemaphore;
            if (isExtension && url.searchParams.has("debug-controller")) {
              clientType = "controller";
              semaphore = controllerSemaphore;
            } else if (isExtension) {
              clientType = "reuse-browser";
              semaphore = reuseBrowserSemaphore;
            } else if (this._options.mode === "launchServer") {
              clientType = "pre-launched-browser-or-android";
              semaphore = browserSemaphore;
            }
            const connection = new _playwrightConnection.PlaywrightConnection(semaphore.aquire(), clientType, ws2, {
              socksProxyPattern: proxyValue,
              browserName,
              launchOptions
            }, {
              playwright: this._preLaunchedPlaywright,
              browser: this._options.preLaunchedBrowser,
              androidDevice: this._options.preLaunchedAndroidDevice,
              socksProxy: this._options.preLaunchedSocksProxy
            }, id, () => semaphore.release());
            ws2[kConnectionSymbol] = connection;
          });
          return wsEndpoint;
        });
      }
      close() {
        return __async(this, null, function* () {
          const server = this._wsServer;
          if (!server)
            return;
          _debugLogger.debugLogger.log("server", "closing websocket server");
          const waitForClose = new Promise((f) => server.close(f));
          yield Promise.all(Array.from(server.clients).map((ws2) => __async(this, null, function* () {
            const connection = ws2[kConnectionSymbol];
            if (connection)
              yield connection.close();
            try {
              ws2.terminate();
            } catch (e) {
            }
          })));
          yield waitForClose;
          _debugLogger.debugLogger.log("server", "closing http server");
          yield new Promise((f) => server.options.server.close(f));
          this._wsServer = void 0;
          _debugLogger.debugLogger.log("server", "closed server");
          _debugLogger.debugLogger.log("server", "closing browsers");
          if (this._preLaunchedPlaywright)
            yield Promise.all(this._preLaunchedPlaywright.allBrowsers().map((browser) => browser.close()));
          _debugLogger.debugLogger.log("server", "closed browsers");
        });
      }
    };
    exports2.PlaywrightServer = PlaywrightServer;
    var Semaphore = class {
      constructor(max) {
        this._max = void 0;
        this._aquired = 0;
        this._queue = [];
        this._max = max;
      }
      setMax(max) {
        this._max = max;
      }
      aquire() {
        const lock = new _manualPromise.ManualPromise();
        this._queue.push(lock);
        this._flush();
        return lock;
      }
      release() {
        --this._aquired;
        this._flush();
      }
      _flush() {
        while (this._aquired < this._max && this._queue.length) {
          ++this._aquired;
          this._queue.shift().resolve();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/playwright-core/lib/browserServerImpl.js
var require_browserServerImpl = __commonJS({
  "node_modules/playwright-core/lib/browserServerImpl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserServerLauncherImpl = void 0;
    var _utilsBundle = require_utilsBundle();
    var _clientHelper = require_clientHelper();
    var _utils = require_utils();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _playwrightServer = require_playwrightServer();
    var _helper = require_helper();
    var _stackTrace = require_stackTrace();
    var _socksProxy = require_socksProxy();
    var BrowserServerLauncherImpl = class {
      constructor(browserName) {
        this._browserName = void 0;
        this._browserName = browserName;
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          const playwright = (0, _playwright.createPlaywright)({
            sdkLanguage: "javascript",
            isServer: true
          });
          const socksProxy = false ? new _socksProxy.SocksProxy() : void 0;
          playwright.options.socksProxyPort = yield socksProxy === null || socksProxy === void 0 ? void 0 : socksProxy.listen(0);
          const metadata = (0, _instrumentation.serverSideCallMetadata)();
          const browser = yield playwright[this._browserName].launch(metadata, __spreadProps(__spreadValues({}, options), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0
          }), toProtocolLogger(options.logger)).catch((e) => {
            const log = _helper.helper.formatBrowserLogs(metadata.log);
            (0, _stackTrace.rewriteErrorMessage)(e, `${e.message} Failed to launch browser.${log}`);
            throw e;
          });
          const path = options.wsPath ? options.wsPath.startsWith("/") ? options.wsPath : `/${options.wsPath}` : `/${(0, _utils.createGuid)()}`;
          const server = new _playwrightServer.PlaywrightServer({
            mode: "launchServer",
            path,
            maxConnections: Infinity,
            preLaunchedBrowser: browser,
            preLaunchedSocksProxy: socksProxy
          });
          const wsEndpoint = yield server.listen(options.port);
          const browserServer = new _utilsBundle.ws.EventEmitter();
          browserServer.process = () => browser.options.browserProcess.process;
          browserServer.wsEndpoint = () => wsEndpoint;
          browserServer.close = () => browser.options.browserProcess.close();
          browserServer.kill = () => browser.options.browserProcess.kill();
          browserServer._disconnectForTest = () => server.close();
          browserServer._userDataDirForTest = browser._userDataDirForTest;
          browser.options.browserProcess.onclose = (exitCode, signal) => {
            socksProxy === null || socksProxy === void 0 ? void 0 : socksProxy.close().catch(() => {
            });
            server.close();
            browserServer.emit("close", exitCode, signal);
          };
          return browserServer;
        });
      }
    };
    exports2.BrowserServerLauncherImpl = BrowserServerLauncherImpl;
    function toProtocolLogger(logger) {
      return logger ? (direction, message) => {
        if (logger.isEnabled("protocol", "verbose"))
          logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
      } : void 0;
    }
  }
});

// node_modules/playwright-core/lib/androidServerImpl.js
var require_androidServerImpl = __commonJS({
  "node_modules/playwright-core/lib/androidServerImpl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidServerLauncherImpl = void 0;
    var _utilsBundle = require_utilsBundle();
    var _utils = require_utils();
    var _playwright = require_playwright();
    var _playwrightServer = require_playwrightServer();
    var AndroidServerLauncherImpl = class {
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          const playwright = (0, _playwright.createPlaywright)({
            sdkLanguage: "javascript",
            isServer: true
          });
          let devices = yield playwright.android.devices({
            host: options.adbHost,
            port: options.adbPort,
            omitDriverInstall: options.omitDriverInstall
          });
          if (devices.length === 0)
            throw new Error("No devices found");
          if (options.deviceSerialNumber) {
            devices = devices.filter((d) => d.serial === options.deviceSerialNumber);
            if (devices.length === 0)
              throw new Error(`No device with serial number '${options.deviceSerialNumber}' not found`);
          }
          if (devices.length > 1)
            throw new Error(`More than one device found. Please specify deviceSerialNumber`);
          const device = devices[0];
          const path = options.wsPath ? options.wsPath.startsWith("/") ? options.wsPath : `/${options.wsPath}` : `/${(0, _utils.createGuid)()}`;
          const server = new _playwrightServer.PlaywrightServer({
            mode: "launchServer",
            path,
            maxConnections: 1,
            preLaunchedAndroidDevice: device
          });
          const wsEndpoint = yield server.listen(options.port);
          const browserServer = new _utilsBundle.ws.EventEmitter();
          browserServer.wsEndpoint = () => wsEndpoint;
          browserServer.close = () => device.close();
          browserServer.kill = () => device.close();
          device.on("close", () => {
            server.close();
            browserServer.emit("close");
          });
          return browserServer;
        });
      }
    };
    exports2.AndroidServerLauncherImpl = AndroidServerLauncherImpl;
  }
});

// node_modules/playwright-core/lib/inProcessFactory.js
var require_inProcessFactory = __commonJS({
  "node_modules/playwright-core/lib/inProcessFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInProcessPlaywright = createInProcessPlaywright;
    var _server = require_server();
    var _connection = require_connection();
    var _browserServerImpl = require_browserServerImpl();
    var _androidServerImpl = require_androidServerImpl();
    function createInProcessPlaywright() {
      const playwright = (0, _server.createPlaywright)({
        sdkLanguage: process.env.PW_LANG_NAME || "javascript"
      });
      const clientConnection = new _connection.Connection(void 0, void 0);
      const dispatcherConnection = new _server.DispatcherConnection(true);
      dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
      clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
      const rootScope = new _server.RootDispatcher(dispatcherConnection);
      new _server.PlaywrightDispatcher(rootScope, playwright);
      const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
      playwrightAPI.chromium._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("chromium");
      playwrightAPI.firefox._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("firefox");
      playwrightAPI.webkit._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("webkit");
      playwrightAPI._android._serverLauncher = new _androidServerImpl.AndroidServerLauncherImpl();
      dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
      clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
      clientConnection.toImpl = (x) => x ? dispatcherConnection._dispatchers.get(x._guid)._object : dispatcherConnection._dispatchers.get("");
      playwrightAPI._toImpl = clientConnection.toImpl;
      return playwrightAPI;
    }
  }
});

// node_modules/playwright-core/lib/inprocess.js
var require_inprocess = __commonJS({
  "node_modules/playwright-core/lib/inprocess.js"(exports2, module2) {
    "use strict";
    var _inProcessFactory = require_inProcessFactory();
    module2.exports = (0, _inProcessFactory.createInProcessPlaywright)();
  }
});

// node_modules/playwright-core/index.js
var require_playwright_core = __commonJS({
  "node_modules/playwright-core/index.js"(exports2, module2) {
    var currentNodeVersion = process.versions.node;
    var semver = currentNodeVersion.split(".");
    var [major] = [+semver[0]];
    if (major < 14) {
      console.error("You are running Node.js " + currentNodeVersion + ".\nPlaywright requires Node.js 14 or higher. \nPlease update your version of Node.js.");
      process.exit(1);
    }
    module2.exports = require_inprocess();
  }
});

// node_modules/playwright-core/api.json
var require_api = __commonJS({
  "node_modules/playwright-core/api.json"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/playwright-core/lib/cli/driver.js
var require_driver = __commonJS({
  "node_modules/playwright-core/lib/cli/driver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.launchBrowserServer = launchBrowserServer;
    exports2.printApiJson = printApiJson;
    exports2.runDriver = runDriver;
    exports2.runServer = runServer;
    var _fs = _interopRequireDefault(require("fs"));
    var playwright = _interopRequireWildcard(require_playwright_core());
    var _server = require_server();
    var _transport = require_transport();
    var _playwrightServer = require_playwrightServer();
    var _processLauncher = require_processLauncher();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function printApiJson() {
      console.log(JSON.stringify(require_api()));
    }
    function runDriver() {
      const dispatcherConnection = new _server.DispatcherConnection();
      new _server.RootDispatcher(dispatcherConnection, (_0, _1) => __async(this, [_0, _1], function* (rootScope, {
        sdkLanguage
      }) {
        const playwright2 = (0, _server.createPlaywright)({
          sdkLanguage
        });
        return new _server.PlaywrightDispatcher(rootScope, playwright2);
      }));
      const transport = new _transport.PipeTransport(process.stdout, process.stdin);
      transport.onmessage = (message) => dispatcherConnection.dispatch(JSON.parse(message));
      dispatcherConnection.onmessage = (message) => transport.send(JSON.stringify(message));
      transport.onclose = () => {
        dispatcherConnection.onmessage = () => {
        };
        selfDestruct();
      };
      process.on("SIGINT", () => {
      });
    }
    function runServer(options) {
      return __async(this, null, function* () {
        const {
          port,
          path = "/",
          maxConnections = Infinity,
          extension
        } = options;
        const server = new _playwrightServer.PlaywrightServer({
          mode: extension ? "extension" : "default",
          path,
          maxConnections
        });
        const wsEndpoint = yield server.listen(port);
        process.on("exit", () => server.close().catch(console.error));
        console.log("Listening on " + wsEndpoint);
        process.stdin.on("close", () => selfDestruct());
      });
    }
    function launchBrowserServer(browserName, configFile) {
      return __async(this, null, function* () {
        let options = {};
        if (configFile)
          options = JSON.parse(_fs.default.readFileSync(configFile).toString());
        const browserType = playwright[browserName];
        const server = yield browserType.launchServer(options);
        console.log(server.wsEndpoint());
      });
    }
    function selfDestruct() {
      setTimeout(() => process.exit(0), 3e4);
      (0, _processLauncher.gracefullyCloseAll)().then(() => {
        process.exit(0);
      });
    }
  }
});

// node_modules/playwright-core/lib/cli/program.js
var require_program = __commonJS({
  "node_modules/playwright-core/lib/cli/program.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _utilsBundle = require_utilsBundle();
    var _driver = require_driver();
    var _traceViewer = require_traceViewer();
    var playwright = _interopRequireWildcard(require_playwright_core());
    var _child_process = require("child_process");
    var _utils = require_utils();
    var _server = require_server();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var packageJSON = require_package();
    _utilsBundle.program.version("Version " + (process.env.PW_CLI_DISPLAY_VERSION || packageJSON.version)).name(buildBasePlaywrightCLICommand(process.env.PW_LANG_NAME));
    _utilsBundle.program.command("mark-docker-image [dockerImageNameTemplate]", {
      hidden: true
    }).description("mark docker image").allowUnknownOption(true).action(function(dockerImageNameTemplate) {
      (0, _utils.assert)(dockerImageNameTemplate, "dockerImageNameTemplate is required");
      (0, _server.writeDockerVersion)(dockerImageNameTemplate).catch(logErrorAndExit);
    });
    commandWithOpenOptions("open [url]", "open page in browser specified via -b, --browser", []).action(function(url, options) {
      open2(options, url, codegenId()).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ open
  $ open -b webkit https://example.com`);
    commandWithOpenOptions("codegen [url]", "open page and generate code for user actions", [["-o, --output <file name>", "saves the generated script to a file"], ["--target <language>", `language to generate, one of javascript, playwright-test, python, python-async, python-pytest, csharp, csharp-mstest, csharp-nunit, java`, codegenId()], ["--save-trace <filename>", "record a trace for the session and save it to a file"], ["--test-id-attribute <attributeName>", "use the specified attribute to generate data test ID selectors"]]).action(function(url, options) {
      codegen(options, url).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ codegen
  $ codegen --target=python
  $ codegen -b webkit https://example.com`);
    _utilsBundle.program.command("debug <app> [args...]", {
      hidden: true
    }).description("run command in debug mode: disable timeout, open inspector").allowUnknownOption(true).action(function(app, options) {
      (0, _child_process.spawn)(app, options, {
        env: __spreadProps(__spreadValues({}, process.env), {
          PWDEBUG: "1"
        }),
        stdio: "inherit"
      });
    }).addHelpText("afterAll", `
Examples:

  $ debug node test.js
  $ debug npm run test`);
    function suggestedBrowsersToInstall() {
      return _server.registry.executables().filter((e) => e.installType !== "none" && e.type !== "tool").map((e) => e.name).join(", ");
    }
    function checkBrowsersToInstall(args) {
      const faultyArguments = [];
      const executables = [];
      for (const arg of args) {
        const executable = _server.registry.findExecutable(arg);
        if (!executable || executable.installType === "none")
          faultyArguments.push(arg);
        else
          executables.push(executable);
      }
      if (faultyArguments.length) {
        console.log(`Invalid installation targets: ${faultyArguments.map((name) => `'${name}'`).join(", ")}. Expecting one of: ${suggestedBrowsersToInstall()}`);
        process.exit(1);
      }
      return executables;
    }
    _utilsBundle.program.command("install [browser...]").description("ensure browsers necessary for this version of Playwright are installed").option("--with-deps", "install system dependencies for browsers").option("--dry-run", "do not execute installation, only print information").option("--force", "force reinstall of stable browser channels").action(function(args, options) {
      return __async(this, null, function* () {
        if ((0, _utils.isLikelyNpxGlobal)()) {
          console.error((0, _utils.wrapInASCIIBox)([`WARNING: It looks like you are running 'npx playwright install' without first`, `installing your project's dependencies.`, ``, `To avoid unexpected behavior, please install your dependencies first, and`, `then run Playwright's install command:`, ``, `    npm install`, `    npx playwright install`, ``, `If your project does not yet depend on Playwright, first install the`, `applicable npm package (most commonly @playwright/test), and`, `then run Playwright's install command to download the browsers:`, ``, `    npm install @playwright/test`, `    npx playwright install`, ``].join("\n"), 1));
        }
        try {
          const hasNoArguments = !args.length;
          const executables = hasNoArguments ? _server.registry.defaultExecutables() : checkBrowsersToInstall(args);
          if (options.withDeps)
            yield _server.registry.installDeps(executables, !!options.dryRun);
          if (options.dryRun) {
            for (const executable of executables) {
              var _executable$directory, _executable$downloadU;
              const version = executable.browserVersion ? `version ` + executable.browserVersion : "";
              console.log(`browser: ${executable.name}${version ? " " + version : ""}`);
              console.log(`  Install location:    ${(_executable$directory = executable.directory) !== null && _executable$directory !== void 0 ? _executable$directory : "<system>"}`);
              if ((_executable$downloadU = executable.downloadURLs) !== null && _executable$downloadU !== void 0 && _executable$downloadU.length) {
                const [url, ...fallbacks] = executable.downloadURLs;
                console.log(`  Download url:        ${url}`);
                for (let i = 0; i < fallbacks.length; ++i)
                  console.log(`  Download fallback ${i + 1}: ${fallbacks[i]}`);
              }
              console.log(``);
            }
          } else {
            const forceReinstall = hasNoArguments ? false : !!options.force;
            yield _server.registry.install(executables, forceReinstall);
          }
        } catch (e) {
          console.log(`Failed to install browsers
${e}`);
          process.exit(1);
        }
      });
    }).addHelpText("afterAll", `

Examples:
  - $ install
    Install default browsers.

  - $ install chrome firefox
    Install custom browsers, supports ${suggestedBrowsersToInstall()}.`);
    _utilsBundle.program.command("uninstall").description("Removes browsers used by this installation of Playwright from the system (chromium, firefox, webkit, ffmpeg). This does not include branded channels.").option("--all", "Removes all browsers used by any Playwright installation from the system.").action((options) => __async(exports2, null, function* () {
      yield _server.registry.uninstall(!!options.all).then(({
        numberOfBrowsersLeft
      }) => {
        if (!options.all && numberOfBrowsersLeft > 0) {
          console.log("Successfully uninstalled Playwright browsers for the current Playwright installation.");
          console.log(`There are still ${numberOfBrowsersLeft} browsers left, used by other Playwright installations.
To uninstall Playwright browsers for all installations, re-run with --all flag.`);
        }
      }).catch(logErrorAndExit);
    }));
    _utilsBundle.program.command("install-deps [browser...]").description("install dependencies necessary to run browsers (will ask for sudo permissions)").option("--dry-run", "Do not execute installation commands, only print them").action(function(args, options) {
      return __async(this, null, function* () {
        try {
          if (!args.length)
            yield _server.registry.installDeps(_server.registry.defaultExecutables(), !!options.dryRun);
          else
            yield _server.registry.installDeps(checkBrowsersToInstall(args), !!options.dryRun);
        } catch (e) {
          console.log(`Failed to install browser dependencies
${e}`);
          process.exit(1);
        }
      });
    }).addHelpText("afterAll", `
Examples:
  - $ install-deps
    Install dependencies for default browsers.

  - $ install-deps chrome firefox
    Install dependencies for specific browsers, supports ${suggestedBrowsersToInstall()}.`);
    var browsers = [{
      alias: "cr",
      name: "Chromium",
      type: "chromium"
    }, {
      alias: "ff",
      name: "Firefox",
      type: "firefox"
    }, {
      alias: "wk",
      name: "WebKit",
      type: "webkit"
    }];
    for (const {
      alias,
      name,
      type
    } of browsers) {
      commandWithOpenOptions(`${alias} [url]`, `open page in ${name}`, []).action(function(url, options) {
        open2(__spreadProps(__spreadValues({}, options), {
          browser: type
        }), url, options.target).catch(logErrorAndExit);
      }).addHelpText("afterAll", `
Examples:

  $ ${alias} https://example.com`);
    }
    commandWithOpenOptions("screenshot <url> <filename>", "capture a page screenshot", [["--wait-for-selector <selector>", "wait for selector before taking a screenshot"], ["--wait-for-timeout <timeout>", "wait for timeout in milliseconds before taking a screenshot"], ["--full-page", "whether to take a full page screenshot (entire scrollable area)"]]).action(function(url, filename, command) {
      screenshot(command, command, url, filename).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ screenshot -b webkit https://example.com example.png`);
    commandWithOpenOptions("pdf <url> <filename>", "save page as pdf", [["--wait-for-selector <selector>", "wait for given selector before saving as pdf"], ["--wait-for-timeout <timeout>", "wait for given timeout in milliseconds before saving as pdf"]]).action(function(url, filename, options) {
      pdf(options, options, url, filename).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ pdf https://example.com example.pdf`);
    _utilsBundle.program.command("run-driver", {
      hidden: true
    }).action(function(options) {
      (0, _driver.runDriver)();
    });
    _utilsBundle.program.command("run-server", {
      hidden: true
    }).option("--port <port>", "Server port").option("--path <path>", "Endpoint Path", "/").option("--max-clients <maxClients>", "Maximum clients").option("--mode <mode>", 'Server mode, either "default" or "extension"').action(function(options) {
      (0, _driver.runServer)({
        port: options.port ? +options.port : void 0,
        path: options.path,
        maxConnections: options.maxClients ? +options.maxClients : Infinity,
        extension: options.mode === "extension" || !!process.env.PW_EXTENSION_MODE
      }).catch(logErrorAndExit);
    });
    _utilsBundle.program.command("print-api-json", {
      hidden: true
    }).action(function(options) {
      (0, _driver.printApiJson)();
    });
    _utilsBundle.program.command("launch-server", {
      hidden: true
    }).requiredOption("--browser <browserName>", 'Browser name, one of "chromium", "firefox" or "webkit"').option("--config <path-to-config-file>", "JSON file with launchServer options").action(function(options) {
      (0, _driver.launchBrowserServer)(options.browser, options.config);
    });
    _utilsBundle.program.command("show-trace [trace...]").option("-b, --browser <browserType>", "browser to use, one of cr, chromium, ff, firefox, wk, webkit", "chromium").option("-h, --host <host>", "Host to serve trace on; specifying this option opens trace in a browser tab").option("-p, --port <port>", "Port to serve trace on, 0 for any free port; specifying this option opens trace in a browser tab").option("--stdin", "Accept trace URLs over stdin to update the viewer").description("show trace viewer").action(function(traces, options) {
      if (options.browser === "cr")
        options.browser = "chromium";
      if (options.browser === "ff")
        options.browser = "firefox";
      if (options.browser === "wk")
        options.browser = "webkit";
      const openOptions = {
        headless: false,
        host: options.host,
        port: +options.port,
        isServer: !!options.stdin
      };
      if (options.port !== void 0 || options.host !== void 0) {
        (0, _traceViewer.openTraceInBrowser)(traces, openOptions).catch(logErrorAndExit);
      } else {
        (0, _traceViewer.openTraceViewerApp)(traces, options.browser, openOptions).then((page) => {
          page.on("close", () => process.exit(0));
        }).catch(logErrorAndExit);
      }
    }).addHelpText("afterAll", `
Examples:

  $ show-trace https://example.com/trace.zip`);
    function launchContext(options, headless, executablePath) {
      return __async(this, null, function* () {
        validateOptions(options);
        const browserType = lookupBrowserType(options);
        const launchOptions = {
          headless,
          executablePath
        };
        if (options.channel)
          launchOptions.channel = options.channel;
        launchOptions.handleSIGINT = false;
        const contextOptions = options.device ? __spreadValues({}, playwright.devices[options.device]) : {};
        if (!headless)
          contextOptions.deviceScaleFactor = _os.default.platform() === "darwin" ? 2 : 1;
        if (browserType.name() === "webkit" && process.platform === "linux") {
          delete contextOptions.hasTouch;
          delete contextOptions.isMobile;
        }
        if (contextOptions.isMobile && browserType.name() === "firefox")
          contextOptions.isMobile = void 0;
        if (options.blockServiceWorkers)
          contextOptions.serviceWorkers = "block";
        if (options.proxyServer) {
          launchOptions.proxy = {
            server: options.proxyServer
          };
          if (options.proxyBypass)
            launchOptions.proxy.bypass = options.proxyBypass;
        }
        const browser = yield browserType.launch(launchOptions);
        if (process.env.PWTEST_CLI_IS_UNDER_TEST) {
          process._didSetSourcesForTest = (text) => {
            process.stdout.write("\n-------------8<-------------\n");
            process.stdout.write(text);
            process.stdout.write("\n-------------8<-------------\n");
            const autoExitCondition = process.env.PWTEST_CLI_AUTO_EXIT_WHEN;
            if (autoExitCondition && text.includes(autoExitCondition))
              Promise.all(context.pages().map((p) => __async(this, null, function* () {
                return p.close();
              })));
          };
          const logs = [];
          require_utilsBundle().debug.log = (...args) => {
            const line = require("util").format(...args) + "\n";
            logs.push(line);
            process.stderr.write(line);
          };
          browser.on("disconnected", () => {
            const hasCrashLine = logs.some((line) => line.includes("process did exit:") && !line.includes("process did exit: exitCode=0, signal=null"));
            if (hasCrashLine) {
              process.stderr.write("Detected browser crash.\n");
              process.exit(1);
            }
          });
        }
        if (options.viewportSize) {
          try {
            const [width, height] = options.viewportSize.split(",").map((n) => parseInt(n, 10));
            contextOptions.viewport = {
              width,
              height
            };
          } catch (e) {
            console.log('Invalid window size format: use "width, height", for example --window-size=800,600');
            process.exit(0);
          }
        }
        if (options.geolocation) {
          try {
            const [latitude, longitude] = options.geolocation.split(",").map((n) => parseFloat(n.trim()));
            contextOptions.geolocation = {
              latitude,
              longitude
            };
          } catch (e) {
            console.log('Invalid geolocation format: user lat, long, for example --geolocation="37.819722,-122.478611"');
            process.exit(0);
          }
          contextOptions.permissions = ["geolocation"];
        }
        if (options.userAgent)
          contextOptions.userAgent = options.userAgent;
        if (options.lang)
          contextOptions.locale = options.lang;
        if (options.colorScheme)
          contextOptions.colorScheme = options.colorScheme;
        if (options.timezone)
          contextOptions.timezoneId = options.timezone;
        if (options.loadStorage)
          contextOptions.storageState = options.loadStorage;
        if (options.ignoreHttpsErrors)
          contextOptions.ignoreHTTPSErrors = true;
        if (options.saveHar) {
          contextOptions.recordHar = {
            path: _path.default.resolve(process.cwd(), options.saveHar),
            mode: "minimal"
          };
          if (options.saveHarGlob)
            contextOptions.recordHar.urlFilter = options.saveHarGlob;
          contextOptions.serviceWorkers = "block";
        }
        const context = yield browser.newContext(contextOptions);
        let closingBrowser = false;
        function closeBrowser() {
          return __async(this, null, function* () {
            if (closingBrowser)
              return;
            closingBrowser = true;
            if (options.saveTrace)
              yield context.tracing.stop({
                path: options.saveTrace
              });
            if (options.saveStorage)
              yield context.storageState({
                path: options.saveStorage
              }).catch((e) => null);
            if (options.saveHar)
              yield context.close();
            yield browser.close();
          });
        }
        context.on("page", (page) => {
          page.on("dialog", () => {
          });
          page.on("close", () => {
            const hasPage = browser.contexts().some((context2) => context2.pages().length > 0);
            if (hasPage)
              return;
            closeBrowser().catch((e) => null);
          });
        });
        process.on("SIGINT", () => __async(this, null, function* () {
          yield closeBrowser();
          process.exit(130);
        }));
        const timeout = options.timeout ? parseInt(options.timeout, 10) : 0;
        context.setDefaultTimeout(timeout);
        context.setDefaultNavigationTimeout(timeout);
        if (options.saveTrace)
          yield context.tracing.start({
            screenshots: true,
            snapshots: true
          });
        delete launchOptions.headless;
        delete launchOptions.executablePath;
        delete launchOptions.handleSIGINT;
        delete contextOptions.deviceScaleFactor;
        return {
          browser,
          browserName: browserType.name(),
          context,
          contextOptions,
          launchOptions
        };
      });
    }
    function openPage(context, url) {
      return __async(this, null, function* () {
        const page = yield context.newPage();
        if (url) {
          if (_fs.default.existsSync(url))
            url = "file://" + _path.default.resolve(url);
          else if (!url.startsWith("http") && !url.startsWith("file://") && !url.startsWith("about:") && !url.startsWith("data:"))
            url = "http://" + url;
          yield page.goto(url).catch((error) => {
            if (process.env.PWTEST_CLI_AUTO_EXIT_WHEN && error.message.includes("Navigation failed because page was closed")) {
            } else {
              throw error;
            }
          });
        }
        return page;
      });
    }
    function open2(options, url, language) {
      return __async(this, null, function* () {
        const {
          context,
          launchOptions,
          contextOptions
        } = yield launchContext(options, !!process.env.PWTEST_CLI_HEADLESS, process.env.PWTEST_CLI_EXECUTABLE_PATH);
        yield context._enableRecorder({
          language,
          launchOptions,
          contextOptions,
          device: options.device,
          saveStorage: options.saveStorage
        });
        yield openPage(context, url);
      });
    }
    function codegen(options, url) {
      return __async(this, null, function* () {
        const {
          target: language,
          output: outputFile,
          testIdAttribute: testIdAttributeName
        } = options;
        const {
          context,
          launchOptions,
          contextOptions
        } = yield launchContext(options, !!process.env.PWTEST_CLI_HEADLESS, process.env.PWTEST_CLI_EXECUTABLE_PATH);
        yield context._enableRecorder({
          language,
          launchOptions,
          contextOptions,
          device: options.device,
          saveStorage: options.saveStorage,
          mode: "recording",
          testIdAttributeName,
          outputFile: outputFile ? _path.default.resolve(outputFile) : void 0,
          handleSIGINT: false
        });
        yield openPage(context, url);
      });
    }
    function waitForPage(page, captureOptions) {
      return __async(this, null, function* () {
        if (captureOptions.waitForSelector) {
          console.log(`Waiting for selector ${captureOptions.waitForSelector}...`);
          yield page.waitForSelector(captureOptions.waitForSelector);
        }
        if (captureOptions.waitForTimeout) {
          console.log(`Waiting for timeout ${captureOptions.waitForTimeout}...`);
          yield page.waitForTimeout(parseInt(captureOptions.waitForTimeout, 10));
        }
      });
    }
    function screenshot(options, captureOptions, url, path) {
      return __async(this, null, function* () {
        const {
          context
        } = yield launchContext(options, true);
        console.log("Navigating to " + url);
        const page = yield openPage(context, url);
        yield waitForPage(page, captureOptions);
        console.log("Capturing screenshot into " + path);
        yield page.screenshot({
          path,
          fullPage: !!captureOptions.fullPage
        });
        yield page.close();
      });
    }
    function pdf(options, captureOptions, url, path) {
      return __async(this, null, function* () {
        if (options.browser !== "chromium") {
          console.error("PDF creation is only working with Chromium");
          process.exit(1);
        }
        const {
          context
        } = yield launchContext(__spreadProps(__spreadValues({}, options), {
          browser: "chromium"
        }), true);
        console.log("Navigating to " + url);
        const page = yield openPage(context, url);
        yield waitForPage(page, captureOptions);
        console.log("Saving as pdf into " + path);
        yield page.pdf({
          path
        });
        yield page.close();
      });
    }
    function lookupBrowserType(options) {
      let name = options.browser;
      if (options.device) {
        const device = playwright.devices[options.device];
        name = device.defaultBrowserType;
      }
      let browserType;
      switch (name) {
        case "chromium":
          browserType = playwright.chromium;
          break;
        case "webkit":
          browserType = playwright.webkit;
          break;
        case "firefox":
          browserType = playwright.firefox;
          break;
        case "cr":
          browserType = playwright.chromium;
          break;
        case "wk":
          browserType = playwright.webkit;
          break;
        case "ff":
          browserType = playwright.firefox;
          break;
      }
      if (browserType)
        return browserType;
      _utilsBundle.program.help();
    }
    function validateOptions(options) {
      if (options.device && !(options.device in playwright.devices)) {
        console.log(`Device descriptor not found: '${options.device}', available devices are:`);
        for (const name in playwright.devices)
          console.log(`  "${name}"`);
        process.exit(0);
      }
      if (options.colorScheme && !["light", "dark"].includes(options.colorScheme)) {
        console.log('Invalid color scheme, should be one of "light", "dark"');
        process.exit(0);
      }
    }
    function logErrorAndExit(e) {
      console.error(e);
      process.exit(1);
    }
    function codegenId() {
      return process.env.PW_LANG_NAME || "playwright-test";
    }
    function commandWithOpenOptions(command, description, options) {
      let result = _utilsBundle.program.command(command).description(description);
      for (const option of options)
        result = result.option(option[0], ...option.slice(1));
      return result.option("-b, --browser <browserType>", "browser to use, one of cr, chromium, ff, firefox, wk, webkit", "chromium").option("--block-service-workers", "block service workers").option("--channel <channel>", 'Chromium distribution channel, "chrome", "chrome-beta", "msedge-dev", etc').option("--color-scheme <scheme>", 'emulate preferred color scheme, "light" or "dark"').option("--device <deviceName>", 'emulate device, for example  "iPhone 11"').option("--geolocation <coordinates>", 'specify geolocation coordinates, for example "37.819722,-122.478611"').option("--ignore-https-errors", "ignore https errors").option("--load-storage <filename>", "load context storage state from the file, previously saved with --save-storage").option("--lang <language>", 'specify language / locale, for example "en-GB"').option("--proxy-server <proxy>", 'specify proxy server, for example "http://myproxy:3128" or "socks5://myproxy:8080"').option("--proxy-bypass <bypass>", 'comma-separated domains to bypass proxy, for example ".com,chromium.org,.domain.com"').option("--save-har <filename>", "save HAR file with all network activity at the end").option("--save-har-glob <glob pattern>", "filter entries in the HAR by matching url against this glob pattern").option("--save-storage <filename>", "save context storage state at the end, for later use with --load-storage").option("--timezone <time zone>", 'time zone to emulate, for example "Europe/Rome"').option("--timeout <timeout>", "timeout for Playwright actions in milliseconds, no timeout by default").option("--user-agent <ua string>", "specify user agent string").option("--viewport-size <size>", 'specify browser viewport size in pixels, for example "1280, 720"');
    }
    function buildBasePlaywrightCLICommand(cliTargetLang) {
      switch (cliTargetLang) {
        case "python":
          return `playwright`;
        case "java":
          return `mvn exec:java -e -D exec.mainClass=com.microsoft.playwright.CLI -D exec.args="...options.."`;
        case "csharp":
          return `pwsh bin/Debug/netX/playwright.ps1`;
        default:
          return `npx playwright`;
      }
    }
    var _default = _utilsBundle.program;
    exports2.default = _default;
  }
});

// node_modules/playwright-core/lib/cli/cli.js
var require_cli = __commonJS({
  "node_modules/playwright-core/lib/cli/cli.js"(exports2) {
    "use strict";
    var _utils = require_utils();
    var _program = _interopRequireDefault(require_program());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function printPlaywrightTestError(command) {
      const packages = [];
      for (const pkg of ["playwright", "playwright-chromium", "playwright-firefox", "playwright-webkit"]) {
        try {
          require.resolve(pkg);
          packages.push(pkg);
        } catch (e) {
        }
      }
      if (!packages.length)
        packages.push("playwright");
      const packageManager = (0, _utils.getPackageManager)();
      if (packageManager === "yarn") {
        console.error(`Please install @playwright/test package before running "yarn playwright ${command}"`);
        console.error(`  yarn remove ${packages.join(" ")}`);
        console.error("  yarn add -D @playwright/test");
      } else if (packageManager === "pnpm") {
        console.error(`Please install @playwright/test package before running "pnpm exec playwright ${command}"`);
        console.error(`  pnpm remove ${packages.join(" ")}`);
        console.error("  pnpm add -D @playwright/test");
      } else {
        console.error(`Please install @playwright/test package before running "npx playwright ${command}"`);
        console.error(`  npm uninstall ${packages.join(" ")}`);
        console.error("  npm install -D @playwright/test");
      }
    }
    {
      const command = _program.default.command("test").allowUnknownOption(true);
      command.description("Run tests with Playwright Test. Available in @playwright/test package.");
      command.action(() => __async(exports2, null, function* () {
        printPlaywrightTestError("test");
        process.exit(1);
      }));
    }
    {
      const command = _program.default.command("show-report").allowUnknownOption(true);
      command.description("Show Playwright Test HTML report. Available in @playwright/test package.");
      command.action(() => __async(exports2, null, function* () {
        printPlaywrightTestError("show-report");
        process.exit(1);
      }));
    }
    _program.default.parse(process.argv);
  }
});

// node_modules/playwright/cli.js
module.exports = require_cli();
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
